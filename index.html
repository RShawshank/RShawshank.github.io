<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rshawshank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="纵浪大化中，不喜亦不惧">
<meta property="og:type" content="website">
<meta property="og:title" content="rhb_blog">
<meta property="og:url" content="http://rshawshank.github.io/index.html">
<meta property="og:site_name" content="rhb_blog">
<meta property="og:description" content="纵浪大化中，不喜亦不惧">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rhb">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rshawshank.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>rhb_blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rhb_blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">rao的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">55</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">23</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">126</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/RShawshank" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2022/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">数据库-常用数据库对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-25 15:14:59 / 修改时间：08:31:42" itemprop="dateCreated datePublished" datetime="2022-04-25T15:14:59Z">2022-04-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据完整性约束"><a href="#数据完整性约束" class="headerlink" title="数据完整性约束"></a>数据完整性约束</h1><ul>
<li>表的数据有一定的取值范围和联系，多表之间的数据有时也有一定的参照关系。</li>
<li>在创建表和修改表时，可通过定义约束条件来保证数据的完整性和一致性。</li>
<li>约束条件是一些规则，在对数据进行插入、删除和修改时要对这些规则进行验证，从而起到约束作用。</li>
</ul>
<h2 id="完整性约束分类"><a href="#完整性约束分类" class="headerlink" title="完整性约束分类"></a>完整性约束分类</h2><ul>
<li><p>域完整性约束（非空not null，检查check）</p>
</li>
<li><p>实体完整性约束（唯一unique，主键primary key）</p>
</li>
<li><p>参照完整性约束（外键foreign key）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>约束类型</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>主键约束（Primary  Key）</td>
<td>要求主键列数据唯一，并且不允许为空。主键可以包含表的一列或多列，如果包含表的多列，则需要在表级定义。</td>
</tr>
<tr>
<td>唯一约束（Unique）</td>
<td>要求该列唯一，允许为空，但只能出现一个空值</td>
</tr>
<tr>
<td>检查约束（Check）</td>
<td>某列取值范围限制、格式限制等，如年龄的约束</td>
</tr>
<tr>
<td>非空约束（not  null）</td>
<td>某类内容不能为空</td>
</tr>
<tr>
<td>外键约束（Foreign  Key）</td>
<td>用于两表间建立关系，需要指定引用主表的那列。外键通常用来约束两个表之间的数据关系，定义外键的那张表称为子表，另一张表称为主表。  在表的创建过程中，应该先创建主表，后创建子表。</td>
</tr>
</tbody></table>
<h2 id="三种完整性约束的区别"><a href="#三种完整性约束的区别" class="headerlink" title="三种完整性约束的区别"></a>三种完整性约束的区别</h2><ul>
<li>域完整性约束:字段约束</li>
<li>实体完整性约束：行和行之间的约束</li>
<li>引用完整性约束：表和表之间的约束</li>
</ul>
<h2 id="创建约束的时机"><a href="#创建约束的时机" class="headerlink" title="创建约束的时机"></a>创建约束的时机</h2><ul>
<li>在建表的同时创建</li>
<li>建表后创建</li>
<li>约束从作用上分类，可以分成两大类：<ul>
<li>表级约束：可以约束表中的任意一列或多列。可以定义出了Not Null以外的任何约束。</li>
<li>列级约束：只能约束其所在的某一列。可以定义任何约束。</li>
</ul>
</li>
</ul>
<h3 id="命名规则推荐采用-约束类型-约束字段"><a href="#命名规则推荐采用-约束类型-约束字段" class="headerlink" title="命名规则推荐采用:约束类型_约束字段"></a>命名规则推荐采用:约束类型_约束字段</h3><table>
<thead>
<tr>
<th>非空约束</th>
<th>NN_表名列名</th>
</tr>
</thead>
<tbody><tr>
<td>唯一约束</td>
<td>UK_表名_列名</td>
</tr>
<tr>
<td>主键约束</td>
<td>PK_表名</td>
</tr>
<tr>
<td>外键约束</td>
<td>FK_表名_列名</td>
</tr>
<tr>
<td>检查约束</td>
<td>CK_表名_列名</td>
</tr>
</tbody></table>
<h1 id="数据库表的约束"><a href="#数据库表的约束" class="headerlink" title="数据库表的约束"></a>数据库表的约束</h1><h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><ul>
<li>主键约束是数据库中最重要的一种约束。在关系中，主键值不可为空，也不允许出现重复，即关系要满足实体完整性规则。</li>
<li>主键从功能上看相当于非空且唯一</li>
<li>一个表中只允许一个主键</li>
<li>主键是表中能够唯一确定一个行数据的字段</li>
<li>主键字段可以是单字段或者是多字段的组合</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Oracle为主键创建对应的唯一性索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t3(</span><br><span class="line"> id number(<span class="number">4</span>)， <span class="comment">--primary key, </span></span><br><span class="line"> <span class="keyword">constraint</span> t3_pk <span class="keyword">primary</span> key(id)</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>

<h2 id="唯一性约束"><a href="#唯一性约束" class="headerlink" title="唯一性约束"></a>唯一性约束</h2><ul>
<li><p>唯一性约束条件确保所在的字段或者字段组合不出现重复值</p>
</li>
<li><p>唯一性约束条件的字段允许出现空值，且可以多个空值</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Oracle将为唯一性约束条件创建对应的唯一性索引</span><br><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees(</span><br><span class="line"> id   NUMBER(<span class="number">6</span>),</span><br><span class="line"> name    VARCHAR2(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line"> email      VARCHAR2(<span class="number">25</span>),</span><br><span class="line"> salary      NUMBER(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line"> hire_date    <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">CONSTRAINT</span> emp_email_uk <span class="keyword">UNIQUE</span>(email)</span><br><span class="line"> );</span><br></pre></td></tr></table></figure>

<h2 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h2><ul>
<li>确保字段值不允许为空</li>
<li>只能在字段级定义</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees(</span><br><span class="line">		employee_id    NUMBER(<span class="number">6</span>),</span><br><span class="line">		name      VARCHAR2(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">		salary         NUMBER(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">		hire_date      <span class="type">DATE</span> <span class="keyword">CONSTRAINT</span> emp_hire_date_nn <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<h2 id="check约束"><a href="#check约束" class="headerlink" title="check约束"></a>check约束</h2><ul>
<li>Check约束用于对一个属性的值加以限制</li>
<li>在check中定义检查的条件表达式，数据需要符合设置的条件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table <span class="title function_">emp3</span></span><br><span class="line"><span class="params">( id number(<span class="number">4</span>)</span> primary key,</span><br><span class="line"> age <span class="title function_">number</span><span class="params">(<span class="number">2</span>)</span> check(age &gt; <span class="number">0</span> and age &lt; <span class="number">100</span>),</span><br><span class="line"> salary <span class="title function_">number</span><span class="params">(<span class="number">7</span>,<span class="number">2</span>)</span>,</span><br><span class="line"> sex <span class="title function_">char</span><span class="params">(<span class="number">1</span>)</span>,</span><br><span class="line"> constraint salary_check <span class="title function_">check</span><span class="params">(salary &gt; <span class="number">0</span>)</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>在这种约束下，插入记录或修改记录时，系统要测试新的记录的值是否满足条件</li>
</ul>
<h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><ul>
<li>外键是表中的一个列，其值必须在另一表的主键或者唯一键中列出</li>
<li>作为主键的表称为“主表”，作为外键的关系称为“依赖表”</li>
<li>外键参照的是主表的主键或者唯一键</li>
<li>对于主表的删除和修改主键值的操作，会对依赖关系产生影响，以删除为例：当要删除主表的某个记录（即删除一个主键值，那么对依赖的影响可采取下列3种做法：<ul>
<li>RESTRICT方式：只有当依赖表中没有一个外键值与要删除的主表中主键值相对应时，才可执行删除操作。</li>
<li>CASCADE方式：将依赖表中所有外键值与主表中要删除的主键值相对应的记录一起删除</li>
<li>SET NULL方式：将依赖表中所有与主表中被删除的主键值相对应的外键值设为空值</li>
<li>FOREIGN KEY (DEPTNO) REFERENCES DEPT(DEPTNO)</li>
<li>[ON DELETE [CASCADE|SET NULL]] 如省略on短语，缺省为第一中处理方式。</li>
</ul>
</li>
</ul>
<h2 id="添加约束和删除约束"><a href="#添加约束和删除约束" class="headerlink" title="添加约束和删除约束"></a>添加约束和删除约束</h2><ul>
<li>添加约束</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 </span><br><span class="line">   <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 约束名 约束类型 具体的约束说明</span><br></pre></td></tr></table></figure>

<ul>
<li>删除约束</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 </span><br><span class="line">   <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> 约束名 </span><br></pre></td></tr></table></figure>

<ul>
<li>可增加或删除约束，但不能直接修改</li>
</ul>
<h1 id="索引index"><a href="#索引index" class="headerlink" title="索引index"></a>索引index</h1><ul>
<li>索引类型默认采用B树数据结构，数据全部集中在叶子节点</li>
<li>索引的创建有两种情况<ul>
<li>自动: 当在表上定义一个PRIMARY KEY 或者UNIQUE 约束条件时,Oracle数据库自动创建一个对应的唯一索引.</li>
<li>手动: 用户可以创建索引以加速查询</li>
</ul>
</li>
</ul>
<h2 id="相关语法"><a href="#相关语法" class="headerlink" title="相关语法"></a>相关语法</h2><ul>
<li>在一列或者多列上创建索引.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index  <span class="keyword">ON</span> <span class="keyword">table</span> (<span class="keyword">column</span>[, <span class="keyword">column</span>]...); </span><br></pre></td></tr></table></figure>

<p>下面的索引将会提高对EMP表基于 ENAME 字段的查询速度.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX  emp_last_name_idx</span><br><span class="line"><span class="keyword">ON</span>  emp (ename)</span><br></pre></td></tr></table></figure>

<ul>
<li>通过DROP INDEX 命令删掉一个索引.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index;</span><br></pre></td></tr></table></figure>

<ul>
<li>删掉 UPPER_LAST_NAME_IDX 索引.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX upper_last_name_idx;</span><br></pre></td></tr></table></figure>

<h1 id="序列sequence"><a href="#序列sequence" class="headerlink" title="序列sequence"></a>序列sequence</h1><p>序列是oracle专有的对象，它用来产生一个自动递增的数列 </p>
<p>创建序列的语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> sequence seq<span class="operator">-</span>name</span><br><span class="line">increment <span class="keyword">by</span> n</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> n</span><br><span class="line">maxvalue n<span class="operator">|</span>nomaxvalue <span class="number">10</span><span class="operator">^</span><span class="number">27</span> <span class="keyword">or</span> <span class="number">-1</span></span><br><span class="line">minvalue n<span class="operator">|</span><span class="keyword">no</span> minvalue</span><br><span class="line"><span class="keyword">cycle</span><span class="operator">|</span>nocycle</span><br><span class="line">cache n<span class="operator">|</span>nocache</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> sequence seq_empcopy_id <span class="keyword">start</span> <span class="keyword">with</span> <span class="number">1</span> increment <span class="keyword">by</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>使用序列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> seq_empcopy_id.nextval <span class="keyword">from</span> dual</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> empcopy (empno,ename)</span><br><span class="line">  <span class="keyword">values</span> (seq_empcopy_id.nextval, ‘TEST’);</span><br></pre></td></tr></table></figure>

<p>查看序列状态</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> seq_empcopy_id.currval <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>

<p>删除序列 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> sequence seq_empcopy_id;</span><br></pre></td></tr></table></figure>

<h1 id="视图view"><a href="#视图view" class="headerlink" title="视图view"></a>视图view</h1><ol>
<li>定义：</li>
</ol>
<ul>
<li>视图是从若干基本表和（或）其他视图构造出来的表。</li>
<li>在创建一个视图时，只是存放的视图的定义，也即是动态检索数据的查询语句，而并不存放视图对应的数据</li>
<li>在用户使用视图时才去求相对应的数据。所以视图被称作“虚表”</li>
</ul>
<ol start="2">
<li>作用：</li>
</ol>
<ul>
<li>可以限制对数据的访问，可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</li>
<li>可以使复杂的查询变的简单。在编写查询后，可以方便地重用它而不必知道他的基本查询细节。</li>
<li>提供了对相同数据的不同显示</li>
</ul>
<p>创建视图</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> <span class="keyword">view</span></span><br><span class="line">[(alias[, alias]...)]</span><br><span class="line"><span class="keyword">AS</span> subquery</span><br><span class="line">[<span class="keyword">WITH</span> READ <span class="keyword">ONLY</span>];</span><br></pre></td></tr></table></figure>

<p>查询视图</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> viewname</span><br></pre></td></tr></table></figure>

<p>不需要再写完全的Select查询语句，</p>
<p>删除视图</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Drop</span> <span class="keyword">view</span> viewname；</span><br></pre></td></tr></table></figure>

<p>删掉视图不会导致数据丢失，因为视图是基于数据库表的一个查询</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>视图是一个虚拟表，对应一条SELECT语句，可将它的输出看作一个表</li>
<li>视图不存储数据</li>
<li>改变基本表的数据，也会反应到基于该表的视图上</li>
<li>视图可以基于基本表的若干行，若干列</li>
<li>视图可以基于一个表、多个表，甚至是基于其他的视图</li>
<li>使用视图可以提高数据访问的安全性，只显示指定的行列数据</li>
<li>使用视图可以降低查询的难度，定制数据显示</li>
<li>可以对视图进行CRUD操作，实际上是对基本表的CRUD操作</li>
<li>如果视图对应多个表，一般不允许添加操作，可以通过触发器解决</li>
<li>使用with read only定义只读视图</li>
</ul>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位，是数据库环境中的逻辑工作单位。</p>
<p>事务是为了保证数据库的完整性</p>
<p>在oracle中，没有事务开始的语句。一个Transaction起始于一条DML(Insert、Update和Delete )语句，结束于以下的几种情况：</p>
<ul>
<li><p>用户显式执行Commit语句提交操作或Rollback语句回退。</p>
</li>
<li><p>当执行DDL(Create、Alter、Drop)语句事务自动提交。</p>
</li>
<li><p>用户正常断开连接时，Transaction自动提交。</p>
</li>
<li><p>系统崩溃或断电时事务自动回退。</p>
</li>
<li><p>Commit表示事务成功地结束，此时告诉系统，数据库要进入一个新的正确状态，该事务对数据库的所有更新都以交付实施。每个Commit语句都可以看成是一个事务成功的结束，同时也是另一个事务的开始。</p>
</li>
<li><p>Rollback表示事务不成功的结束，此时告诉系统，已发生错误，数据库可能处在不正确的状态，该事务对数据库的更新必须被撤销，数据库应恢复该事务到初始状态。每个Rollback语句同时也是另一个事务的开始。</p>
</li>
<li><p>一旦执行了commit语句，将目前对数据库的操作提交给数据库（实际写入DB），以后就不能用rollback进行撤销。</p>
</li>
<li><p>执行一个 DDL ，DCL语句或从 SQL*Plus正常退出，都会自动执行commit命令。</p>
</li>
<li><p>提交或回滚前数据的状态</p>
<ul>
<li>以前的数据可恢复</li>
<li>当前的用户可以看到DML操作的结果</li>
<li>其他用户不能看到DML操作的结果</li>
<li>被操作的数据被锁住,其他用户不能修改这些数据</li>
</ul>
</li>
<li><p>提交后数据的状态</p>
</li>
<li><p>数据的修改被永久写在数据库中.</p>
<ul>
<li>数据以前的状态永久性丢失.</li>
</ul>
</li>
<li><p>所有的用户都能看到操作后的结果.</p>
<ul>
<li>记录锁被释放,其他用户可操作这些记录.</li>
</ul>
</li>
<li><p>回滚后数据的状态</p>
<ul>
<li>语句将放弃所有的数据修改</li>
<li>修改的数据被回退.</li>
<li>恢复数据以前的状态.</li>
<li>行级锁被释放.</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2022/01/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">正则表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-12 15:47:51" itemprop="dateCreated datePublished" datetime="2022-01-12T15:47:51Z">2022-01-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-13 03:18:00" itemprop="dateModified" datetime="2022-01-13T03:18:00Z">2022-01-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><table>
<thead>
<tr>
<th>single char</th>
<th>quantifiers(数量)</th>
<th>position(位置)</th>
</tr>
</thead>
<tbody><tr>
<td>\d 匹配数字</td>
<td>* 0个或者更多</td>
<td>^一行的开头</td>
</tr>
<tr>
<td>\w  匹配word(数字、字母)</td>
<td>+ 1个或更多，至少1个</td>
<td>$一行的结尾</td>
</tr>
<tr>
<td>\W 匹配<strong>非</strong>word(数字、字母)</td>
<td>? 0个或1个,一个Optional</td>
<td>\b 单词”结界”(word bounds)</td>
</tr>
<tr>
<td>\s 匹配white space(包括空格、tab等)</td>
<td>{min,max}出现次数在一个范围内</td>
<td></td>
</tr>
<tr>
<td>\S 匹配<strong>非</strong>white space(包括空格、tab等)</td>
<td>{n}匹配出现n次的</td>
<td></td>
</tr>
<tr>
<td>. 匹配任何，任何的字符</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="常见的正则表达式"><a href="#常见的正则表达式" class="headerlink" title="常见的正则表达式"></a>常见的正则表达式</h2><h4 id="1、检验密码强度"><a href="#1、检验密码强度" class="headerlink" title="1、检验密码强度"></a><strong>1、检验密码强度</strong></h4><p>密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(<span class="string">?=</span>.*\\d)(<span class="string">?=</span>.*[a-z])(<span class="string">?=</span>.*[A-Z]).&#123;<span class="number">8</span>,<span class="number">10</span>&#125;$</span><br></pre></td></tr></table></figure>

<h4 id="2-校验中文"><a href="#2-校验中文" class="headerlink" title="2. 校验中文"></a><strong>2. 校验中文</strong></h4><p>字符串仅能是中文。</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[<span class="symbol">\\</span>u4e00-<span class="symbol">\\</span>u9fa5]&#123;0,&#125;$复制代码</span><br></pre></td></tr></table></figure>

<h4 id="3-由数字、26个英文字母或下划线组成的字符串"><a href="#3-由数字、26个英文字母或下划线组成的字符串" class="headerlink" title="3. 由数字、26个英文字母或下划线组成的字符串"></a><strong>3. 由数字、26个英文字母或下划线组成的字符串</strong></h4><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\\w+<span class="variable">$复</span>制代码</span><br></pre></td></tr></table></figure>

<h4 id="4-校验E-Mail-地址"><a href="#4-校验E-Mail-地址" class="headerlink" title="4. 校验E-Mail 地址"></a><strong>4. 校验E-Mail 地址</strong></h4><p>同密码一样，下面是E-mail地址合规性的正则检查语句。</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">\\</span>w!#$%&amp;&#x27;*+/=?^_`&#123;|&#125;~-]+(?:<span class="symbol">\\</span>.[<span class="symbol">\\</span>w!#$%&amp;&#x27;*+/=?^_`&#123;|&#125;~-]+)*@(?:[<span class="symbol">\\</span>w](?:[<span class="symbol">\\</span>w-]*[<span class="symbol">\\</span>w])?<span class="symbol">\\</span>.)+[<span class="symbol">\\</span>w](?:[<span class="symbol">\\</span>w-]*[<span class="symbol">\\</span>w])?复制代码</span><br></pre></td></tr></table></figure>

<h4 id="5-校验身份证号码"><a href="#5-校验身份证号码" class="headerlink" title="5. 校验身份证号码"></a><strong>5. 校验身份证号码</strong></h4><p>下面是身份证号码的正则校验。15 或 18位。</p>
<p>15位：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[<span class="number">1</span><span class="number">-9</span>]\\d&#123;<span class="number">7</span>&#125;((<span class="number">0</span>\\d)|<span class="type">(1</span>[<span class="number">0</span><span class="number">-2</span>]))(([<span class="number">0</span>|<span class="type">1</span>|<span class="type">2</span>]\\d)|<span class="type">3</span>[<span class="number">0</span><span class="number">-1</span>])\\d&#123;<span class="number">3</span>&#125;$复制代码</span><br></pre></td></tr></table></figure>

<p>18位：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^<span class="comment">[1-9]</span>\\d&#123;5&#125;<span class="comment">[1-9]</span>\\d&#123;3&#125;((0\\d)|(1<span class="comment">[0-2]</span>))((<span class="comment">[0|1|2]</span>\\d)|3<span class="comment">[0-1]</span>)\\d&#123;3&#125;(<span class="comment">[0-9]</span>|X)$复制代码</span><br></pre></td></tr></table></figure>

<h4 id="6-校验日期"><a href="#6-校验日期" class="headerlink" title="6. 校验日期"></a><strong>6. 校验日期</strong></h4><p>“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(?:(?!0000)<span class="comment">[0-9]</span>&#123;4&#125;-(?:(?:0<span class="comment">[1-9]</span>|1<span class="comment">[0-2]</span>)-(?:0<span class="comment">[1-9]</span>|1<span class="comment">[0-9]</span>|2<span class="comment">[0-8]</span>)|(?:0<span class="comment">[13-9]</span>|1<span class="comment">[0-2]</span>)-(?:29|30)|(?:0<span class="comment">[13578]</span>|1<span class="comment">[02]</span>)-31)|(?:<span class="comment">[0-9]</span>&#123;2&#125;(?:0<span class="comment">[48]</span>|<span class="comment">[2468]</span><span class="comment">[048]</span>|<span class="comment">[13579]</span><span class="comment">[26]</span>)|(?:0<span class="comment">[48]</span>|<span class="comment">[2468]</span><span class="comment">[048]</span>|<span class="comment">[13579]</span><span class="comment">[26]</span>)00)-02-29)$复制代码</span><br></pre></td></tr></table></figure>

<h4 id="7-校验金额"><a href="#7-校验金额" class="headerlink" title="7. 校验金额"></a><strong>7. 校验金额</strong></h4><p>金额校验，精确到2位小数。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^<span class="comment">[0-9]</span>+(.<span class="comment">[0-9]</span>&#123;2&#125;)?$复制代码</span><br></pre></td></tr></table></figure>

<h4 id="8-校验手机号"><a href="#8-校验手机号" class="headerlink" title="8. 校验手机号"></a><strong>8. 校验手机号</strong></h4><p>下面是国内 13、15、18开头的手机号正则表达式。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(<span class="number">13</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="type">14</span>[<span class="number">5</span>|<span class="type">7</span>]|<span class="type">15</span>[<span class="number">0</span>|<span class="type">1</span>|<span class="type">2</span>|<span class="type">3</span>|<span class="type">5</span>|<span class="type">6</span>|<span class="type">7</span>|<span class="type">8</span>|<span class="type">9</span>]|<span class="type">18</span>[<span class="number">0</span>|<span class="type">1</span>|<span class="type">2</span>|<span class="type">3</span>|<span class="type">5</span>|<span class="type">6</span>|<span class="type">7</span>|<span class="type">8</span>|<span class="type">9</span>])\\d&#123;<span class="number">8</span>&#125;$复制代码</span><br></pre></td></tr></table></figure>

<h4 id="9-判断IE的版本"><a href="#9-判断IE的版本" class="headerlink" title="9. 判断IE的版本"></a><strong>9. 判断IE的版本</strong></h4><p>IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^.*<span class="variable constant_">MSIE</span> [<span class="number">5</span>-<span class="number">8</span>](<span class="string">?:\\</span>.[<span class="number">0</span>-<span class="number">9</span>]+)<span class="string">?(</span><span class="string">?!</span>.*Trident\\/[<span class="number">5</span>-<span class="number">9</span>]\\.<span class="number">0</span>).*<span class="variable">$复</span>制代码</span><br></pre></td></tr></table></figure>

<h4 id="10-校验IP-v4地址"><a href="#10-校验IP-v4地址" class="headerlink" title="10. 校验IP-v4地址"></a><strong>10. 校验IP-v4地址</strong></h4><p>IP4 正则语句。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\b(?:(?:25<span class="comment">[0-5]</span>|2<span class="comment">[0-4]</span><span class="comment">[0-9]</span>|<span class="comment">[01]</span>?<span class="comment">[0-9]</span><span class="comment">[0-9]</span>?)\\.)&#123;3&#125;(?:25<span class="comment">[0-5]</span>|2<span class="comment">[0-4]</span><span class="comment">[0-9]</span>|<span class="comment">[01]</span>?<span class="comment">[0-9]</span><span class="comment">[0-9]</span>?)\\b复制代码</span><br></pre></td></tr></table></figure>

<h4 id="11-校验IP-v6地址"><a href="#11-校验IP-v6地址" class="headerlink" title="11. 校验IP-v6地址"></a><strong>11. 校验IP-v6地址</strong></h4><p>IP6 正则语句。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(([<span class="number">0</span>-<span class="number">9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">7</span>,<span class="number">7</span>&#125;[<span class="number">0</span>-<span class="number">9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;|([<span class="number">0</span>-<span class="number">9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">7</span>&#125;:|([<span class="number">0</span>-<span class="number">9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">6</span>&#125;:[<span class="number">0</span>-<span class="number">9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;|([<span class="number">0</span>-<span class="number">9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">5</span>&#125;<span class="comment">(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)</span>&#123;<span class="number">1</span>,<span class="number">4</span>&#125;<span class="comment">(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)</span>&#123;<span class="number">1</span>,<span class="number">3</span>&#125;<span class="comment">(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;<span class="comment">(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)</span>|fe8<span class="number">0</span>:<span class="comment">(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;((<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|(<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span>-<span class="number">9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span>-<span class="number">9</span>])\\.)&#123;<span class="number">3</span>,<span class="number">3</span>&#125;(<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|(<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span>-<span class="number">9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span>-<span class="number">9</span>])|([<span class="number">0</span>-<span class="number">9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:((<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|(<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span>-<span class="number">9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span>-<span class="number">9</span>])\\.)&#123;<span class="number">3</span>,<span class="number">3</span>&#125;(<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|(<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span>-<span class="number">9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span>-<span class="number">9</span>]))复制代码</span><br></pre></td></tr></table></figure>

<h4 id="12-检查URL的前缀"><a href="#12-检查URL的前缀" class="headerlink" title="12. 检查URL的前缀"></a><strong>12. 检查URL的前缀</strong></h4><p>应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!s.match(<span class="regexp">/^[a-zA-Z]+:\\/</span>\\<span class="regexp">//</span>))</span><br><span class="line">&#123;</span><br><span class="line">    s = <span class="string">&#x27;http://&#x27;</span> + s;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure>

<h4 id="13-提取URL链接"><a href="#13-提取URL链接" class="headerlink" title="13. 提取URL链接"></a><strong>13. 提取URL链接</strong></h4><p>下面的这个表达式可以筛选出一段文本中的URL。</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(f|ht)&#123;1&#125;(tp|tps):<span class="symbol">\\</span>/<span class="symbol">\\</span>/([<span class="symbol">\\</span>w-]+<span class="symbol">\\</span>.)+[<span class="symbol">\\</span>w-]+(<span class="symbol">\\</span>/[<span class="symbol">\\</span>w- ./?%&amp;=]*)?复制代码</span><br></pre></td></tr></table></figure>

<h4 id="14-文件路径及扩展名校验"><a href="#14-文件路径及扩展名校验" class="headerlink" title="14. 文件路径及扩展名校验"></a><strong>14. 文件路径及扩展名校验</strong></h4><p>验证文件路径和扩展名 </p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^([a-zA-Z]<span class="symbol">\\</span>:|<span class="symbol">\\</span><span class="symbol">\\</span>)<span class="symbol">\\</span><span class="symbol">\\</span>([^<span class="symbol">\\</span><span class="symbol">\\</span>]+<span class="symbol">\\</span><span class="symbol">\\</span>)*[^<span class="symbol">\\</span>/:*?&quot;&lt;&gt;|]+<span class="symbol">\\</span>.txt(l)?$复制代码</span><br></pre></td></tr></table></figure>

<h4 id="15-提取Color-Hex-Codes"><a href="#15-提取Color-Hex-Codes" class="headerlink" title="15. 提取Color Hex  Codes"></a><strong>15. 提取Color Hex  Codes</strong></h4><p>有时需要抽取网页中的颜色代码，可以使用下面的表达式。</p>
<figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\<span class="function"><span class="keyword">#</span><span class="params">([<span class="variable">a</span>-<span class="variable">fA</span>-<span class="variable">F</span>]|[0-9])</span></span>&#123;3,6&#125;复制代码</span><br></pre></td></tr></table></figure>

<h4 id="16-提取网页图片"><a href="#16-提取网页图片" class="headerlink" title="16. 提取网页图片"></a><strong>16. 提取网页图片</strong></h4><p>假若你想提取网页中所有图片信息，可以利用下面的表达式。</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">\\</span>&lt; *[img][^<span class="symbol">\\</span>&gt;]*[src] *= *[<span class="symbol">\\</span>&quot;<span class="symbol">\\</span>&#x27;]&#123;0,1&#125;([^<span class="symbol">\\</span>&quot;<span class="symbol">\\</span>&#x27;<span class="symbol">\\</span> &gt;]*)复制代码</span><br></pre></td></tr></table></figure>

<h4 id="17-提取页面超链接"><a href="#17-提取页面超链接" class="headerlink" title="17. 提取页面超链接"></a><strong>17. 提取页面超链接</strong></h4><p>提取html中的超链接。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(]*)</span><span class="comment">(href=&quot;https?://)</span><span class="comment">((?!(?:(?:www\\.)</span>?<span class="string">&#x27;.implode(&#x27;</span>|<span class="comment">(?:www\\.)</span>?<span class="string">&#x27;, $follow_list).&#x27;</span>))[^<span class="string">&quot;]+)&quot;</span><span class="comment">((?!.*\\brel=)</span>[^&gt;]*)<span class="comment">(?:[^&gt;]*)</span>&gt;复制代码</span><br></pre></td></tr></table></figure>

<h4 id="18-精炼CSS"><a href="#18-精炼CSS" class="headerlink" title="18. 精炼CSS"></a><strong>18. 精炼CSS</strong></h4><p>通过下面的表达式，可以搜索相同属性值的CSS，从而达到精炼代码的目的。</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^<span class="symbol">\\</span>s*[a-zA-Z<span class="symbol">\\</span>-]+<span class="symbol">\\</span>s*[:]&#123;1&#125;<span class="symbol">\\</span>s[a-zA-Z0-9<span class="symbol">\\</span>s.#]+[;]&#123;1&#125;复制代码</span><br></pre></td></tr></table></figure>

<h4 id="19-抽取注释"><a href="#19-抽取注释" class="headerlink" title="19. 抽取注释"></a><strong>19. 抽取注释</strong></h4><p>如果你需要移除HMTL中的注释，可以使用如下的表达式。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="20-匹配HTML标签"><a href="#20-匹配HTML标签" class="headerlink" title="20. 匹配HTML标签"></a><strong>20. 匹配HTML标签</strong></h4><p>通过下面的表达式可以匹配出HTML中的标签。</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">\\</span>s]+))?)+<span class="symbol">\\</span>s*|<span class="symbol">\\</span>s*)/?&gt;复制代码</span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903845227659271">正则表达式不要背 - 掘金 (juejin.cn)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%85%AD%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%85%AD%EF%BC%89/" class="post-title-link" itemprop="url">java-设计模式（六）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-29 09:28:21" itemprop="dateCreated datePublished" datetime="2021-12-29T09:28:21Z">2021-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-12 06:30:10" itemprop="dateModified" datetime="2022-01-12T06:30:10Z">2022-01-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="二十一、观察者模式（observer）"><a href="#二十一、观察者模式（observer）" class="headerlink" title="二十一、观察者模式（observer）"></a>二十一、观察者模式（observer）</h2><p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p>
<p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220112140918.png" alt="img"></p>
<ul>
<li><p>主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。</p>
</li>
<li><p>观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法,观察者为所有的具体观察者定义一个接口，在得到主题的通知时更新自己</p>
</li>
<li><p>ConcreteSubject类是具体主题，将有关状态存入具体观察者对象，在具体主题内部状态改变时，给所有登记过的观察者发出通知；</p>
</li>
<li><p>ConcreteObserver是具体观察者，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协同。</p>
</li>
</ul>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>主题Subject</p>
<p>　　首先定义一个观察者数组，并实现增、删及通知操作。它的职责很简单，就是定义谁能观察，谁不能观察，用Vector是线程同步的，比较安全，也可以使用ArrayList，是线程异步的，但不安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观察者数组</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; oVector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加一个观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.oVector.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除一个观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.oVector.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通知所有观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(Observer observer : <span class="built_in">this</span>.oVector) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象观察者Observer</p>
<p>　　观察者一般是一个接口，每一个实现该接口的实现类都是具体观察者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">     <span class="comment">//更新</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>具体主题</p>
<p>　　继承Subject类，在这里实现具体业务，在具体项目中，该类会有很多变种。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体业务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="built_in">super</span>.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体观察者</p>
<p>　　实现Observer接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息，进行处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client客户端</p>
<p>　　首先创建一个被观察者，然后定义一个观察者，将该被观察者添加到该观察者的观察者数组中，进行测试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个主题</span></span><br><span class="line">        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line">        <span class="comment">//定义一个观察者</span></span><br><span class="line">        <span class="type">Observer</span> <span class="variable">observer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>();</span><br><span class="line">        <span class="comment">//观察</span></span><br><span class="line">        subject.addObserver(observer);</span><br><span class="line">        <span class="comment">//开始活动</span></span><br><span class="line">        subject.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="开发中常见的场景"><a href="#开发中常见的场景" class="headerlink" title="开发中常见的场景"></a>开发中常见的场景</h3><ul>
<li><p>聊天室程序的，服务器转发给所有客户端</p>
</li>
<li><p>网络游戏(多人联机对战)场景中，服务器将客户端的状态进行分发</p>
</li>
<li><p>邮件订阅</p>
</li>
<li><p>Servlet中，监听器的实现</p>
</li>
<li><p>Android中，广播机制</p>
</li>
<li><p>JDK的AWT中事件处理模型,基于观察者模式的委派事件模型(Delegation Event Model)</p>
<ul>
<li><p>事件源—————-目标对象</p>
</li>
<li><p>事件监听器————观察者</p>
</li>
</ul>
</li>
<li><p>京东商城中，群发某商品打折信息</p>
</li>
</ul>
<h3 id="观察者模式的应用"><a href="#观察者模式的应用" class="headerlink" title="观察者模式的应用"></a>观察者模式的应用</h3><p>　　1. 何时使用</p>
<ul>
<li>一个对象状态改变，所有的依赖对象都将得到通知</li>
</ul>
<p> 　2. 方法</p>
<ul>
<li>使用面向对象技术</li>
</ul>
<p> 　3. 优点</p>
<ul>
<li>观察者和被观察者是抽象耦合的</li>
<li>建立了一套触发机制</li>
</ul>
<p> 　4. 缺点</p>
<ul>
<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间</li>
<li>如果观察者和观察目标间有循环依赖，可能导致系统崩溃</li>
<li>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的</li>
</ul>
<p> 　5. 使用场景</p>
<ul>
<li>关联行为场景</li>
<li>事件多级触发场景</li>
<li>跨系统的消息变换场景，如消息队列的处理机制</li>
</ul>
<p>　　6. 应用实例</p>
<ul>
<li>手机丢了，委托别人给其他人发消息通知</li>
<li>通知老师&#x2F;老板来了</li>
<li>拍卖，拍卖师观察最高标价，然后通知给其它竞价者竞价</li>
<li>在一个目录下建立一个文件，会同时通知目录管理器增加目录，并通知磁盘减少空间，文件是被观察者，目录管理器和磁盘管理器是观察者</li>
<li>猫叫了一声，吓着了老鼠，也惊到了主人，猫是被观察者，老鼠和人是观察者</li>
</ul>
<p>　　7. 注意事项</p>
<ul>
<li>避免循环引用</li>
<li>如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式</li>
</ul>
<h2 id="二十二、备忘录模式（Memento）"><a href="#二十二、备忘录模式（Memento）" class="headerlink" title="二十二、备忘录模式（Memento）"></a>二十二、备忘录模式（Memento）</h2><p>在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220112142720.png" alt="img"></p>
<ul>
<li>Originator：原始对象</li>
<li>Caretaker：负责保存好备忘录</li>
<li>Memento：备忘录，存储原始对象的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。</li>
</ul>
<h3 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h3><p>发起人角色</p>
<p>　　记录当前时刻的内部状态，并负责创建和恢复备忘录数据，允许访问返回到先前状态所需的所有数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">createMento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">Memento</span>(state));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemento</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;state = &quot;</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备忘录角色</p>
<p>　　负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Memento</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备忘录管理员角色</p>
<p>　　对备忘录进行管理、保存和提供备忘录，只能将备忘录传递给其他角色。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">getMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemento</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client客户端</p>
<p>　　下面编写一小段代码测试一下，即先将状态置为On，保存后再将状态置为Off，然后通过备忘录管理员角色恢复初始状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Originator</span> <span class="variable">originator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Originator</span>();</span><br><span class="line">        originator.setState(<span class="string">&quot;On&quot;</span>);    <span class="comment">//Originator初始状态</span></span><br><span class="line">        originator.show();</span><br><span class="line"></span><br><span class="line">        <span class="type">Caretaker</span> <span class="variable">caretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Caretaker</span>();</span><br><span class="line">        caretaker.setMemento(originator.createMento());</span><br><span class="line"></span><br><span class="line">        originator.setState(<span class="string">&quot;Off&quot;</span>);    <span class="comment">//Originator状态变为Off</span></span><br><span class="line">        originator.show();</span><br><span class="line"></span><br><span class="line">        originator.setMemento(caretaker.getMemento());    <span class="comment">//回复初始状态</span></span><br><span class="line">        originator.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="备忘录模式的应用"><a href="#备忘录模式的应用" class="headerlink" title="备忘录模式的应用"></a>备忘录模式的应用</h3><p>　　1. 何时使用</p>
<ul>
<li>需要记录一个对象的内部状态时，为了允许用户取消不确定或者错误的操作，能够恢复到原先的状态</li>
</ul>
<p>　　2. 方法</p>
<ul>
<li>通过一个备忘录类专门存储对象状态</li>
</ul>
<p>　　3. 优点</p>
<ul>
<li>给用户提供了一种可以恢复状态的机制，可以使用能够比较方便地回到某个历史的状态</li>
<li>实现了信息的封装，使得用户不需要关心状态的保存细节</li>
</ul>
<p>　　4. 缺点</p>
<ul>
<li>消耗资源</li>
</ul>
<p>　　5. 使用场景</p>
<ul>
<li>需要保存和恢复数据的相关场景</li>
<li>提供一个可回滚的操作，如ctrl+z、浏览器回退按钮、Backspace键等</li>
<li>需要监控的副本场景</li>
</ul>
<p>　　6. 应用实例</p>
<ul>
<li>游戏存档</li>
<li>ctrl+z键、浏览器回退键等（撤销&#x2F;还原）</li>
<li>棋盘类游戏的悔棋</li>
<li>数据库事务的回滚</li>
</ul>
<p>　　7. 注意事项</p>
<ul>
<li>为了符合迪米特法则，需要有一个管理备忘录的类</li>
<li>不要在频繁建立备份的场景中使用备忘录模式。为了节约内存，可使用原型模式+备忘录模式</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89/" class="post-title-link" itemprop="url">java-设计模式（五）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-29 09:28:10" itemprop="dateCreated datePublished" datetime="2021-12-29T09:28:10Z">2021-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-12 05:43:40" itemprop="dateModified" datetime="2022-01-12T05:43:40Z">2022-01-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="十四、中介者模式（Mediator）"><a href="#十四、中介者模式（Mediator）" class="headerlink" title="十四、中介者模式（Mediator）"></a>十四、中介者模式（Mediator）</h2><p>集中相关对象之间复杂的沟通和控制方式。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220111163216.png" alt="img"></p>
<ul>
<li>Mediator是抽象中介者，定义了同事对象到中介者对象的接口；</li>
<li>Colleague是抽象同事类；</li>
<li>ConcreteMediator是具体中介者对象，实现抽象类的方法，它需要知道所有具体同事类，并从具体同事接收消息，向具体同事对象发出命令；</li>
<li>ConcreteColleague是具体同事类，每个具体同事只知道自己的行为，而不了解其它同事类的情况，但它们却都认识中介者对象。</li>
</ul>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>抽象中介者</p>
<p>　　抽象中介者角色定义统一的接口，用于各同事角色之间的通信。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象的发送消息方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message, Colleague colleague)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象同事类</p>
<p>　　每一个同事角色都知道中介者角色，而且与其它的同事角色通信的时候，一定要通过中介者角色协作。每个同事类的行为分两种：一种是同事本身行为，比如改变对象本身的状态，处理自己的行为等，这种行为叫做自发行为，与其它同事类或者中介者没有任何依赖；第二种是必须依赖中介者才能完成的行为，叫做依赖方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Colleague</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体中介者类</p>
<p>　　具体中介者角色通过协调各同事角色实现协作行为，因此它必须依赖于各个同事角色。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcreteColleague1 colleague1;</span><br><span class="line">    <span class="keyword">private</span> ConcreteColleague2 colleague2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColleague1</span><span class="params">(ConcreteColleague1 colleague1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.colleague1 = colleague1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColleague2</span><span class="params">(ConcreteColleague2 colleague2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.colleague2 = colleague2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message, Colleague colleague)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(colleague == colleague1) &#123;</span><br><span class="line">            colleague2.notify(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            colleague1.notify(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体同事类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteColleague1</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteColleague1</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        mediator.send(message, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;同事1得到消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcreteMediator</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteMediator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ConcreteColleague1</span> <span class="variable">colleague1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteColleague1</span>(mediator);</span><br><span class="line">        <span class="type">ConcreteColleague2</span> <span class="variable">colleague2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteColleague2</span>(mediator);</span><br><span class="line"></span><br><span class="line">        mediator.setColleague1(colleague1);</span><br><span class="line">        mediator.setColleague2(colleague2);</span><br><span class="line"></span><br><span class="line">        colleague1.send(<span class="string">&quot;Nice to meet u.&quot;</span>);</span><br><span class="line">        colleague2.send(<span class="string">&quot;Nice to meet u too.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中介者模式的应用"><a href="#中介者模式的应用" class="headerlink" title="中介者模式的应用"></a>中介者模式的应用</h3><p>　　1. 何时使用</p>
<ul>
<li>多个类相互耦合，形成网状结构时</li>
</ul>
<p>　　2. 方法</p>
<ul>
<li>将网状结构分离为星型结构</li>
</ul>
<p>　　3. 优点</p>
<ul>
<li>减少类间依赖，降低了耦合</li>
<li>符合迪米特原则</li>
</ul>
<p>　　4. 缺点</p>
<ul>
<li>中介者会膨胀的很大，而且逻辑复杂</li>
</ul>
<p>　　5. 使用场景</p>
<ul>
<li>系统中对象之间存在比较复杂的引用关系</li>
<li>想通过一个中间类来封装多个类的行为，而又不想生成太多的子类</li>
</ul>
<h4 id="开发中常见的场景"><a href="#开发中常见的场景" class="headerlink" title="开发中常见的场景"></a>开发中常见的场景</h4><ul>
<li>MVC模式(其中的C，控制器就是一个中介者对象。M和V都和他打交道) </li>
<li>窗口游戏程序，窗口软件开发中窗口对象也是一个中介者对象</li>
<li>图形界面开发GUI中，多个组件之间的交互，可以通过引入一个中介者 对象来解决，可以是整体的窗口对象或者DOM对象</li>
<li>Java.lang.reflect.Method#invoke()</li>
</ul>
<h2 id="十五、命令模式（command）"><a href="#十五、命令模式（command）" class="headerlink" title="十五、命令模式（command）"></a>十五、命令模式（command）</h2><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220111165607.png" alt="img"></p>
<ul>
<li>Invoker调用者&#x2F;请求者：请求的发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联。在程序运行时，将调用命令对象的execute()，间接调用接收者的相关操作。</li>
<li>Command是命令角色，需要执行的所有命令都在这里声明，可以是接口或抽象类；</li>
<li>Receiver接收者：知道如何实施与执行一个请求相关的操作，任何类都可能作为一个接收者；</li>
<li>ConcreteCommand将一个接收者对象绑定与一个动作，调用接收者相应的操作，以实现Execute。</li>
<li>Client：在客户类中故需要创建调用者对象、具体命令类对象，在创建具体命令对象是指定对应的接收者。发送者和接收者之间没有直接的关系，都通过命令对象来调用</li>
</ul>
<h3 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h3><p>command类</p>
<p>​	用来声明执行操作的接口&#x2F;抽象类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Command</span><span class="params">(Receiver receiver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行命令的方法</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteCommand类</p>
<p>　　具体的Command类，用于构造传递接收者，根据环境需求，具体的命令类也可能有n个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造传递接收者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteCommand</span><span class="params">(Receiver receiver)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(receiver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//必须实现一个命令</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Invoker类</p>
<p>　　接收命令，并执行命令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受命令</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行命令</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Receiver类</p>
<p>　　该角色就是干活的角色， 命令传递到这里是应该被执行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行请求！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client类</p>
<p>　　首先定义一个接收者，然后定义一个命令用于发送给接收者，之后再声明一个调用者，即可把命令交给调用者执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义接收者</span></span><br><span class="line">        <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>();</span><br><span class="line">        <span class="comment">//定义一个发送给接收者的命令</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteCommand</span>(receiver);</span><br><span class="line">        <span class="comment">//声明调用者</span></span><br><span class="line">        <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Invoker</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把命令交给调用者执行</span></span><br><span class="line">        invoker.setCommand(command);</span><br><span class="line">        invoker.executeCommand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命令模式的应用"><a href="#命令模式的应用" class="headerlink" title="命令模式的应用"></a>命令模式的应用</h3><p>　　1. 何时使用</p>
<ul>
<li>在某些场合，如要对行为进行“记录、撤销&#x2F;重做、事务”等处理时</li>
</ul>
<p> 　2. 方法</p>
<ul>
<li>通过调用者调用接收者执行命令，顺序为调用者→接收者→命令</li>
</ul>
<p> 　3. 优点</p>
<ul>
<li>类间耦合，调用者角色与接收者角色之间没有任何依赖关系</li>
<li>可扩展性</li>
<li>命令模式结合职责链模式可以实现命令族解析任务；结合模板方法模式可以减少Command子类的膨胀问题</li>
</ul>
<p> 　4. 缺点</p>
<ul>
<li>可能导致某些系统有过多的具体命令类</li>
</ul>
<p> 　5. 使用场景</p>
<ul>
<li>认为是命令的地方都可以使用</li>
<li>系统需要支持命令的撤销&#x2F;恢复操作时</li>
</ul>
<p> 　6. 应用实例</p>
<ul>
<li>GUI中每一个按钮都是一条命令</li>
<li>模拟CMD（DOS命令）</li>
<li>订单的撤销&#x2F;恢复</li>
<li>触发-反馈机制的处理</li>
</ul>
<h2 id="十六、解释器模式（interpreter）——不常用"><a href="#十六、解释器模式（interpreter）——不常用" class="headerlink" title="十六、解释器模式（interpreter）——不常用"></a>十六、解释器模式（interpreter）——不常用</h2><p>为语言创建解释器，通常由语言的语法和语法分析来定义。</p>
<ul>
<li>用于描述如何构成一个简单的语言解释器，主要用于使用面向对象语言开发的 编译器和解释器设计。 </li>
<li>当我们需要开发一种新的语言时，可以考虑使用解释器模式。 </li>
<li><strong>尽量不要使用解释器模式</strong>，后期维护会有很大麻烦。在项目中，可以使用 Jruby，Groovy、java的js引擎来替代解释器的作用，弥补java语言的不足</li>
</ul>
<h2 id="十七、访问者模式（visitor）"><a href="#十七、访问者模式（visitor）" class="headerlink" title="十七、访问者模式（visitor）"></a>十七、访问者模式（visitor）</h2><p>表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变元素的类的前提下定义作用于这些元素的新操作。</p>
<h3 id="开发中的场景-应用范围非常窄，了解即可"><a href="#开发中的场景-应用范围非常窄，了解即可" class="headerlink" title="开发中的场景(应用范围非常窄，了解即可)"></a>开发中的场景(应用范围非常窄，了解即可)</h3><ul>
<li>XML文档解析器设计</li>
<li>编译器的设计</li>
<li>复杂集合对象的处理</li>
</ul>
<h2 id="十八、策略模式（strategy）"><a href="#十八、策略模式（strategy）" class="headerlink" title="十八、策略模式（strategy）"></a>十八、策略模式（strategy）</h2><p>定义一系列算法，封装每个算法，并使它们可以互换。（<strong>分离算法，选择实现</strong>）</p>
<p>策略模式可以让算法独立于使用它的客户端。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220112111007.png" alt="img"></p>
<ul>
<li>Context是上下文，用一个ConcreteStrategy来配置，维护一个对Strategy对象的引用；</li>
<li>Strategy是策略类，用于定义所有支持算法的公共接口；</li>
<li>ConcreteStrategy是具体策略类，封装了具体的算法或行为，继承于Strategy。</li>
</ul>
<h3 id="与状态模式的比较"><a href="#与状态模式的比较" class="headerlink" title="与状态模式的比较"></a>与状态模式的比较</h3><p>状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。</p>
<p>状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。</p>
<h3 id="Implementation-2"><a href="#Implementation-2" class="headerlink" title="Implementation"></a>Implementation</h3><p>Context上下文</p>
<p>　　Context上下文角色，也叫Context封装角色，起承上启下的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"></span><br><span class="line">    Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上下文接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.algorithmInterface();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>策略角色</p>
<p>　　抽象策略角色，是对策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。algorithm是“运算法则”的意思。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//算法方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体策略角色</p>
<p>　　用于实现抽象策略中的操作，即实现具体的算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">extends</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;算法A实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client客户端</p>
<p>　　下面依次更换策略，测试一下策略模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Context context;</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>());</span><br><span class="line">        context.contextInterface();</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>());</span><br><span class="line">        context.contextInterface();</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyC</span>());</span><br><span class="line">        context.contextInterface();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="策略模式的应用"><a href="#策略模式的应用" class="headerlink" title="策略模式的应用"></a>策略模式的应用</h3><p>　　1. 何时使用</p>
<ul>
<li>一个系统有许多类，而区分它们的只是他们直接的行为时</li>
</ul>
<p>　　2. 方法</p>
<ul>
<li>将这些算法封装成一个一个的类，任意的替换</li>
</ul>
<p>　　3. 优点</p>
<ul>
<li>算法可以自由切换</li>
<li>避免使用多重条件判断（如果不用策略模式我们可能会使用多重条件语句，不利于维护）</li>
<li>扩展性良好，增加一个策略只需实现接口即可</li>
</ul>
<p>　　4. 缺点</p>
<ul>
<li>策略类数量会增多，每个策略都是一个类，复用的可能性很小</li>
<li>所有的策略类都需要对外暴露</li>
</ul>
<p>　　5. 使用场景</p>
<ul>
<li>多个类只有算法或行为上稍有不同的场景</li>
<li>算法需要自由切换的场景</li>
<li>需要屏蔽算法规则的场景</li>
</ul>
<p>　　6. 应用实例</p>
<ul>
<li>出行方式，自行车、汽车等，每一种出行方式都是一个策略</li>
<li>商场促销方式，打折、满减等</li>
<li>Java AWT中的LayoutManager，即布局管理器</li>
</ul>
<p>　　7. 注意事项</p>
<ul>
<li>如果一个系统的策略多于四个，就需要考虑使用混合模式来解决策略类膨胀的问题</li>
</ul>
<h3 id="开发中常见的场景-1"><a href="#开发中常见的场景-1" class="headerlink" title="开发中常见的场景"></a>开发中常见的场景</h3><ul>
<li>JAVASE中GUI编程中，布局管理</li>
<li>Spring框架中，Resource接口，资源访问策略 </li>
<li>javax.servlet.http.HttpServlet#service()</li>
</ul>
<h2 id="十九、模板方法模式（template-method）"><a href="#十九、模板方法模式（template-method）" class="headerlink" title="十九、模板方法模式（template method）"></a>十九、模板方法模式（template method）</h2><p>定义算法框架，并将一些步骤的实现延迟到子类。</p>
<p>通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p>
<p><strong>处理步骤父类中定义好，具体实现延迟到子类中定义。</strong></p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220112111539.png" alt="img"></p>
<ul>
<li>AbstractClass实现类一个模板方法，定义了算法的骨架，具体子类将重定义PrimitiveOperation以实现一个算法的步骤；</li>
<li>ConcreteClass实现了PrimitiveOperation以完成算法中与特定子类相关的步骤。</li>
</ul>
<h3 id="Implementation-3"><a href="#Implementation-3" class="headerlink" title="Implementation"></a>Implementation</h3><p>抽象模板类</p>
<p>　　定义一个模板方法来组合PrimitiveOperation1()和PrimitiveOperation2()两个方法形成一个算法，然后让子类重定义这两个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">PrimitiveOperation1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">PrimitiveOperation2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TemplateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        PrimitiveOperation1();</span><br><span class="line">        PrimitiveOperation2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体模板类</p>
<p>　　这里定义两个具体模板类，ConcreteClassA及ConcreteClassB来进行测试，继承抽象模板类，实现具体方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClassA</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrimitiveOperation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体方法A方法1实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrimitiveOperation2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体方法A方法2实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client客户端</p>
<p>　　通过调用模板方法来分别得到不同的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AbstractClass abstractClass;</span><br><span class="line"></span><br><span class="line">        abstractClass = <span class="keyword">new</span> <span class="title class_">ConcreteClassA</span>();</span><br><span class="line">        abstractClass.TemplateMethod();</span><br><span class="line"></span><br><span class="line">        abstractClass = <span class="keyword">new</span> <span class="title class_">ConcreteClassB</span>();</span><br><span class="line">        abstractClass.TemplateMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="开发中常见的场景："><a href="#开发中常见的场景：" class="headerlink" title="开发中常见的场景："></a>开发中常见的场景：</h3><p>非常频繁，各个框架、类库都存在</p>
<ul>
<li>数据库访问的封装</li>
<li>Junit单元测试</li>
<li>servlet中关于doGet（）和doPost（）方法调用</li>
<li>Hibernate中模板程序</li>
<li>spring中JDBCTemplate、HibernateTemplate···</li>
</ul>
<h3 id="模板方法模式的应用"><a href="#模板方法模式的应用" class="headerlink" title="模板方法模式的应用"></a>模板方法模式的应用</h3><p>　　1. 何时使用</p>
<ul>
<li>有一些通用的方法时</li>
</ul>
<p>　　2. 方法</p>
<ul>
<li>将通用算法抽象出来</li>
</ul>
<p>　　3. 优点</p>
<ul>
<li>封装不变部分，扩展可变部分</li>
<li>提取公共部分代码，便于维护</li>
<li>行为由父类控制，子类实现</li>
</ul>
<p>　　4. 缺点</p>
<ul>
<li>每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大</li>
</ul>
<p>　　5. 使用场景</p>
<ul>
<li>有多个子类共有的方法，且逻辑相同</li>
<li>重要的、复杂的方法，可以考虑作为模板方法</li>
<li>重构时，模板方法模式是一个经常使用到的模式，把相同的代码抽取到父类中，通过钩子函数约束其行为</li>
</ul>
<p>　　6. 应用实例</p>
<ul>
<li>做试卷，大家题目都是一样的，只是答案不同</li>
<li>对于汽车，车从发动到停车的顺序是相同的，不同的是引擎声、鸣笛声等</li>
<li>造房时，地基、走线、水管都一样，只有在建筑后期才有差异</li>
</ul>
<p>　　7. 注意事项</p>
<ul>
<li>为防恶意操作，一般模板方法都加上final关键字</li>
</ul>
<h2 id="二十、状态模式（state）"><a href="#二十、状态模式（state）" class="headerlink" title="二十、状态模式（state）"></a>二十、状态模式（state）</h2><p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220112133737.png" alt="img"></p>
<ul>
<li>Context类为环境角色，用于维护一个ConcreteState子类的实例，这个实例定义当前的状态；</li>
<li>State为抽象状态角色，定义一个接口以封装与Context的一个特定接口状态相关的行为；</li>
<li>ConcreteState是具体状态角色，每一个子类实现一个与Context的一个状态相关的行为。</li>
</ul>
<h3 id="Implementation-4"><a href="#Implementation-4" class="headerlink" title="Implementation"></a>Implementation</h3><p>Context类</p>
<p>　　环境角色具有两个职责，即处理本状态必须完成的任务，及决定是否可以过渡到其它状态。对于环境角色，有几个不成文的约束：</p>
<ul>
<li>即把状态对象声明为静态常量，有几个状态对象就声明几个状态常量</li>
<li>环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">State</span> <span class="variable">STATE1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteState1</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">State</span> <span class="variable">STATE2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteState2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前状态</span></span><br><span class="line">    <span class="keyword">private</span> State currentState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得当前状态</span></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置当前状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCurrentState</span><span class="params">(State currentState)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentState = currentState;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;当前状态：&quot; + currentState);</span></span><br><span class="line">        <span class="comment">//切换状态</span></span><br><span class="line">        <span class="built_in">this</span>.currentState.setContext(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentState.handle1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentState.handle2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> State抽象状态类</p>
<p>　　抽象环境中声明一个环境角色，提供各个状态类自行访问，并且提供所有状态的抽象行为，由各个实现类实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Context context;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//行为1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handle1</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//行为2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handle2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 具体状态</p>
<p>　　具体状态实现，这里以定义ConcreteState1和ConcreteState2两个具体状态类为例，ConcreteState2的具体内容同ConcreteState1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteState1</span> <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteState1 的 handle1 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.context.setCurrentState(Context.STATE2);</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteState1 的 handle2 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client客户端</p>
<p>　　定义Context环境角色，初始化具体状态1，执行行为观察结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义环境角色</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        <span class="comment">//初始化状态</span></span><br><span class="line">        context.setCurrentState(<span class="keyword">new</span> <span class="title class_">ConcreteState1</span>());</span><br><span class="line">        <span class="comment">//行为执行</span></span><br><span class="line">        context.handle1();</span><br><span class="line">        context.handle2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="开发中常见的场景-2"><a href="#开发中常见的场景-2" class="headerlink" title="开发中常见的场景"></a>开发中常见的场景</h3><ul>
<li>银行系统中账号状态的管理</li>
<li>OA系统中公文状态的管理</li>
<li>酒店系统中，房间状态的管理</li>
<li>线程对象各状态之间的切换</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89/" class="post-title-link" itemprop="url">java-设计模式（四）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-29 09:28:00" itemprop="dateCreated datePublished" datetime="2021-12-29T09:28:00Z">2021-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-11 08:08:24" itemprop="dateModified" datetime="2022-01-11T08:08:24Z">2022-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="九、装饰模式（decorator）"><a href="#九、装饰模式（decorator）" class="headerlink" title="九、装饰模式（decorator）"></a>九、装饰模式（decorator）</h2><p>为对象动态添加功能。</p>
<p>装饰模式是一种用来代替继承的技术，无须通过继承增加子类就能拓展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时可以<strong>避免类型体系的快速膨胀</strong>。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220110143736.png" alt="img"></p>
<ul>
<li>Component：抽象构件，真实对象和装饰对象都有的接口，这样，客户端对象可以以与真实对象相同的方式同装饰对象交互</li>
<li>ConreteComponent：具体构件对象（真实对象）</li>
<li>Decorator：装饰角色。持有一个<strong>抽象构件</strong>的引用，装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象。这样，就能在真实对象调用前后增加新的功能</li>
<li>ConreteDecorator：具体装饰对象。负责给构件对象增加新的责任</li>
</ul>
<p> 要点： <strong>装饰者与被装饰者拥有共同的超类，继承的目的是继承类型，而不是行为</strong></p>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>component抽象类：</p>
<p>Component是一个接口或是抽象类，就是定义我们最核心的对象，也就是最原始的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">     </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>conretetComponent:</p>
<p>具体构件，通过继承实现Component抽象类中的抽象方法。是最核心、最原始、最基本的接口或抽象类的实现，我们要装饰的就是它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConretetComponent</span> <span class="keyword">extends</span> <span class="title class_">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体对象的操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Decorator装饰类:</p>
<p>　　一般是一个抽象类，在其属性里必然有一个private变量指向Component抽象构件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造函数传递给被修饰者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//委托给被修饰者执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(component != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.component.operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteDecorator类：</p>
<p>　　我们可以写多个具体实现类，把最核心的、最原始的、最基本的东西装饰成其它东西。</p>
<p>　　这里就写两个类，稍改一下二者的实现顺序，看看结果。</p>
<p>　　A类，它的operation()方法先执行了method1()方法，再执行了Decorator的operation()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义被修饰者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecoratorA</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义自己的修饰方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method1 修饰&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.method1();</span><br><span class="line">        <span class="built_in">super</span>.operation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B类，它的operation()方法先执行了Decorator的operation()方法，再执行了method2()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDecoratorB</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义被修饰者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecoratorB</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义自己的修饰方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2 修饰&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.operation();</span><br><span class="line">        <span class="built_in">this</span>.method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>();</span><br><span class="line">        <span class="comment">//第一次修饰</span></span><br><span class="line">        component = <span class="keyword">new</span> <span class="title class_">ConcreteDecoratorA</span>(component);</span><br><span class="line">        <span class="comment">//第二次修饰</span></span><br><span class="line">        component = <span class="keyword">new</span> <span class="title class_">ConcreteDecoratorB</span>(component);</span><br><span class="line">        <span class="comment">//修饰后运行</span></span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IO流实现细节"><a href="#IO流实现细节" class="headerlink" title="IO流实现细节"></a>IO流实现细节</h3><ul>
<li>Component抽象构件角色：<ul>
<li>io流中的InputStream、OutputStream、Reader、Writer</li>
</ul>
</li>
<li>ConcreteComponent 具体构件角色：<ul>
<li>io流中的FileInputStream、FileOutputStream</li>
</ul>
</li>
<li>Decorator装饰角色：<ul>
<li>持有一个抽象构件的引用：io流中的FilterInputStream、FilterOutputStream</li>
</ul>
</li>
<li>ConcreteDecorator具体装饰角色：<ul>
<li>负责给构件对象增加新的责任。Io流中的BufferedOutputStream、BufferedInputStream等。</li>
</ul>
</li>
</ul>
<h3 id="装饰模式的应用"><a href="#装饰模式的应用" class="headerlink" title="装饰模式的应用"></a>装饰模式的应用</h3><p>　1. 何时使用</p>
<ul>
<li>在不想增加很多子类的情况下扩展类时</li>
</ul>
<p> 　2. 方法</p>
<ul>
<li>将具体功能职责划分，同时继承装饰者模式</li>
</ul>
<p> 　3. 优点</p>
<ul>
<li>装饰类和被装饰类可以独立发展，而不会相互耦合。它有效地把类的核心职责和装饰功能分开了</li>
<li>装饰模式是继承关系的一个替代方案</li>
<li>装饰模式可以动态地扩展一个实现类的功能</li>
</ul>
<p>　　4. 缺点</p>
<ul>
<li>多层装饰比较复杂。比如我们现在有很多层装饰，出了问题，一层一层检查，最后发现是最里层的装饰出问题了，想想工作量都害怕</li>
</ul>
<p>　　5. 使用场景</p>
<ul>
<li>需要扩展一个类的功能时</li>
<li>需要动态地给一个对象增加功能，并可以动态地撤销时</li>
<li>需要为一批的兄弟类进行改装或加装功能时</li>
</ul>
<h3 id="装饰模式和桥接模式的区别"><a href="#装饰模式和桥接模式的区别" class="headerlink" title="装饰模式和桥接模式的区别"></a>装饰模式和桥接模式的区别</h3><p>两个模式都是为了解决过多子类对象问题。但他们的诱因不一样。桥接模式是对象自身现有机制沿着多个维度变化，是既有部分不稳定。装饰模式是为了增加新的功能。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/adamjwh/p/9036358.html">简说设计模式——装饰模式 - JAdam - 博客园 (cnblogs.com)</a></p>
<h2 id="十、外观模式（facade）"><a href="#十、外观模式（facade）" class="headerlink" title="十、外观模式（facade）"></a>十、外观模式（facade）</h2><p>提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。</p>
<h3 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h3><p>观看电影需要操作很多电器，使用外观模式实现一键看电影功能。</p>
<p>子系统角色：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOnTV</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;turnOnTV()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCD</span><span class="params">(String cd)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;setCD( &quot;</span> + cd + <span class="string">&quot; )&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startWatching</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;startWatching()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外观类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystem</span> <span class="variable">subSystem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystem</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watchMovie</span><span class="params">()</span> &#123;</span><br><span class="line">        subSystem.turnOnTV();</span><br><span class="line">        subSystem.setCD(<span class="string">&quot;a movie&quot;</span>);</span><br><span class="line">        subSystem.startWatching();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Facade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Facade</span>();</span><br><span class="line">        facade.watchMovie();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少。</p>
<h3 id="外观模式的应用"><a href="#外观模式的应用" class="headerlink" title="外观模式的应用"></a>外观模式的应用</h3><p>　　1. 何时使用</p>
<ul>
<li>客户端不需要知道系统内部的复杂联系，整个系统只提供一个“接待员”即可</li>
<li>定义系统的入口</li>
</ul>
<p> 　2. 方法</p>
<ul>
<li>客户端不与系统耦合，外观类与系统耦合</li>
</ul>
<p> 　3. 优点</p>
<ul>
<li>减少了系统的相互依赖</li>
<li>提高了灵活性。不管系统内部如何变化，只要不影响到外观对象，任你自由活动</li>
<li>提高了安全性。想让你访问子系统的哪些业务就开通哪些逻辑，不在外观上开通的方法，你就访问不到</li>
</ul>
<p> 　4. 缺点</p>
<ul>
<li>不符合开不原则，修改很麻烦</li>
</ul>
<p> 　5. 使用场景</p>
<ul>
<li>为一个复杂的模块或子系统提供一个外界访问的接口</li>
<li>子系统相对独立，外界对子系统的访问只要黑箱操作即可</li>
<li>预防低水平人员带来的风险扩散</li>
</ul>
<h2 id="十一、享元模式（FlyWeight）"><a href="#十一、享元模式（FlyWeight）" class="headerlink" title="十一、享元模式（FlyWeight）"></a>十一、享元模式（FlyWeight）</h2><p>运用共享技术有效地支持大量细粒度的对象。</p>
<p>池技术：String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220110153253.png" alt="img"></p>
<ul>
<li>FlyWeightFactory：享元工厂类。创建并管理享元对象，享元池一般设计成键值对。</li>
<li>FlyWeight：抽象享元类。通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，设置外部状态。</li>
<li>ConcreteFlyWeight：具体享元类。为内部状态提供成员变量进行存储</li>
<li>UnsharedConcreteFlyWeight：非共享享元类。不能被共享的子类可以设计为非共享享元类</li>
</ul>
<h3 id="Implementation-2"><a href="#Implementation-2" class="headerlink" title="Implementation"></a>Implementation</h3><p>Flyweight抽象类</p>
<p>　　所有具体享元类的超类或接口，通过这个接口，Flyweight可以接受并作用于外部状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Flyweight</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部状态</span></span><br><span class="line">    <span class="keyword">public</span> String intrinsic;</span><br><span class="line">    <span class="comment">//外部状态</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String extrinsic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要求享元角色必须接受外部状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Flyweight</span><span class="params">(String extrinsic)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.extrinsic = extrinsic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义业务操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> extrinsic)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getIntrinsic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> intrinsic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIntrinsic</span><span class="params">(String intrinsic)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.intrinsic = intrinsic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteFlyweight类</p>
<p>　　继承Flyweight超类或实现Flyweight接口，并为其内部状态增加存储空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title class_">Flyweight</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受外部状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteFlyweight</span><span class="params">(String extrinsic)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(extrinsic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据外部状态进行逻辑处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> extrinsic)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体Flyweight:&quot;</span> + extrinsic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UnsharedConcreteFlyweight类</p>
<p>　　指那些不需要共享的Flyweight子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsharedConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title class_">Flyweight</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnsharedConcreteFlyweight</span><span class="params">(String extrinsic)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(extrinsic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> extrinsic)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不共享的具体Flyweight:&quot;</span> + extrinsic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FlyweightFactory类</p>
<p>　　一个享元工厂，用来创建并管理Flyweight对象，主要是用来确保合理地共享Flyweight，当用户请求一个Flyweight时，FlyweightFactory对象提供一个已创建的实例或创建一个实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyweightFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个池容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, Flyweight&gt; pool = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//享元工厂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Flyweight <span class="title function_">getFlyweight</span><span class="params">(String extrinsic)</span> &#123;</span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">flyweight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pool.containsKey(extrinsic)) &#123;    <span class="comment">//池中有该对象</span></span><br><span class="line">            flyweight = pool.get(extrinsic);</span><br><span class="line">            System.out.print(<span class="string">&quot;已有 &quot;</span> + extrinsic + <span class="string">&quot; 直接从池中取----&gt;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//根据外部状态创建享元对象</span></span><br><span class="line">            flyweight = <span class="keyword">new</span> <span class="title class_">ConcreteFlyweight</span>(extrinsic);</span><br><span class="line">            <span class="comment">//放入池中</span></span><br><span class="line">            pool.put(extrinsic, flyweight);</span><br><span class="line">            System.out.print(<span class="string">&quot;创建 &quot;</span> + extrinsic + <span class="string">&quot; 并从池中取出----&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">extrinsic</span> <span class="operator">=</span> <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">flyweightX</span> <span class="operator">=</span> FlyweightFactory.getFlyweight(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">        flyweightX.operate(++ extrinsic);</span><br><span class="line"></span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">flyweightY</span> <span class="operator">=</span> FlyweightFactory.getFlyweight(<span class="string">&quot;Y&quot;</span>);</span><br><span class="line">        flyweightY.operate(++ extrinsic);</span><br><span class="line"></span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">flyweightZ</span> <span class="operator">=</span> FlyweightFactory.getFlyweight(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">        flyweightZ.operate(++ extrinsic);</span><br><span class="line"></span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">flyweightReX</span> <span class="operator">=</span> FlyweightFactory.getFlyweight(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">        flyweightReX.operate(++ extrinsic);</span><br><span class="line"></span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">unsharedFlyweight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnsharedConcreteFlyweight</span>(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">        unsharedFlyweight.operate(++ extrinsic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部状态和外部状态"><a href="#内部状态和外部状态" class="headerlink" title="内部状态和外部状态"></a>内部状态和外部状态</h3><p>　　上面享元模式的定义为我们提出了两个要求：细粒度和共享对象。我们知道分配太多的对象到应用程序中将有损程序的性能，同时还容易造成内存溢出，要避免这种情况，用到的就是共享技术，这里就需要提到内部状态和外部状态了。</p>
<p>　　因为要求细粒度对象，所以不可避免地会使对象数量多且性质相近，此时我们就将这些对象的信息分为两个部分：内部状态和外部状态。</p>
<p>　　<strong>内部状态</strong>指对象共享出来的信息，存储在享元对象内部并且不会随环境的改变而改变；<strong>外部状态</strong>指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。</p>
<p>　　我们举一个最简单的例子，棋牌类游戏大家都有玩过吧，比如说说围棋和跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色略多一点，但也是不太变化的，所以棋子颜色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同，我们落子嘛，落子颜色是定的，但位置是变化的，所以方位坐标就是棋子的外部状态。</p>
<p>　　那么为什么这里要用享元模式呢？可以想象一下，上面提到的棋类游戏的例子，比如围棋，理论上有361个空位可以放棋子，常规情况下每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题。</p>
<h3 id="享元模式的应用"><a href="#享元模式的应用" class="headerlink" title="享元模式的应用"></a>享元模式的应用</h3><p>　　1. 何时使用</p>
<ul>
<li>系统中有大量对象时</li>
<li>这些对象消耗大量内存时</li>
<li>这些对象的状态大部分可以外部化时</li>
</ul>
<p>　　2. 方法</p>
<ul>
<li>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap&#x2F;HashTable存储</li>
</ul>
<p>　　3. 优点</p>
<ul>
<li>大大减少了对象的创建，降低了程序内存的占用，提高效率</li>
</ul>
<p>　　4. 缺点</p>
<ul>
<li>提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变</li>
<li>为了节省内存，共享了内部状态，分离出外部状态，而读取外部状态 使运行时间变长。用时间换取了空间。</li>
</ul>
<p> 　5. 使用场景</p>
<ul>
<li>系统中存在大量相似对象</li>
<li>需要缓冲池的场景</li>
</ul>
<p> 　6. 应用实例</p>
<ul>
<li>String常量池</li>
<li>数据库连接池</li>
</ul>
<p> 　7. 注意事项</p>
<ul>
<li>注意划分内部状态和外部状态，否则可能会引起线程安全问题</li>
<li>这些类必须有一个工厂类加以控制</li>
</ul>
<h1 id="结构型模式汇总"><a href="#结构型模式汇总" class="headerlink" title="结构型模式汇总"></a>结构型模式汇总</h1><table>
<thead>
<tr>
<th align="center">代理模式</th>
<th align="center">为真实对象提供一个代理，从而控制对真实对象的访问</th>
</tr>
</thead>
<tbody><tr>
<td align="center">适配模式</td>
<td align="center">使原本由于接口不兼容不能一起工作的类可以一起工作</td>
</tr>
<tr>
<td align="center">桥接模式</td>
<td align="center">处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。</td>
</tr>
<tr>
<td align="center">组合模式</td>
<td align="center">将对象组合成树状结构以表示”部分和整体”层次结构，使得客户可以统一 的调用叶子对象和容器对象</td>
</tr>
<tr>
<td align="center">装饰模式</td>
<td align="center">动态地给一个对象添加额外的功能，比继承灵活</td>
</tr>
<tr>
<td align="center">外观模式</td>
<td align="center">为子系统提供统一的调用接口，使得子系统更加容易使用</td>
</tr>
<tr>
<td align="center">享元模式</td>
<td align="center">运用共享技术有效的实现管理大量细粒度对象，节省内存，提高效率</td>
</tr>
</tbody></table>
<h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><ul>
<li><p>行为型模式关注的是系统中对象之间的相互交互，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责。</p>
</li>
<li><p>创建型模式关注的是对象的创建过程。</p>
</li>
<li><p>结构型模式关注的是对象和类的组织。</p>
</li>
</ul>
<h2 id="十二、责任链模式（chain-of-responsibility）"><a href="#十二、责任链模式（chain-of-responsibility）" class="headerlink" title="十二、责任链模式（chain of responsibility）"></a>十二、责任链模式（chain of responsibility）</h2><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220110162827.png" alt="img"></p>
<ul>
<li>Handler：抽象处理者。定义了一个处理请求的接口。</li>
<li>ConcreteHandler：具体处理者。处理它所负责的请求，可访问它的后继者。如果可处理该请求就处理，否则就将该请求转发给它的后继者。</li>
</ul>
<h3 id="Implementation-3"><a href="#Implementation-3" class="headerlink" title="Implementation"></a>Implementation</h3><p>抽象处理者</p>
<p>　　抽象处理者实现了三个职责：</p>
<ul>
<li>定义一个请求的处理方法handlerMessage()，是唯一对外开放的方法</li>
<li>定义一个链的编排方式setNext()，用于设置下一个处理者</li>
<li>定义了具体的请求者必须实现的两个方法，即定义自己能够处理的级别的getHandlerLevel()方法及具体的处理任务echo()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;    <span class="comment">//下一个处理者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Response <span class="title function_">handlerMessage</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.getHandlerLevel().equals(request.getRequestLevel())) &#123;    <span class="comment">//判断是否是自己的处理级别</span></span><br><span class="line">            response = <span class="built_in">this</span>.echo(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.nextHandler != <span class="literal">null</span>) &#123;    <span class="comment">//下一处理者不为空</span></span><br><span class="line">                response = <span class="built_in">this</span>.nextHandler.handlerMessage(request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没有适当的处理者，业务自行处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定下一个处理者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Handler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个处理者的处理等级</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Level <span class="title function_">getHandlerLevel</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个处理者都必须实现的处理任务</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Response <span class="title function_">echo</span><span class="params">(Request request)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体处理者</p>
<p>　　这里我们定义三个具体处理者，以便能组成一条链，ConcreteHandlerB及ConcreteHandlerC就不再赘述了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandlerA</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Level <span class="title function_">getHandlerLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置自己的处理级别</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Response <span class="title function_">echo</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="comment">//完成处理逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="责任链模式的应用"><a href="#责任链模式的应用" class="headerlink" title="责任链模式的应用"></a>责任链模式的应用</h3><p>开发中常见的场景： </p>
<ul>
<li>Java中，异常机制就是一种责任链模式。一个try可以对应多个catch， 当第一个catch不匹配类型，则自动跳到第二个catch. </li>
<li>Javascript语言中，事件的冒泡和捕获机制。Java语言中，事件的处理 采用观察者模式。</li>
<li>Servlet开发中，过滤器的链式处理 </li>
<li>Struts2中，拦截器的调用也是典型的责任链模式</li>
</ul>
<p>　　1. 何时使用</p>
<ul>
<li>处理消息时</li>
</ul>
<p>　　2. 方法</p>
<ul>
<li>拦截的类都实现同一接口</li>
</ul>
<p>　　3. 优点</p>
<ul>
<li>将请求和处理分开，实现解耦，提高系统的灵活性</li>
<li>简化了对象，使对象不需要知道链的结构</li>
</ul>
<p>　　4. 缺点</p>
<ul>
<li>性能会收到影响，特别是在链比较长的时候</li>
<li>调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂</li>
<li>不能保证请求一定被接收</li>
</ul>
<p>　　5. 使用场景</p>
<ul>
<li>有多个对象可以处理同一个请求</li>
<li>在不明确指定接收者的情况下，向多个对象中的提交请求</li>
<li>可动态指定一组对象处理请求</li>
</ul>
<p>　　6. 应用实例</p>
<ul>
<li>多级请求</li>
<li>击鼓传花</li>
<li>请假&#x2F;加薪请求</li>
<li>Java Web中Tomcat对Encoding的处理、拦截器</li>
</ul>
<p>　　7. 注意事项</p>
<ul>
<li>需控制链中最大节点数量，一般通过在Handler中设置一个最大节点数量，在setNext()方法中判断是否已经超过阀值，超过则不允许该链建立，避免出现超长链无意识地破坏系统性能</li>
</ul>
<h2 id="十三、迭代器模式（iterator）"><a href="#十三、迭代器模式（iterator）" class="headerlink" title="十三、迭代器模式（iterator）"></a>十三、迭代器模式（iterator）</h2><p>提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220111155357.png" alt="img"></p>
<ul>
<li>Aggregate：聚集抽象类。负责提供创建具体迭代器角色的接口</li>
<li>Iterator：迭代抽象类，用于定义得到开始对象、得到下一个对象、判断是否到结尾、当前对象等抽象方法，统一接口</li>
<li>ConcreteAggregate：具体聚集类，继承Aggregate</li>
<li>ConcreteIterator：具体迭代器类，继承Iterator，实现开始、下一个、是否结尾、当前对象等方法</li>
</ul>
<h3 id="Implementation-4"><a href="#Implementation-4" class="headerlink" title="Implementation"></a>Implementation</h3><p>抽象容器</p>
<p>　　负责提供接口，比如存在一个类似createIterator()这样的方法，在Java中一般是iterator()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Aggregate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object object)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Object object)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象迭代器</p>
<p>　　负责定义访问和遍历元素的接口，基本上有固定的三个方法，即first()获取第一个元素、next()访问下一个元素、hasNext()是否已经遍历到底部。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span>;    <span class="comment">//遍历到下一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;    <span class="comment">//是否已经遍历到尾部</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">()</span>;    <span class="comment">//删除当前指向的元素</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体容器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title class_">Aggregate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Vector</span> <span class="variable">vector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vector.add(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.remove(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteIterator</span>(<span class="built_in">this</span>.vector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体迭代器</p>
<p>　简单的实现就是通过一个游标，在一个容器中上下翻滚，遍历所有它需要查看的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Vector</span> <span class="variable">vector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//定义当前游标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteIterator</span><span class="params">(Vector vector)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vector = vector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.hasNext()) &#123;</span><br><span class="line">            result = <span class="built_in">this</span>.vector.get(<span class="built_in">this</span>.cursor ++);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.cursor == <span class="built_in">this</span>.vector.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vector.remove(<span class="built_in">this</span>.cursor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器模式的应用"><a href="#迭代器模式的应用" class="headerlink" title="迭代器模式的应用"></a>迭代器模式的应用</h3><p>　　1. 何时使用</p>
<ul>
<li>遍历一个聚合对象时</li>
</ul>
<p>　　2. 方法</p>
<ul>
<li>把在元素间游走的责任交给迭代器，而不是聚合对象</li>
</ul>
<p>　　3. 优点</p>
<ul>
<li>支持以不同的方式遍历一个聚合对象</li>
<li>迭代器简化了聚合类</li>
<li>在同一个聚合上可以有多个遍历</li>
<li>增加新的聚合类和迭代器类都很方便，无需修改原有代码</li>
</ul>
<p>　　4. 缺点</p>
<ul>
<li>增加了系统的复杂性。因为迭代器模式将存储数据和遍历数据的职责分离，增加了新的聚合类需要对应增加新的迭代器类，增加了系统的复杂性。</li>
</ul>
<p>　　5. 使用场景 </p>
<ul>
<li>访问一个聚合对象的内容无需暴露它的内部表示时</li>
<li>需要为聚合对象提供多种便利方式时</li>
<li>为遍历不同的聚合结构提供一个统一的接口</li>
</ul>
<p>　　6. 应用实例</p>
<ul>
<li>Java中的Iterator迭代器</li>
<li>foreach遍历</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">java-设计模式（三）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-29 09:27:50" itemprop="dateCreated datePublished" datetime="2021-12-29T09:27:50Z">2021-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-10 06:27:48" itemprop="dateModified" datetime="2022-01-10T06:27:48Z">2022-01-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>核心作用：是从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题。</p>
<p>分类：</p>
<ul>
<li>适配器模式、代理模式、桥接模式、 装饰模式、组合模式、外观模式、享元模式</li>
</ul>
<table>
<thead>
<tr>
<th>代理模式</th>
<th>为真实对象提供一个代理，从而控制对真实对象的访问</th>
</tr>
</thead>
<tbody><tr>
<td>适配模式</td>
<td>使原本由于接口不兼容不能一起工作的类可以一起工作</td>
</tr>
<tr>
<td>桥接模式</td>
<td>处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。</td>
</tr>
<tr>
<td>组合模式</td>
<td>将对象组合成树状结构以表示”部分和整体”层次结构，使得客户可以统一的调用叶子对象和容器对象</td>
</tr>
<tr>
<td>装饰模式</td>
<td>动态地给一个对象添加额外的功能，比继承灵活</td>
</tr>
<tr>
<td>外观模式</td>
<td>为子系统提供统一的调用接口，使得子系统更加容易使用</td>
</tr>
<tr>
<td>享元模式</td>
<td>运用共享技术有效的实现管理大量细粒度对象，节省内存，提高效率</td>
</tr>
</tbody></table>
<h2 id="五、代理模式（proxy）"><a href="#五、代理模式（proxy）" class="headerlink" title="五、代理模式（proxy）"></a>五、代理模式（proxy）</h2><p>控制对其它对象的访问。</p>
<p><strong>核心作用：</strong></p>
<p>控制对其他对象的访问。</p>
<p><strong>核心角色：</strong></p>
<ul>
<li><p>抽象角色：定义代理角色和真实角色的公共给对外方法</p>
</li>
<li><p>真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用</p>
<p><strong>关注真正的业务逻辑！</strong></p>
</li>
<li><p>代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。</p>
<p><strong>将统一的流程控制放到代理角色中处理!</strong></p>
</li>
</ul>
<p><strong>开发框架中应用场景：</strong></p>
<ul>
<li>struts2中拦截器的实现</li>
<li>数据库连接池关闭处理</li>
<li>Hibernate中延时加载的实现</li>
<li>mybatis中实现拦截器插件</li>
<li>AspectJ的实现</li>
<li>spring中AOP的实现<ul>
<li>日志拦截</li>
<li>声明式事务处理</li>
</ul>
</li>
<li>web service</li>
<li>RMI远程方法调用</li>
</ul>
<p>包含四类：</p>
<ul>
<li><p>远程代理（remote proxy）:控制对源程对象不同地址空间）的访问。它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。</p>
</li>
<li><p>虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。</p>
</li>
<li><p>保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。</p>
</li>
<li><p>智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。</p>
</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9b679ff5-94c6-48a7-b9b7-2ea868e828ed.png"/> </div><br>

<p>例子：</p>
<p>以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HighResolutionImage</span> <span class="keyword">implements</span> <span class="title class_">Image</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> URL imageURL;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> startTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HighResolutionImage</span><span class="params">(URL imageURL)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.imageURL = imageURL;</span><br><span class="line">        <span class="built_in">this</span>.startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="built_in">this</span>.width = <span class="number">600</span>;</span><br><span class="line">        <span class="built_in">this</span>.height = <span class="number">600</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLoad</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟图片加载，延迟 3s 加载完成</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> endTime - startTime &gt; <span class="number">3000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Real Image: &quot;</span> + imageURL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProxy</span> <span class="keyword">implements</span> <span class="title class_">Image</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HighResolutionImage highResolutionImage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImageProxy</span><span class="params">(HighResolutionImage highResolutionImage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.highResolutionImage = highResolutionImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!highResolutionImage.isLoad()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Temp Image: &quot;</span> + highResolutionImage.getWidth() + <span class="string">&quot; &quot;</span> + highResolutionImage.getHeight());</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        highResolutionImage.showImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageViewer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">image</span> <span class="operator">=</span> <span class="string">&quot;http://image.jpg&quot;</span>;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(image);</span><br><span class="line">        <span class="type">HighResolutionImage</span> <span class="variable">highResolutionImage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HighResolutionImage</span>(url);</span><br><span class="line">        <span class="type">ImageProxy</span> <span class="variable">imageProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageProxy</span>(highResolutionImage);</span><br><span class="line">        imageProxy.showImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向切面编程AOP介绍"><a href="#面向切面编程AOP介绍" class="headerlink" title="面向切面编程AOP介绍"></a>面向切面编程AOP介绍</h2><p>AOP（Aspect-Oriented Programming，面向切面的编程） </p>
<ul>
<li>它是可以通过预编译方式和运行期动态代理实现在不修改源代码的情 况下给程序动态统一添加功能的一种技术。它是一种新的方法论，它是对传统OOP编程的一种补充。</li>
</ul>
<p>常用术语：</p>
<ul>
<li><p>切面（Aspect）：其实就是共有功能的实现。 </p>
</li>
<li><p>通知（Advice）：是切面的具体实现。 </p>
</li>
<li><p>连接点（Joinpoint）：就是程序在运行过程中能够插入切面的地点。 </p>
</li>
<li><p>切入点（Pointcut）：用于定义通知应该切入到哪些连接点上。 </p>
</li>
<li><p>目标对象（Target）：就是那些即将切入切面的对象，也就是那些被通知的对象 </p>
</li>
<li><p>代理对象（Proxy）：将通知应用到目标对象之后被动态创建的对象。 </p>
</li>
<li><p>织入（Weaving）：将切面应用到目标对象从而创建一个新的代理对象的过程。</p>
</li>
</ul>
<p>开源的AOP框架：</p>
<ul>
<li>Aspect</li>
</ul>
<h2 id="六、适配器模式（Adapter）"><a href="#六、适配器模式（Adapter）" class="headerlink" title="六、适配器模式（Adapter）"></a>六、适配器模式（Adapter）</h2><p>把一个类接口转换成另一个用户需要的接口。</p>
<p><strong>使用场景</strong></p>
<ul>
<li>系统需要使用<strong>现有的类</strong>，而这些类的<strong>接口不符合</strong>系统的需要。</li>
<li>想要建立一个可以<strong>重复使用</strong>的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li>
<li>需要一个<strong>统一的输出接口</strong>，而输入端的类型不可预知。</li>
</ul>
<p><strong>工作中的场景</strong></p>
<ul>
<li><p>经常用来做旧系统改造和升级</p>
</li>
<li><p>如果我们的系统开发之后再也不需要维护，那么很多模式都是没必要的，但是不幸的是，事实却是维护一个系统的代价往往是开发一个系统的数倍。</p>
</li>
</ul>
<p><strong>我们学习中见过的场景</strong></p>
<ul>
<li>java.io.InputStreamReader(InputStream)</li>
<li>java.io.OutputStreamWriter(OutputStream)</li>
</ul>
<h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><p>一句话描述：Adapter类，通过<strong>继承</strong>需要被适配的类，<strong>实现</strong>我们想要的类<strong>接口</strong>，完成src-&gt;dst的适配。</p>
<p>我们现有的src类：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 介绍：src类: 我们有的220V电压</span></span><br><span class="line"><span class="comment"> * 作者：zhangxutong</span></span><br><span class="line"><span class="comment"> * 邮箱：zhangxutong@imcoming.com</span></span><br><span class="line"><span class="comment"> * 时间： 2016/10/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Voltage220</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">output220V</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> src = <span class="number">220</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;我是&quot;</span> + src + <span class="string">&quot;V&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想要的dst接口：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 介绍：dst接口：客户需要的5V电压</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> 作者：zhangxutong</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 邮箱：zhangxutong@imcoming.com</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> 时间： 2016/10/18.</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">*/</span></span></span></span></span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">interface</span> <span class="title">Voltage5</span> </span>&#123;</span><br><span class="line">    <span class="built_in">int</span> output5V();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适配器类：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 介绍：Adapter类：完成220V-5V的转变</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> 通过继承src类，实现 dst 类接口，完成src-&gt;dst的适配。</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 作者：zhangxutong</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> 邮箱：zhangxutong@imcoming.com</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 时间： 2016/10/18.</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span>/</span></span></span></span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220</span> <span class="keyword">implements</span> <span class="title">Voltage5</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="built_in">int</span> output5V() &#123;</span><br><span class="line">        <span class="built_in">int</span> src = output220V();</span><br><span class="line">        System.out.println(<span class="string">&quot;适配器工作开始适配电压&quot;</span>);</span><br><span class="line">        <span class="built_in">int</span> dst = src / <span class="number">44</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;适配完成后输出电压：&quot;</span> + dst);</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象的适配器模式（常用）"><a href="#对象的适配器模式（常用）" class="headerlink" title="对象的适配器模式（常用）"></a>对象的适配器模式（常用）</h3><p>基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承src类，而是持有src类的实例，以解决<strong>兼容性</strong>的问题。<br> 即：<strong>持有</strong> src类，<strong>实现</strong> dst 类<strong>接口</strong>，完成src-&gt;dst的适配。<br> （根据“合成复用原则”，在系统中<strong>尽量使用关联关系来替代继承关系</strong>，因此大部分结构型模式都是对象结构型模式。）</p>
<p> Adapter类如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 介绍：对象适配器模式：</span></span><br><span class="line"><span class="comment"> * 持有 src类，实现 dst 类接口，完成src-&gt;dst的适配。 。以达到解决**兼容性**的问题。</span></span><br><span class="line"><span class="comment"> * 作者：zhangxutong</span></span><br><span class="line"><span class="comment"> * 邮箱：zhangxutong@imcoming.com</span></span><br><span class="line"><span class="comment"> * 时间： 2016/10/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VoltageAdapter2</span> <span class="title">implements</span> <span class="title">Voltage5</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Voltage220 mVoltage220;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VoltageAdapter2</span>(<span class="params">Voltage220 voltage220</span>)</span> &#123;</span><br><span class="line">        mVoltage220 = voltage220;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">output5V</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> dst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != mVoltage220) &#123;</span><br><span class="line">            <span class="built_in">int</span> src = mVoltage220.output220V();</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;对象适配器工作，开始适配电压&quot;</span>);</span><br><span class="line">            dst = src / <span class="number">44</span>;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;适配完成后输出电压：&quot;</span> + dst);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。<br> 根据合成复用原则，组合大于继承，<br> 所以它解决了类适配器必须继承src的局限性问题，也不再强求dst必须是接口。<br> 同样的它使用成本更低，更灵活。</p>
<p>（和装饰者模式初学时可能会弄混，这里要搞清，装饰者是对src的装饰，使用者毫无察觉到src已经被装饰了（使用者用法不变）。 这里对象适配以后，使用者的用法还是变的。<br> <strong>即，装饰者用法： setSrc-&gt;setSrc，对象适配器用法：setSrc-&gt;setAdapter.</strong>)</p>
<h3 id="接口的适配器模式"><a href="#接口的适配器模式" class="headerlink" title="接口的适配器模式"></a>接口的适配器模式</h3><p>定义：</p>
<p>当不需要<strong>全部实现</strong>接口提供的方法时，可先设计一个<strong>抽象类</strong>实现接口，并为该接口中每个方法提供一个<strong>默认实现</strong>（空方法），那么该抽象类的子类可<strong>有选择</strong>地覆盖父类的某些方法来实现需求，它适用于<strong>一个接口不想使用其所有的方法</strong>的情况。</p>
<h2 id="七、桥接模式（Bridge）"><a href="#七、桥接模式（Bridge）" class="headerlink" title="七、桥接模式（Bridge）"></a>七、桥接模式（Bridge）</h2><p>将抽象与实现分离开来，使得它们可以独立变化。</p>
<p><strong>核心要点</strong></p>
<ul>
<li>处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。</li>
</ul>
<p><strong>效果及实现要点</strong>：</p>
<ol>
<li>桥接模式使用对象见的组合关系解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。</li>
<li>所谓抽象和实现沿着各自维度的变化，即“<strong>子类化</strong>”它们，得到各个子类之后，便可以任意它们，从而获得不同路上的不同其次。</li>
<li>桥接模式有时候类似于多继承方案，但是多继承方案往往违背了SRP原则，复用性较差。桥接模式是比继承方案更好的解决方法。</li>
<li>桥接模式的应用一般在“两个非常强的变化维度”，有时候即使有两个变化的维度，但是某个方向的变化维度并不剧烈——换而言之两个变化不会导致纵横交错的结果，并不一定要使用桥接模式。</li>
</ol>
<p><strong>使用场景</strong></p>
<ol>
<li>如果你不希望在抽象和实现部分采用固定的绑定关系，可以采用桥接模式，来把抽象和实现部分分开，然后在程序运行期间来动态的设置抽象部分需要用到的具体的实现，还可以动态切换具体的实现。</li>
<li>如果出现抽象部分和实现部分都应该可以扩展的情况，可以采用桥接模式，让抽象部分和实现部分可以独立的变化，从而可以灵活的进行单独扩展，而不是搅在一起，扩展一边会影响到另一边。</li>
<li>如果希望实现部分的修改，不会对客户产生影响，可以采用桥接模式，客户是面向抽象的接口在运行，实现部分的修改，可以独立于抽象部分，也就不会对客户产生影响了，也可以说对客户是透明的。</li>
<li>如果采用继承的实现方案，会导致产生很多子类，对于这种情况，可以考虑采用桥接模式，分析功能变化的原因，看看是否能分离成不同的纬度，然后通过桥接模式来分离它们，从而减少子类的数目。</li>
</ol>
<p><strong>实际开发中应用场景</strong></p>
<ul>
<li>JDBC驱动程序 <ul>
<li>AWT中的Peer架构</li>
</ul>
</li>
<li>银行日志管理：<ul>
<li>格式分类：操作日志、交易日志、异常日志 </li>
<li>距离分类：本地记录日志、异地记录日志</li>
</ul>
</li>
<li>人力资源系统中的奖金计算模块： <ul>
<li>奖金分类：个人奖金、团体奖金、激励奖金。 </li>
<li>部门分类：人事部门、销售部门、研发部门。</li>
</ul>
</li>
<li>OA系统中的消息处理： <ul>
<li>业务类型：普通消息、加急消息、特急消息 </li>
<li>发送消息方式：系统内消息、手机短信、邮件</li>
</ul>
</li>
</ul>
<h2 id="八、组合模式（composite）"><a href="#八、组合模式（composite）" class="headerlink" title="八、组合模式（composite）"></a>八、组合模式（composite）</h2><p>将对象组合成树形结构来表示“整体&#x2F;部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。</p>
<p><strong>组合模式核心：</strong></p>
<ul>
<li>组合部件（Component）：它是一个抽象角色，为要组合的对象提供统一的接口。</li>
<li>叶子（Leaf）：在组合中表示子节点对象，叶子节点不能有子节点。</li>
<li>合成部件（Composite）：定义有枝节点的行为，用来存储部件，实现在Component接口中的有关操作，如增加（Add）和删除（Remove）</li>
</ul>
<p>组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。</p>
<p>组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。</p>
<h3 id="透明模式"><a href="#透明模式" class="headerlink" title="透明模式"></a>透明模式</h3><p>在Component中声明所有来管理子对象的方法，其中包括Add，Remove等。这样实现Component接口的所有子类都具备了Add和Remove方法。这样做的好处是叶节点和枝节点对于外界没有区别，它们具备完全一致的接口。</p>
<p>component：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Component</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加一个叶子构件或树枝构件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component component)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除一个叶子构件或树枝构件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component component)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取分支下的所有叶子构件和树枝构件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> depth)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>composite：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Composite</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建容器</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; componentArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Component&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.componentArrayList.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.componentArrayList.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="comment">//输出树形结构</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;depth; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下级遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Component component : componentArrayList) &#123;</span><br><span class="line">            component.display(depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>leaf：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Leaf</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="comment">//空实现，抛出“不支持请求”异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="comment">//空实现，抛出“不支持请求”异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="comment">//输出树形结构的叶子节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;depth; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>弊端：客户端对叶节点和枝节点是一致的，但叶节点并不具备Add和Remove的功能，因而对它们的实现是没有意义的</p>
<h3 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h3><p>安全模式是把树枝节点和树叶节点彻底分开，树枝节点单独拥有用来组合的方法，这种方法比较安全。</p>
<p>component:</p>
<p>这里相比透明模式就少了add()和romove()抽象方法的声明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Component</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取分支下的所有叶子构件和树枝构件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> depth)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>composite：</p>
<p>这里add()和remove()方法的实现就从继承变为了自己实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Composite</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建容器</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; componentArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Component&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加一个叶子构件或树枝构件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.componentArrayList.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除一个叶子构件或树枝构件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.componentArrayList.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="comment">//输出树形结构</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;depth; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下级遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Component component : componentArrayList) &#123;</span><br><span class="line">            component.display(depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>leaf：</p>
<p>叶子节点中没有了空实现，比较安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Leaf</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="comment">//输出树形结构的叶子节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;depth; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合模式的应用"><a href="#组合模式的应用" class="headerlink" title="组合模式的应用"></a>组合模式的应用</h3><p>　　1. 何时使用</p>
<ul>
<li>想表达“部分-整体”层次结构（树形结构）时</li>
<li>希望用户忽略组合对象与单个对象的不同，用户将统一的使用组合结构中的所有对象</li>
</ul>
<p>　　2. 方法</p>
<ul>
<li>树枝和叶子实现统一接口，树枝内部组合该接口</li>
</ul>
<p>　　3. 优点</p>
<ul>
<li>高层模块调用简单。一棵树形机构中的所有节点都是Component，局部和整体对调用者来说没有任何区别，高层模块不必关心自己处理的是单个对象还是整个组合结构。</li>
<li>节点自由增加</li>
</ul>
<p>　　4. 缺点</p>
<ul>
<li>使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒转原则</li>
</ul>
<p>　　5. 使用场景</p>
<ul>
<li>维护和展示部分-整体关系的场景（如树形菜单、文件和文件夹管理）</li>
<li>从一个整体中能够独立出部分模块或功能的场景</li>
</ul>
<p>　　6. 应用实例</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/adamjwh/p/8392737.html">Swing</a>中，Button、Checkbox等组件都是树叶，而Container容器是树枝</li>
<li>文本编辑时，可以单个字编辑，也可以整段编辑，还可以全文编辑</li>
<li>文件复制时，可以一个一个文件复制，也可以整个文件夹复制</li>
</ul>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/adamjwh/p/9033547.html">简说设计模式——组合模式 - JAdam - 博客园 (cnblogs.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">java-设计模式（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-29 09:27:05" itemprop="dateCreated datePublished" datetime="2021-12-29T09:27:05Z">2021-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-30 06:20:28" itemprop="dateModified" datetime="2021-12-30T06:20:28Z">2021-12-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="三、建造者模式（Builder）"><a href="#三、建造者模式（Builder）" class="headerlink" title="三、建造者模式（Builder）"></a>三、建造者模式（Builder）</h2><p>建造者模式可以将一个类的构建和表示进行分离</p>
<p><strong>适用场景：</strong></p>
<ul>
<li>隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果</li>
<li>多个部件都可以装配到一个对象中，但产生的运行结果不相同</li>
<li>产品类非常复杂或者产品类因为调用顺序不同而产生不同作用</li>
<li>初始化一个对象时，参数过多，或者很多参数具有默认值</li>
<li>Builder模式不适合创建差异性很大的产品类<br> 产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本</li>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；</li>
</ul>
<p><strong>开发中应用场景：</strong></p>
<ul>
<li>StringBuilder类的append方法</li>
<li>SQL中的PreparedStatement</li>
<li>JDOM中，DomBuilder、SAXBuilder</li>
</ul>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3d1c9ffb0a28">一篇文章就彻底弄懂建造者模式(Builder Pattern) - 简书 (jianshu.com)</a></p>
<h2 id="四、原型模式（prototype）"><a href="#四、原型模式（prototype）" class="headerlink" title="四、原型模式（prototype）"></a>四、原型模式（prototype）</h2><p>使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。</p>
<p><strong>适用场景</strong></p>
<ul>
<li>通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式</li>
<li>就是java中的克隆技术，以某个对象为原型，复制出新的对象。显然，新的对象具备原型对象的特点。优势有：效率高(直接克隆，避免了重新执行构造过程步骤) </li>
<li>克隆类似于new，但是不同于new。new创建新的对象属性采用的是默认值。克隆出的 对象的属性值完全和原型对象相同。并且克隆出的新对象改变不会影响原型对象。然后， 再修改克隆对象的值。</li>
</ul>
<h3 id="原型模式实现"><a href="#原型模式实现" class="headerlink" title="原型模式实现"></a>原型模式实现</h3><ul>
<li>Cloneable接口和clone方法</li>
<li>Prototype模式中实现起来最困难的地方就是内存复制操作，所幸在Java中提供了 clone()方法替我们做了绝大部分事情。</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> Prototype <span class="title function_">myClone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String filed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcretePrototype</span><span class="params">(String filed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.filed = filed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Prototype <span class="title function_">myClone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(filed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> filed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">clone</span> <span class="operator">=</span> prototype.myClone();</span><br><span class="line">        System.out.println(clone.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/29/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/29/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/" class="post-title-link" itemprop="url">java-面向对象思想</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-29 09:26:25 / 修改时间：01:36:02" itemprop="dateCreated datePublished" datetime="2021-12-29T09:26:25Z">2021-12-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h1><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="泛化关系（Generalization）"><a href="#泛化关系（Generalization）" class="headerlink" title="泛化关系（Generalization）"></a>泛化关系（Generalization）</h3><p>用来描述继承关系，在 Java 中使用 extends 关键字。</p>
<h3 id="实现关系-Realization"><a href="#实现关系-Realization" class="headerlink" title="实现关系 (Realization)"></a>实现关系 (Realization)</h3><p>用来实现一个接口，在 Java 中使用 implements 关键字。</p>
<h3 id="关联关系-Association"><a href="#关联关系-Association" class="headerlink" title="关联关系 (Association)"></a>关联关系 (Association)</h3><p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p>
<p>【代码表现】：成员变量</p>
<h3 id="聚合关系-Aggregation"><a href="#聚合关系-Aggregation" class="headerlink" title="聚合关系 (Aggregation)"></a>聚合关系 (Aggregation)</h3><p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p>
<p>聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。</p>
<p>【代码表现】：成员变量</p>
<h3 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="组合关系 (Composition)"></a>组合关系 (Composition)</h3><p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p>
<p>组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期</p>
<p>【代码表现】：成员变量</p>
<h3 id="依赖关系-Dependency"><a href="#依赖关系-Dependency" class="headerlink" title="依赖关系 (Dependency)"></a>依赖关系 (Dependency)</h3><p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：</p>
<ul>
<li>A 类是 B 类方法的局部变量；</li>
<li>A 类是 B 类方法的参数；</li>
<li>A 类向 B 类发送消息，从而影响 B 类发生变化。</li>
</ul>
<p>【代码表现】：局部变量、方法的参数或者对静态方法的调用</p>
<h3 id="各种关系的强弱顺序"><a href="#各种关系的强弱顺序" class="headerlink" title="各种关系的强弱顺序"></a>各种关系的强弱顺序</h3><p>泛化&#x3D;实现&gt;组合&gt;聚合&gt;关联&gt;依赖</p>
<h2 id="面向对象的六大原则"><a href="#面向对象的六大原则" class="headerlink" title="面向对象的六大原则"></a>面向对象的六大原则</h2><h3 id="1、单一职责原则SRP"><a href="#1、单一职责原则SRP" class="headerlink" title="1、单一职责原则SRP"></a>1、单一职责原则SRP</h3><p>面向对象的六大原则就一个类而言，应该仅有一个引起它变化的原因。</p>
<p>简单的说就是：一个类中应该是一组相关性很高的函数、数据的封装。两个不一样的功能不应该放在一个类中。</p>
<p>这个原则没有具体的划分界限，需要根据个人经验，具体业务逻辑而定。这也是优化代码的第一步。试想一下，如果所有的功能写在一个类里，那么这个类会越来越大，越来越复杂，越不易修改维护。那么根据功能，各自独立拆分出来，岂不是逻辑会清晰些。</p>
<h3 id="2、开闭原则OCP"><a href="#2、开闭原则OCP" class="headerlink" title="2、开闭原则OCP"></a>2、开闭原则OCP</h3><p>定义是：软件中的对象（类、模块、函数等）应该对于<strong>扩展是开放的，但是对于修改是封闭的</strong>。当软件需要变化时，我们<u>尽量</u>通过扩展的方式来实现变化，而不是通过修改已有的代码来实现（可能引入的代码会破坏原有系统）。</p>
<h3 id="3、里氏替换原则LSP"><a href="#3、里氏替换原则LSP" class="headerlink" title="3、里氏替换原则LSP"></a>3、里氏替换原则LSP</h3><p>定义：所有引用父类的地方，必须能使用子类的对象。简单地说就是<strong>将父类替换为他的子类是不会出现问题</strong>，反之，未必可以。</p>
<p>那么里氏替换原则就是依赖于面向对象语言的<strong>继承</strong>与<strong>多态</strong>。核心原理是<strong>抽象</strong>。</p>
<p>这里列举一下继承的优缺点：<br>优点：<br>（1）代码重用，减少创建类的成本，每个子类都拥有父类的方法与属性。<br>（2）子类与父类基本相似，但与父类又有所区别。<br>（3）提高代码的可扩展性。<br>缺点：<br>（1）继承是侵入性的，只要继承就必须拥有父类所有的属性与方法。<br>（2）可能造成子类代码冗余、灵活性降低。</p>
<p>开闭原则和里氏替换原则是生死相依的、不离不弃的。他们都强调了抽象这一重要的特性。</p>
<p>看着定义很是抽象，但是通俗的理解就是由子类实例化的父类引用，在使用这个引用时，感觉就像是使用了父类一样。一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;...&#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;...&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="comment">// 类型是A，但实际是B类型实例化的，就是依赖多态</span></span><br><span class="line">    a.method();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、依赖倒置原则DIP"><a href="#4、依赖倒置原则DIP" class="headerlink" title="4、依赖倒置原则DIP"></a>4、依赖倒置原则DIP</h3><p>定义：指代一种特定的解耦方式，使得高层次的模块不依赖于低层次的模块的实现细节的目的。他有一下几个关键点：<br>（1）高层模块不依赖于低层模块，应该都依赖其抽象。<br>（2）抽象不依赖细节。<br>（3）细节应依赖抽象。</p>
<p>解释：在Java中，<strong>抽象就是指接口或者抽象类，两者都是不能直接被实例化的</strong>；<strong>细节就是实现类，实现接口或者继承抽象类而产生的就是细节</strong>，也就是可以加上一个关键字new产生的对象。<strong>高层模块就是调用端，底层模块就是具体实现类。</strong></p>
<p>依赖倒置原则在Java中的表现就是：<strong>模块间通过抽象发生，实现类之间不发生直接依赖关系，其依赖关系是通过接口或者抽象类产生的。如果类与类直接依赖细节，那么就会直接耦合，那么当修改时，就会同时修改依赖者代码，这样限制了可扩展性。</strong></p>
<h3 id="5、接口隔离原则ISP"><a href="#5、接口隔离原则ISP" class="headerlink" title="5、接口隔离原则ISP"></a>5、接口隔离原则ISP</h3><p>定义：类间的依赖关系应该建立在最小的接口上，将庞大、臃肿的接口拆分成更小的、更具体的接口。目的是系统的解耦，从而更容易重构、更改和重新部署。</p>
<h3 id="6、迪米特原则LOD"><a href="#6、迪米特原则LOD" class="headerlink" title="6、迪米特原则LOD"></a>6、迪米特原则LOD</h3><p>定义：一个类应该对自己需要耦合或者调用的类知道的最少，类的内部如何实现与调用者或者依赖者没有关系，调用者或依赖者只需知道他需要的方法，其他可以一概不管。这样使得系统具有更低的耦合与更好的可扩展性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/23/java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/23/java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">java-类加载全过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-22 16:59:21" itemprop="dateCreated datePublished" datetime="2021-12-22T16:59:21Z">2021-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-24 08:06:36" itemprop="dateModified" datetime="2021-12-24T08:06:36Z">2021-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="类加载全过程"><a href="#类加载全过程" class="headerlink" title="类加载全过程"></a>类加载全过程</h1><p>一个Java文件从编码完成到最终执行，一般主要包括两个过程</p>
<ul>
<li><p>编译</p>
<p>即把java文件，通过javac命令编译成字节码，也就是.class文件。</p>
</li>
<li><p>运行</p>
<p>则是把编译生成的.class文件交给Java虚拟机(JVM)执行。</p>
</li>
</ul>
<p>类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。</p>
<p>JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且<strong>只加载一次</strong>。</p>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>类加载的过程主要分为三个部分：</p>
<ul>
<li>加载</li>
<li>链接</li>
<li>初始化</li>
</ul>
<p>而链接又可以细分为三个小部分：</p>
<ul>
<li>验证</li>
<li>准备</li>
<li>解析</li>
</ul>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20211223103209.jpeg" alt="img"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载指的是把class字节码文件从各个来源通过类加载器装载入内存中。</p>
<p>这里有两个重点：</p>
<ul>
<li><strong>字节码来源</strong>。一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译</li>
<li><strong>类加载器</strong>。一般包括<strong>启动类加载器</strong>，<strong>扩展类加载器</strong>，<strong>应用类加载器</strong>，以及用户的<strong>自定义类加载器</strong>。</li>
</ul>
<p><strong>注：为什么会有自定义类加载器？</strong></p>
<ul>
<li>一方面是由于java代码很容易被反编译，如果需要对自己的代码加密的话，可以对编译后的代码进行加密，然后再通过实现自己的自定义类加载器进行解密，最后再加载。</li>
<li>另一方面也有可能从非标准的来源加载代码，比如从网络来源，那就需要自己实现一个类加载器，从指定源进行加载。</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。</p>
<p>包括对于<strong>文件格式的验证</strong>，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？</p>
<p>对于<strong>元数据的验证</strong>，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？</p>
<p>对于<strong>字节码的验证</strong>，保证程序语义的合理性，比如要保证类型转换的合理性。</p>
<p>对于<strong>符号引用的验证</strong>，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>主要是为类变量（注意，不是实例变量）分配内存，并且赋予<strong>初值</strong>。</p>
<p>特别需要注意，<strong>初值，不是代码中具体写的初始化的值</strong>，而是Java虚拟机根据不同变量类型的默认初始值。</p>
<p>比如8种<strong>基本类型</strong>的初值，默认为0；<strong>引用类型</strong>的初值则为null；<strong>常量</strong>的初值即为代码中设置的值，final static tmp &#x3D; 456， 那么该阶段tmp的初值就是456</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将常量池内的符号引用替换为直接引用的过程。</p>
<p>两个重点：</p>
<ul>
<li><strong>符号引用</strong>。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。</li>
<li><strong>直接引用</strong>。可以理解为一个内存地址，或者一个偏移量。比如<strong>类方法，类变量</strong>的直接引用是指向方法区的<strong>指针</strong>；而<strong>实例方法，实例变量</strong>的直接引用则是从实例的头指针开始算起到这个实例变量位置的<strong>偏移量</strong></li>
</ul>
<p>举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。</p>
<p>在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>这个阶段主要是对<strong>类变量</strong>初始化，是执行类构造器的过程。类构造器<clinit>()方法是由编译器自动收集类中的所有类变量的<strong>赋值</strong>动作和**静态语句块(static块)**中的语句合并产生的。</p>
<p>换句话说，只对static修饰的变量或语句进行初始化。</p>
<p>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。</p>
<p>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</p>
<ul>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。</li>
</ul>
<p>Java程序初始化顺序：</p>
<blockquote>
<p> 1、父类的静态变量<br> 2、父类的静态代码块<br> 3、子类的静态变量<br> 4、子类的静态代码块<br> 5、父类的非静态变量<br> 6、父类的非静态代码块<br> 7、父类的构造方法<br> 8、子类的非静态变量<br> 9、子类的非静态代码块<br> 10、子类的构造方法</p>
</blockquote>
<h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><ol>
<li>创建类的实例，也就是new一个对象</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（Class.forName(“com.lyj.load”)）</li>
<li>初始化一个类的子类（会首先初始化子类的父类）</li>
<li>JVM启动时标明的启动类，即文件名和类名相同的那个类</li>
</ol>
<p>  除此之外，下面几种情形需要特别指出：</p>
<p> 对于一个final类型的静态变量，如果该变量的值在编译时就可以确定下来，那么这个变量相当于“宏变量”。Java编译器会在编译时直接把这个变量出现的地方替换成它的值，因此即使程序使用该静态变量，也不会导致该类的初始化。反之，如果final类型的静态Field的值不能在编译时确定下来，则必须等到运行时才可以确定该变量的值，如果通过该类来访问它的静态变量，则会导致该类被初始化。</p>
<h2 id="类的引用"><a href="#类的引用" class="headerlink" title="类的引用"></a>类的引用</h2><h3 id="主动引用（一定会初始化）"><a href="#主动引用（一定会初始化）" class="headerlink" title="主动引用（一定会初始化）"></a>主动引用（一定会初始化）</h3><p>当虚拟机启动，先初始化main方法所在的类<br>1.new一个类的对象<br>2.调用类的静态成员(除了final常量)和静态方法<br>3.使用java.lang.reflect包的方法对类进行反射调用<br>4.当初始化一个类的时候，如果其父类没有被初始化，则会先初始化它的父类</p>
<h3 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h3><p>1.访问一个静态域时，只有真正的声名这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类被初始化<br>2.通过数组引用定义类时，不会触发此类的初始化<br>3.引用常量不会触发此类的初始化(常量在链接阶段就存入调用类的常量池中了)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;mian方法所在类被初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  ClassNotFoundException&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          类的主动引用，一定会引起类的初始化 当虚拟机启动，先初始化main方法所在的类</span></span><br><span class="line"><span class="comment">          1.new一个类的对象</span></span><br><span class="line"><span class="comment">          2.调用类的静态成员(除了final常量)和静态方法</span></span><br><span class="line"><span class="comment">          3.使用java.lang.reflect包的方法对类进行反射调用</span></span><br><span class="line"><span class="comment">          4.当初始化一个类的时候，如果其父类没有被初始化，则会先初始化它的父类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//new一个类的对象</span></span><br><span class="line">        <span class="comment">//Animal animal = new Animal();//mian方法所在类被初始化 父类被初始化</span></span><br><span class="line">        <span class="comment">//调用类的静态成员(除了final常量)和静态方法</span></span><br><span class="line">        <span class="comment">//System.out.println(Animal.num);//mian方法所在类被初始化 3</span></span><br><span class="line">        <span class="comment">//System.out.println(Animal.name);//mian方法所在类被初始化 父类被初始化 狗</span></span><br><span class="line">        <span class="comment">//Animal.print();//mian方法所在类被初始化 父类被初始化 动物在叫</span></span><br><span class="line">        <span class="comment">//使用java.lang.reflect包的方法对类进行反射调用</span></span><br><span class="line">        <span class="comment">//Class c1 = Class.forName(&quot;exam.reflect.Cat&quot;);// mian方法所在类被初始化 父类被初始化 子类被初始化</span></span><br><span class="line">        <span class="comment">//当初始化一个类的时候，如果其父类没有被初始化，则会先初始化它的父类</span></span><br><span class="line">        <span class="comment">//Cat cat = new Cat();// mian方法所在类被初始化 父类被初始化 子类被初始化</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">           类的被动引用  不会发生类的初始化</span></span><br><span class="line"><span class="comment">           1.访问一个静态域时，只有真正的声名这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类被初始化</span></span><br><span class="line"><span class="comment">           2.通过数组引用定义类时，不会触发此类的初始化</span></span><br><span class="line"><span class="comment">           3.引用常量不会触发此类的初始化(常量在链接阶段就存入调用类的常量池中了)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//子类引用父类的静态变量，不会子类被初始化</span></span><br><span class="line">        <span class="comment">//System.out.println(Cat.name);mian方法所在类被初始化 父类被初始化 狗通过数组引用定义类时，不会触发此类的初始化</span></span><br><span class="line">        <span class="comment">//Animal[] animals = new Animal[5];//mian方法所在类被初始化</span></span><br><span class="line">        <span class="comment">//Cat[] cats = new Cat[6];//mian方法所在类被初始化</span></span><br><span class="line">        <span class="comment">//引用常量不会触发此类的初始化</span></span><br><span class="line">        <span class="comment">//System.out.println(Animal.NAME);//mian方法所在类被初始化 动物</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类被初始化&quot;</span>);</span><br><span class="line">        name = <span class="string">&quot;猫&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span>  <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类被初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">color</span>  <span class="operator">=</span> <span class="string">&quot;黄色&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="类加载器的原理"><a href="#类加载器的原理" class="headerlink" title="类加载器的原理"></a>类加载器的原理</h2><h3 id="类缓存"><a href="#类缓存" class="headerlink" title="类缓存"></a>类缓存</h3><p>标准的Java SE类加载器可以按要求查找类，一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过，JVM垃圾收集器可以回收这些Class对象。</p>
<h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20211224153606.webp" alt="img"></p>
<p><strong>A.从Java虚拟机的角度：</strong></p>
<p><strong>1.Bootstrap ClassLoader启动类加载器</strong><br><strong>2.其他类加载器</strong><br>从JVM的角度，加载器只分为两类,即JVM自身实现的Bootstrap启动类加载器，和其他JVM以外的所有类加载器。Bootstrap翻译为根，故也叫根类加载器。</p>
<p><strong>B.从开发者的角度：</strong></p>
<p><strong>1.Bootstrap ClassLoader根类加载器</strong><br><strong>2.Extension ClassLoader拓展类加载器</strong><br><strong>3.Application ClassLoader应用程序类加载器</strong><br>1.根类加载器，加载位于&#x2F;jre&#x2F;lib目录中的或者被参数-Xbootclasspath所指定的目录下的核心Java类库。此类加载器是Java虚拟机的一部分，使用native代码(C++)编写。</p>
<p>2.扩展类加载器，加载位于&#x2F;jre&#x2F;lib&#x2F;ext目录中的或者java.ext.dirs系统变量所指定的目录下的拓展类库。此加载器由sun.misc.Launcher ExtClassLoader实现。</p>
<p>3.系统类加载器，加载用户路径(ClassPath)上所指定的类库。此加载器由sun.misc.Launcher$ AppClassLoader实现。</p>
<blockquote>
<p><strong>引导类加载器（bootstrap class loader）</strong><br> （1）它用来加载 Java 的核心库(JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar,sun.boot.class.path路径下的内容)，是用原生代码（C语言）来实现的，并不继承自 java.lang.ClassLoader。<br> （2）加载扩展类和应用程序类加载器。并指定他们的父类加载器。</p>
<p><strong>扩展类加载器（extensions class loader）</strong><br> （1）用来加载 Java 的扩展库(JAVA_HOME&#x2F;jre&#x2F;ext&#x2F;*.jar，或java.ext.dirs路径下的内容) 。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java类。<br> （2）由sun.misc.Launcher$ExtClassLoader实现。</p>
<p><strong>应用程序类加载器（application class loader）</strong><br> （1）它根据 Java 应用的类路径（classpath，java.class.path 路径下的内容）来加载 Java 类。<strong>一般来说，Java 应用的类都是由它来完成加载的。</strong><br> （2）由sun.misc.Launcher$AppClassLoader实现。</p>
</blockquote>
<p>类加载器加载Class大致要经过如下8个步骤：</p>
<ol>
<li>检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。</li>
<li>如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。</li>
<li>请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。</li>
<li>请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。</li>
<li>当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。</li>
<li>从文件中载入Class，成功后跳至第8步。</li>
<li>抛出ClassNotFountException异常。</li>
<li>返回对应的java.lang.Class对象。</li>
</ol>
<h2 id="类加载器的代理模式"><a href="#类加载器的代理模式" class="headerlink" title="类加载器的代理模式"></a>类加载器的代理模式</h2><p>代理模式即是将指定类的加载交给其他的类加载器。常用双亲委托机制。</p>
<p>JVM的类加载机制主要有如下3种。</p>
<ul>
<li>全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</li>
<li>双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。</li>
<li>缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。</li>
</ul>
<h4 id="1、双亲委托机制"><a href="#1、双亲委托机制" class="headerlink" title="1、双亲委托机制"></a>1、双亲委托机制</h4><p>双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，如果都不能加载则报错——ClassNotFoundException。这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。</p>
<p>  双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</p>
<p>值得注意是，双亲委托机制是代理模式的一种，但并不是所有的类加载器都采用双亲委托机制。在tomcat服务器类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。</p>
<h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>（1）首先检查请求的类型是否已经被这个类装载器装载到命名空间中了，如果已经装载，直接返回；否则转入步骤2。</p>
<p>（2）委派类加载请求给父类加载器，如果父类加载器能够完成，则返回父类加载器加载的Class实例；否则转入步骤3。</p>
<p>（3）调用本类加载器的findClass（…）方法，试图获取对应的字节码，如果获取的到，则调用defineClass（…）导入类型到方法区；如果获取不到对应的字节码或者其他原因失败，返回异常给loadClass（…）， loadClass（…）转抛异常，终止加载过程（注意：这里的异常种类不止一种）。</p>
<p> <strong>- 注意：被两个类加载器加载的同一个类，JVM认为是不相同的类。</strong></p>
<h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><p>通常当你需要动态加载资源的时候 , 你至少有三个 ClassLoader 可以选择 :<br> 1.系统类加载器或叫作应用类加载器 (system classloader or application classloader)<br> 2.当前类加载器<br> 3.当前线程类加载器</p>
<p><strong>• 当前线程类加载器是为了抛弃双亲委派加载链模式。</strong><br> 每个线程都有一个关联的上下文类加载器。如果你使用new Thread()方式生成新的线程，新线程将继承其父线程的上下文类加载器。如果程序对线程上下文类加载器没有任何改动的话，程序中所有的线程将都使用系统类加载器作为上下文类加载器。<br> <strong>• Thread.currentThread().getContextClassLoader()</strong></p>
<h2 id="tomcat服务器的类加载器"><a href="#tomcat服务器的类加载器" class="headerlink" title="tomcat服务器的类加载器"></a>tomcat服务器的类加载器</h2><p>每个 Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式(不同于前面说的双亲委托机制)，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。但也是为了保证安全，这样核心库就不在查询范围之内。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/17/java-%E5%AD%97%E8%8A%82%E7%A0%81%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/17/java-%E5%AD%97%E8%8A%82%E7%A0%81%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">java-字节码操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-17 15:26:50" itemprop="dateCreated datePublished" datetime="2021-12-17T15:26:50Z">2021-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-20 06:45:16" itemprop="dateModified" datetime="2021-12-20T06:45:16Z">2021-12-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="字节码操作"><a href="#字节码操作" class="headerlink" title="字节码操作"></a>字节码操作</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>java的动态性的两种常见方式</p>
<ul>
<li>字节码操作</li>
<li>反射</li>
</ul>
<p>运行时操作字节码可以实现的功能如下：</p>
<ul>
<li><p>动态生成新的类</p>
</li>
<li><p>动态改变某个类的结构（添加&#x2F;删除&#x2F;修改 新的属性）</p>
</li>
</ul>
<p>优势：</p>
<ul>
<li><p>比反射开销小，性能高。</p>
</li>
<li><p>JAVAasist性能高于反射，低于ASM</p>
</li>
</ul>
<p>常见的字节码操作类库</p>
<ul>
<li><p>BCEL</p>
<p> Byte Code Engineering Library (BCEL) ，这是 Apache Software Foundation 的 Jakarta 项目的一部分。 BCEL 是 Java classworking 广泛 使用的一种 框架 , 它 可以让您深入 JVM 汇编语言进行类操作的细节。 BCEL 与 Javassist 有不同的处理字节码方法， BCEL 在实际的 JVM 指令层次上进行操作 (BCEL 拥有丰富的 JVM 指令级支持 ) 而 Javassist 所 强调 的是源代码 级别的 工作 。</p>
</li>
<li><p>ASM</p>
<p> 是一个轻量级 java 字节码操作框架，直接涉及到 JVM 底层的操作和 指令</p>
</li>
<li><p>CGLIB</p>
<p>是一个强大的，高性能，高质量的 Code</p>
</li>
<li><p>Javaassist </p>
<p>性能较ASM差，跟cglib差不多，但是用用简单，很多框架都在使用</p>
</li>
</ul>
<h2 id="javassist"><a href="#javassist" class="headerlink" title="javassist"></a>javassist</h2><p>使用Javassist需要使用javassist.jar</p>
<p>优势：</p>
<p>  比反射开销小，性能高。<br>  JAVAsist性能高于反射，低于ASM</p>
<p>局限性：</p>
<p>  JDK新语法不支持（包括泛型、枚举），不支持注解修改，但可以通过底层的javasist类来解决，具体参考：javassist.bytecode.annotaion<br>  不支持数组的初始化，如 String[]{“1”,”2”}，除非只有数组的容量为1<br>  不支持内部类和匿名类<br>  不支持 continue 和 break 表达式。<br>  对于继承关系，有些不支持 。例如：- class A{} - class B extends A{} - class C enxends B {}</p>
<p>应用场景：</p>
<p>  AOP:<br>    给一个类增加新的方法<br>    给一段语句前面和后面（before&#x2F;after&#x2F;around）动态的加代码<br>  Reflection:起到类似反射的效果</p>
<p>javassist 的最外层的 API 和 JAVA 的反射包中的 API 颇为类似 。</p>
<p>它主要由 CtClass ， CtMethod, ，以及 CtField 几个类组成。用以执行和 JDK 反射 API 中 java.lang.Class ， java.lang.reflect.Method ， java.lang.reflect.Method .Field 相同的 操作 。<br>方法操作</p>
<p>  修改已有方法的方法体体（插入代码到已有方法体）<br>  新增方法 删除方法<br>  占位符参数介绍：</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20211217164511.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtConstructor;</span><br><span class="line"><span class="keyword">import</span> javassist.CtField;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test10</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault(); <span class="comment">// 类池</span></span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">class1</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;com.gs.Emp&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建属性</span></span><br><span class="line">    <span class="type">CtField</span> <span class="variable">f1</span> <span class="operator">=</span> CtField.make(<span class="string">&quot;private int num;&quot;</span>, class1);</span><br><span class="line">    <span class="type">CtField</span> <span class="variable">f2</span> <span class="operator">=</span> CtField.make(<span class="string">&quot;private String name;&quot;</span>, class1);</span><br><span class="line">    class1.addField(f1);</span><br><span class="line">    class1.addField(f2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建方法</span></span><br><span class="line">     </span><br><span class="line">    <span class="type">CtMethod</span> <span class="variable">setName</span> <span class="operator">=</span> CtMethod.make(<span class="string">&quot;public void setName(String name)&#123;this.name = name;&#125;&quot;</span>, class1);</span><br><span class="line">    <span class="type">CtMethod</span> <span class="variable">getName</span> <span class="operator">=</span> CtMethod.make(<span class="string">&quot;public String getName()&#123;return name;&#125;&quot;</span>, class1);</span><br><span class="line">    class1.addMethod(setName);</span><br><span class="line">    class1.addMethod(getName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加构造器。  如果是带参构造器，需要传递参数类型，基本数据类型用CtClass获取，引用类型，需要用pool获取</span></span><br><span class="line">    <span class="type">CtConstructor</span> <span class="variable">constructor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtConstructor</span>(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;CtClass.intType,pool.get(<span class="string">&quot;java.lang.String&quot;</span>)&#125;, class1);</span><br><span class="line">    constructor.setBody(<span class="string">&quot;&#123;this.num = num;this.name = name;&#125;&quot;</span>); <span class="comment">//构造器的方法体</span></span><br><span class="line">    </span><br><span class="line">    class1.writeFile(<span class="string">&quot;E:/myjava&quot;</span>); <span class="comment">//将上面写好的类，写入到这个工作空间中</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;生成类成功！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903751082328072">Java 动态字节码技术 - 掘金 (juejin.cn)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rhb</p>
  <div class="site-description" itemprop="description">纵浪大化中，不喜亦不惧</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">126</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RShawshank" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RShawshank" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rhb</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
