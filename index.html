<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rshawshank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="纵浪大化中，不喜亦不惧">
<meta property="og:type" content="website">
<meta property="og:title" content="rhb_blog">
<meta property="og:url" content="http://rshawshank.github.io/index.html">
<meta property="og:site_name" content="rhb_blog">
<meta property="og:description" content="纵浪大化中，不喜亦不惧">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rhb">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rshawshank.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>rhb_blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rhb_blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">rao的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">57</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">23</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">140</span></a>

  </li>
        <li class="menu-item menu-item-photos">

    <a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
        <li class="menu-item menu-item-readnote">

    <a href="/readnote" rel="section"><i class="fa fa-book fa-fw"></i>阅读笔记</a>

  </li>
        <li class="menu-item menu-item-somethink">

    <a href="/somethink/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>随笔闲谈</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/RShawshank" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2022/11/14/java-maven%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/14/java-maven%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-14 00:19:31" itemprop="dateCreated datePublished" datetime="2022-11-14T00:19:31Z">2022-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>title: java-maven学习（一）——介绍<br>copyright: true<br>toc: true<br>typora-root-url: ..<br>date: 2021-11-16 14:10:53<br>tags:</p>
<ul>
<li>java<br>categories:</li>
<li>学习笔记</li>
<li>java</li>
</ul>
<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><ul>
<li><p>构建工具：自动化构建，抽象构建过程</p>
<ul>
<li>可跨平台——对外提供了一致的操作接口</li>
</ul>
</li>
<li><p>依赖管理工具和项目管理工具</p>
<ul>
<li>提供中央仓库，自动下载构件</li>
</ul>
</li>
</ul>
<p>最新最全的maven依赖项版本查询网站：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://mvnrepository.com/">http://mvnrepository.com</a></p>
</blockquote>
<h2 id="一、为什么使用Maven这样的构建工具【why】"><a href="#一、为什么使用Maven这样的构建工具【why】" class="headerlink" title="一、为什么使用Maven这样的构建工具【why】"></a>一、为什么使用Maven这样的构建工具【why】</h2><ol>
<li>一个项目就是一个工程</li>
</ol>
<p>如果项目非常庞大，就不适合使用package来划分模块，最好是每一个模块对应一个工程，利于分工协作。借助于maven就可以将一个项目拆分成多个工程</p>
<ol start="2">
<li>项目中使用jar包，需要“复制”、“粘贴”项目的lib中</li>
</ol>
<p>同样的jar包重复的出现在不同的项目工程中，你需要做不停的复制粘贴的重复工作。借助于maven，可以将jar包保存在“仓库”中，不管在哪个项目只要使用引用即可就行。</p>
<ol start="3">
<li>jar包需要的时候每次都要自己准备好或到官网下载</li>
</ol>
<p>借助于maven我们可以使用统一的规范方式下载jar包，规范</p>
<ol start="4">
<li>jar包版本不一致的风险</li>
</ol>
<p>不同的项目在使用jar包的时候，有可能会导致各个项目的jar包版本不一致，导致未执行错误。借助于maven，所有的jar包都放在“仓库”中，所有的项目都使用仓库的一份jar包。</p>
<ol start="5">
<li>一个jar包依赖其他的jar包需要自己手动的加入到项目中</li>
</ol>
<p>FileUpload组件-&gt;IO组件，commons-fileupload-1.3.jar依赖于commons-io-2.0.1.jar</p>
<p>极大的浪费了我们导入包的时间成本，也极大的增加了学习成本。借助于maven，它会自动的将依赖的jar包导入进来。</p>
<h2 id="二、maven是什么【what】"><a href="#二、maven是什么【what】" class="headerlink" title="二、maven是什么【what】"></a>二、maven是什么【what】</h2><p>① maven是一款服务于java平台的自动化构建工具</p>
<p>make-&gt;Ant-&gt;Maven-&gt;Gradle</p>
<p>② 构建</p>
<p>构建定义：把动态的Web工程经过编译得到的编译结果部署到服务器上的整个过程。</p>
<p>编译：java源文件[.java]-&gt;编译-&gt;Classz字节码文件[.class]</p>
<p>部署：最终在sevlet容器中部署的不是动态web工程，而是编译后的文件</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205051401053.jpeg"></p>
<p>③ 构建的各个环节</p>
<ul>
<li>清理clean：将以前编译得到的旧文件class字节码文件删除</li>
<li>编译compile：将java源程序编译成class字节码文件</li>
<li>测试test：自动测试，自动调用junit程序</li>
<li>报告report：测试程序执行的结果</li>
<li>打包package：动态Web工程打War包，java工程打jar包</li>
<li>安装install：Maven特定的概念—–将打包得到的文件复制到“仓库”中的指定位置</li>
<li>部署deploy：将动态Web工程生成的war包复制到Servlet容器下，使其可以运行</li>
</ul>
<h2 id="三、安装maven"><a href="#三、安装maven" class="headerlink" title="三、安装maven"></a>三、安装maven</h2><p>① 当前系统是否配置JAVA_HOME的环境变量</p>
<p>② 下载maven，解压maven放在一个非中文无空格的路径下</p>
<p>③ 配置maven的相关环境变量</p>
<ul>
<li>在环境变量增加M2_HOME，路径是maven解压后的根目录</li>
<li>在环境变量里的path中增加maven&#x2F;bin的目录</li>
</ul>
<p>④ 验证：maven -v 查看maven版本</p>
<p>看到版本信息，恭喜你已经OK了。</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205051401651.png"></p>
<h3 id="maven目录"><a href="#maven目录" class="headerlink" title="maven目录"></a>maven目录</h3><ul>
<li><strong>bin目录</strong>：</li>
</ul>
<p>该目录包含了mvn运行的脚本，这些脚本用来配置java命令，准备好classpath和相关的Java系统属性，然后执行Java命令。</p>
<ul>
<li><strong>boot目录</strong>:</li>
</ul>
<p>该目录只包含一个文件，该文件为<code>plexus-classworlds-2.5.2.jar</code>。<code>plexus-classworlds</code>是一个类加载器框架，相对于默认的java类加载器，它提供了更加丰富的语法以方便配置，Maven使用该框架加载自己的类库。</p>
<ul>
<li><strong>conf目录</strong>:</li>
</ul>
<p>该目录包含了一个非常重要的文件settings.xml。直接修改该文件，就能在机器上全局地定制Maven的行为，一般情况下，我们更偏向于复制该文件至<del>&#x2F;.m2&#x2F;目录下（</del>表示用户目录），然后修改该文件，在用户范围定制Maven的行为。</p>
<ul>
<li><strong>lib目录</strong>:</li>
</ul>
<p>该目录包含了所有Maven运行时需要的Java类库，Maven本身是分模块开发的，因此用户能看到诸如maven-core-3.0.jar、maven-model-3.0.jar之类的文件，此外这里还包含一些Maven用到的第三方依赖如commons-cli-1.2.jar、commons-lang-2.6.jar等等。</p>
<h2 id="四、第一个maven"><a href="#四、第一个maven" class="headerlink" title="四、第一个maven"></a>四、第一个maven</h2><p>① 创建约定的目录结构（maven工程必须按照约定的目录结构创建）</p>
<blockquote>
<p>根目录：工程名<br>|—src：源码|—|—main:存放主程序|—|—|—java：java源码文件|—|—|—resource：存放框架的配置文件|—|—test：存放测试程序|—pop.xml：maven的核心配置文件</p>
</blockquote>
<p>我们按照上面的文件夹目录结构手动创建一下，不用任何IDE环境（手动的其实最有助于我们理解maven）</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205051401657.jpeg"></p>
<h3 id="文件内容如下"><a href="#文件内容如下" class="headerlink" title="文件内容如下"></a>文件内容如下</h3><p>在src&#x2F;main&#x2F;java&#x2F;com&#x2F;hzg&#x2F;maven目录下新建文件Hello.java，内容如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hzg.maven;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span>+name+<span class="string">&quot;!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>POM文件内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hzg.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="常用maven命令"><a href="#常用maven命令" class="headerlink" title="常用maven命令"></a>常用maven命令</h3><ul>
<li>mvn clean：表示运行清理操作（会默认把target文件夹中的数据清理）。</li>
<li>mvn compile：编译主程序，会将代码编译到target文件夹中。</li>
<li>mvn test-compile：编译测试程序</li>
<li>mvn test：执行测试</li>
<li>mvn package：打包</li>
<li>mvn install：安装</li>
</ul>
<p><strong>执行maven命令必须进入到pom.xml的目录中进行执行</strong></p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205051401897.png"></p>
<p>进入到项目的pom.xml目录之后，就可以执行啦。</p>
<p><strong>1、运行 mvn compile</strong></p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205051401896.jpeg"></p>
<p>OK，运行完毕，你在pom.xml配置的依赖的包已经导入到仓库了，问题来了，<strong>仓库默认的位置在哪？</strong></p>
<p><strong>仓库的默认位置：</strong>c:\Usrs[登录当前系统的用户名].m2\repository</p>
<p>刚才执行完compile之后，之前的文件夹发生了变化</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205051401705.png"></p>
<p>我们发现Hello项目里里多了一个target文件夹。文件夹的内容为：</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205051401005.png"></p>
<p>发现target里主要存放的就是编译后的字节码文件</p>
<p><strong>2、运行mvn test-compile</strong>，target文件夹下面除了classes之外多了test-classes文件夹</p>
<p><strong>3、运行mvn package</strong>，target文件夹下面又多了一个打好的jar包</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205051401922.png"></p>
<p>4、运行mvn clean，发现整个target文件夹都没了。又回到了编译之前我们手动创建的文件夹</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205051401090.png"></p>
<h2 id="五、Maven插件安装，基于IDEA"><a href="#五、Maven插件安装，基于IDEA" class="headerlink" title="五、Maven插件安装，基于IDEA"></a>五、Maven插件安装，基于IDEA</h2><ol>
<li>引入下载好的maven。网上教程很多</li>
</ol>
<h3 id="Maven使用"><a href="#Maven使用" class="headerlink" title="Maven使用"></a>Maven使用</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.tengj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springBootDemo1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>springBootDemo1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码的第一行是XML头，指定了该xml文档的版本和编码方式。 </p>
<ul>
<li><p>project是所有pom.xml的根元素，它还声明了一些POM相关的命名空间及xsd元素。 </p>
</li>
<li><p>根元素下的第一个子元素modelVersion指定了当前的POM模型的版本，对于Maven3来说，它只能是4.0.0 代码中最重要是包含了groupId,artifactId和version了。这三个元素定义了一个项目基本的坐标，在Maven的世界，任何的jar、pom或者jar都是以基于这些基本的坐标进行区分的。</p>
</li>
<li><p>groupId定义了项目属于哪个组，随意命名，比如谷歌公司的myapp项目，就取名为 com.google.myapp</p>
</li>
<li><p>artifactId定义了当前Maven项目在组中唯一的ID,比如定义hello-world。</p>
</li>
<li><p>version指定了项目当前的版本0.0.1-SNAPSHOT,SNAPSHOT意为快照，说明该项目还处于开发中，是不稳定的。</p>
</li>
<li><p>name元素生命了一个对于用户更为友好的项目名称，虽然这不是必须的，但还是推荐为每个POM声明name,以方便信息交流</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>实际项目<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">　　　　 <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>模块<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">　　　　 <span class="tag">&lt;<span class="name">version</span>&gt;</span>版本<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">　　　　 <span class="tag">&lt;<span class="name">type</span>&gt;</span>依赖类型<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">　　　　 <span class="tag">&lt;<span class="name">scope</span>&gt;</span>依赖范围<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">　　　　 <span class="tag">&lt;<span class="name">optional</span>&gt;</span>依赖是否可选<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">　　　　 &lt;!—主要用于排除传递性依赖--&gt;</span><br><span class="line">　　　　 <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">　　　　     <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">　　　　　　　    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>…<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">　　　　　　　　　 <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>…<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">　　　　　　　<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">　　　　 <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>dependencies 可以包含一个或者多个dependency元素，以声明一个或者多个项目依赖。</li>
<li>grounpId、artifactId和version 组成了依赖的基本坐标。</li>
<li>type 指定了依赖的类型，默认为 jar。</li>
<li>scope 指定了依赖的范围（详情见下面<strong>依赖范围</strong>部分）。</li>
<li>optional 标记了依赖是否是可选的（详情见下面<strong>依赖可选</strong>部分）。</li>
<li>exclusions 用来排除传递性依赖（详情见下面<strong>依赖排除</strong>部分）。</li>
</ul>
<h2 id="六、仓库"><a href="#六、仓库" class="headerlink" title="六、仓库"></a>六、仓库</h2><p><strong>仓库的分类：</strong></p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205051632351.webp"></p>
<h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><p>一般来说，在Maven项目目录下，没有诸如lib&#x2F;这样用来存放依赖文件的目录。当Maven在执行编译或测试时，如果需要使用依赖文件，它总是基于坐标使用本地仓库的依赖文件。</p>
<p>默认情况下，不管是Window还是macOS，或者是 Linux，每个用户都会在自己的用户目录下有一个路径名为 <code>.m2/repository/</code> 的仓库目录。</p>
<p>如果你想自定义本地仓库目录地址，可以编辑文件<code>~/.m2/settings.xml</code>，设置localRepository元素的值为你想要的仓库地址，例如:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\java\repository\<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，该用户的本地仓库地址就被设置成了<code> D:\java\repository\</code>。 需要注意的是，默认情况下，<code>~/.m2/settings.xml</code>文件不存在，用户需要从Maven安装目录复制<code>$M2_HOME/conf/settings.xml</code>文件再进行编辑。</p>
<h3 id="远程仓库-中央仓库"><a href="#远程仓库-中央仓库" class="headerlink" title="远程仓库-中央仓库"></a>远程仓库-中央仓库</h3><p>默认情况下，本地仓库是被注释掉的，也就是空的，那么就必须得给 Maven 配置一个可用的远程仓库，否则 Maven 在 build（构建）的时候就无法去下载依赖。</p>
<p><strong>中央仓库</strong>就是这样一个可用的远程仓库，里面包含了这个世界上绝大多数流行的开源 Java 类库，以及源码、作者信息、许可证信息等等。</p>
<h3 id="远程仓库-aliyun仓库"><a href="#远程仓库-aliyun仓库" class="headerlink" title="远程仓库-aliyun仓库"></a>远程仓库-aliyun仓库</h3><p>不过，默认的中央仓库访问速度比较慢，通常我们会选择使用阿里的 Maven 远程仓库。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>ali-maven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>fail<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>repositories 可以包含一个或者多个repository元素，以声明一个或者多个仓库。</li>
<li>id，仓库声明的唯一id，需要注意的是，Maven自带的中央仓库使用的id为central，如果其他仓库也使用了该id，就会覆盖中央仓库的配置。</li>
<li>url，指向了仓库的地址。</li>
<li>releases和snapshots，用来控制Maven对于发布版构件和快照版构件的下载权限。</li>
<li>enabled子元素为 true 时表示可以从仓库下载发布版构件和快照版构件。</li>
<li>updatePolicy 子元素用来配置Maven从远处仓库检查更新的频率。<ul>
<li>默认值是daily，表示每天检查一次；</li>
<li>可选值 never 表示从不检查；</li>
<li>可选值always表示每次构建时检查更新；</li>
<li>可选值interval表示每隔X分钟检查一次更新（X为任意整数）。</li>
</ul>
</li>
<li>checksumPolicy 子元素用来配置Maven检查校验的策略。在下载构件的时候，Maven会去校验，如果校验失败，<ul>
<li>当checksumPolicy的值为默认的warn时，Maven会在执行构建时输出警告信息；</li>
<li>值为fail 时，Maven遇到校验错误就让构建失败；</li>
<li>值为ignore时，Maven将完全忽略校验。</li>
</ul>
</li>
</ul>
<h3 id="远程仓库-私服"><a href="#远程仓库-私服" class="headerlink" title="远程仓库-私服"></a>远程仓库-私服</h3><p>私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的Maven用户使用。当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载请求提供服务。因此，一些无法从外部仓库下载到的构件也能从本地上传到私服上供大家使用。 私服的好处：</p>
<ul>
<li>节省自己的外网速度</li>
<li>加速Maven构建</li>
<li>部署第三方构建</li>
<li>提高稳定性，增强控制</li>
<li>降低中央仓库的负荷</li>
</ul>
<h3 id="远程仓库的配置"><a href="#远程仓库的配置" class="headerlink" title="远程仓库的配置"></a>远程仓库的配置</h3><p>在平时的开发中，我们往往不会使用默认的中央仓库，默认的中央仓库访问的速度比较慢，访问的人或许很多，有时候也无法满足我们项目的需求，可能项目需要的某些构件中央仓库中是没有的，而在其他远程仓库中有，如JBoss Maven仓库。这时，可以在pom.xml中配置该仓库，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置远程仓库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>jboss<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>JBoss Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repository.jboss.com/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>daily<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>**repository:**在repositories元素下，可以使用repository子元素声明一个或者多个远程仓库。</li>
<li><strong>id：</strong>仓库声明的唯一id，尤其需要注意的是，Maven自带的中央仓库使用的id为central，如果其他仓库声明也使用该id，就会覆盖中央仓库的配置。</li>
<li><strong>name：</strong>仓库的名称，让我们直观方便的知道仓库是哪个，暂时没发现其他太大的含义。</li>
<li><strong>url：</strong>指向了仓库的地址，一般来说，该地址都基于http协议，Maven用户都可以在浏览器中打开仓库地址浏览构件。</li>
<li>**releases和snapshots：**用来控制Maven对于发布版构件和快照版构件的下载权限。需要注意的是**enabled**子元素，该例中releases的enabled值为true，表示开启JBoss仓库的发布版本下载支持，而snapshots的enabled值为false，表示关闭JBoss仓库的快照版本的下载支持。根据该配置，Maven只会从JBoss仓库下载发布版的构件，而不会下载快照版的构件。</li>
<li><strong>layout：</strong>元素值default表示仓库的布局是Maven2及Maven3的默认布局，而不是Maven1的布局。基本不会用到Maven1的布局。</li>
<li><strong>其他：</strong>对于releases和snapshots来说，除了enabled，它们还包含另外两个子元素updatePolicy和checksumPolicy。</li>
</ul>
<p>1：元素<strong>updatePolicy</strong>用来配置Maven从远处仓库检查更新的频率，默认值是daily，表示Maven每天检查一次。其他可用的值包括：never-从不检查更新；always-每次构建都检查更新；interval：X-每隔X分钟检查一次更新（X为任意整数）。<br> 2：元素<strong>checksumPolicy</strong>用来配置Maven检查校验和文件的策略。当构建被部署到Maven仓库中时，会同时部署对应的检验和文件。在下载构件的时候，Maven会验证校验和文件，如果校验和验证失败，当checksumPolicy的值为默认的warn时，Maven会在执行构建时输出警告信息，其他可用的值包括：fail-Maven遇到校验和错误就让构建失败；ignore-使Maven完全忽略校验和错误。</p>
<h3 id="远程仓库的认证"><a href="#远程仓库的认证" class="headerlink" title="远程仓库的认证"></a>远程仓库的认证</h3><p>大部分的远程仓库不需要认证，但是如果是自己内部使用，为了安全起见，还是要配置认证信息的。 配置认证信息和配置远程仓库不同，远程仓库可以直接在pom.xml中配置，但是认证信息必须配置在settings.xml文件中。这是因为pom往往是被提交到代码仓库中供所有成员访问的，而settings.xml一般只存在于本机。因此，在settings.xml中配置认证信息更为安全。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line">     <span class="comment">&lt;!--配置远程仓库认证信息--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">id</span>&gt;</span>releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line">     ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里除了配置账号密码之外，值关键的就是id了，这个id要跟你在pom.xml里面配置的远程仓库repository的id一致，正是这个id将认证信息与仓库配置联系在了一起。</p>
<h3 id="部署构件至远程仓库"><a href="#部署构件至远程仓库" class="headerlink" title="部署构件至远程仓库"></a>部署构件至远程仓库</h3><p>我们自己搭建远程仓库的目的就是为了可以<strong>方便部署我们自己项目的构件以及一些无法从外部仓库直接获取的构件</strong>,供其他团队成员使用。 Maven除了能对项目进行编译、测试、打包之外，还能将项目生成的构件部署到远程仓库中。首先，需要编辑项目的pom.xml文件。配置distributionManagement元素，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>public<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://59.50.95.66:8081/nexus/content/repositories/releases<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://59.50.95.66:8081/nexus/content/repositories/snapshots<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>repository表示表示发布版本（稳定版本）构件的仓库</li>
<li>snapshotRepository表示快照版本（开发测试版本）的仓库。</li>
<li>这两个元素都需要配置id、name和url.<ul>
<li>id为远程仓库的唯一标识</li>
<li>name是为了方便人阅读</li>
<li>url表示该仓库的地址。</li>
</ul>
</li>
</ul>
<p>配置好了就运行命令<code>mvn clean deploy</code>，Maven就会将项目构建输出的构件部署到配置对应的远程仓库，如果项目当前的版本是快照版本，则部署到快照版本的仓库地址，否则就部署到发布版本的仓库地址。 当前项目是快照还是发布版本是通过 true 这个来区分的。</p>
<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>如果仓库X可以提供仓库Y存储的所有内容，那么就可以认为X是Y的一个镜像。用过Maven的都知道，国外的中央仓库用起来太慢了，所以选择一个国内的镜像就很有必要，我推荐国内的阿里云镜像。 阿里云镜像：配置很简单，修改conf文件夹下的settings.xml文件，添加如下镜像配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上例子中，的值为central,表示该配置为中央库的镜像，任何对于中央仓库的请求都会转至该镜像，用户也可以用同样的方法配置其他仓库的镜像</p>
<p>这里介绍下<code>&lt;mirrorOf&gt;</code>配置的各种选项</p>
<ul>
<li><code>&lt;mirrorOf&gt;*&lt;mirrorOf&gt;</code>:匹配所有远程仓库。</li>
<li><code>&lt;mirrorOf&gt;external:*&lt;mirrorOf&gt;</code>:匹配所有远程仓库，使用localhost的除外，使用file:&#x2F;&#x2F;协议的除外。也就是说，匹配所有不在本机上的远程仓库。</li>
<li><code>&lt;mirrorOf&gt;repo1,repo2&lt;mirrorOf&gt;</code>:匹配仓库repo1h和repo2，使用逗号分隔多个远程仓库。</li>
<li><code>&lt;mirrorOf&gt;*,!repo1&lt;mirrorOf&gt;</code>:匹配所有远程仓库，repo1除外，使用感叹号将仓库从匹配中排除。</li>
</ul>
<p>需要注意的是，由于镜像仓库完全屏蔽了被镜像仓库，当镜像仓库不稳定或者停止服务的时候，Maven仍将无法访问被镜像仓库，因而将无法下载构件。</p>
<h3 id="maven-坐标"><a href="#maven-坐标" class="headerlink" title="maven 坐标"></a>maven 坐标</h3><p><strong>在 maven 中，根据 <code>groupId</code>、<code>artifactId</code>、<code>version</code> 组合成 <code>groupId:artifactId:version</code> 来唯一识别一个 jar 包。</strong></p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205060953017.png"></p>
<ul>
<li><p><strong>groupId</strong> - 团体、组织的标识符。团体标识的约定是，它以创建这个项目的组织名称的逆向域名(reverse domain name)开头。一般对应着 java 的包结构。</p>
</li>
<li><p><strong>artifactId</strong> - 单独项目的唯一标识符。比如我们的 tomcat、commons 等。不要在 artifactId 中包含点号(.)。</p>
</li>
<li><p>version</p>
<p>- 一个项目的特定版本。</p>
<ul>
<li><p>maven 有自己的版本规范，一般是如下定义 major version、minor version、incremental version-qualifier ，比如 1.2.3-beta-01。要说明的是，maven 自己判断版本的算法是 major、minor、incremental 部分用数字比较，qualifier 部分用字符串比较，所以要小心 alpha-2 和 alpha-15 的比较关系，最好用 alpha-02 的格式。</p>
</li>
<li><p>maven 在版本管理时候可以使用几个特殊的字符串 SNAPSHOT、LATEST、RELEASE。比如 </p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">1</span>.<span class="number">0</span>-SNAPSHOT</span><br></pre></td></tr></table></figure>

<p>。各个部分的含义和处理逻辑如下说明：</p>
<ul>
<li><strong>SNAPSHOT</strong> - 这个版本一般用于开发过程中，表示不稳定的版本。</li>
<li><strong>LATEST</strong> - 指某个特定构件的最新发布，这个发布可能是一个发布版，也可能是一个 snapshot 版，具体看哪个时间最后。</li>
<li><strong>RELEASE</strong> ：指最后一个发布版。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>packaging</strong> - 项目的类型，描述了项目打包后的输出，默认是 jar。常见的输出类型为：pom, jar, maven-plugin, ejb, war, ear, rar, par。</p>
</li>
</ul>
<p>maven工程的坐标与仓库中路径的关系：</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205060953011.jpeg"></p>
<p>maven坐标和仓库对应的映射关系：[groupId][artifactId][version][artifactId]-[version].jar</p>
<p>去本地仓库看一下此目录：org\springframework\spring-core\4.3.4.RELEASE\spring-core-4.3.4.RELEASE.jar</p>
<p>在Maven世界中，任何一个依赖、插件或者项目构建的输出，都可以称为构件。得益于坐标机制，任何Maven项目使用任何一个构件的方式都是完全相同的。在此基础上，Maven可以在某个位置统一存储所有Maven项目共享的构件，这个统一的位置就是仓库。</p>
<p>实际的Maven项目将不再各自存储其依赖文件，它们只需要声明这些依赖的坐标，在需要的时候（例如，编译项目的时候需要将依赖加入到classpath中），Maven会自动根据坐标找到仓库中的构件，并使用它们。</p>
<p>为了实现重用，项目构建完毕后可生成的构件也可以安装或者部署到仓库中，供其他项目使用。</p>
<h2 id="七、配置文件说明"><a href="#七、配置文件说明" class="headerlink" title="七、配置文件说明"></a>七、配置文件说明</h2><p>参看链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq877507054/article/details/79138294">https://blog.csdn.net/qq877507054/article/details/79138294</a></p>
<h3 id="1、pom-xml文件"><a href="#1、pom-xml文件" class="headerlink" title="1、pom.xml文件"></a>1、pom.xml文件</h3><h3 id="2、settings-xml文件"><a href="#2、settings-xml文件" class="headerlink" title="2、settings.xml文件"></a>2、settings.xml文件</h3><ul>
<li>用来设置Maven参数的配置文件。</li>
<li>是Maven的全局配置文件。</li>
<li>包含类似本地仓库、远程仓库和联网使用的代理信息等配置。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">localRepository</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interactiveMode</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">offline</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginGroups</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servers</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">proxies</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfiles</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在Maven安装目录的conf子目录下面的settings.xml才是真正的全局的配置。</p>
<p>用户目录的.m2子目录下面的settings.xml的配置只是针对当前用户的。</p>
<p>当这两个文件同时存在的时候，那么对于相同的配置信息用户目录下面的settings.xml中定义的会覆盖Maven安装目录下面的settings.xml中的定义。用户目录下的settings.xml文件一般是不存在的，但是Maven允许我们在这里定义我们自己的settings.xml，如果需要在这里定义我们自己的settings.xml的时候就可以把Maven安装目录下面的settings.xml文件拷贝到用户目录的.m2目录下，然后改成自己想要的样子。</p>
<p>通过配置文件中的注释，我们可以看到，有两种配置此文件的方法</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.用户级别</span><br><span class="line">$&#123;user.home&#125;/.m2/settings.xml</span><br><span class="line">可以通过指令 -s /path/to/user/settings.xml</span><br><span class="line"></span><br><span class="line">2.全局级别</span><br><span class="line">$&#123;maven.home&#125;/conf/settings.xml.</span><br><span class="line">可以通过指令 -gs /path/to/global/settings.xml</span><br></pre></td></tr></table></figure>

<p>一般情况下，只需要如下两个就够了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>E:\config\maven\repository-spring<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是在实际开发中，一般都配有自己的私服，所以会加上私服的用户名称及密码</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">offline</span>&gt;</span>true<span class="tag">&lt;/<span class="name">offline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">password</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">password</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">server</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<h4 id="2-1-localRepository"><a href="#2-1-localRepository" class="headerlink" title="2.1 localRepository"></a>2.1 localRepository</h4><p>localRepository用于构建系统的本地仓库的路径。<br>默认的值是${user.home}&#x2F;.m2&#x2F;repository。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Default: $&#123;user.home&#125;/.m2/repository</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>/path/to/local/repo<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-interactiveMode"><a href="#2-2-interactiveMode" class="headerlink" title="2.2 interactiveMode"></a>2.2 interactiveMode</h4><p>interactiveMode 用于决定<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=maven&spm=1001.2101.3001.7020">maven</a>是否在需要输出的时候提示你，默认true。如果是false，它将使用合理的默认值，或者基于一些设置。</p>
<h4 id="2-3-offline"><a href="#2-3-offline" class="headerlink" title="2.3 offline"></a>2.3 offline</h4><p>决定maven是否在构建的时候进行网络传输。<br>默认false，表示联网状态，true为取消联网。<br>在某些情况下设置为true是很有用的，比如jar无法从网上下载等</p>
<h4 id="2-4-pluginGroups"><a href="#2-4-pluginGroups" class="headerlink" title="2.4 pluginGroups"></a>2.4 pluginGroups</h4><p>pluginGroups 插件组</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginGroup</span>&gt;</span>org.mortbay.jetty<span class="tag">&lt;/<span class="name">pluginGroup</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>这样Maven可以使用简单的命令执行org.morbay.jetty:jetty-maven-plugin:run</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn jetty run</span><br></pre></td></tr></table></figure>

<h4 id="2-5-proxies"><a href="#2-5-proxies" class="headerlink" title="2.5 proxies"></a>2.5 proxies</h4><p>此项用于设置http代理<br>有时候由于安全问题，需要配置http代理，通过代理服务才能正常访问外部仓库下载资源可以ping repo1.maven.org来访问中央仓库<br>telnet 218.14.227.197 3128 来查看代理地址以及端口是否畅通</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">proxies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">proxy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>optional<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">active</span>&gt;</span>true<span class="tag">&lt;/<span class="name">active</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">protocol</span>&gt;</span>http<span class="tag">&lt;/<span class="name">protocol</span>&gt;</span><span class="comment">&lt;!--代理协议--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>proxyuser<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">password</span>&gt;</span>proxypass<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">host</span>&gt;</span>proxy.host.net<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">nonProxyHosts</span>&gt;</span>local.net|some.host.com<span class="tag">&lt;/<span class="name">nonProxyHosts</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">proxy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">proxies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>id：proxy的唯一标识，用来区别proxy元素。</li>
<li>active：表示是否激活代理，如果配置多个，默认是第一个生效</li>
<li>username，password：提供连接代理服务器时的认证。</li>
<li>host，port：主机地址，端口号</li>
<li>nonProxyHosts：用来表示哪些主机名不需要代理，可以用|来分割多个，此外也支持通配符，如：*.goole.com表示所有以goole.com结尾的都不需要通过代理</li>
</ul>
<h6 id="设置http代理"><a href="#设置http代理" class="headerlink" title="设置http代理"></a>设置http代理</h6><p>编辑setting.xml文件 有时候你所在的公司基于安全因素考虑，要求你使用通过安全认证的代理访问因特网。这种情况下，就需要为Maven配置HTTP代理，才能让它正常访问外部仓库，以下载所需要的资源。首先确认自己无法直接访问公共的maven中央仓库，直接运行命令ping repo1.maven.org可以检查网络。如果真的需要代理，先检查一下代理服务器是否畅通。比如现在有一个IP地址为218.14.227.197，端口为3128的代理服务，我们可以运行telnet 218.14.227.197 3128来检测该地址的该端口是否畅通。如果得到出错信息，需要先获取正确的代理服务信息，如果telnet连接正确，则输入ctrl+]，然后q，回车，退出即可。</p>
<p>检查完毕之后，编辑~&#x2F;.m2&#x2F;settings.xml文件(如果没有该文件，则复制$M2_HOME&#x2F;conf&#x2F;settings.xml)。添加代理配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span>  </span><br><span class="line">  ...  </span><br><span class="line">  <span class="tag">&lt;<span class="name">proxies</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">proxy</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>my-proxy<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">active</span>&gt;</span>true<span class="tag">&lt;/<span class="name">active</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">protocol</span>&gt;</span>http<span class="tag">&lt;/<span class="name">protocol</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">host</span>&gt;</span>218.14.227.197<span class="tag">&lt;/<span class="name">host</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span>&gt;</span>3128<span class="tag">&lt;/<span class="name">port</span>&gt;</span>  </span><br><span class="line">      <span class="comment">&lt;!--  </span></span><br><span class="line"><span class="comment">        &lt;username&gt;***&lt;/username&gt;  </span></span><br><span class="line"><span class="comment">        &lt;password&gt;***&lt;/password&gt;  </span></span><br><span class="line"><span class="comment">        &lt;nonProxyHosts&gt;  </span></span><br><span class="line"><span class="comment">          repository.mycom.com|*.google.com  </span></span><br><span class="line"><span class="comment">        &lt;/nonProxyHosts&gt;  </span></span><br><span class="line"><span class="comment">      --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">proxy</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">proxies</span>&gt;</span>  </span><br><span class="line">  ...  </span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>这段配置十分简单，proxies下可以有多个proxy元素，如果声明了多个proxy元素，则默认情况下第一个被激活的proxy会生效。这里声明了一个id为my-proxy的代理，active的值为true表示激活该代理，protocol表示使用的代理协议，这里是http。当然，最重要的是指定正确的主机名(host元素)和端口(port元素)。上述xml配置中注释掉了username,password,nonProxyHosts几个元素。当代理服务需要认证时，就需要配置username和password。nonProxyHost元素用来指定哪些主机不需要代理，可以使用”|”符号来分隔多个主机名。此外，该配置也支持通配符，如:*.google.com表示所有以google.com结尾的域名访问都不要通过代理。</p>
<h4 id="2-6-servers"><a href="#2-6-servers" class="headerlink" title="2.6 servers"></a>2.6 servers</h4><p>这是一个认证配置的列表,根据系统中使用的server-id控制。认证配置在maven连接到远程服务时使用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用登录方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>deploymentRepo<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">username</span>&gt;</span>repouser<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">password</span>&gt;</span>repopwd<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 使用秘钥认证 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>siteServer<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">privateKey</span>&gt;</span>/path/to/private/key<span class="tag">&lt;/<span class="name">privateKey</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">passphrase</span>&gt;</span>可空<span class="tag">&lt;/<span class="name">passphrase</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7-mirrors"><a href="#2-7-mirrors" class="headerlink" title="2.7 mirrors"></a>2.7 mirrors</h4><p>指定镜像仓库位置用于从远程仓库下载资源</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>mirrorId<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>repositoryId<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://my.repository.com/repo/path<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>id：用于继承和直接查找，唯一</li>
<li>mirrorOf：镜像所包含的仓库的Id</li>
<li>name：唯一标识，用于区分镜像站</li>
<li>url：镜像路径</li>
</ul>
<h4 id="2-8-profiles"><a href="#2-8-profiles" class="headerlink" title="2.8 profiles"></a>2.8 profiles</h4><ul>
<li>settings.xml中时意味着该profile是全局的，所以只能配置范围宽泛一点配置信息，比如远程仓库等。而一些比较细致一点的需要定义在项目的pom.xml中。</li>
<li>profile可以让我们定义一系列的配置信息，然后指定其激活条件。<br>根据每个profile对应不同的激活条件和配置信息，从而达到不同环境使用不同配置。</li>
<li>例子：通过profile定义jdk1.5以上使用一套配置，jdk1.5以下使用另外一套配置；或者通过操作系统来使用不同的配置信息。</li>
<li>settings.xml中的信息有repositories、pluginRepositories和properties。定义在properties的值可以在pom.xml中使用。</li>
</ul>
<h5 id="activation"><a href="#activation" class="headerlink" title="activation"></a>activation</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">//可定义多个profile,使用activeProfiles激活</span><br><span class="line">	<span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>false<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">name</span>&gt;</span>mavenVersion<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exists</span>&gt;</span>$&#123;basedir&#125;/file2.properties<span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">missing</span>&gt;</span>$&#123;basedir&#125;/file1.properties<span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>jdk：检测到对应jdk版本就激活</p>
</li>
<li><p>os：针对不同操作系统</p>
</li>
<li><p>property：当maven检测到property（pom中如${name}这样的）profile将被激活</p>
</li>
<li><p>file：如果存在文件，激活，不存在文件激活</p>
</li>
</ul>
<p>通过以下命令查看哪些profile将生效</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn help:active-profiles</span><br></pre></td></tr></table></figure>

<h5 id="properites"><a href="#properites" class="headerlink" title="properites"></a>properites</h5><p>Maven的属性是值占位符，如果X是一个属性的话，在POM中可以使用${X}来进行任意地方的访问。他们来自于五种不同的风格，所有都可以从settings.xml文件中访问到。</p>
<p>1.env.x：“env.”前缀会返回当前的环境变量。如${env.PATH}就是使用了$path环境变量（windosws中的%PATH%）。</p>
<p>2.project.x：一个点“.”分割的路径，在POM中就是相关的元素的值。例如：<project><version>1.0</version></project>就可以通过${project.version}来访问。</p>
<p>3.settings.x：一个点“.”分割的路径，在settings.xml中就是相对应的元素的值，例如：<settings><offline>false</offline></settings>就可以通过${settings.offline}来访问。</p>
<p>4.Java系统属性：通过java.lang.System.getProperties()来访问的属性都可以像POM中的属性一样访问，例如：${java.home}</p>
<p>5.x：被<properties/>或者外部文件定义的属性，值可以这样访问${someVar}</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">user.install</span>&gt;</span>$&#123;user.home&#125;/our-project<span class="tag">&lt;/<span class="name">user.install</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面这个profile如果被激活，那么在pom中${user.install}就可以被访问了。</p>
<p>实战:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">p.jdbc.url</span>&gt;</span>172.11.2.112:3306/yh2_qr<span class="tag">&lt;/<span class="name">p.jdbc.url</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">p.jdbc.username</span>&gt;</span>root<span class="tag">&lt;/<span class="name">p.jdbc.username</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">p.jdbc.password</span>&gt;</span>root<span class="tag">&lt;/<span class="name">p.jdbc.password</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>uat<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">p.jdbc.url</span>&gt;</span>172.11.2.131:3306/yh2_qr<span class="tag">&lt;/<span class="name">p.jdbc.url</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">p.jdbc.username</span>&gt;</span>root<span class="tag">&lt;/<span class="name">p.jdbc.username</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">p.jdbc.password</span>&gt;</span>Cheryfs5t6y89kL<span class="tag">&lt;/<span class="name">p.jdbc.password</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line">jdbc.url=jdbc:mysql://$&#123;p.jdbc.url&#125;?characterEncoding=utf-8&amp;allowMultiQueries=true</span><br><span class="line">jdbc.username=$&#123;p.jdbc.username&#125;</span><br><span class="line">jdbc.password=$&#123;p.jdbc.password&#125;</span><br></pre></td></tr></table></figure>

<h5 id="repositories"><a href="#repositories" class="headerlink" title="repositories"></a>repositories</h5><p>repositories是远程项目集合maven用来移植到本地仓库用于构建系统。如果来自本地仓库，Maven调用它的插件和依赖关系。不同的远程仓库可能包含不同的项目，当profile被激活，他们就会需找匹配的release或者snapshot构件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>codehausSnapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Codehaus Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//发行版</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//快照版</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>never<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>fail<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://snapshots.maven.codehaus.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>1.releases，snapshots：这是各种构件的策略，release或者snapshot。这两个集合，POM就可以根据独立仓库任意类型的依赖改变策略。如：一个人可能只激活下载snapshot用来开发。</p>
<p>2.enable：true或者false，决定仓库是否对于各自的类型激活(release或者snapshot)。</p>
<p>3.updatePolicy:这个元素决定更新频率。maven将比较本地pom的时间戳（存储在仓库的maven数据文件中）和远程的.有以下选择: always, daily (默认), interval:X (x是代表分钟的整型)，never.</p>
<p>4.checksumPolicy：当Maven向仓库部署文件的时候，它也部署了相应的校验和文件。可选的为：ignore，fail，warn，或者不正确的校验和。</p>
<p>5.layout：在上面描述仓库的时候，提到他们有统一的布局。Maven 2有它仓库默认布局。然而，Maven 1.x有不同布局。使用这个元素来表明它是default还是legacy。</p>
<h4 id="2-9-activeProfiles"><a href="#2-9-activeProfiles" class="headerlink" title="2.9 activeProfiles"></a>2.9 activeProfiles</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>alwaysActiveProfile<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>anotherAlwaysActiveProfile<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>每个activeProfile元素对应一个profile id的值，任何profile id被定义到activeProfile的profile将被激活。</p>
<p>参看链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hongmoshui/p/10762272.html">https://www.cnblogs.com/hongmoshui/p/10762272.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/szrs/p/15251037.html">https://www.cnblogs.com/szrs/p/15251037.html</a></p>
<h3 id="4-3、两者的关系"><a href="#4-3、两者的关系" class="headerlink" title="4.3、两者的关系"></a>4.3、两者的关系</h3><p>pom.xml文件针对于具体的项目，settings.xml文件作为maven的全局配置文件；满足条件时，会采用settings.xml文件中的配置，如settingsxml文件中的Profiles标签。还有一些比较私密的配置可以写在settings.xml文件中。</p>
<ol>
<li>Setting.xml中repository的配置与pom.xml中repository的配置有什么不同?</li>
</ol>
<p>Setting.xml中配置repository与pom.xml中配置repository的作用是相同的，都是为了指定多个存储库的使用(you can specify the use of multiple repositories)。但在pom.xml中配置只对当前项目与子项目有用，而在setting.xml中配置为全局性配置，用于所用的项目。</p>
<p>参看链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xrq730/p/5530069.html">https://www.cnblogs.com/xrq730/p/5530069.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq877507054/article/details/79138294">https://blog.csdn.net/qq877507054/article/details/79138294</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2022/11/11/akka%E2%80%94%E2%80%94%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/11/akka%E2%80%94%E2%80%94%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">akka——（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-10 16:38:28" itemprop="dateCreated datePublished" datetime="2022-11-10T16:38:28Z">2022-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 15:08:09" itemprop="dateModified" datetime="2022-11-13T15:08:09Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="akka简介"><a href="#akka简介" class="headerlink" title="akka简介"></a>akka简介</h1><p>Akka 是一个用 Scala 编写的库，用于在 JVM 平台上简化编写具有可容错的、高可伸缩性的 Java 和 Scala 的 Actor 模型应用，其同时提供了Java 和 Scala 的开发接口。实现了RPC框架。</p>
<p>Akka 提供：</p>
<ul>
<li>不使用原子或锁之类的低级并发构造的多线程行为，甚至可以避免你考虑内存可见性问题。</li>
<li>系统及其组件之间的透明远程通信，使你不再编写和维护困难的网络代码。</li>
<li>一个集群的、高可用的体系结构，具有弹性、可按需扩展性，使你能够提供真正的反应式系统。</li>
</ul>
<h2 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h2><h3 id="RPC-是什么？"><a href="#RPC-是什么？" class="headerlink" title="RPC 是什么？"></a>RPC 是什么？</h3><p>RPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。比较正式的描述是：一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。那么我们至少从这样的描述中挖掘出几个要点：</p>
<p><strong>RPC是协议</strong>：既然是协议就只是一套规范，那么就需要有人遵循这套规范来进行实现。目前典型的RPC实现包括：Dubbo、Thrift、GRPC、Hetty等。这里要说明一下，目前技术的发展趋势来看，实现了RPC协议的应用工具往往都会附加其他重要功能，例如Dubbo还包括了服务治等功能。</p>
<p><strong>网络协议和网络IO模型对其透明</strong>：既然RPC的客户端认为自己是在调用本地对象。那么传输层使用的是TCP&#x2F;UDP还是HTTP协议，又或者是一些其他的网络协议它就不需要关心了。既然网络协议对其透明，那么调用过程中，使用的是哪一种网络IO模型调用者也不需要关心。</p>
<p><strong>信息格式对其透明</strong>：我们知道在本地应用程序中，对于某个对象的调用需要传递一些参数，并且会返回一个调用结果。至于被调用的对象内部是如何使用这些参数，并计算出处理结果的，调用方是不需要关心的。那么对于远程调用来说，这些参数会以某种信息格式传递给网络上的另外一台计算机，这个信息格式是怎样构成的，调用方是不需要关心的。</p>
<p><strong>应该有跨语言能力</strong>：为什么这样说呢？因为调用方实际上也不清楚远程服务器的应用程序是使用什么语言运行的。那么对于调用方来说，无论服务器方使用的是什么语言，本次调用都应该成功，并且返回值也应该按照调用方程序语言所能理解的形式进行描述。</p>
<p>所以，RPC的作用主要体现在这两个方面：</p>
<ul>
<li>屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法；</li>
<li>隐藏底层网络通信的复杂性，让我们更专注于业务逻辑。</li>
</ul>
<h3 id="RPC-框架基本架构"><a href="#RPC-框架基本架构" class="headerlink" title="RPC 框架基本架构"></a>RPC 框架基本架构</h3><p>下面我们通过一幅图来说说 RPC 框架的基本架构 </p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/20221113170329.webp"> RPC 框架包含三个最重要的组件，分别是客户端、服务端和注册中心。在一次 RPC 调用流程中，这三个组件是这样交互的：</p>
<ul>
<li>服务端在启动后，会将它提供的服务列表发布到注册中心，客户端向注册中心订阅服务地址；</li>
<li>客户端会通过本地代理模块 Proxy 调用服务端，Proxy 模块收到负责将方法、参数等数据转化成网络字节流；</li>
<li>客户端从服务列表中选取其中一个的服务地址，并将数据通过网络发送给服务端；</li>
<li>服务端接收到数据后进行解码，得到请求信息；</li>
<li>服务端根据解码后的请求信息调用对应的服务，然后将调用结果返回给客户端。</li>
</ul>
<h3 id="RPC-框架通信流程以及涉及到的角色"><a href="#RPC-框架通信流程以及涉及到的角色" class="headerlink" title="RPC 框架通信流程以及涉及到的角色"></a>RPC 框架通信流程以及涉及到的角色</h3><p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/20221113170337.webp"> 从上面这张图中，可以看见 RPC 框架一般有这些组件：服务治理(注册发现)、负载均衡、容错、序列化&#x2F;反序列化、编解码、网络传输、线程池、动态代理等角色，当然有的RPC框架还会有连接池、日志、安全等角色。</p>
<h3 id="具体调用过程"><a href="#具体调用过程" class="headerlink" title="具体调用过程"></a>具体调用过程</h3><p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/20221113170352.webp"></p>
<ol>
<li>服务消费方(client)以本地调用方式调用服务</li>
<li>client stub 接收到调用后负责将方法、参数等封装成能够进行网络传输的消息体</li>
<li>client stub 将消息进行编码并发送到服务端</li>
<li>server stub 收到消息后进行解码</li>
<li>server stub 根据解码结果调用本地的服务</li>
<li>本地服务执行并将结果返回给 server stub</li>
<li>server stub 将返回导入结果进行编码并发送至消费方</li>
<li>client stub 接收到消息并进行解码</li>
<li>服务消费方(client)得到结果</li>
</ol>
<h3 id="RPC-消息协议"><a href="#RPC-消息协议" class="headerlink" title="RPC 消息协议"></a>RPC 消息协议</h3><p>RPC调用过程中需要将参数编组为消息进行发送，接收方需要解组消息为参数，过程处理结果同样需要经编组、解组。消息由哪些部分构成及消息的表示形式就构成了消息协议。<br> RPC调用过程中采用的消息协议称为RPC消息协议。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6992867064952127524">如何手撸一个较为完整的RPC框架 - 掘金 (juejin.cn)</a></p>
<h2 id="Actor模型"><a href="#Actor模型" class="headerlink" title="Actor模型"></a>Actor模型</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xingchong/p/16202290.html">Actor——Actor模型原理的通俗理解 (转) - 会飞的斧头 - 博客园 (cnblogs.com)</a></p>
<h3 id="Akka中Actors模型"><a href="#Akka中Actors模型" class="headerlink" title="Akka中Actors模型"></a>Akka中Actors模型</h3><ul>
<li>对并发模型进行了更高的抽象</li>
<li>异步、非阻塞、高性能的事件驱动编程模型</li>
<li>轻量级事件处理（1GB内存可容纳百万级别个Actor）</li>
</ul>
<p>为什么Actor模型是一种处理并发问题的解决方案？</p>
<p>处理并发问题就是如何保证共享数据的一致性和正确性，为什么会有保持共享数据正确性这个问题呢？无非是我们的程序是多线程的，多个线程对同一个数据进行修改，若不加同步条件，势必会造成数据污染。那么我们是不是可以转换一下思维，用单线程去处理相应的请求，但是又有人会问了，若是用单线程处理，那系统的性能又如何保证。Actor模型的出现解决了这个问题。</p>
<p>Actor模型概图：</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/20221113230215.png"></p>
<p>从上图中我们可以看到，Actor与Actor之前只能用消息进行通信，当某一个Actor给另外一个Actor发消息，消息是有顺序的，你只需要将消息投寄的相应的邮箱，至于对方Actor怎么处理你的消息你并不知道，当然你也可等待它的回复。</p>
<p>JVM中的Actor有以下几个特点：</p>
<ul>
<li>每个Actor都有对应一个邮箱</li>
<li>Actor是串行处理消息的</li>
<li>Actor中的消息是不可变的</li>
</ul>
<p>其实只从上面一些描述来看，并不能看出Actor在处理并发问题上的有什么优势。</p>
<p>但我总结了两点：<em>简化并发编程</em>，<em>提升程序性能</em></p>
<h4 id="简化并发编程"><a href="#简化并发编程" class="headerlink" title="简化并发编程"></a>简化并发编程</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2022/11/10/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/10/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-10 01:57:12" itemprop="dateCreated datePublished" datetime="2022-11-10T01:57:12Z">2022-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/20190111184331949.png"></p>
<h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><ul>
<li>存储器：存放程序和数据的器件。</li>
<li>存储位：存放一个二进制数位的存储单元，是存储器最小的存储单位。</li>
<li>存储字：计算机可寻址（作为一个整体存入或取出）的最小信息单位。</li>
<li>存储单元：存放一个存储字的若干个记忆单元组成一个存储单元。</li>
<li>存储体：大量存储单元的集合组成存储体。</li>
<li>存储单元地址：存储单元的编号。</li>
<li>字编址：对存储单元按字编址。</li>
<li>字节编址：对存储单元按字节编址。</li>
<li>寻址：通过地址寻找数据，从对应地址的存储单元中访存数据。</li>
</ul>
<h1 id="存储系统分类"><a href="#存储系统分类" class="headerlink" title="存储系统分类"></a>存储系统分类</h1><h2 id="按存储介质分类"><a href="#按存储介质分类" class="headerlink" title="按存储介质分类"></a>按存储介质分类</h2><p><strong>半导体存储器</strong>：用半导体器件组成的存储器。<br><strong>磁表面存储器</strong>：用磁性材料做成的存储器。（磁盘、磁带）<br><strong>激光存储器</strong>：信息以刻痕的形式保存在盘面上，用激光束照射盘面，靠盘面的不同反射率来读出信息。</p>
<h2 id="按存取方式分类"><a href="#按存取方式分类" class="headerlink" title="按存取方式分类"></a>按存取方式分类</h2><h3 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h3><p><strong>随机存储器（RAM，Random Access Memory）</strong>：可随机访问任意存储单元，且存取时间与存储单元的物理位置无关。主要充当高速缓冲存储器和主存储器。</p>
<blockquote>
<p>半导体随机存储器</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/1520534-20190831150521567-371157831.png"></p>
</blockquote>
<h4 id="动态随机存储器（DRAM）"><a href="#动态随机存储器（DRAM）" class="headerlink" title="动态随机存储器（DRAM）"></a>动态随机存储器（DRAM）</h4><p>只能将数据保持很短的时间。为了保持数据，DRAM 使用电容存储，所以必须隔一段时间刷新（Refresh）一次，如果存储单元没有被刷新，存储的信息就会丢失，关机就会丢失数据。<strong>常用于主存储器</strong>。<strong>DRAM 采用地址复用技术，地址线是原来的 1&#x2F;2，且地址信号分行、列两次传送</strong>。相对于 SRAM 来说，DRAM 具有容易集成、价位低、容量大和功耗低等优点，但 DRAM 的存取速度比 SRAM 慢，一般用来组成大容量主存系统。</p>
<p>DRAM 保存的信息会自动消失（易失性存储器），为此，每隔一段时间必须刷新，通常取 2ms，这个时间称为刷新周期。常用的刷新方式有 3 种：集中刷新、分散刷新和异步刷新。</p>
<p>　　（1）集中刷新：指在一个刷新周期内，利用一段固定的时间，依次对存储器的<strong>所有行</strong>进行逐一再生，在此期间停止对存储器的读写操作，称为“死时间”，又称访存“死区”。集中刷新的优点是读写操作时不受刷新工作的影响，因此系统的存取速度较高；缺点是在集中刷新期间（死区）不能访问存储器。</p>
<blockquote>
<p>补充一点：为什么刷新与存取不能并行？<br>因为内存就一套地址译码和片选装置，刷新与存取有相似的过程，它要选中一行——这期间片选线、地址线、地址译码器全被占用着。同理，刷新操作之间也不能并行——意味着一次只能刷一行。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/1920541-20200319112715598-1052856783.png"></p>
</blockquote>
<p>　　（2）分散刷新：把对每行的刷新分散到各个工作周期中。这样，一个存储器的系统工作周期分为两部分：前半部分用于正常读、写或保持；后半部分用于刷新某一行。这种刷新方式增加了系统的存取周期，如存储芯片的存取周期为 0.5μs，则系统的存取周期为 1μs。分散刷新的优点是<strong>没有死区</strong>；缺点是加长了系统的存取周期，降低了整机的速度。</p>
<blockquote>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/1920541-20200319112726854-1502618203.png"></p>
<p>即在每个存取操作后绑定一个刷新操作。延长了存取周期，这样存取周期就成了0.5μs + 0.5μs &#x3D;1μs。但是由于与存取操作绑定，就不需要专门给出一段时间来刷新了。这样，每有128个读取操作，就会把0-127行全部刷新一遍。故每隔128μs 就可将存储芯片全部刷新一遍，即刷新周期是1μs×128&#x3D;128μs远短于2ms，而且不存在停止读&#x2F;写的死时间，但是存取周期长了，整个系统速度降低了。（分散刷新的刷新周期128μs ，其实不需要这么频繁，会导致浪费）</p>
</blockquote>
<p>　　（3）异步刷新：异步刷新是前两种方法的结合，它既可以缩短“死时间”，又能充分利用最大刷新间隔为 2ms 的特点。具体做法是将刷新周期除以行数，得到两次刷新操作的时间间隔 t，利用逻辑电路每隔时间 t 产生一次刷新请求。这样可以避免使 CPU 连续等待过长的时间，而且减少了刷新次数，从根本上提高了整机速度。</p>
<blockquote>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/1920541-20200319112736772-1585159475.png"></p>
<p>具体操作为：在2ms内对128行各刷新一遍</p>
<p>即每隔15.6μs刷新一行(2000μs&#x2F;128≈15.6μs)，而每行刷新的时间仍为0.5μs。这样，刷新一行只能停止一个存取周期，但对每行来说，刷新间隔时间仍为2ms，而死时间为0.5μs。（相对每一段来说，是集中式刷新，相对整体来说，是分散式刷新）</p>
<p>如果将DRAM的刷新安排在CPU对指令的译码阶段，由于这个阶段CPU不访问存储器，所以这种方案既克服了分散刷新需独占0.5μs用于刷新，使存取周期加长且降低系统速度的缺点，又不会出现集中刷新的访存“死区”问题，从根本上上提高了整机的工作效率。</p>
</blockquote>
<p>DRAM 的刷新需注意以下问题：（1）<strong>刷新对 CPU 是透明的，即刷新不依赖外部的访问</strong>；（2）动态 RAM 的刷新单位是行，故刷新操作时仅需要行地址；（3）刷新操作类似于读操作，但又有所不同。刷新操作仅给栅极电容补充电荷，不需要信息输出。另外，刷新时不需要选片，即整个存储器中的所有芯片同时被刷新。</p>
<p>　　SRAM 和 DRAM 都满足断电内容消失，但<strong>需要刷新的只有 DRAM</strong>，而 SRAM 不需要刷新。</p>
<h4 id="静态随机存储器（SRAM）"><a href="#静态随机存储器（SRAM）" class="headerlink" title="静态随机存储器（SRAM）"></a>静态随机存储器（SRAM）</h4><p><em>所谓的 “静态”，指这种存储器只要保持通电，里面储存的数据就可以恒常保持</em>。相对之下，DRAM 里面储存的数据需要周期性地 Refresh。然而，当电力供应停止（关机）时，储存的数据还是会消失，所以也称为 Volatile Memory（易失性存储器），这与在断电后仍能储存数据的 ROM 或闪存不同的。但是 SRAM 也有它的缺点，即它的集成度较低，功耗较 DRAM 大，相同容量的 DRAM 内存可以设计为较小的体积，但是 SRAM 却需要很大的体积。同样面积的硅片可以做出更大容量的 DRAM，因此 SRAM 显得更贵。<strong>常用于高速缓存</strong>。</p>
<table>
<thead>
<tr>
<th><strong>特点 \ 类型</strong></th>
<th><strong>SRAM</strong></th>
<th><strong>DRAM</strong></th>
</tr>
</thead>
<tbody><tr>
<td>存储信息</td>
<td>触发器</td>
<td>电容</td>
</tr>
<tr>
<td>破坏性读出</td>
<td>非</td>
<td>是</td>
</tr>
<tr>
<td>需要刷新</td>
<td>不要</td>
<td>需要</td>
</tr>
<tr>
<td>送行列地址</td>
<td>同时送</td>
<td>分两次送</td>
</tr>
<tr>
<td>运行速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>集成度</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>发热量（功耗）</td>
<td>大</td>
<td>小</td>
</tr>
<tr>
<td>存储成本</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>主要用途</td>
<td>高速缓存</td>
<td>主机内存</td>
</tr>
</tbody></table>
<h3 id="静态存储器结构"><a href="#静态存储器结构" class="headerlink" title="静态存储器结构"></a>静态存储器结构</h3><p>译码部分：</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191221204450394.png"></p>
<p>找到静态存储器中对应的存储单元。</p>
<p>总体：</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191221204615051.png"></p>
<h3 id="串行访问存储器（SAS）"><a href="#串行访问存储器（SAS）" class="headerlink" title="串行访问存储器（SAS）"></a>串行访问存储器（SAS）</h3><p>对存储单元进行 读&#x2F;写 操作时，需按其物理地址的先后顺序寻址，包括顺序存取存储器（如磁带，SAM）与直接存取存储器（如磁盘,DAM）。</p>
<h4 id="顺序存取存储器（SAM）"><a href="#顺序存取存储器（SAM）" class="headerlink" title="顺序存取存储器（SAM）"></a>顺序存取存储器（SAM）</h4><p>是完全的串行访问，顺序存取存储器的内容只能按照某种顺序存取，存取时间的长短与信息在存储体上的物理位置有关，其特点是存取速度缓慢。如：磁带，读写时要待磁带移动到合适位置之后才能顺序读写。由于价格便宜，主要用于数据备份容灾系统。</p>
<h4 id="直接存取存储器（DAM）"><a href="#直接存取存储器（DAM）" class="headerlink" title="直接存取存储器（DAM）"></a>直接存取存储器（DAM）</h4><p>是部分的串行访问，如：HHD 机械硬盘，对信息的存取有两步操作。首先，磁头直接移动到目标区域（磁道），然后再从磁道的合适位置开始读写，它介于顺序存取和随机存取之间。主要用于辅助存储器。</p>
<h3 id="只读存储器（ROM）"><a href="#只读存储器（ROM）" class="headerlink" title="只读存储器（ROM）"></a>只读存储器（ROM）</h3><p>存储器的内容只能随机读出而不能写入。信息一旦写入存储器就固定不变，即使断电，内容也不会丢失。因此，通常用它存放固定不变的程序、常数和汉字字库，甚至用于操作系统的固化。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。</p>
<p>由 ROM 派生出的存储器也包含可反复重写的类型，<strong>ROM 与 RAM 的存取方式均为随机存取</strong>。广义上的只读存储器已可已可通过电擦除等方式进行写入，其“只读”的概念没有保留，但仍然保留了断电内容保留、随机读取特性，但其写入速度比读取速度慢得多。</p>
<h4 id="掩膜式只读存储器（MROM）"><a href="#掩膜式只读存储器（MROM）" class="headerlink" title="掩膜式只读存储器（MROM）"></a>掩膜式只读存储器（MROM）</h4><p>MROM 写入后任何人无法改变其内容</p>
<h4 id="一次可编程只读存储器（PROM）"><a href="#一次可编程只读存储器（PROM）" class="headerlink" title="一次可编程只读存储器（PROM）"></a>一次可编程只读存储器（PROM）</h4><p>PROM 允许用户利用专门的设备（编程器）写入自己的程序，一旦写入，内容就无法改变。</p>
<h4 id="可擦除可编程只读存储器（EPROM）"><a href="#可擦除可编程只读存储器（EPROM）" class="headerlink" title="可擦除可编程只读存储器（EPROM）"></a>可擦除可编程只读存储器（EPROM）</h4><p>EPROM不仅可以由用户利用编程器写入信息，而且可以对其内容进行多次改写。需要修改 EPROM 内容时，先将其全部内容擦除，然后编程。</p>
<h4 id="闪速存储器（Flash-Memory）"><a href="#闪速存储器（Flash-Memory）" class="headerlink" title="闪速存储器（Flash Memory）"></a>闪速存储器（Flash Memory）</h4><h4 id="固态硬盘（Solid-State-Drives"><a href="#固态硬盘（Solid-State-Drives" class="headerlink" title="固态硬盘（Solid State Drives"></a>固态硬盘（Solid State Drives</h4><h2 id="按信息的可保存性分类"><a href="#按信息的可保存性分类" class="headerlink" title="按信息的可保存性分类"></a>按信息的可保存性分类</h2><p><strong>非永久记忆（易失性）的存储器</strong>：掉电后数据消失的存储器，如：<em>半导体读&#x2F;写存储器 RAM</em>。<br><strong>永久性记忆（非易失性）的存储器</strong>：掉电后仍能保存信息的存储器，如：<em>磁性材料做成的存储器以及半导体 ROM</em>。</p>
<p>若某个存储单元所存储的信息被读出时，原存储信息被破坏，则称为<u>破坏性读出</u>；若读出时，被读单元存储信息不被破坏，则称为非破坏性读出，具有破坏性读出的存储器，每次读出操作后，必须紧接一个再生的操作，以便恢复被破坏的信息。</p>
<h2 id="三层存储结构"><a href="#三层存储结构" class="headerlink" title="三层存储结构"></a>三层存储结构</h2><p>几个问题：</p>
<p>1、cpu速度慢：cpu访问的是主存，但是主存的速度慢于cpu的读取速度。导致cpu的速度慢。</p>
<p>2、主存容量不足</p>
<p>解决方法：</p>
<p>1、cache：解决cpu速度慢的问题（一般是集成在cpu上）</p>
<p>2、辅存解决主存容量小的问题</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191221202328281.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/1520534-20190831145558214-2105504734.png"></p>
<blockquote>
<p>存储系统层次结构主要体现在 “Cache - 主存” 层次和 “主存 - 辅存” 层次。前者主要解决 CPU 和主存速度不匹配的问题，后者主要解决存储系统容量的问题</p>
</blockquote>
<p><strong>主存和 Cache 之间的数据调动是由硬件自动完成的，对所有程序员均是透明的；而主存和辅存之间的数据调动则是由硬件和操作系统共同完成的，对应用程序员是透明的</strong>。</p>
<h3 id="主存储器：主存（又称内存）"><a href="#主存储器：主存（又称内存）" class="headerlink" title="主存储器：主存（又称内存）"></a>主存储器：主存（又称内存）</h3><p>用来存放计算机运行期间所需的大量程序和数据，<strong>CPU 可以直接随机地对其进行访问</strong>，也可以和告诉缓冲存储器（Cache）及辅助存储器交换数据，其特点是容量较小、存取速度较快、单位价格较高。</p>
<ul>
<li>半导体存储器、DRAM、非永久记忆存储器</li>
<li>特性：“可随机访问任意存储单元” 和 “掉电即失去数据”，这些特性均服务于冯诺依曼体系 “存储程序” 的核心理想。</li>
</ul>
<h3 id="辅助存储器：辅存"><a href="#辅助存储器：辅存" class="headerlink" title="辅助存储器：辅存"></a>辅助存储器：辅存</h3><p>又称外存储器（外存），是主存储器的后援存储器，用来存放当前暂时不用的程序和数据，以及一些需要永久性保存的信息，它不能与 CPU 直接交换信息。其特点是容量极大、存取速度较慢、单位成本低。</p>
<h3 id="高速缓冲存储器：cache"><a href="#高速缓冲存储器：cache" class="headerlink" title="高速缓冲存储器：cache"></a>高速缓冲存储器：cache</h3><p>位于主存和 CPU 之间，用来存放正在执行的程序段和数据，以便 CPU 能高速地使用它们。Cache 地存取速度可与 CPU 的速度匹配，但存储容量小、价格高。目前的高档计算机通常将它们制作在 CPU 中。</p>
<h2 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h2><p>存储器有 3 个主要性能指标，即存储容量、单位成本和存储速度。这 3 个指标相互制约，设计存储器系统所追求的目标就是大容量、低成本和高速度。</p>
<p>具体可见《王道》</p>
<h1 id="主存中的数据组织"><a href="#主存中的数据组织" class="headerlink" title="主存中的数据组织"></a>主存中的数据组织</h1><p>主存：随机访问存储器，包含读&#x2F;写存储空间和只读存储空间</p>
<p><strong>存储字长</strong>：主存的一个存储单元所包含的二进制位数。按照字节为单位。</p>
<h2 id="数据存储与边界的关系"><a href="#数据存储与边界的关系" class="headerlink" title="数据存储与边界的关系"></a>数据存储与边界的关系</h2><p>按边界对齐，方便访问和读取。但是会浪费空间。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191221202909440.png"></p>
<h2 id="大端和小端存储方式"><a href="#大端和小端存储方式" class="headerlink" title="大端和小端存储方式"></a>大端和小端存储方式</h2><p>大端：最高字节地址作为数据地址</p>
<p>小端：最低字节地址作为数据地址</p>
<p>大端模式更符合人的读写习惯，但是小端模式更符合计算机的处理。</p>
<h1 id="CPU和主存储器连接"><a href="#CPU和主存储器连接" class="headerlink" title="CPU和主存储器连接"></a>CPU和主存储器连接</h1><ul>
<li><p>连接由总线来支持：包括数据总线、地址总线和控制总线。</p>
</li>
<li><p>CPU 通过 AR（地址寄存器）&amp; AB（地址总线）、DR（数码寄存器）&amp; DB（数据总线）和主存进行数据传输。</p>
</li>
</ul>
<p>若 AR 为 K 位字长，表示 CPU 的寻址宽度，即允许主存包含有 2K 个可寻址存储单位；<br>若 DR 为 n 位字长，则表示在一个存储周期内，CPU 和主存之间通过总线进行 n 位数据传输。<br>控制总线包括控制数据传输的读（READ）、写（WRITE）和表示存储器功能完成的（READY）的三种控制线。</p>
<blockquote>
<p>cpu向内存写数据的时，相当于将数据写入内存地址中。数据的地址经过地址总线送给译码器，译码器的有效输出送给锁存单元的使能端，而cpu中寄存器数据通过数据总线送给锁存单元的输入端，实现数据存入内存。</p>
<p>cpu读内存数据时，相当于将内存地址中的数据读入cpu。数据的地址经过地址总线送给译码器，译码器的有效输出送给锁存单元的使能端，此时锁存单元将输出端数据送入数据总线，再通过数据总线送入cpu。</p>
<p>cpu与内存通过数据总线交换数据，数据总线是双向的。</p>
</blockquote>
<h2 id="CPU读取主存数据"><a href="#CPU读取主存数据" class="headerlink" title="CPU读取主存数据"></a>CPU读取主存数据</h2><p>当 CPU 从存储器读取一个存储字时，CPU 必须指定该存储字的地址，将该地址送到 AR 再经 AB 送到存储器，同时，CPU 通过控制线发送 READ 信号到存储器。此后，CPU 等到存储器通过控制线发来一个 READY 信号，表示已经完成了数据的读，并将数据经 DB 放到 DR 上了，CPU 再从 DR 取出相应的数据。以此来完成了一个存储器字的读与取。</p>
<h2 id="CPU存放数据到主存"><a href="#CPU存放数据到主存" class="headerlink" title="CPU存放数据到主存"></a>CPU存放数据到主存</h2><p>CPU 为了存放一个字到存储器，首先将存储字在存储器中的存放地址通过 AR 经 AB 发送到存储器，并将存储字放到 DR，同时发出一个 WRITE 信号到存储器。此后，CPU 等到接收 READY 信号。存储器会根据 AB 收到的地址来存放 DB 接收到的存储字，然后通过 READY 控制线发送 READY 信号给 CPU 接收。以此完成了一个存储字的存放。</p>
<p>可见，主存和 CPU 之间采用的是异步工作方式，以 READY 信号表示以此访存操作的结束。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/20200311152228285.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/20190708131719484.jpeg"></p>
<h2 id="存储扩展"><a href="#存储扩展" class="headerlink" title="存储扩展"></a>存储扩展</h2><p>CPU 的数据线数与存储芯片数据位数不一定相等，通常进行位扩展，用多个存储芯片对字长进行扩充，使数据位数与 CPU 的数据线数相等。可用的技术方法有位扩展法、子扩展法和字位同时扩展法。</p>
<p>分为字扩展和位扩展以及字位扩展。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191221211045477.png"></p>
<h3 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h3><p>地址线不变，但是数据线分成了四个部分。因为<strong>位表示的是字的深度，字的地址还是和没扩展前一样的。</strong></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191221211321650.png"></p>
<p><strong>仅采用位扩展时，各个芯片连接地址线的方式一样，而连接数据线的方式不一样，某一时刻选中所有芯片，所以片选信号线要连接到所有芯片。</strong></p>
<h3 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h3><p>由于位数没有发生变化，所以数据线是没有发生变化的。但是由于字的<strong>数量（厚度）</strong>增加了，所以地址线要增加。</p>
<p><em>片选信号是选择字扩展中的字的厚度中的那一层。</em></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191221211536092.png"></p>
<p>字扩展将存储芯片的地址线、数据线、读写控制线相应并联，而由片选信号来区分芯片的地址范围</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191221211551295.png"></p>
<p><strong>仅采用字扩展时，各个芯片连接地址线方式相同，连接数据线的方式也相同，但在某一时刻只需选中部分芯片，所以通过片选信号或采用译码器设计连接到相应的芯片。</strong></p>
<h3 id="字位扩展"><a href="#字位扩展" class="headerlink" title="字位扩展"></a>字位扩展</h3><p>字位同时扩展就是既增加存储字的数量，又增加存储字长。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222143433903.png"></p>
<p><strong>采用字位同时扩展时，各个芯片连接地址线的方式相同，但连接数据线的方式不同，而且需要通过片选信号或采用译码器设计连接到相应的芯片。</strong></p>
<h1 id="双端口-RAM-和多模块存储器"><a href="#双端口-RAM-和多模块存储器" class="headerlink" title="双端口 RAM 和多模块存储器"></a>双端口 RAM 和多模块存储器</h1><p>双端口 RAM 是指同一个存储器有左、右两个独立的端口，分别具有两组相互独立的地址线、数据线和控制线，允许两个独立的控制器同时异步地访问存储单元。当两个端口的地址不相同时，在两个端口上进行读写操作一定不会发生冲突。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/1520534-20190831193253926-1954121305.png"></p>
<p>两个端口同时存取存储器地同一地址单元时，会因数据冲突造成数据存储或读取错误。两个端口对同一主存操作有以下4 种情况：</p>
<ol>
<li>两个端口不同时对同一地址单元存取数据。</li>
<li>两个端口同时对同一地址单元读出数据。</li>
<li>两个端口同时对同一地址单元写入数据。</li>
<li>两个端口同时对同一地址单元操作，一个写入数据，另一个读出数据。</li>
</ol>
<p>其中，第 1 种和第 2 种情况不会出现错误；第 3 种情况会出现写入错误；第 4 种情况会出现读出错误。</p>
<h1 id="多体交叉存储器"><a href="#多体交叉存储器" class="headerlink" title="多体交叉存储器"></a>多体交叉存储器</h1><p>由多个存储模块构成。基本思想是：在不提高存储器效率、不扩展数据通路位数的前提下，通过存储芯片的交叉组织，提高CPU单位时间内访问的数据量，从而缓解快速的CPU与慢速的主存之间的速度差异。</p>
<p>分为高位和低位两种多体交叉存储器。</p>
<h2 id="高位多体交叉存储器"><a href="#高位多体交叉存储器" class="headerlink" title="高位多体交叉存储器"></a>高位多体交叉存储器</h2><p>可以看到的是，用<strong>高位段地址</strong>经过译码后产生片选信号，<strong>选择存储体</strong>。<strong>低位段地址</strong>直接选择一个存储体内的不同<strong>存储单元</strong>。</p>
<p><strong>特点</strong></p>
<ul>
<li><strong>相邻的地址在同一个存储体中</strong></li>
<li><strong>不同存储体的地址不相邻</strong></li>
</ul>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222144034180.png"></p>
<p><strong>问题</strong></p>
<p><strong>因为连续的地址在同一个存储体中，无法实现存储体并行工作</strong></p>
<h2 id="低位多体交叉存储器"><a href="#低位多体交叉存储器" class="headerlink" title="低位多体交叉存储器"></a>低位多体交叉存储器</h2><p>用<strong>低位段地址</strong>经过译码后产生片选信号，<strong>选择存储体</strong>。<strong>高位段地址</strong>直接选择一个存储体内的不同<strong>存储单元</strong>。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222145028079.png"></p>
<p><strong>存储流水线访问</strong></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222145353046.png"></p>
<p>其中：存储周期T&#x3D;0至W<del>0</del> 时间，表示的是存储体存入数据的时间。</p>
<p>连续并行读取时间是：0至W<del>0</del> +W<del>0</del>至W<del>1</del> （此时第一个存储体的数据读出） +W<del>1</del>至W<del>2</del> （此时第二个存储体的数据读出） +W<del>2</del>至W<del>3</del></p>
<h1 id="Cache的基本原理"><a href="#Cache的基本原理" class="headerlink" title="Cache的基本原理"></a>Cache的基本原理</h1><p>cache，中译名高速缓冲存储器，其作用是为了更好的利用局部性原理，减少CPU访问主存的次数。简单地说，CPU正在访问的指令和数据，其可能会被以后多次访问到，或者是该指令和数据附近的内存区域，也可能会被多次访问。因此，第一次访问这一块区域时，将其复制到cache中，以后访问该区域的指令或者数据时，就不用再从主存中取出。</p>
<blockquote>
<p>程序访问的局部性原理包括时间局部性和空间局部性。</p>
<ul>
<li>空间局部性：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是邻近的</li>
<li>时间局部性：在最近的未来要用到的信息，很可能是现在正在使用的信息</li>
</ul>
</blockquote>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222150221127.png"></p>
<p>主要分析的是CPU和主存之间的Cache</p>
<h3 id="cache的工作过程"><a href="#cache的工作过程" class="headerlink" title="cache的工作过程"></a>cache的工作过程</h3><p>Cache和主存都被分成若干大小相等的块（Cache块又称为Cache行），每块由若干字节组成，块的长度称为块长（Cache行长）。所以Cache中的块数要远少于主存中的块数，它仅保存主存中最活跃的若干块的副本。</p>
<p><strong>CPU与Cache之间的数据交换以字为单位，而Cache与主存之间的数据交换则以Cahce块为单位。</strong></p>
<ul>
<li><p>当CPU发出读请求时，若访存地址在Cache中<strong>命中</strong>，就将此地址转换成Cache地址<strong>，直接对Cahce进行读操作，与主存无关</strong>；若访存地址在Cache中<strong>未命中</strong>，<strong>则需访问主存</strong>，<strong>并把此字所在的块一次性地从主存调入Cache，若此时Cache已满，则需根据某种 替换算法，用这个块替换Cache中原来的某块信息。</strong></p>
<ul>
<li><p>Q：如何判断数据在Cache中？</p>
<p>​	A：使用相联存储器（注意，这里是在相联存储器中进行分析的，没有进入到cache块中）</p>
</li>
<li><p>Q：Cache中的数据是有效的吗？</p>
<p>​	A：使用cache块中的vaild</p>
</li>
</ul>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222151148417.png"></p>
</li>
<li><p>当CPU发出写请求时，若Cache命中，有可能会遇到Cache与主存中的内容不一致的问题，此时需要根据某种 <strong>写策略</strong> 解决这个问题。</p>
<ul>
<li><p>在写穿式Cache中，数据更新时，在写入缓存之后，立即也将数据写入内存，如果此时请求指定的地址没有对应的缓存，那么直接写入内存。所以每次操作总会执行：</p>
<p>​			  第一步，CPU将数据写入Cache；<br>　　	第二步，将Cache数据传送到Memory中相应的位置； </p>
</li>
<li><p>在写回式Cache中，数据更新时，在写入缓存之后，不会立即更新对应的内存，只有当该缓存被用于其他的内存数据（即数据被替换出缓存）时，被修改的缓存中的数据才会被覆盖式地写入到对应的内存中。</p>
<p>​				并不是每次执行步骤1后都执行步骤2操作。</p>
</li>
<li><p>Q：写回前，主存的数据是新的吗？（因为没有及时的写回主存中）</p>
<p>​		A：使用cache块中的dirty</p>
</li>
</ul>
</li>
</ul>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222151318537.png" alt="image-20191222151318537"></p>
<h3 id="cache的地址划分"><a href="#cache的地址划分" class="headerlink" title="cache的地址划分"></a>cache的地址划分</h3><p>因为cache是以块划分的，所以对主存地址，需要进行二次划分。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222152243021.png"></p>
<p>为了解决上述的三个问题，cache的结构需要进行相应的改变。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222152556327.png" alt="cache的结构"></p>
<p>CPU将地址置入相联存储器中，如果数据在cache中，去cache中对应的地址查找，如果不再就直接对主存进行访问。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222152817373.png"></p>
<h2 id="相联存储器"><a href="#相联存储器" class="headerlink" title="相联存储器"></a>相联存储器</h2><p>作用：判断CPU要访问的内容是否在Cache中，在的话，会给出相应内容在cache中的地址。</p>
<p>存放查找表  (独立硬件，不在缓存中)<br>存储容量 &#x3D; 查找表容量 &#x3D; cache块数 * 表项大小<br>cache中用于存放<strong>块表</strong>，虚拟存储器中存放<strong>段表、页表</strong><br>（valid,      Key，               Value ）<br> ( 有效位,  主存块地址 ， Cache块地址）  注：value不一定是必要的</p>
<p>CPU给出的块地址与查找表中某单元相同且有效位为1表示<strong>命中</strong></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222205525474.png"></p>
<p><strong>步骤</strong>(对应的是系统的读过程)</p>
<ul>
<li><p>CPU给出主存地址（块地址，块内地址）</p>
</li>
<li><p>主存<strong>块地址</strong>为<strong>关键字</strong>查找相联存储器中的查找表</p>
</li>
<li><p>如相符表示<strong>副本</strong>在cache中，命中，访问cache</p>
</li>
<li><p>否则数据缺失，访问主存</p>
<ul>
<li><p>将数据所在块副本调入cache（块交换—局部性）</p>
</li>
<li><p>载入副本过程可能引起替换</p>
</li>
<li><p>更新查找表，记录当前数据块地址</p>
</li>
<li><p>cache缺失时系统等待数据调入</p>
</li>
</ul>
</li>
</ul>
<p><strong>基本结构如下</strong></p>
<p>检索寄存器从地址中剥离Key</p>
<p>当明确查找的在Cache中时，符合寄存器会记录要查找的地址的位置</p>
<p><strong>此处的存储体就是cache中的标记存储体</strong></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222203715046.png"></p>
<p>由下图可以看到：key包含了tag和offset。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222204443669.png"></p>
<h2 id="cache地址映射和变换方法"><a href="#cache地址映射和变换方法" class="headerlink" title="cache地址映射和变换方法"></a>cache地址映射和变换方法</h2><p>这里的地址映射是指：主存空间映射到cache的地址空间。</p>
<p>在使用相联存储器得知数据在cache中后，接下来需要得知主存数据如何放置到cache行中。此外，cache满后应该如何处理？如何实现保持cache和主存的一致性？</p>
<h3 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h3><p><strong>只有一个组，就是全相联。</strong>不用hash来确定组，<strong>直接挨个比对高位地址，来确定是否命中</strong>。可以想见这种方式不适合大的缓存。想想看，如果4M 的大缓存　linesize为32Byte，采用全相联的话，就意味着4<em>1024</em>1024&#x2F;32 &#x3D; 128K 个line挨个比较，来确定是否命中，这是多要命的事情。高速缓存立马成了低速缓存了。</p>
<p><strong>映射算法：主存的数据块可映射到cache任意行</strong>同时将该数据块地址对应的标记存储体中保存。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222212547429.png"></p>
<p>主存地址&#x3D;块地址（标记）+块内地址（字）</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222214501924.png"></p>
<p>因为只有一组，cache中的所有行标记会全部送入相联存储器中进行比较。如果命中的话，从cache中剥离出具体要访问的那个字。反之，会根据cpu给出的原始地址再次访问主存。</p>
<h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p>每个组只有一个line，选中组之后不需要和组中的每个line比对，因为只有一个line。这样导致了cache的利用率低，块内冲突率高，但是淘汰算法（后来的赶走之前的）简单，适合大容量cache。</p>
<p><strong>映射算法：cache共n行，主存第j快映射到cache行号为i&#x3D;jmod (n)即映射到特定行</strong></p>
<p>主存调入cache中的位置由行地址决定。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222214438924.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222214717465.png"></p>
<p>先看索引，取出对应的标识放入相联存储器中比较。命中与否的结果与上述相同。可以很明显的看出比较的内容变少了。</p>
<h3 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h3><p>cache分成多个组，每个组分成多个行。所谓8路组相连（ 8-way set associative）的含义是指，每个组里面有8个行。</p>
<p>cache分组（每组包含的行数相同），主存以cache分组标准将块分组（两者数量相同）</p>
<p><strong>映射算法：cache共n组，主存第j块号映射到cache的组号是i&#x3D;jmod（n）。即主存的数据块映射到cache特定组的任意行</strong></p>
<blockquote>
<p>我们知道，cache的容量要远远小于主存，主存和cache肯定不是一一对应的，那么主存中的地址和cache的映射关系是怎样的呢？</p>
<p>拿到一个地址，首先是映射到一个组里面去。如何映射？取内存地址的中间几位来映射。</p>
<p>举例来说，data cache: 32-KB, 8-way set associative, 64-byte line size</p>
<p>Cache总大小为32KB，8路组相连（每组有8个line），每个line的大小linesize为64Byte,OK，我们可以很轻易的算出一共有32K&#x2F;8&#x2F;64&#x3D;64 个组。</p>
<p>对于32位的内存地址，每个line有2^6 &#x3D; 64Byte，所以地址的【0，5】区分line中的那个字节。一共有64个组。我们取内存地址中间6为来hash查找地址属于那个组。即内存地址的【6，11】位来确定属于64组的哪一个组。组确定了之后，【12，31】的内存地址与组中8个line挨个比对，如果【12，31】为与某个line一致，并且这个line为有效，那么缓存命中。</p>
</blockquote>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222222824337.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222222921836.png"></p>
<p>先看索引，取出索引组的全部行对应的标识放入相联存储器中比较。命中与否的结果与上述相同。</p>
<h2 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h2><p>cache存储空间被占满后需要替换数据块。</p>
<p><strong>直接映射是不需要替换算法的。全相联映射替换算法适用于全部行。组相联映射替换算法适用组内全部行</strong></p>
<p>① 先进先出算法(FIFO)</p>
<p>基本思想：按照数据块进入Cache的先后决定替换的顺序，即在需要进行替换时，选择最先</p>
<p>​     被调入Cache中的块作为替换块。这种方法要求为每块记录它们进入Cache的先</p>
<p>​     后次序。</p>
<p>优点：FIFO算法系统开销较小。</p>
<p>缺点：是不考虑程序访问的局部性，可能会把一些需要经常使用的块（如循环程序块）也作</p>
<p>   为最早进入Cache的块而替换掉，因此，可能导致Cache的命中率不高。</p>
<p>② 近期最少使用(LRU)算法</p>
<p>基本思想：将近期内长久未被访问过的行换出。为此，每行设置一个计数器，cache每命中一次，命中行计数器清零，其它各行计数器增1，因此它是未访问次数计数器。当需要替换时，比较各特定行的计数值，将计数值最大的行换出。</p>
<p>优点：这种算法显然保护了刚调入Cache的新数据，符合cache工作原理，因而使cache有较高</p>
<p>   的命中率。LRU算法硬件实现简单</p>
<p>③ 最不经常使用(LFU)算法</p>
<p>基本思想：将一段时间内被访次数最少的那行数据换出。为此，每行设置一个计数器，新新</p>
<p>​     调入行的数据从0开始计数，每访问一次被访行的计数器增1。当需要替换时，对</p>
<p>​     这些特定行的计数值进行比较，将计数值最小的行换出。</p>
<p>缺点：一段期间访问情况不能严格反映近期访问情况。例如特定行中的A、B两行，A行在期间的前期多次被访问而后期未被访问，但累积计数值很大，B行是前期不常用而后期却正被频繁访问，但可能由于累积计数小于A行而被LFU算法换出了。</p>
<p>④ 随机替换算法</p>
<p>基本思想：需要进行替换时，从特定的行位置中随机地选取一行进行替换。</p>
<p>优点：硬件实现最容易，而且速度也比前几种策略快。</p>
<p>缺点：随意换出的数据很可能马上又要用，从而降低命中率和cache工作效率。但这个负面效应随着cache容量增大会减少，模拟研究表明随机替换策略的功效只是稍逊于LFU和LRU。</p>
<h3 id="随机替换法"><a href="#随机替换法" class="headerlink" title="随机替换法"></a>随机替换法</h3><h3 id="替换算法的抖动"><a href="#替换算法的抖动" class="headerlink" title="替换算法的抖动"></a>替换算法的抖动</h3><p>调出去的那块就是即将访问的那块数据。</p>
<p>要避免抖动，需要在程序行为上避免。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222224652504.png"></p>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><p>解决了程序大小大于内存的限制问题</p>
<p>虚拟存储器处于“主存-辅存”存储层次。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222225312099.png"></p>
<ul>
<li><strong>辅存—–逻辑地址</strong></li>
<li><strong>主存—–物理地址</strong></li>
</ul>
<h3 id="页式虚拟存储器"><a href="#页式虚拟存储器" class="headerlink" title="页式虚拟存储器"></a>页式虚拟存储器</h3><p>采用页表判断cpu访问的内容是否在主存，如果在辅存，则调用其内容到主存中。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222225546137.png"></p>
<p>转换：</p>
<p>MMU用于指出页表在内存中的位置，通过与VPN结合就能访问到页表中与虚拟页号VPN相对应的物理页号PPN。实现虚拟地址到物理地址的转换。</p>
<blockquote>
<p>页表常驻在内存中。保存有虚拟页号和物理页号的对应关系。</p>
<p>进程开始要访问一个地址，它可能会经历下面的过程</p>
<p>1、每次我要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址<br>2、所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上<br>3、进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过页表来记录<br>4、页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）<br>5、当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常<br>6、缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。</p>
<p>当每个进程创建的时候，内核会为进程分配4G的<strong>虚拟内存</strong>，当进程还没有开始运行时，这只是一个内存布局。<strong>实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射）。这个时候数据和代码还是在磁盘上的。当运行到对应的程序时，进程（拿着虚拟地址）去寻找页表，发现页表中地址没有存放在物理内存上，而是在磁盘上，于是发生缺页异常，于是将磁盘上的数据拷贝到物理内存中。</strong></p>
<p>另外在进程运行过程中，要通过malloc来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p>
<p>可以认为虚拟空间都被映射到了磁盘空间中（事实上也是按需要映射到磁盘空间上，通过mmap，mmap是用来建立虚拟空间和磁盘空间的映射关系的）</p>
</blockquote>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222225706372.png"></p>
<h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><p>虚实地址转换过程中存在的问题：</p>
<p>两次访问主存：第一次拿页表项判断是否在主存中，第二次得到数据。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222235123905.png"></p>
<p>5，6步骤是为了替换主存中的对应物理地址的内容。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191223112011182.png"></p>
<p>为了减少访问主存的次数。设置TLB，不去主存拿页表。故TLB能节省一次CPU访问主存的次数。</p>
<p>于是TLB设计成页表映像的一部分。</p>
<p>1、CPU拿着虚拟地址访问MMU（为了将虚拟地址中剥离出的虚页号与MMU中的页表基址寄存器结合得到物理内存地址）</p>
<p>2、MMU拿着虚页号VPN访问TLB</p>
<blockquote>
<p>首先，先去TLB中根据标志Tag寻找，假如找到了并且有效位是1，说明TLB命中了，那么直接就可以从TLB中获取该虚拟页号对应的物理页号。假如有效位是0，说明该页不在内存中，这时候就发生缺页异常，CPU需要先去外存中将<strong>该页调入内存并将页表和TLB更新。</strong></p>
<p>  假如<strong>在TLB中没有找到，那么就去页表（Page Table）中寻找（以虚拟页号为索引）</strong>，假如找到了并且有效位是1，那么就可以取出对应的物理页号。假如有效位是0，说明该页不在内存中，这时候就发生缺页异常，<strong>CPU需要先去外存中将该页调入内存并将页表和TLB更新。</strong></p>
<p>  假如在页表中没有找到，也是缺页。同意会执行上述的缺页处理。</p>
<p>  （不管从哪获取到物理页号，都可以根据规则组拼成实际物理地址，然后就可以访存去数据啦）</p>
</blockquote>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191222235644799.png"></p>
<p>此处TLB tag是因为TLB只是页表的一个子集，不能全部遍历页表中的每一项。所以要增加tag判断与虚页对应的物理页是否存在。（具体见上面的引用部分）</p>
<h3 id="段式虚拟存储器"><a href="#段式虚拟存储器" class="headerlink" title="段式虚拟存储器"></a>段式虚拟存储器</h3><p>以段为单位。一般将主存空间按照实际运行程序中的段来划分。由此 段可大可小。</p>
<p>段的独立性—易于编译、管理、修改和维护，也便于多道程序共享</p>
<p>各段的长度不同，给主存的分配带来麻烦</p>
<p>段式管理容易产生碎块，浪费主存空间</p>
<h3 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h3><p>程序按模块分段</p>
<p>段再分成长度固定的页。</p>
<p>程序调入调出按页面来进行</p>
<p>程序共享保护按段进行</p>
<p>兼备段式，页式管理的优点</p>
<p>在地址映像中需要多次查表</p>
<h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><p>核心技术：将数据条带化后的存放在不同磁盘上，通过多磁盘的并行操作提高磁盘系统的读写速率。使用基于异或运算为基础的校验技术恢复损坏的数据</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191223112352878.png"></p>
<p>最左边的盘就是冗余盘。是用于备份的。</p>
<h3 id="RAID0"><a href="#RAID0" class="headerlink" title="RAID0"></a>RAID0</h3><p>数据以条带方式均匀分散在各磁盘上。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191223112559304.png"></p>
<p>没有冗余，没有校验技术，任一磁盘坏了就GG。</p>
<h3 id="RAID1"><a href="#RAID1" class="headerlink" title="RAID1"></a>RAID1</h3><p>数据采用镜像的冗余方式，同一个数据有多份拷贝</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191223112953043.png"></p>
<h3 id="RAID3-x2F-4"><a href="#RAID3-x2F-4" class="headerlink" title="RAID3&#x2F;4"></a>RAID3&#x2F;4</h3><p>专用校验盘。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191223113009663.png"></p>
<h3 id="RAID5"><a href="#RAID5" class="headerlink" title="RAID5"></a>RAID5</h3><p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191223113521894.png"></p>
<h3 id="RAID10"><a href="#RAID10" class="headerlink" title="RAID10"></a>RAID10</h3><p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191223113548311.png"></p>
<h3 id="RAID01"><a href="#RAID01" class="headerlink" title="RAID01"></a>RAID01</h3><p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191223113601613.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20191223113627560.png"></p>
<h1 id="一些习题"><a href="#一些习题" class="headerlink" title="一些习题"></a>一些习题</h1><p>![](&#x2F;images&#x2F;组成原理-存储系统&#x2F;FireShot Capture 015 - [图文]计算机系统结构习题课()-万继光 - 百度文库 - wenku.baidu.com.png)</p>
<p>![](&#x2F;images&#x2F;组成原理-存储系统&#x2F;FireShot Capture 020 - [图文]计算机系统结构习题课()-万继光 - 百度文库 - wenku.baidu.com-1595315230835.png)![](&#x2F;images&#x2F;组成原理-存储系统&#x2F;FireShot Capture 011 - [图文]计算机系统结构习题课()-万继光 - 百度文库 - wenku.baidu.com.png)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2022/05/19/javaSpring%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94SpringBean/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/19/javaSpring%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94SpringBean/" class="post-title-link" itemprop="url">javaSpring学习（三）——SpringBean</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-19 10:14:13" itemprop="dateCreated datePublished" datetime="2022-05-19T10:14:13Z">2022-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-Bean简介"><a href="#Spring-Bean简介" class="headerlink" title="Spring Bean简介"></a>Spring Bean简介</h1><p>简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。</p>
<p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Constructor-arg with &#x27;value&#x27; attribute --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下图简单地展示了 IoC 容器如何使用配置元数据来管理对象。</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205171109826.png"></p>
<p><code>org.springframework.beans</code>和 <code>org.springframework.context</code> 这两个包是 IoC 实现的基础。</p>
<h1 id="一、bean与spring容器的关系"><a href="#一、bean与spring容器的关系" class="headerlink" title="一、bean与spring容器的关系"></a>一、bean与spring容器的关系</h1><p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205171109835.webp" alt="img"></p>
<p>Bean配置信息定义了Bean的实现及依赖关系，Spring容器根据各种形式的Bean配置信息在容器内部建立Bean定义注册表，然后根据注册表加载、实例化Bean，并建立Bean和Bean的依赖关系，最后将这些准备就绪的Bean放到Bean缓存池中，以供外层的应用程序进行调用。</p>
<h1 id="二、Spring注解"><a href="#二、Spring注解" class="headerlink" title="二、Spring注解"></a>二、Spring注解</h1><p>从广义上Spring注解可以分为两类：</p>
<p><strong>一类注解是用于注册Bean</strong>：即是把已经在xml文件中配置好的Bean拿来用，完成属性、方法的组装；比如@Autowired , @Resource，可以通过byTYPE（@Autowired）、byNAME（@Resource）的方式获取Bean；</p>
<blockquote>
<p> 假如IOC容器就是一间空屋子，首先这间空屋子啥都没有，我们要吃大餐，我们就要从外部搬运食材和餐具进来。这里把某一样食材或者某一样餐具搬进空屋子的操作就相当于每个注册Bean的注解作用类似。注册Bean的注解作用就是往IOC容器中放（注册）东西！ 用于注册Bean的注解： 比如@Component , @Repository , @ Controller , @Service , @Configration这些注解就是用于注册Bean，放进IOC容器中，一来交给spring管理方便解耦，二来还可以进行二次使用，啥是二次使用呢？这里的二次使用可以理解为：在你开始从外部搬运食材和餐具进空屋子的时候，一次性搬运了猪肉、羊肉、铁勺、筷子四样东西，这个时候你要开始吃大餐，首先你吃东西的时候肯定要用筷子或者铁勺，别说你手抓，只要你需要，你就会去找，这个时候发现你已经把筷子或者铁勺放进了屋子，你就不用再去外部拿筷子进屋子了，意思就是IOC容器中已经存在，就可以只要拿去用，而不必再去注册！而拿屋子里已有的东西的操作就是下面要讲的用于使用Bean的注解！</p>
</blockquote>
<p><strong>一类注解是用于使用Bean</strong>：@Component , @Repository , @ Controller , @Service , @Configration这些注解都是把你要实例化的对象转化成一个Bean，放在IoC容器中，等你要用的时候，它会和上面的@Autowired , @Resource配合到一起，把对象、属性、方法完美组装。</p>
<blockquote>
<p> 用于使用Bean的注解：比如@Autowired , @Resource注解，这些注解就是把屋子里的东西自己拿来用，如果你要拿，前提一定是屋子（IOC）里有的，不然就会报错，比如你要做一道牛肉拼盘需要五头牛做原材料才行，你现在锅里只有四头牛，这个时候你知道，自己往屋子里搬过五头牛，这个时候就直接把屋子里的那头牛直接放进锅里，完成牛肉拼盘的组装。是的这些注解就是需要啥想要啥，只要容器中有就往容器中拿！而这些注解又有各自的区别，比如@Autowired用在筷子上，这筷子你可能只想用木质的，或许只想用铁质的，@Autowired作用在什么属性的筷子就那什么筷子，而@Resource如果用在安格斯牛肉上面，就指定要名字就是安格斯牛肉的牛肉。</p>
</blockquote>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h1 id="三、bean的配置方式"><a href="#三、bean的配置方式" class="headerlink" title="三、bean的配置方式"></a>三、bean的配置方式</h1><p>bean配置有三种方法：</p>
<ul>
<li>基于xml配置Bean</li>
<li>使用注解定义Bean</li>
<li>基于java类提供Bean定义信息</li>
</ul>
<h2 id="1、传统XML配置方式"><a href="#1、传统XML配置方式" class="headerlink" title="1、传统XML配置方式"></a>1、传统XML配置方式</h2><p>直接填写 bean标签属性和子标签，根据构造函数实现，可能还会有ref引用其他bean，或者基本属性，集合属性等等</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 默认命名空间 --&gt;</span></span><br><span class="line"> xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">	 <span class="comment">&lt;!--xsi标准命名空间，用于指定自定义命题空间的schema文件--&gt;</span></span><br><span class="line"> xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">     <span class="comment">&lt;!--自定义命名空间aop----名称空间全称，必须在xsi命名空间为其指定空间对应的schema文件，参见下注释--&gt;</span></span><br><span class="line"> xmlns:aop=&quot;http://www.spingframework.org/schema/aop&quot;</span><br><span class="line">    <span class="comment">&lt;!--为每个命名空间指定具体的schema文件--&gt;</span></span><br><span class="line"> xsi:schemaLocation=</span><br><span class="line">    &quot;http://www.springframework.org/schema/beans </span><br><span class="line"> 	http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span><br><span class="line">    http://www.springframework.org/schema/aop</span><br><span class="line"> 	http://www.springframework.org/schema/aop/spring-aop-3.0.xsd</span><br><span class="line">   &quot;&gt;</span><br><span class="line">     <span class="comment">&lt;!-- 默认命名空间的配置--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>,<span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- aop命名空间的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建对象时，默认执行无参构造函数创建对象。</p>
<ul>
<li>默认命名空间：</li>
<li>它没有空间名，用于Spring Bean的定义；</li>
<li>xsi命名空间：这个命名空间用于为每个文档中命名空间指定相应的Schema样式文件，是标准组织定义的标准命名空间；</li>
<li>aop命名空间：这个命名空间是Spring配置AOP的命名空间，是用户自定义的命名空间。</li>
</ul>
<p>命名空间的定义分为两个步骤：第一步指定命名空间的名称；第二步指定命名空间的Schema文档样式文件的位置，用空格或回车换行进行分分隔。</p>
<h2 id="2、Bean基本配置"><a href="#2、Bean基本配置" class="headerlink" title="2、Bean基本配置"></a>2、Bean基本配置</h2><p>在Spring容器的配置文件中定义一个简要Bean的配置片段如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一般情况下，Spring IOC容器中的一个Bean即对应配置文件中的一个&lt;bean&gt;,这种镜像对应关系应该容易理解。</p>
<ul>
<li>id为这个Bean的名称，通过容器的getBean(“foo”)即可获取对应的Bean，在容器中起到定位查找的作用，是外部程序和Spring IOC容器进行交互的桥梁。</li>
<li>class属性指定了Bean对应的实现类。</li>
</ul>
<h2 id="3、依赖注入"><a href="#3、依赖注入" class="headerlink" title="3、依赖注入"></a>3、依赖注入</h2><ol>
<li>属性注入</li>
<li>构造函数注入</li>
<li>工厂方式注入</li>
</ol>
<h3 id="使用注解定义bean——-Component"><a href="#使用注解定义bean——-Component" class="headerlink" title="使用注解定义bean——@Component"></a>使用注解定义bean——@Component</h3><p>Spring容器成功启动的三大要件分别是：Bean定义信息、Bean实现类以及Spring本身。如果采用基于XML的配置，Bean定义信息和Bean实现类本身是分离的，而采用基于注解的配置方式时，Bean定义信息即通过在Bean实现类上标注注解实现。</p>
<p>下面是使用注解定义一个DAO的Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baobaotao.anno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"><span class="comment">//（1）通过Repository定义一个DAO的Bean</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在（1）处，我们使用<code>@Component</code>注解在UserDao类声明处对类进行标注，它可以被Spring容器识别，Spring容器自动将POJO转换为容器管理的Bean。</p>
<p>它和以下的XML配置是等效的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baobaotao.anno.UserDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>除了<code>@Component</code>以外，Spring提供了3个功能基本和@Component等效的注解，它们分别用于对DAO、Service及Web层的Controller进行注解，所以也称这些注解为Bean的衍型注解：（类似于xml文件中定义Bean&lt;bean id&#x3D;” “ class&#x3D;” “&#x2F;&gt;</p>
<ul>
<li><code>@Repository</code>：用于对DAO实现类进行标注；&#x3D;&#x3D;&gt; Dao层</li>
<li><code>@Service</code>：用于对Service实现类进行标注；&#x3D;&#x3D;&gt;业务逻辑层</li>
<li><code>@Controller</code>：用于对Controller实现类进行标注；&#x3D;&#x3D;&gt;web控制层</li>
</ul>
<p>之所以要在@Component之外提供这三个特殊的注解，是为了让注解类本身的用途清晰化，此外Spring将赋予它们一些特殊的功能。</p>
<h4 id="使用注解配置信息启动spring容器"><a href="#使用注解配置信息启动spring容器" class="headerlink" title="使用注解配置信息启动spring容器"></a>使用注解配置信息启动spring容器</h4><p>Spring提供了一个context的命名空间，它提供了通过扫描类包以应用注解定义Bean的方式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--①声明context的命名空间--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">         http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">         http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">         http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         &gt;</span></span><br><span class="line">    <span class="comment">&lt;!--②扫描类包以应用注解定义的Bean--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.baobaotao.anno&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.baobaotao.anno.LogonService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- context:component-scan base-package=&quot;com.baobaotao&quot; resource-pattern=&quot;anno/*.class&quot;/ --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- context:component-scan base-package=&quot;com.baobaotao&quot;&gt;</span></span><br><span class="line"><span class="comment">       &lt;context:include-filter type=&quot;regex&quot; expression=&quot;com\.baobaotao\.anno.*Dao&quot;/&gt;</span></span><br><span class="line"><span class="comment">       &lt;context:include-filter type=&quot;regex&quot; expression=&quot;com\.baobaotao\.anno.*Service&quot;/&gt;</span></span><br><span class="line"><span class="comment">       &lt;context:exclude-filter type=&quot;aspectj&quot; expression=&quot;com.baobaotao..*Controller+&quot;/&gt;</span></span><br><span class="line"><span class="comment">   &lt;/context:component-scan --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在①处声明context命名空间，在②处即可通过context命名空间的component-scan的base-package属性指定一个需要扫描的基类包，Spring容器将会扫描这个基类包里的所有类，并从类的注解信息中获取Bean的定义信息。</p>
<p>如果仅希望扫描特定的类而非基包下的所有类，你们可以使用resource-pattern属性过滤特定的类，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; context:component-scan base-package=&quot;com.baobaotao&quot; resource-pattern=&quot;anno/*.class&quot;/ &gt;</span><br></pre></td></tr></table></figure>

<p>这里我们将基类包设置为com.baobaotao，默认情况下resource-pattern属性的值为”**&#x2F;<em>.class”，即基类包里的所有类。这里我们设置为”anno&#x2F;</em>.class”,则Spring仅会扫描基包里anno子包中的类。</p>
<h2 id="4、基于java类提供Bean定义——-Configuration"><a href="#4、基于java类提供Bean定义——-Configuration" class="headerlink" title="4、基于java类提供Bean定义——@Configuration"></a>4、基于java类提供Bean定义——@Configuration</h2><p>在普通的POJO类中只要标注@Configuration注解，就可以为spring容器提供Bean定义的信息了，每个标注了@Bean的类方法都相当于提供了一个Bean的定义信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baobaotao.conf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="comment">//①将一个POJO标注为定义Bean的配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConf</span> &#123;</span><br><span class="line">        <span class="comment">//②以下两个方法定义了两个Bean，以提供了Bean的实例化逻辑</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">userDao</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LogDao <span class="title function_">logDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogDao</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//③定义了logonService的Bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LogonService <span class="title function_">logonService</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LogonService</span> <span class="variable">logonService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogonService</span>();</span><br><span class="line">                <span class="comment">//④将②和③处定义的Bean注入到LogonService Bean中</span></span><br><span class="line">        logonService.setLogDao(logDao());</span><br><span class="line">        logonService.setUserDao(userDao());</span><br><span class="line">        <span class="keyword">return</span> logonService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>①处在APPConf类的定义处标注了@Configuration注解，说明这个类可用于为Spring提供Bean的定义信息。类的方法处可以标注@Bean注解，Bean的类型由方法返回值类型决定，名称默认和方法名相同，也可以通过入参显示指定Bean名称，如@Bean(name&#x3D;”userDao”).直接在@Bean所标注的方法中提供Bean的实例化逻辑。</p>
<p>在②处userDao()和logDao()方法定义了一个UserDao和一个LogDao的Bean，它们的Bean名称分别是userDao和logDao。在③处，又定义了一个logonService Bean，并且在④处注入②处所定义的两个Bean。</p>
<p>因此，以上的配置和以下XML配置时等效的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baobaotao.anno.UserDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baobaotao.anno.LogDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baobaotao.conf.LogonService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">p:logDao-ref</span>=<span class="string">&quot;logDao&quot;</span> <span class="attr">p:userDao-ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>基于java类的配置方式和基于XML或基于注解的配置方式相比，前者通过代码的方式更加灵活地实现了Bean的实例化及Bean之间的装配，但后面两者都是通过配置声明的方式，在灵活性上要稍逊一些，但是配置上要更简单一些。</p>
<h2 id="5、-Component-和-Bean-的区别是什么？"><a href="#5、-Component-和-Bean-的区别是什么？" class="headerlink" title="5、@Component 和 @Bean 的区别是什么？"></a>5、@Component 和 @Bean 的区别是什么？</h2><ul>
<li><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li>
<li><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li>
</ul>
<p><code>@Bean</code>注解使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码相当于下面的 xml 配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transferService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面这个例子是通过 <code>@Component</code> 无法实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> OneService <span class="title function_">getService</span><span class="params">(status)</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> (status)  &#123;</span><br><span class="line">        when <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl1</span>();</span><br><span class="line">        when <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl2</span>();</span><br><span class="line">        when <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、Bean注入"><a href="#四、Bean注入" class="headerlink" title="四、Bean注入"></a>四、Bean注入</h1><p>Bean注入的方式有两种，一种是在XML中配置，此时分别有属性注入、构造函数注入和工厂方法注入；另一种则是使用注解的方式注入 @Autowired,@Resource,@Required。</p>
<h2 id="1、在xml文件中配置依赖注入"><a href="#1、在xml文件中配置依赖注入" class="headerlink" title="1、在xml文件中配置依赖注入"></a>1、在xml文件中配置依赖注入</h2><h3 id="a-属性注入"><a href="#a-属性注入" class="headerlink" title="a.属性注入"></a>a.属性注入</h3><p>属性注入即通过setXxx()方法注入Bean的属性值或依赖对象，由于属性注入方式具有可选择性和灵活性高的优点，因此属性注入是实际应用中最常采用的注入方式。</p>
<p>属性注入要求Bean提供一个默认的构造函数，并为需要注入的属性提供对应的Setter方法。Spring先调用Bean的默认构造函数实例化Bean对象，然后通过反射的方式调用Setter方法注入属性值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baobaotao.anno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogonService</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LogDao logDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLogDao</span><span class="params">(LogDao logDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.logDao = logDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> LogDao <span class="title function_">getLogDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> logDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getUserDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;beanName:&quot;</span>+beanName);        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;initMethod1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;initMethod2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bean.xml配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">         http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">         http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">         http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-autowire</span>=<span class="string">&quot;byName&quot;</span></span></span><br><span class="line"><span class="tag">         &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baobaotao.anno.LogDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baobaotao.anno.UserDao&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.baobaotao.anno.LogonService&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 控制器调用setLogDao方法，将容器中的LogDao bean作为传入的参数 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--此处的name是决定LogonService类中的那个参数，ref是指bean配置文件中的bean名称--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;logDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;logDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ref引用一个已经存在的对象</li>
<li>property:是通过setter方法注入</li>
</ul>
<h3 id="b-构造方法注入"><a href="#b-构造方法注入" class="headerlink" title="b.构造方法注入"></a>b.构造方法注入</h3><p>使用构造函数注入的前提是Bean必须提供带参数的构造函数。例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baobaotao.anno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogonService</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LogonService</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LogonService</span><span class="params">(LogDao logDao, UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.logDao = logDao;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LogDao logDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLogDao</span><span class="params">(LogDao logDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.logDao = logDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> LogDao <span class="title function_">getLogDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> logDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getUserDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;beanName:&quot;</span>+beanName);        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;initMethod1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;initMethod2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bean.xml配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">         http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">         http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">         http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baobaotao.anno.LogDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baobaotao.anno.UserDao&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.baobaotao.anno.LogonService&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span>  <span class="attr">ref</span>=<span class="string">&quot;logDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>constructor-arg:通过构造方法注入</li>
</ul>
<h4 id="constructor-arg标签属性："><a href="#constructor-arg标签属性：" class="headerlink" title="constructor-arg标签属性："></a>constructor-arg标签属性：</h4><ul>
<li>name属性：通过参数名找到参数列表中对应参数</li>
<li>index属性：通过参数在参数列表中的索引找到参数列表中对应参数，index从0开始：</li>
<li>type属性：通过参数数据类型找到参数列表中对应参数</li>
<li>value属性：设置参数列表参数对应的值，用于设定基本数据类型和String类型的数据</li>
<li>ref属性：如果参数值为非基本数据类型，则可通过ref为参数注入值，其值为另一个bean标签id或name属性的属性值</li>
</ul>
<h4 id="constructor-arg子标签："><a href="#constructor-arg子标签：" class="headerlink" title="constructor-arg子标签："></a>constructor-arg子标签：</h4><ul>
<li>ref子标签：对应ref属性，该标签name属性的属性值为另一个bean标签id或name属性的属性值；</li>
<li>value子标签：对应value属性,用于设置基本数据类型或String类型的参数值；</li>
<li>list子标签：为数组或List类型的参数赋值</li>
<li>set子标签：为Set集合类型参数赋值</li>
<li>map子标签：为Map集合类型参数赋值</li>
<li>props子标签：为Properties类型的参数赋值</li>
</ul>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://www.csdn.net/tags/NtzaUgxsNDQ1MTItYmxvZwO0O0OO0O0O.html">constructor-arg ref - CSDN</a></p>
<h3 id="c-工厂方法注入"><a href="#c-工厂方法注入" class="headerlink" title="c.工厂方法注入"></a>c.工厂方法注入</h3><p>非静态工厂方法：</p>
<p>有些工厂方法是非静态的，即必须实例化工厂类后才能调用工厂放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baobaotao.ditype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> Car <span class="title function_">createHongQiCar</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">       car.setBrand(<span class="string">&quot;红旗CA72&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> car;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title function_">createCar</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">       <span class="keyword">return</span> car;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂类负责创建一个或多个目标类实例，工厂类方法一般以接口或抽象类变量的形式返回目标类实例，工厂类对外屏蔽了目标类的实例化步骤，调用者甚至不用知道具体的目标类是什么。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">         http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 工厂方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;carFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baobaotao.ditype.CarFactory&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;car5&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;carFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createHongQiCar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>静态工厂方法：</p>
<p>很多工厂类都是静态的，这意味着用户在无须创建工厂类实例的情况下就可以调用工厂类方法，因此，静态工厂方法比非静态工厂方法的调用更加方便。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">         http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;car6&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baobaotao.ditype.CarFactory&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">factory-method</span>=<span class="string">&quot;createCar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="2、使用注解的方式注入"><a href="#2、使用注解的方式注入" class="headerlink" title="2、使用注解的方式注入"></a>2、使用注解的方式注入</h2><h3 id="a-使用-Autowired进行自动注入"><a href="#a-使用-Autowired进行自动注入" class="headerlink" title="a.使用@Autowired进行自动注入"></a>a.使用@Autowired进行自动注入</h3><p>Spring通过@Autowired注解实现Bean的依赖注入，下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baobaotao.anno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="comment">//① 定义一个Service的Bean（不需要在XML中定义Bean）</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogonService</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>&#123;</span><br><span class="line">        <span class="comment">//② 分别注入LogDao及UserDao的Bean（不需要在XML中定义property属性注入）</span></span><br><span class="line">    <span class="meta">@Autowired(required=false)</span></span><br><span class="line">    <span class="keyword">private</span> LogDao logDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userDao&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> LogDao <span class="title function_">getLogDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> logDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getUserDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;beanName:&quot;</span>+beanName);        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;initMethod1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;initMethod2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在①处，我们使用@Service将LogonService标注为一个Bean，在②处，通过@Autowired注入LogDao及UserDao的Bean。</p>
<p>@Autowired默认按类型匹配的方式，在容器查找匹配的Bean，当有且仅有一个匹配的Bean时，Spring将其注入到@Autowired标注的变量中。</p>
<h4 id="使用-Autowired的required属性"><a href="#使用-Autowired的required属性" class="headerlink" title="使用@Autowired的required属性"></a>使用@Autowired的required属性</h4><p>如果容器中没有一个和标注变量类型匹配的Bean，Spring容器启动时将报NoSuchBeanDefinitionException的异常。如果希望Spring即使找不到匹配的Bean完成注入也不用抛出异常，那么可以使用@Autowired(required&#x3D;false)进行标注：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogonService</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired(required=false)</span></span><br><span class="line">    <span class="keyword">private</span> LogDao logDao;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，@Autowired的required属性的值为true，即要求一定要找到匹配的Bean，否则将报异常。</p>
<h3 id="b-使用-Qualifier指定注入Bean的名称"><a href="#b-使用-Qualifier指定注入Bean的名称" class="headerlink" title="b.使用@Qualifier指定注入Bean的名称"></a>b.使用@Qualifier指定注入Bean的名称</h3><p>如果容器中有一个以上匹配的Bean时，则可以通过@Qualifier注解限定Bean的名称，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogonService</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired(required=false)</span></span><br><span class="line">    <span class="keyword">private</span> LogDao logDao;    <span class="comment">//①注入名为UserDao，类型为UserDao的Bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userDao&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里假设容器有两个类型为UserDao的Bean，一个名为userDao，另一个名为otherUserDao，则①处会注入名为userDao的Bean。</p>
<h3 id="c-对类方法进行标注"><a href="#c-对类方法进行标注" class="headerlink" title="c.对类方法进行标注"></a>c.对类方法进行标注</h3><p>@Autowired可以对类成员变量及方法的入参进行标注，下面我们在类的方法上使用@Autowired注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baobaotao.anno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogonService</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> LogDao logDao;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLogDao</span><span class="params">(LogDao logDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.logDao = logDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userDao&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;auto inject&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个方法拥有多个入参，在默认情况下，Spring自动选择匹配入参类型的Bean进行注入。Spring允许对方法入参标注@Qualifier以指定注入Bean的名称，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="meta">@Qualifier(&quot;userDao&quot;)</span>UserDao userDao,LogDao logDao)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;multi param inject&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    <span class="built_in">this</span>.logDao =logDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上例子中，UserDao的入参注入名为userDao的Bean，而LogDao的入参注入LogDao类型的Bean。</p>
<p>一般情况下，在Spring容器中大部分的Bean都是单实例的，所以我们一般都无须通过@Repository、@Service等注解的value属性为Bean指定名称，也无须使用@Qualifier按名称进行注入。</p>
<h3 id="d-对标准注解的支持"><a href="#d-对标准注解的支持" class="headerlink" title="d.对标准注解的支持"></a>d.对标准注解的支持</h3><p>此外，Spring还支持@Resource和@Inject注解，这两个标准注解和@Autowired注解的功能类型，都是对类变量及方法入参提供自动注入的功能。</p>
<p><code>@Resource</code>要求提供一个Bean名称的属性，如果属性为空，则自动采用标注处的变量名或方法名作为Bean的名称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baobaotao.anno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Boss</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boss</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;construct...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    private void setCar(Car car)&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;execute in setCar&quot;);</span></span><br><span class="line"><span class="comment">//        this.car = car;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource(&quot;car&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setCar</span><span class="params">(Car car)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;execute in setCar&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;execute in init1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;execute in init1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">destory1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;execute in destory1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">destory2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;execute in destory2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，如果@Resource未指定”car”属性，则也可以根据属性方法得到需要注入的Bean名称。可见**<code>@Autowired</code>默认按类型匹配注入Bean，<code>@Resource</code>则按名称匹配注入Bean**。而@Inject和@Autowired一样也是按类型匹配注入的Bean的，只不过它没有required属性。<u>可见不管是@Resource还是@Inject注解，其功能都没有@Autowired丰富，因此除非必须，大可不必在乎这两个注解。</u></p>
<p>（类似于Xml中使用</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;logDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>  <span class="attr">name</span>=<span class="string">&quot;logDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;logDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 进行注入，如果使用了@Autowired或者Resource等，这不需要在定义Bean时使用属性注入和构造方法注入了）</p>
<h3 id="e-Autowired-和-Resource-的区别"><a href="#e-Autowired-和-Resource-的区别" class="headerlink" title="e.@Autowired 和 @Resource 的区别"></a>e.@Autowired 和 @Resource 的区别</h3><ol>
<li><p><code>@Autowired</code>注入是<strong>按照类型注入</strong>的，只要配置文件中的bean类型和需要的bean类型是一致的，这时候注入就没问题。但是如果相同类型的bean不止一个，此时注入就会出现问题，Spring容器无法启动。</p>
<blockquote>
<p><code>Autowired</code> 属于 Spring 内置的注解，默认的注入方式为<code>byType</code>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</p>
<p><strong>这会有什么问题呢？</strong> 当一个接口存在多个实现类的话，<code>byType</code>这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。</p>
<p>这种情况下，注入方式会变为 <code>byName</code>（根据名称进行匹配），这个名称通常就是类名（首字母小写）。</p>
</blockquote>
</li>
<li><p><code>@Resourced</code>标签是<strong>按照bean的名字来进行注入</strong>的，如果我们没有在使用@Resource时指定bean的名字，同时Spring容器中又没有该名字的bean,这时候@Resource就会退化为@Autowired即按照类型注入，这样就有可能违背了使用@Resource的初衷。所以建议在使用@Resource时都显示指定一下bean的名字@Resource(name&#x3D;”xxx”)</p>
</li>
</ol>
<p>就比如说下面代码中的 <code>smsService</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// smsService 就是我们上面所说的名称</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br></pre></td></tr></table></figure>

<p>举个例子，<code>SmsService</code> 接口有两个实现类: <code>SmsServiceImpl1</code>和 <code>SmsServiceImpl2</code>，且它们都已经被 Spring 容器所管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错，byName 和 byType 都无法匹配到 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsServiceImpl1;</span><br><span class="line"><span class="comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="comment">// smsServiceImpl1 就是我们上面所说的名称</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br></pre></td></tr></table></figure>

<p>我们还是建议通过 <code>@Qualifier</code> 注解来显示指定名称而不是依赖变量的名称。</p>
<p><code>@Resource</code>属于 JDK 提供的注解，默认注入方式为 <code>byName</code>。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为<code>byType</code>。</p>
<p><code>@Resource</code> 有两个比较重要且日常开发常用的属性：<code>name</code>（名称）、<code>type</code>（类型）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Resource &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    Class&lt;?&gt; type() <span class="keyword">default</span> Object.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果仅指定 <code>name</code> 属性则注入方式为<code>byName</code>，如果仅指定<code>type</code>属性则注入方式为<code>byType</code>，如果同时指定<code>name</code> 和<code>type</code>属性（不建议这么做）则注入方式为<code>byType</code>+<code>byName</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错，byName 和 byType 都无法匹配到 bean</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsServiceImpl1;</span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）</span></span><br><span class="line"><span class="meta">@Resource(name = &quot;smsServiceImpl1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br></pre></td></tr></table></figure>

<p>简单总结一下：</p>
<ul>
<li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li>
<li><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li>
<li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显示指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显示指定名称。</li>
</ul>
<h3 id="f-让-Resource和-Autowired生效的几种方式"><a href="#f-让-Resource和-Autowired生效的几种方式" class="headerlink" title="f.让@Resource和@Autowired生效的几种方式"></a>f.让@Resource和@Autowired生效的几种方式</h3><p>1.在xml配置文件中显式指定 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 为了使用Autowired标签，我们必须在这里配置一个bean的后置处理器 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;</span> /&gt;</span>   </span><br><span class="line">      </span><br><span class="line">    <span class="comment">&lt;!-- 为了使用@Resource标签，这里必须配置一个后置处理器 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.annotation.CommonAnnotationBeanPostProcessor&quot;</span> /&gt;</span>  </span><br></pre></td></tr></table></figure>

<p>2.在xml配置文件中使用context:annotation-config </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.在xml配置文件中使用context:component-scan </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.baobaotao.anno&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.重写Spring容器的Context,在自定义BeanFactory时调用AnnotationConfigUtils.registerAnnotationConfigProcessors()把这两个注解处理器增加到容器中。 </p>
<h3 id="g-自动注入"><a href="#g-自动注入" class="headerlink" title="g.自动注入"></a>g.自动注入</h3><p>此时对象已经存放在了容器中，等着被用。那我们怎么从容器中取到我们想用的对象呢？</p>
<p>两种方式，一种是通过类型，一种是通过名字。（容器中的一个对象必然携带两个信息，一个是自己是哪个类的对象，即类型；一个是自己叫什么名字）</p>
<p>最先想到的就是get，对，get。从哪里get呢？从容器中。容器在哪里呢？</p>
<p>容器 最根是个BeanFactory（开始设计的时候定义的）,有个子类叫ApplicationContext（容器管理的一些方法，就像Object和Map），专门做这事情。从 ApplicationContext中get出来我们需要的对象。</p>
<blockquote>
<p>ApplicationContext 有很多实现，主要针对不同场景下</p>
</blockquote>
<ul>
<li>AnnotationConfigApplicationContext : 从一个或多个基于Java的配置类中加载上下文定义，适用于Java注解的方式;</li>
<li>ClassPathXmlApplicationContext : 从类路径下的一个或多个xml配置文件中加载上下文定义,适用于xml配置的方式;</li>
<li>FilesSystemXmlApplicationContext : 从文件系统下的一个或多个xml配置文件中加载上下文定义，也就是说系统盘符中加载xml配置文件</li>
<li>AnnotationConfigWebApplicationContext : 专门为web应用准备的，适用于注解方式;</li>
<li>XmlWebApplicationContext : 从web应用下的一个或多个xml配置文件加载上下文定义，适用于xml配置方式</li>
</ul>
<h1 id="五、Bean的作用域"><a href="#五、Bean的作用域" class="headerlink" title="五、Bean的作用域"></a>五、Bean的作用域</h1><p>Spring 中 Bean 的作用域通常有下面几种：</p>
<ul>
<li><strong>singleton</strong> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。</li>
<li><strong>prototype</strong> : 每次请求都会创建一个新的 bean 实例。</li>
<li><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>global-session</strong> ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li>
</ul>
<p><strong>如何配置 bean 的作用域呢？</strong></p>
<p>xml 方式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注解方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">personPrototype</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、Bean的生命周期"><a href="#六、Bean的生命周期" class="headerlink" title="六、Bean的生命周期"></a>六、Bean的生命周期</h1><blockquote>
<p>下面的内容整理自：<a target="_blank" rel="noopener" href="https://yemengying.com/2016/07/14/spring-bean-life-cycle/">https://yemengying.com/2016/07/14/spring-bean-life-cycle/</a> ，除了这篇文章，再推荐一篇很不错的文章 ：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zrtqsk/p/3735273.html">https://www.cnblogs.com/zrtqsk/p/3735273.html</a> 。</p>
</blockquote>
<ul>
<li>Bean 容器找到配置文件中 Spring Bean 的定义。</li>
<li>Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。<strong>由BeanFactory读取Bean定义文件，并生成各个实例。</strong></li>
<li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li>
<li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li>
<li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li>
<li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
<li>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li>
<li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li>
</ul>
<p>图示：</p>
<img src="https://camo.githubusercontent.com/70ba44111686c9f9a4fcac62d8ae01fd23e3e707d91fbce4af1205856dcd458f/68747470733a2f2f696d616765732e7869616f7a6875616e6c616e2e636f6d2f70686f746f2f323031392f32346263326261643363653238313434643630643965306132656466366337662e6a7067" alt="Spring Bean 生命周期" style="zoom: 80%;" />

<p>与之比较类似的中文版本:</p>
<img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205171109857.jpeg" alt="Spring Bean 生命周期" style="zoom:80%;" />

<h1 id="七、Bean的实例化"><a href="#七、Bean的实例化" class="headerlink" title="七、Bean的实例化"></a>七、Bean的实例化</h1><p>1、 懒汉式：BeanFactory</p>
<p>只有当客户端调用BeanFactory的getBean()方法来请求某个实例对象的时候，才会触发相应bean的实例化进程（ 当然对于 BeanFactory 容器而言并不是所有的 getBean() 方法都会触发实例化进程，比如 signleton 类型的 bean，该类型的 bean 只会在第一次调用 getBean() 的时候才会触发，而后续的调用则会直接返回容器缓存中的实例对象）</p>
<p>2、 饿汉式：ApplicationContext</p>
<p>使用ApplicationContext容器启动的时候立刻调用注册到该容器所有bean定义的实例化方法</p>
<p>Spring提供了两种类型的IOC容器实现（两种类型的配置方式是一样）</p>
<ol>
<li>BeanFactory：是Spring框架的基础设施，面向Spring本身</li>
<li>ApplicationContext： 面向使用 Spring 框架的开发者，几乎所有的应用场合都直接使用 ApplicationContext 而非底层的</li>
</ol>
<h2 id="Spring单例Bean与单例模式的区别"><a href="#Spring单例Bean与单例模式的区别" class="headerlink" title="Spring单例Bean与单例模式的区别"></a>Spring单例Bean与单例模式的区别</h2><p>单例模式是指在一个JVM进程中仅有一个实例，而Spring单例是指一个Spring Bean容器(ApplicationContext)中仅有一个实例。</p>
<p>首先看单例模式，在一个JVM进程中（理论上，一个运行的JAVA程序就必定有自己一个独立的JVM）仅有一个实例，于是无论在程序中的何处获取实例，始终都返回同一个对象。</p>
<p>与此相比，Spring的单例Bean是与其容器（ApplicationContext）密切相关的，所以在一个JVM进程中，如果有多个Spring容器，即使是单例bean，也一定会创建多个实例。</p>
<h2 id="单例-Bean-的线程安全问题"><a href="#单例-Bean-的线程安全问题" class="headerlink" title="单例 Bean 的线程安全问题"></a>单例 Bean 的线程安全问题</h2><p>大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p>
<p>常见的有两种解决办法：</p>
<ol>
<li>在 Bean 中尽量避免定义可变的成员变量。</li>
<li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li>
</ol>
<p>不过，大部分 Bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2022/05/19/javaSpring%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94SpringMVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/19/javaSpring%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94SpringMVC/" class="post-title-link" itemprop="url">javaSpring学习（五）——SpringMVC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-19 10:14:13" itemprop="dateCreated datePublished" datetime="2022-05-19T10:14:13Z">2022-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205180932342.png" alt="img"></p>
<p>网上有很多人说 MVC 不是设计模式，只是软件设计规范，我个人更倾向于 MVC 同样是众多设计模式中的一种。**<a target="_blank" rel="noopener" href="https://github.com/iluwatar/java-design-patterns">java-design-patterns</a>** 项目中就有关于 MVC 的相关介绍。</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205180932402.png" alt="img"></p>
<p>想要真正理解 Spring MVC，我们先来看看 Model 1 和 Model 2 这两个没有 Spring MVC 的时代。</p>
<p><strong>Model 1 时代</strong></p>
<p>很多学 Java 后端比较晚的朋友可能并没有接触过 Model 1 时代下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。</p>
<p>这个模式下 JSP 即是控制层（Controller）又是表现层（View）。显而易见，这种模式存在很多问题。比如控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；再比如前端和后端相互依赖，难以进行测试维护并且开发效率极低。</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205180932366.png" alt="mvc-mode1"></p>
<p><strong>Model 2 时代</strong></p>
<p>学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+ JSP（View）+Servlet（Controller） ”这种开发模式，这就是早期的 JavaWeb MVC 开发模式。</p>
<ul>
<li>Model:系统涉及的数据，也就是 dao 和 bean。</li>
<li>View：展示模型中的数据，只是用来展示。</li>
<li>Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户。</li>
</ul>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205180932407.png" alt="img"></p>
<p>Model2 模式下还存在很多问题，Model2 的抽象和封装程度还远远不够，使用 Model2 进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。</p>
<p>于是，很多 JavaWeb 开发相关的 MVC 框架应运而生比如 Struts2，但是 Struts2 比较笨重。</p>
<p><strong>Spring MVC 时代</strong></p>
<p>随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。</p>
<p>MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p>
<h2 id="SpringMVC-工作原理"><a href="#SpringMVC-工作原理" class="headerlink" title="SpringMVC 工作原理"></a>SpringMVC 工作原理</h2><p><strong>Spring MVC 原理如下图所示：</strong></p>
<blockquote>
<p>SpringMVC 工作原理的图解我没有自己画，直接图省事在网上找了一个非常清晰直观的，原出处不明。</p>
</blockquote>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205180932353.png" alt="img"></p>
<p><strong>流程说明（重要）：</strong></p>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>处理器映射器，解析请求对应的 <code>Handler</code>。</li>
<li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）</li>
<li>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给<code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code>调用<code>HandlerAdapter</code>处理器适配器。</li>
<li><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>HandlerAdapter</code>将<code>controller</code>执行结果<code>ModelAndView</code>返回给<code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code>将<code>ModelAndView</code>传给<code>ViewReslover</code>视图解析器。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
<p>请求 —&gt;<code> DispatcherServlet</code>（前端控制器）—&gt; 调用<code>HandlerMapping</code>（处理器映射器）—&gt;<code> DispatcherServlet</code>调用<code> HandlerAdapter</code>（处理器适配器）—&gt; 适配调用具体的<code>Controller</code> —&gt; 返回<code>ModelAndView</code> —&gt; 传给<code>ViewReslover</code>视图解析器 —&gt; 解析后返回具体<code>View</code> —&gt; 根据<code>View</code>进行渲染视图响应用户.</p>
<h2 id="Spring与SpringMVC父子容器的区别和联系"><a href="#Spring与SpringMVC父子容器的区别和联系" class="headerlink" title="Spring与SpringMVC父子容器的区别和联系"></a>Spring与SpringMVC父子容器的区别和联系</h2><ol>
<li>Spring 与SpringMVC 两个都是容器,存在父子关系（包含和被包含的关系）</li>
<li>Spring容器中存放着mapper代理对象，service对象，SpringMVC存放着Controller对象。<strong>子容器SpringMVC中可以访问父容器中的对象。但父容器Spring不能访问子容器SpringMVC的对象</strong>（存在领域作用域的原因，子容器可以访问父容器中的成员，而子容器的成员则只能被自己使用）。如：Service对象可以在Controller层中注入，反之则不行。</li>
<li>Spring容器导入的properties配置文件，只能在Spring容器中用而在SpringMVC容器中不能读取到。 需要在SpringMVC 的配置文件中重新进行导入properties文件，并且同样在父容器Spring中不能被使用，导入后使用@Value(“${key}”)在java类中进行读取。</li>
</ol>
<h1 id="SpringMVC拦截器"><a href="#SpringMVC拦截器" class="headerlink" title="SpringMVC拦截器"></a>SpringMVC拦截器</h1><h2 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h2><ol>
<li>日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算PV（Page View）等</li>
<li>权限检查：如登录检测，进入处理器检测检测是否登录，如果没有直接返回到登录页面</li>
<li>性能监控：有时候系统在某段时间莫名其妙的慢，可以通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间（如果有反向代理，如apache可以自动记录）</li>
<li>通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现。</li>
<li>OpenSessionInView：如Hibernate，在进入处理器打开Session，在完成后关闭Session。</li>
</ol>
<h2 id="拦截器接口"><a href="#拦截器接口" class="headerlink" title="拦截器接口"></a>拦截器接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerInterceptor</span> &#123;  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 预处理回调方法，实现处理器的预处理（如登录检查），第三个参数为响应的处理器（如我们上一章的Controller实现）</span></span><br><span class="line"><span class="comment">    * 返回值：true表示继续流程（如调用下一个拦截器或处理器）；</span></span><br><span class="line"><span class="comment">    * false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过response来产生响应</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(  </span></span><br><span class="line"><span class="params">            HttpServletRequest request, HttpServletResponse response,   </span></span><br><span class="line"><span class="params">            Object handler)</span>   </span><br><span class="line">            <span class="keyword">throws</span> Exception;  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(  </span></span><br><span class="line"><span class="params">            HttpServletRequest request, HttpServletResponse response,   </span></span><br><span class="line"><span class="params">            Object handler, ModelAndView modelAndView)</span>   </span><br><span class="line">            <span class="keyword">throws</span> Exception;  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间 ，</span></span><br><span class="line"><span class="comment">    * 还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中preHandle返回true的拦截器的afterCompletion。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(  </span></span><br><span class="line"><span class="params">            HttpServletRequest request, HttpServletResponse response,   </span></span><br><span class="line"><span class="params">            Object handler, Exception ex)</span>  </span><br><span class="line">            <span class="keyword">throws</span> Exception;  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h2 id="拦截器和过滤器什么区别"><a href="#拦截器和过滤器什么区别" class="headerlink" title="拦截器和过滤器什么区别"></a>拦截器和过滤器什么区别</h2><p>Spring的拦截器与Servlet的过滤器Filter有很多相似之处，比如两者都是AOP编程思想的体现，都能实现权限检查、日志记录等，不同的是：</p>
<ol>
<li>使用范围不同：Filter是Servlet规范规定的，只能用于Web程序中，而拦截器既可以用于Web程序，也可以用于Application、Swing程序中</li>
<li>规范不同：Filter是Servlet规范中定义的，是Servlet容器支持的。而拦截器是在Spring容器内的，是Spring框架支持的</li>
<li>使用的资源不同：拦截器是一个Spring的组件，归Spring管理，配置在Spring文件中，因此能使用Spring里的任何资源、对象，例如Service对象、数据源、事务管理等，通过IoC注入到拦截器即可，而Filter则不能</li>
<li>深度不同：Filter只在Servlet前后起作用。而拦截器能够深入到方法前后、异常抛出前后等，因此拦截器的使用具有更大的弹性。所以在Spring架构的程序中，要优先使用拦截器。</li>
<li>实现原理不同：拦截器是基于动态代理来实现的，而过滤器是基于函数回调来实现的。</li>
<li>作用域不同：拦截器只对Action起作用，过滤器可以对所有请求起作用。</li>
<li>调用次序不同：在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://github.com/doocs/source-code-hunter">参考文章</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2022/05/19/javaSpring%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94Spring%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/19/javaSpring%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94Spring%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">javaSpring学习（四）——Spring事务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-19 10:14:13" itemprop="dateCreated datePublished" datetime="2022-05-19T10:14:13Z">2022-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring事务介绍"><a href="#Spring事务介绍" class="headerlink" title="Spring事务介绍"></a>Spring事务介绍</h1><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
<p>格外注意的是：<strong>事务能否生效数据库引擎是否支持事务是关键。比如常用的 MySQL 数据库默认使用支持事务的 <code>innodb</code>引擎。但是，如果把数据库引擎变为 <code>myisam</code>，那么程序也就不再支持事务了！</strong></p>
<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：</p>
<blockquote>
<ol>
<li>将小明的余额减少 1000 元。</li>
<li>将小红的余额增加 1000 元。</li>
</ol>
</blockquote>
<p>万一在这两个操作之间突然出现错误比如银行系统崩溃或者网络故障，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrdersService</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrdersDao</span><span class="params">(AccountDao accountDao)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.accountDao = accountDao;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional(propagation = Propagation.REQUIRED,</span></span><br><span class="line"><span class="meta">                isolation = Isolation.DEFAULT, readOnly = false, timeout = -1)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accountMoney</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//小红账户多1000</span></span><br><span class="line">		accountDao.addMoney(<span class="number">1000</span>,xiaohong);</span><br><span class="line">		<span class="comment">//模拟突然出现的异常，比如银行中可能为突然停电等等</span></span><br><span class="line">    <span class="comment">//如果没有配置事务管理的话会造成，小红账户多了1000而小明账户没有少钱</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//小王账户少1000</span></span><br><span class="line">		accountDao.reduceMoney(<span class="number">1000</span>,xiaoming);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，数据库事务的 ACID 四大特性是事务的基础，下面简单来了解一下。</p>
<ul>
<li><strong>原子性（Atomicity）：</strong> 一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li><strong>一致性（Consistency）：</strong> 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li>
<li><strong>隔离性（Isolation）：</strong> 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li><strong>持久性（Durability）:</strong> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<h1 id="Spring-管理事务的方式"><a href="#Spring-管理事务的方式" class="headerlink" title="Spring 管理事务的方式"></a>Spring 管理事务的方式</h1><ul>
<li><strong>编程式事务</strong> ： 在代码中硬编码(不推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li>
<li><strong>声明式事务</strong> ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）</li>
</ul>
<h2 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h2><p>通过 <code>TransactionTemplate</code>或者<code>TransactionManager</code>手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</p>
<p>使用<code>TransactionTemplate</code> 进行编程式事务管理的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallbackWithoutResult</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doInTransactionWithoutResult</span><span class="params">(TransactionStatus transactionStatus)</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ....  业务代码</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    <span class="comment">//回滚</span></span><br><span class="line">                    transactionStatus.setRollbackOnly();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>TransactionManager</code> 进行编程式事务管理的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> transactionManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// ....  业务代码</span></span><br><span class="line">              transactionManager.commit(status);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              transactionManager.rollback(status);</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h2><p>推荐使用（代码侵入性最小），实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）。</p>
<p>使用 <code>@Transactional</code>注解进行事务管理的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">  <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">  <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">  b.bMethod();</span><br><span class="line">  c.cMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-事务管理接口介绍"><a href="#Spring-事务管理接口介绍" class="headerlink" title="Spring 事务管理接口介绍"></a>Spring 事务管理接口介绍</h2><p>Spring 框架中，事务管理相关最重要的 3 个接口如下：</p>
<ul>
<li>**<code>PlatformTransactionManager</code>**： （平台）事务管理器，Spring 事务策略的核心。</li>
<li>**<code>TransactionDefinition</code>**： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。</li>
<li>**<code>TransactionStatus</code>**： 事务运行状态。</li>
</ul>
<p>我们可以把 <strong><code>PlatformTransactionManager</code></strong> 接口可以被看作是事务上层的管理者，而 <strong><code>TransactionDefinition</code></strong> 和 <strong><code>TransactionStatus</code></strong> 这两个接口可以看作是事务的描述。</p>
<p><strong><code>PlatformTransactionManager</code></strong> 会根据 <strong><code>TransactionDefinition</code></strong> 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 <strong><code>TransactionStatus</code></strong> 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</p>
<h3 id="PlatformTransactionManager-事务管理接口"><a href="#PlatformTransactionManager-事务管理接口" class="headerlink" title="PlatformTransactionManager:事务管理接口"></a>PlatformTransactionManager:事务管理接口</h3><p><strong>Spring 并不直接管理事务，而是提供了多种事务管理器</strong> 。Spring 事务管理器的接口是： <strong><code>PlatformTransactionManager</code></strong> 。</p>
<p>通过这个接口，Spring 为各个平台如 JDBC(<code>DataSourceTransactionManager</code>)、Hibernate(<code>HibernateTransactionManager</code>)、JPA(<code>JpaTransactionManager</code>)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p>
<p><strong><code>PlatformTransactionManager</code> 接口的具体实现如下:</strong></p>
<p><img src="https://github.com/Snailclimb/JavaGuide/blob/main/docs/system-design/framework/spring/images/spring-transaction/PlatformTransactionManager.png" alt="img"></p>
<p><code>PlatformTransactionManager</code>接口中定义了三个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> &#123;</span><br><span class="line">    <span class="comment">//获得事务</span></span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里多插一嘴。为什么要定义或者说抽象出来<code>PlatformTransactionManager</code>这个接口呢？</strong></p>
<p>主要是因为要将事务管理行为抽象出来，然后不同的平台去实现它，这样我们可以保证提供给外部的行为不变，方便我们扩展。</p>
<p><strong>“为什么我们要用接口？”</strong> 。</p>
<blockquote>
<p>《设计模式》（GOF 那本）这本书在很多年前都提到过说要基于接口而非实现编程，你真的知道为什么要基于接口编程么？</p>
<p>纵观开源框架和项目的源码，接口是它们不可或缺的重要组成部分。要理解为什么要用接口，首先要搞懂接口提供了什么功能。我们可以把接口理解为提供了一系列功能列表的约定，接口本身不提供功能，它只定义行为。但是谁要用，就要先实现我，遵守我的约定，然后再自己去实现我定义的要实现的功能。</p>
<p>举个例子，我上个项目有发送短信的需求，为此，我们定了一个接口，接口只有两个方法:</p>
<p>1.发送短信 2.处理发送结果的方法。</p>
<p>刚开始我们用的是阿里云短信服务，然后我们实现这个接口完成了一个阿里云短信的服务。后来，我们突然又换到了别的短信服务平台，我们这个时候只需要再实现这个接口即可。这样保证了我们提供给外部的行为不变。几乎不需要改变什么代码，我们就轻松完成了需求的转变，提高了代码的灵活性和可扩展性。</p>
<p>什么时候用接口？当你要实现的功能模块设计抽象行为的时候，比如发送短信的服务，图床的存储服务等等。</p>
</blockquote>
<h3 id="TransactionDefinition-事务属性"><a href="#TransactionDefinition-事务属性" class="headerlink" title="TransactionDefinition:事务属性"></a>TransactionDefinition:事务属性</h3><p>事务管理器接口 <strong><code>PlatformTransactionManager</code></strong> 通过 <strong><code>getTransaction(TransactionDefinition definition)</code></strong> 方法来得到一个事务，这个方法里面的参数是 <strong><code>TransactionDefinition</code></strong> 类 ，这个类就定义了一些基本的事务属性。</p>
<p><strong>什么是事务属性呢？</strong> 事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。</p>
<p>事务属性包含了 5 个方面：</p>
<ul>
<li>隔离级别</li>
<li>传播行为</li>
<li>回滚规则</li>
<li>是否只读</li>
<li>事务超时</li>
</ul>
<p><code>TransactionDefinition</code> 接口中定义了 5 个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionDefinition</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_REQUIRED</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_SUPPORTS</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_MANDATORY</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_REQUIRES_NEW</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_NOT_SUPPORTED</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_NEVER</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_NESTED</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_DEFAULT</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_READ_UNCOMMITTED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_READ_COMMITTED</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_REPEATABLE_READ</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_SERIALIZABLE</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">TIMEOUT_DEFAULT</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 返回事务的传播行为，默认值为 REQUIRED。</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPropagationBehavior</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//返回事务的隔离级别，默认值是 DEFAULT</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getIsolationLevel</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getTimeout</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 返回是否为只读事务，默认值为 false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isReadOnly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TransactionStatus-事务状态"><a href="#TransactionStatus-事务状态" class="headerlink" title="TransactionStatus:事务状态"></a>TransactionStatus:事务状态</h3><p><code>TransactionStatus</code>接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息。</p>
<p><code>PlatformTransactionManager.getTransaction(…)</code>方法返回一个 <code>TransactionStatus</code> 对象。</p>
<p><strong>TransactionStatus 接口内容如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionStatus</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNewTransaction</span><span class="params">()</span>; <span class="comment">// 是否是新的事务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasSavepoint</span><span class="params">()</span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setRollbackOnly</span><span class="params">()</span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRollbackOnly</span><span class="params">()</span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="type">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="事务属性详解"><a href="#事务属性详解" class="headerlink" title="事务属性详解"></a>事务属性详解</h1><p>实际业务开发中，大家一般都是使用 <code>@Transactional</code> 注解来开启事务，但很多人并不清楚这个注解里面的参数是什么意思，有什么用。为了更好的在项目中使用事务管理，强烈推荐好好阅读一下下面的内容。</p>
<h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h2><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。</p>
<p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
<p>举个例子：我们在 A 类的<code>aMethod()</code>方法中调用了 B 类的 <code>bMethod()</code> 方法。这个时候就涉及到业务层方法之间互相调用的事务问题。如果我们的 <code>bMethod()</code>如果发生异常需要回滚，如何配置事务传播行为才能让 <code>aMethod()</code>也跟着回滚呢？这个时候就需要事务传播行为的知识了，如果你不知道的话一定要好好看一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.xxx)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.xxx)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>TransactionDefinition</code>定义中包括了如下几个表示传播行为的常量：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionDefinition &#123;</span><br><span class="line">    int PROPAGATION_REQUIRED <span class="operator">=</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    int PROPAGATION_SUPPORTS <span class="operator">=</span> <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    int PROPAGATION_MANDATORY <span class="operator">=</span> <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    int PROPAGATION_REQUIRES_NEW <span class="operator">=</span> <span class="number">3</span><span class="comment">;</span></span><br><span class="line">    int PROPAGATION_NOT_SUPPORTED <span class="operator">=</span> <span class="number">4</span><span class="comment">;</span></span><br><span class="line">    int PROPAGATION_NEVER <span class="operator">=</span> <span class="number">5</span><span class="comment">;</span></span><br><span class="line">    int PROPAGATION_NESTED <span class="operator">=</span> <span class="number">6</span><span class="comment">;</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，为了方便使用，Spring 相应地定义了一个枚举类：<code>Propagation</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionDefinition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Propagation</span> &#123;</span><br><span class="line"></span><br><span class="line">    REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line"></span><br><span class="line">    SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line"></span><br><span class="line">    MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line"></span><br><span class="line">    REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line"></span><br><span class="line">    NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line"></span><br><span class="line">    NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line"></span><br><span class="line">    NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    Propagation(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正确的事务传播行为可能的值如下</strong> ：</p>
<p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p>
<p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。也就是说：</p>
<ul>
<li>如果外部方法没有开启事务的话，<code>Propagation.REQUIRED</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</li>
<li>如果外部方法开启事务并且被<code>Propagation.REQUIRED</code>的话，所有<code>Propagation.REQUIRED</code>修饰的内部方法和外部方法均属于同一事务 ，只要一个方法回滚，整个事务均回滚。</li>
</ul>
<p>举个例子：如果我们上面的<code>aMethod()</code>和<code>bMethod()</code>使用的都是<code>PROPAGATION_REQUIRED</code>传播行为的话，两者使用的就是同一个事务，只要其中一个方法回滚，整个事务均回滚。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p>
<p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p>
<p>举个例子：如果我们上面的<code>bMethod()</code>使用<code>PROPAGATION_REQUIRES_NEW</code>事务传播行为修饰，<code>aMethod</code>还是用<code>PROPAGATION_REQUIRED</code>修饰的话。如果<code>aMethod()</code>发生异常回滚，<code>bMethod()</code>不会跟着回滚，因为 <code>bMethod()</code>开启了独立的事务。但是，如果 <code>bMethod()</code>抛出了未被捕获的异常并且这个异常满足事务回滚规则的话,<code>aMethod()</code>同样也会回滚，因为这个异常被 <code>aMethod()</code>的事务管理机制检测到了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong>:</p>
<p>如果当前存在事务，就在嵌套事务内执行；如果当前没有事务，就执行与<code>TransactionDefinition.PROPAGATION_REQUIRED</code>类似的操作。也就是说：</p>
<ul>
<li>在外部方法开启事务的情况下,在内部开启一个新的事务，作为嵌套事务存在。</li>
<li>如果外部方法无事务，则单独开启一个事务，与 <code>PROPAGATION_REQUIRED</code> 类似。</li>
</ul>
<p>这里还是简单举个例子：如果 <code>bMethod()</code> 回滚的话，<code>aMethod()</code>也会回滚。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p>
<p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p>
<p>这个使用的很少，就不举例子来说了。</p>
<p><strong>若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚，这里不对照案例讲解了，使用的很少。</strong></p>
<ul>
<li><strong><code>TransactionDefinition.PROPAGATION_SUPPORTS</code></strong>: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code></strong>: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NEVER</code></strong>: 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p>更多关于事务传播行为的内容请看这篇文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486668&idx=2&sn=0381e8c836442f46bdc5367170234abb&chksm=cea24307f9d5ca11c96943b3ccfa1fc70dc97dd87d9c540388581f8fe6d805ff548dff5f6b5b&token=1776990505&lang=zh_CN#rd">《太难了~面试官让我结合案例讲讲自己对 Spring 事务传播行为的理解。》</a></p>
<h2 id="Spring-事务中的隔离级别"><a href="#Spring-事务中的隔离级别" class="headerlink" title="Spring 事务中的隔离级别"></a>Spring 事务中的隔离级别</h2><p>和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：<code>Isolation</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Isolation</span> &#123;</span><br><span class="line"></span><br><span class="line">    DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),</span><br><span class="line"></span><br><span class="line">    READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),</span><br><span class="line"></span><br><span class="line">    READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),</span><br><span class="line"></span><br><span class="line">    REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),</span><br><span class="line"></span><br><span class="line">    SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    Isolation(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我依次对每一种事务隔离级别进行介绍：</p>
<ul>
<li><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong> : 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<p>相关阅读：<a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/transaction-isolation-level.html">MySQL事务隔离级别详解</a>。</p>
<h3 id="事务超时属性"><a href="#事务超时属性" class="headerlink" title="事务超时属性"></a>事务超时属性</h3><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 <code>TransactionDefinition</code> 中以 int 的值来表示超时时间，其单位是秒，默认值为-1，这表示事务的超时时间取决于底层事务系统或者没有超时时间。</p>
<h3 id="事务只读属性"><a href="#事务只读属性" class="headerlink" title="事务只读属性"></a>事务只读属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionDefinition</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 返回是否为只读事务，默认值为 false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isReadOnly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于只有读取数据查询的事务，可以指定事务类型为 readonly，即只读事务。只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中。</p>
<p>很多人就会疑问了，为什么我一个数据查询操作还要启用事务支持呢？</p>
<p>拿 MySQL 的 innodb 举例子，根据官网 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-autocommit-commit-rollback.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-autocommit-commit-rollback.html</a> 描述：</p>
<blockquote>
<p>MySQL 默认对每一个新建立的连接都启用了<code>autocommit</code>模式。在该模式下，每一个发送到 MySQL 服务器的<code>sql</code>语句都会在一个单独的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务。</p>
</blockquote>
<p>但是，如果你给方法加上了<code>Transactional</code>注解的话，这个方法执行的所有<code>sql</code>会被放在一个事务中。如果声明了只读事务的话，数据库就会去优化它的执行，并不会带来其他的什么收益。</p>
<p>如果不加<code>Transactional</code>，每条<code>sql</code>会开启一个单独的事务，中间被其它事务改了数据，都会实时读取到最新值。</p>
<p>分享一下关于事务只读属性，其他人的解答：</p>
<ul>
<li>如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持 SQL 执行期间的读一致性；</li>
<li>如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询 SQL 必须保证整体的读一致性，否则，在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持</li>
</ul>
<h3 id="事务回滚规则"><a href="#事务回滚规则" class="headerlink" title="事务回滚规则"></a>事务回滚规则</h3><p>这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常（<code>RuntimeException</code> 的子类）时才会回滚，<code>Error</code> 也会导致事务回滚，但是，在遇到检查型（Checked）异常时不会回滚。</p>
<p><img src="https://github.com/Snailclimb/JavaGuide/raw/main/docs/system-design/framework/spring/images/spring-transaction/roollbackFor.png" alt="img"></p>
<p>如果你想要回滚你定义的特定的异常类型的话，可以这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor= MyException.class)</span></span><br></pre></td></tr></table></figure>

<h1 id="Transactional注解"><a href="#Transactional注解" class="headerlink" title="@Transactional注解"></a>@Transactional注解</h1><p><code>Exception</code> 分为运行时异常 <code>RuntimeException</code> 和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当 <code>@Transactional</code> 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在 <code>@Transactional</code> 注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚，加上 <code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</p>
<h2 id="Transactional-注解使用详解"><a href="#Transactional-注解使用详解" class="headerlink" title="@Transactional 注解使用详解"></a>@Transactional 注解使用详解</h2><ol>
<li><strong>方法</strong> ：推荐将注解使用于方法上，不过需要注意的是：<strong>该注解只能应用到 public 方法上，否则不生效。</strong></li>
<li><strong>类</strong> ：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。</li>
<li><strong>接口</strong> ：不推荐在接口上使用。</li>
</ol>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ol>
<li>当spring遍历容器中所有的切面，查找与当前实例化bean匹配的切面，这里就是获取事务属性切面，查找@Transactional注解及其属性值，然后根据得到的切面进入createProxy方法，创建一个AOP代理。</li>
<li>默认是使用JDK动态代理创建代理，如果目标类是接口，则使用JDK动态代理，否则使用Cglib。</li>
<li>获取的是当前目标方法对应的拦截器，里面是根据之前获取到的切面来获取相对应拦截器，这时候会得到TransactionInterceptor实例。如果获取不到拦截器，则不会创建MethodInvocation，直接调用目标方法。</li>
<li>在需要进行事务操作的时候，Spring会在调用目标类的目标方法之前进行开启事务、调用异常回滚事务、调用完成会提交事务。是否需要开启新事务，是根据@Transactional注解上配置的参数值来判断的。如果需要开启新事务，获取Connection连接，然后将连接的自动提交事务改为false，改为手动提交</li>
<li>Spring并不会对所有类型异常都进行事务回滚操作，默认是只对Unchecked Exception(Error和RuntimeException)进行事务回滚操作。</li>
</ol>
<p>从上面的分析可以看到，Spring使用AOP实现事务的统一管理,基本都是下面这两种情况：</p>
<ol>
<li>A类的a1方法没有标注@Transactional，a2方法标注@Transactional，在a1里面调用a2。a1方法是目标类A的原生方法，调用a1的时候即直接进入目标类A进行调用，在目标类A里面只有a2的原生方法，在a1里调用a2，即直接执行a2的原生方法，并不通过创建代理对象进行调用，所以并不会进入TransactionInterceptor的invoke方法，不会开启事务。</li>
<li>将@Transactional注解标注在非public方法上。内部使用AOP，所以必须是public修饰的方法才可以被代理</li>
</ol>
<h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><p><code>@Transactional</code>注解源码如下，里面包含了基本事务属性的配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(&quot;transactionManager&quot;)</span></span><br><span class="line">	String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">	String <span class="title function_">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	Propagation <span class="title function_">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED;</span><br><span class="line"></span><br><span class="line">	Isolation <span class="title function_">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> <span class="title function_">timeout</span><span class="params">()</span> <span class="keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>@Transactional</code> 的常用配置参数总结：</strong></p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>propagation</td>
<td>Propagation类型（枚举），事务的传播行为，默认值为 REQUIRED，可选的值在上面介绍过</td>
</tr>
<tr>
<td>isolation</td>
<td>Isolation类型（枚举），事务的隔离级别，默认值采用 DEFAULT，可选的值在上面介绍过</td>
</tr>
<tr>
<td>timeout</td>
<td>int类型，事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td>
</tr>
<tr>
<td>readOnly</td>
<td>boolean类型，指定事务是否为只读事务，默认值为 false。</td>
</tr>
<tr>
<td>rollbackFor</td>
<td>Class&lt;? extends Throwable&gt;[]类型，默认为空数组。用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。</td>
</tr>
</tbody></table>
<p>其他参数：</p>
<ol>
<li>rollbackForClassName参数，String[]类型，默认为空数组。</li>
<li>noRollbackFor参数，Class&lt;? extends Throwable&gt;[]类型，默认为空数组。</li>
<li>noRollbackForClassName参数，String[]类型，默认为空数组。</li>
</ol>
<p>一般不推荐使用rollbackForClassName和noRollbackForClassName两个参数，而用另外两个参数来代替，从参数的类型上就可以看出区别，使用字符串的缺点在于：如果不是用类的完整路径，就可能导致回滚设置对位于不同包中的同名类都生效；且如果类名写错，也无法得到IDE的动态提示。</p>
<p>但是，如果不配置任何与回滚有关的参数，不代表事务不会进行回滚，如果没有配置这四个选项，那么<code>DefaultTransactionAttribute</code>配置将会生效，具体的行为是，抛掷任何<code>unchecked Exception</code>都会触发回滚，当然包括所有的<code>RuntimeException</code>。</p>
<h2 id="事务注解原理"><a href="#事务注解原理" class="headerlink" title="事务注解原理"></a>事务注解原理</h2><p>我们知道，**<code>@Transactional</code> 的工作机制是基于 AOP 实现的，AOP 又是使用动态代理实现的。如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理。**</p>
<p>多提一嘴：<code>createAopProxy()</code> 方法 决定了是使用 JDK 还是 Cglib 来做动态代理，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">AopProxyFactory</span>, Serializable &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">						<span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类或者一个类中的 public 方法上被标注<code>@Transactional</code> 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被<code>@Transactional</code> 注解的 public 方法的时候，实际调用的是，<code>TransactionInterceptor</code> 类中的 <code>invoke()</code>方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</p>
<blockquote>
<p><code>TransactionInterceptor</code> 类中的 <code>invoke()</code>方法内部实际调用的是 <code>TransactionAspectSupport</code> 类的 <code>invokeWithinTransaction()</code>方法。由于新版本的 Spring 对这部分重写很大，而且用到了很多响应式编程的知识，这里就不列源码了。</p>
</blockquote>
<h2 id="Spring-AOP-自调用问题"><a href="#Spring-AOP-自调用问题" class="headerlink" title="Spring AOP 自调用问题"></a>Spring AOP 自调用问题</h2><p>若同一类中的其他没有 <code>@Transactional</code> 注解的方法内部调用有 <code>@Transactional</code> 注解的方法，有<code>@Transactional</code> 注解的方法的事务会失效。</p>
<p>这是由于<code>Spring AOP</code>代理的原因造成的，因为只有当 <code>@Transactional</code> 注解的方法在类以外被调用的时候，Spring 事务管理才生效。</p>
<p><code>MyService</code> 类中的<code>method1()</code>调用<code>method2()</code>就会导致<code>method2()</code>的事务失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">     method2();</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法就是避免同一类中自调用或者使用 AspectJ 取代 Spring AOP 代理。</p>
<h2 id="Transactional的使用注意事项总结"><a href="#Transactional的使用注意事项总结" class="headerlink" title="@Transactional的使用注意事项总结"></a>@Transactional的使用注意事项总结</h2><ul>
<li><code>@Transactional</code> 注解只有作用到 public 方法上事务才生效，不推荐在接口上使用；</li>
<li>避免同一个类中调用 <code>@Transactional</code> 注解的方法，这样会导致事务失效；</li>
<li>正确的设置 <code>@Transactional</code> 的 <code>rollbackFor</code> 和 <code>propagation</code> 属性，否则事务可能会回滚失败;</li>
<li>被 <code>@Transactional</code> 注解的方法所在的类必须被 Spring 管理，否则不生效；</li>
<li>底层使用的数据库必须支持事务机制，否则不生效；</li>
<li>……</li>
</ul>
<h2 id="Spring事务什么情况下回滚？"><a href="#Spring事务什么情况下回滚？" class="headerlink" title="Spring事务什么情况下回滚？"></a>Spring事务什么情况下回滚？</h2><p>Spring事务回滚机制是这样的：当所拦截的方法有指定异常抛出，事务才会自动进行回滚。</p>
<p>默认配置下，事务只会对Error与RuntimeException及其子类这些UNChecked异常，做出回滚。一般的Exception这些Checked异常不会发生回滚（如果一般Exception想回滚要做出配置）；</p>
<h2 id="Spring事务try-catch会回滚吗？"><a href="#Spring事务try-catch会回滚吗？" class="headerlink" title="Spring事务try catch会回滚吗？"></a>Spring事务try catch会回滚吗？</h2><p>依赖spring事物时，当service层进行try catch异常捕获时，事物不会产生回滚，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertMsg</span><span class="params">(ConversationBean conversationBean)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">10</span>)&#123;</span><br><span class="line">                testDao.insert2(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                testDao.insert1(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时异常被捕获，这种业务方法也就等于脱离了spring事务的管理，因为没有任何异常会从业务方法中抛出，全被捕获，导致spring异常抛出触发事务回滚策略失效。</p>
<p>解决此类问题时，需要在try catch中显示的抛出异常RuntimeException 然后在Controller层捕获异常并编写返回值，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertMsg</span><span class="params">(ConversationBean conversationBean)</span>&#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(i!=<span class="number">10</span>)&#123;</span><br><span class="line">                 testDao.insert2(i);</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 testDao.insert1(i);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>[总结]Spring 事务管理中@Transactional 的参数:<a target="_blank" rel="noopener" href="http://www.mobabel.net/spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B8%ADtransactional%E7%9A%84%E5%8F%82%E6%95%B0/">http://www.mobabel.net/spring 事务管理中 transactional 的参数/</a></li>
<li>Spring 官方文档：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html">https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html</a></li>
<li>《Spring5 高级编程》</li>
<li>透彻的掌握 Spring 中@transactional 的使用: <a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html">https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html</a></li>
<li>Spring 事务的传播特性：<a target="_blank" rel="noopener" href="https://github.com/love-somnus/Spring/wiki/Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E7%89%B9%E6%80%A7">https://github.com/love-somnus/Spring/wiki/Spring 事务的传播特性</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013341344">Spring 事务传播行为详解</a> ：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013341344">https://segmentfault.com/a/1190000013341344</a></li>
<li>全面分析 Spring 的编程式事务管理及声明式事务管理：<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html">https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2022/05/09/javaSpring%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94Spring%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/09/javaSpring%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94Spring%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">javaSpring学习（一）——Spring介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-09 10:14:13" itemprop="dateCreated datePublished" datetime="2022-05-09T10:14:13Z">2022-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring介绍"><a href="#Spring介绍" class="headerlink" title="Spring介绍"></a>Spring介绍</h1><p>一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。</p>
<p>Spring 最核心的思想就是不重新造轮子，开箱即用！</p>
<h2 id="Spring框架的设计目标、设计理念以及核心"><a href="#Spring框架的设计目标、设计理念以及核心" class="headerlink" title="Spring框架的设计目标、设计理念以及核心"></a>Spring框架的设计目标、设计理念以及核心</h2><p>Spring设计目标：Spring为开发者提供一个一站式轻量级应用开发平台；</p>
<p>Spring设计理念：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；Spring通过IoC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器，实现解耦；</p>
<blockquote>
<p>POJO是普通java类，具有一部分getter&#x2F;setter方法的那种类就可以称作POJO。相对于bean类缺少了：无参构造方法和序列化serializable接口。</p>
</blockquote>
<p>Spring框架的核心：IoC容器和AOP模块。通过IoC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。</p>
<p>IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p>
<p>Spring 提供的核心功能主要是 <strong>IoC</strong> 和 <strong>AOP</strong>。</p>
<ul>
<li>Spring 官网：<a target="_blank" rel="noopener" href="https://spring.io/">https://spring.io/</a></li>
<li>Github 地址： <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></li>
</ul>
<h2 id="列举一些重要的-Spring-模块"><a href="#列举一些重要的-Spring-模块" class="headerlink" title="列举一些重要的 Spring 模块"></a>列举一些重要的 Spring 模块</h2><p>下图对应的是 Spring4.x 版本。目前最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205091059848.png"></p>
<p><strong>Spring Core</strong></p>
<p>核心模块， Spring 其他所有的功能基本都需要依赖于该模块，主要提供 IoC 依赖注入功能的支持。</p>
<p><strong>Spring Aspects</strong></p>
<p>该模块为与 AspectJ 的集成提供支持。</p>
<p><strong>Spring AOP</strong></p>
<p>提供了面向切面的编程实现。</p>
<p><strong>Spring Data Access&#x2F;Integration ：</strong></p>
<p>Spring Data Access&#x2F;Integration 由 5 个模块组成：</p>
<ul>
<li>spring-jdbc : 提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li>
<li>spring-tx : 提供对事务的支持。</li>
<li>spring-orm : 提供对 Hibernate 等 ORM 框架的支持。</li>
<li>spring-oxm ： 提供对 Castor 等 OXM 框架的支持。</li>
<li>spring-jms : Java 消息服务。</li>
</ul>
<p><strong>Spring Web</strong></p>
<p>Spring Web 由 4 个模块组成：</p>
<ul>
<li>spring-web ：对 Web 功能的实现提供一些最基础的支持。</li>
<li>spring-webmvc ： 提供对 Spring MVC 的实现。</li>
<li>spring-websocket ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li>
<li>spring-webflux ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步.</li>
</ul>
<p><strong>Spring Test</strong></p>
<p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p>
<p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p>
<h2 id="Spring-Spring-MVC-Spring-Boot-之间什么关系"><a href="#Spring-Spring-MVC-Spring-Boot-之间什么关系" class="headerlink" title="Spring,Spring MVC,Spring Boot 之间什么关系?"></a>Spring,Spring MVC,Spring Boot 之间什么关系?</h2><p>很多人对 Spring,Spring MVC,Spring Boot 这三者傻傻分不清楚！这里简单介绍一下这三者，其实很简单，没有什么高深的东西。</p>
<p>Spring 包含了多个功能模块（上面刚刚提高过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。</p>
<p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205091102398.png"></p>
<p>使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！</p>
<p>Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。</p>
<p>Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！</p>
<h1 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h1><p>关于下面一些设计模式的详细介绍，可以看文章<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN#rd">《面试官:“谈谈 Spring 中都用到了那些设计模式?”。》</a> 。</p>
<ul>
<li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring下默认的bean均为singleton，可以通过singleton&#x3D;“true|false” 或者 scope&#x3D;”?”来指定。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
<li>……</li>
</ul>
<h1 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h1><h2 id="如何使用-JPA-在数据库中非持久化一个字段？"><a href="#如何使用-JPA-在数据库中非持久化一个字段？" class="headerlink" title="如何使用 JPA 在数据库中非持久化一个字段？"></a>如何使用 JPA 在数据库中非持久化一个字段？</h2><p>假如我们有下面一个类：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entity</span>(name=<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Id</span></span><br><span class="line">    <span class="variable">@GeneratedValue</span>(strategy = GenerationType.AUTO)</span><br><span class="line">    <span class="variable">@Column</span>(name = <span class="string">&quot;ID&quot;</span>)</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Column</span>(name=<span class="string">&quot;USER_NAME&quot;</span>)</span><br><span class="line">    private String userName;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Column</span>(name=<span class="string">&quot;PASSWORD&quot;</span>)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">String</span> <span class="selector-tag">secrect</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想让<code>secrect</code> 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">String</span> transient1; <span class="comment">// not persistent because of static</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> transient2 = <span class="string">&quot;Satish&quot;</span>; <span class="comment">// not persistent because of final</span></span><br><span class="line">transient <span class="built_in">String</span> transient3; <span class="comment">// not persistent because of transient</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="built_in">String</span> transient4; <span class="comment">// not persistent because of @Transient</span></span><br></pre></td></tr></table></figure>

<p>一般使用后面两种方式比较多</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/blob/main/docs/system-design/framework/spring/spring-knowledge-and-questions-summary.md">JavaGuide&#x2F;spring-knowledge-and-questions-summary.md at main · Snailclimb&#x2F;JavaGuide (github.com)</a></p>
</li>
<li><p>《Spring 技术内幕》</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/wmyskxz/p/8820371.html">http://www.cnblogs.com/wmyskxz/p/8820371.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.journaldev.com/2696/spring-interview-questions-and-answers">https://www.journaldev.com/2696/spring-interview-questions-and-answers</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.edureka.co/blog/interview-questions/spring-interview-questions/">https://www.edureka.co/blog/interview-questions/spring-interview-questions/</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/clwydjgs/p/9317849.html">https://www.cnblogs.com/clwydjgs/p/9317849.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://howtodoinjava.com/interview-questions/top-spring-interview-questions-with-answers/">https://howtodoinjava.com/interview-questions/top-spring-interview-questions-with-answers/</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.tomaszezula.com/2014/02/09/spring-series-part-5-component-vs-bean/">http://www.tomaszezula.com/2014/02/09/spring-series-part-5-component-vs-bean/</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/34172888/difference-between-bean-and-autowired">https://stackoverflow.com/questions/34172888/difference-between-bean-and-autowired</a></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2022/05/09/javaSpring%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94SpringCore/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/09/javaSpring%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94SpringCore/" class="post-title-link" itemprop="url">javaSpring学习（二）——SpringCore</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-09 10:14:13" itemprop="dateCreated datePublished" datetime="2022-05-09T10:14:13Z">2022-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h1><p><strong>IoC（Inverse of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。</p>
<p>IOC的思想是：IoC的核心思想在于资源统一管理,你所持有的资源全部放入到IoC容器中,而你也只需要依赖IoC容器,该容器会自动为你装配所需要的具体依赖，<strong>而不是传统的在你的对象内部直接控制。</strong>对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。</p>
<ul>
<li>谁控制谁，控制什么：<strong>IoC 容器控制了对象</strong>；<strong>主要控制了外部资源获取（不只是对象包括比如文件等）</strong></li>
<li>为何是反转，哪些方面反转了：传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？<strong>因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</strong></li>
</ul>
<blockquote>
<p>当某个角色(可能是一个Java实例，调用者)需要另一个角色(另一个Java实例，被调用者)的协助时，在 传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在Spring里，创建被调用者的工作不再由调用者来完成，因此称为控制反转;<strong>创建被调用者 实例的工作通常由Spring容器来完成，然后注入调用者，因此也称为依赖注入。</strong></p>
<p><strong>注入内容包括：注入某个对象所需要的外部资源（包括对象、资源、常量数据）</strong></p>
</blockquote>
<p><strong>为什么叫控制反转？</strong></p>
<p>Spring所倡导的开发方式：<strong>所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</strong></p>
<ul>
<li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li>
<li><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</li>
</ul>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205110948049.png"></p>
<p>其实<strong>IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC&#x2F;DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。</strong></p>
<p>　　<strong>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</strong></p>
<p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p>
<p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p>
<h2 id="IOC-x2F-DI"><a href="#IOC-x2F-DI" class="headerlink" title="IOC&#x2F;DI"></a>IOC&#x2F;DI</h2><p>引言：Spring 能有效地组织J2EE应用各层的对象。不管是控制层的Action对象，还是业务层的Service对象，还是持久层的DAO对象，都可在Spring的 管理下有机地协调、运行。Spring将各层的对象以松耦合的方式组织在一起，Action对象无须关心Service对象的具体实现，Service对 象无须关心持久层对象的具体实现，<strong>各层对象的调用完全面向接口</strong>。当系统需要重构时，代码的改写量将大大减少。</p>
<p>上面所说的一切都得宜于Spring的核心机制，依赖注入。依赖注入让bean与bean之间以配置文件组织在一起，而不是以硬编码的方式耦合在一起。</p>
<p><strong>IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的</strong>。</p>
<p>如果调用者使用到被调用对象才会从spring容器中取出依赖的对象注入到使用的类中，如果不用则会放回spring容器的对象池中，做到内存节省并且代码的耦合度也降低。面向接口编程中，让依赖注入只需要找到符合规范的接口注入即可实现调用者和被调用者解耦。对象的调用关系由spring管理。</p>
<blockquote>
<p>spring的依赖注入对调用者和被调用者几乎没有任何要求，完全支持对pojo之间依赖关系的管理</p>
</blockquote>
<p>　　<strong>IoC和DI</strong>由什么<strong>关系</strong>呢？其实它们<strong>是同一个概念的不同角度描述</strong>，相对IoC 而言，“依赖注入”明确描述了“<strong>被注入对象依赖IoC容器配置依赖对象</strong>”。</p>
<h3 id="构造器依赖注入和-Setter方法注入的区别"><a href="#构造器依赖注入和-Setter方法注入的区别" class="headerlink" title="构造器依赖注入和 Setter方法注入的区别"></a>构造器依赖注入和 Setter方法注入的区别</h3><table>
<thead>
<tr>
<th>构造函数注入</th>
<th>setter 注入</th>
</tr>
</thead>
<tbody><tr>
<td>没有部分注入</td>
<td>有部分注入</td>
</tr>
<tr>
<td>不会覆盖 setter 属性</td>
<td>会覆盖 setter 属性</td>
</tr>
<tr>
<td>任意修改都会创建一个新实例</td>
<td>任意修改不会创建一个新实例</td>
</tr>
<tr>
<td>适用于设置很多属性</td>
<td>适用于设置少量属性</td>
</tr>
</tbody></table>
<p>两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</p>
<h2 id="IOC原理"><a href="#IOC原理" class="headerlink" title="IOC原理"></a>IOC原理</h2><p>1 Spring的bean容器也叫beanfactory，我们常用的applicationcontext实际上内部有一个listablebeanfactory实际存储bean的map。</p>
<p>2 bean加载过程：spring容器加载时先读取配置文件，一般是xml，然后解析xml，找到其中所有bean，依次解析，然后生成每个bean的beandefinition，存在一个map中，根据beanid映射实际bean的map。</p>
<p>3 bean初始化：加载完以后，如果不启用懒加载模式，则默认使用单例加载，在注册完bean以后，可以获取到beandefinition信息，然后根据该信息首先先检查依赖关系，如果依赖其他bean则先加载其他bean，然后通过反射的方式即newinstance创建一个单例bean。</p>
<p>为什么要用反射呢，因为实现类可以通过配置改变，但接口是一致的，使用反射可以避免实现类改变时无法自动进行实例化。</p>
<p>当然，bean也可以使用原型方式加载，使用原型的话，每次创建bean都会是全新的。</p>
<h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><ul>
<li><a target="_blank" rel="noopener" href="https://javadoop.com/post/spring-ioc">IoC 源码阅读</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486938&idx=1&sn=c99ef0233f39a5ffc1b98c81e02dfcd4&chksm=cea24211f9d5cb07fa901183ba4d96187820713a72387788408040822ffb2ed575d28e953ce7&token=1736772241&lang=zh_CN#rd">面试被问了几百遍的 IoC 和 AOP ，还在傻傻搞不清楚？</a></li>
</ul>
<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><p>AOP(Aspect-Oriented Programming:面向切面编程)利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了 多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的 逻辑或责任封装起来，比如日志记录，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p>
<h2 id="AOP中的相关概念"><a href="#AOP中的相关概念" class="headerlink" title="AOP中的相关概念"></a>AOP中的相关概念</h2><ul>
<li><p><code>Advice</code>（通知）：Advice 定义了在 <code>Pointcut</code> 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。</p>
<p>【就是你想要的功能，也就是上面说的 安全，事物，日志等。你给先定义好，然后在想用的地方用一下。】</p>
</li>
<li><p><code>Joint point</code>（连接点）：spring允许你使用通知的地方，那可真就多了，基本每个方法的前，后（两者都有也行），或抛出异常时都可以是连接点，spring只支持方法连接点.其他如aspectJ还可以让你在构造器或属性注入时都行，不过那不是咱关注的，只要记住，<strong>和方法有关的前前后后（抛出异常），都是连接点。</strong></p>
</li>
<li><p><code>Pointcut</code>（切点）：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。</p>
<p>【你的一个类里，有15个方法，那就有几十个连接点了对把，但是你并不想在所有方法附近都使用通知（使用叫织入，以后再说），你只想让其中的几个，在调用这几个方法之前，之后或者抛出异常时干点什么，那么就用切点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。】</p>
</li>
<li><p><code>Aspect</code>（切面）： 切面是通知和切入点的结合。现在发现了吧，没连接点什么事情，连接点就是为了让你好<strong>理解</strong>切点，搞出来的，明白这个<strong>概念</strong>就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等就能知道），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。</p>
</li>
<li><p><code>introduction</code>(引入)：允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗</p>
</li>
<li><p><code>Target</code>（目标对象）：引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。</p>
</li>
<li><p><code>Weaving</code>（织入）：把切面应用到目标对象来创建新的代理对象的过程。有3种方式，spring采用的是运行时，为什么是运行时，后面解释。</p>
<p>　　关键就是：切点定义了哪些连接点会得到通知</p>
</li>
<li><p><code>proxy</code>（代理）：怎么实现整套aop机制的，都是通过代理。</p>
</li>
</ul>
<h2 id="AOP原理理解"><a href="#AOP原理理解" class="headerlink" title="AOP原理理解"></a>AOP原理理解</h2><p>​	spring用代理类包裹切面，把他们织入到Spring管理的bean中。也就是说代理类伪装成目标类，它会截取对目标类中方法的调用，让调用者对目标类的调用都先变成调用伪装类，伪装类中就先执行了切面，再把调用转发给真正的目标bean。</p>
<p>　　现在可以自己想一想，怎么搞出来这个伪装类，才不会被调用者发现（过JVM的检查，JAVA是强类型检查，哪里都要检查类型）。</p>
<p>　　1.<strong>实现和目标类相同的接口</strong>，我也实现和你一样的接口，反正上层都是接口级别的调用，这样我就伪装成了和目标类一样的类（实现了同一接口，咱是兄弟了），也就逃过了类型检查，到java运行期的时候，利用多态的后期绑定（所以spring采用运行时），伪装类（代理类）就变成了接口的真正实现，而他里面包裹了真实的那个目标类，最后实现具体功能的还是目标类，只不过伪装类在之前干了点事情（写日志，安全检查，事物等）。</p>
<p>　　顺着这个思路想，要是本身这个类就没实现一个接口呢，你怎么伪装我，我就压根没有机会让你搞出这个双胞胎的弟弟，那么就用第2种代理方式，创建一个目标类的子类，生个儿子，让儿子伪装我</p>
<p>　　2.<strong>生成子类调用</strong>，这次用子类来做为伪装类，当然这样也能逃过JVM的强类型检查，我继承的吗，当然查不出来了，子类重写了目标类的所有方法，当然在这些重写的方法中，不仅实现了目标类的功能，还在这些功能之前，实现了一些其他的（写日志，安全检查，事物等）。</p>
<p>　　这次的对比就是，儿子先从爸爸那把本事都学会了，所有人都找儿子办事情，但是儿子每次办和爸爸同样的事之前，都要收点小礼物（写日志），然后才去办真正的事。当然爸爸是不知道儿子这么干的了。这里就有件事情要说，某些本事是爸爸独有的(final的)，儿子学不了，学不了就办不了这件事，办不了这个事情，自然就不能收人家礼了。</p>
<p>　　前一种兄弟模式，spring会使用JDK的java.lang.reflect.Proxy类，它允许Spring动态生成一个新类来实现必要的接口，织入通知，并且把对这些接口的任何调用都转发到目标类。</p>
<p>　　后一种父子模式，spring使用CGLIB库生成目标类的一个子类，在创建这个子类的时候，spring织入通知，并且把对这个子类的调用委托到目标类。</p>
<p>　　相比之下，还是兄弟模式好些，他能更好的实现松耦合，尤其在今天都高喊着面向接口编程的情况下，父子模式只是在没有实现接口的时候，也能织入通知，应当做一种例外。</p>
<h2 id="实现AOP的技术"><a href="#实现AOP的技术" class="headerlink" title="实现AOP的技术"></a>实现AOP的技术</h2><ul>
<li>采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；</li>
<li>采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。</li>
</ul>
<h2 id="Spring实现AOP"><a href="#Spring实现AOP" class="headerlink" title="Spring实现AOP"></a>Spring实现AOP</h2><ol>
<li>JDK动态代理：其代理对象必须是某个接口的实现，它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理；其核心的两个类是InvocationHandler和Proxy。</li>
<li>CGLIB代理：实现原理类似于JDK动态代理，只是它在运行期间生成的代理对象是针对目标类扩展的子类。CGLIB是高效的代码生成包，底层是依靠ASM（开源的java字节码编辑类库）操作字节码实现的，性能比JDK强；需要引入包asm.jar和cglib.jar。</li>
</ol>
<p>如下图所示：</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205110948068.jpeg" alt="SpringAOPProcess"></p>
<p>AOP:</p>
<p>AOP的切面，切点，增强器一般也是配置在xml文件中的，所以bean容器在解析xml时会找到这些内容，并且首先创建增强器bean的实例。</p>
<p>基于上面创建bean的过程，AOP起到了什么作用呢，或者是是否有参与到其中呢，答案是有的。</p>
<p>在获得beandefinition的时候，spring容器会检查该bean是否有aop切面所修饰，是否有能够匹配切点表达式的方法，如果有的话，在创建bean之前，会将bean重新封装成一个动态代理的对象。</p>
<p>代理类会为bean增加切面中配置的advisor增强器，然后返回bean的时候实际上返回的是一个动态代理对象。</p>
<p>所以我们在调用bean的方法时，会自动织入切面的增强器，当然，动态代理既可以选择jdk增强器，也可以选择cglib增强器。</p>
<p>Spring事务：</p>
<p>spring事务其实是一种特殊的aop方式。在spring配置文件中配置好事务管理器和声明式事务注解后，就可以使用@transactional进行事务方法的处理了。</p>
<p>事务管理器的bean中会配置基本的信息，然后需要配置事务的增强器，不同方法使用不同的增强器。当然如果使用注解的话就不用这么麻烦了。</p>
<p>然后和aop的动态代理方式类似，当Spring容器为bean生成代理时，会注入事务的增强器，其中实际上实现了事务中的begin和commit，所以执行方法的过程实际上就是在事务中进行的。</p>
<h2 id="AOP使用场景"><a href="#AOP使用场景" class="headerlink" title="AOP使用场景"></a>AOP使用场景</h2><ol>
<li>Authentication 权限检查</li>
<li>Caching 缓存</li>
<li>Context passing 内容传递</li>
<li>Error handling 错误处理</li>
<li>Lazy loading　延迟加载</li>
<li>Debugging　　调试</li>
<li>logging, tracing, profiling and monitoring　日志记录，跟踪，优化，校准</li>
<li>Performance optimization　性能优化，效率检查</li>
<li>Persistence　　持久化</li>
<li>Resource pooling　资源池</li>
<li>Synchronization　同步</li>
<li>Transactions 事务管理</li>
</ol>
<h2 id="过滤器filter、拦截器interceptor、和AOP的区别与联系"><a href="#过滤器filter、拦截器interceptor、和AOP的区别与联系" class="headerlink" title="过滤器filter、拦截器interceptor、和AOP的区别与联系"></a>过滤器filter、拦截器interceptor、和AOP的区别与联系</h2><h3 id="filter过滤器"><a href="#filter过滤器" class="headerlink" title="filter过滤器"></a>filter过滤器</h3><ul>
<li><strong>过滤器拦截web访问url地址</strong>。 严格意义上讲，filter只是适用于web中，依赖于Servlet容器，利用<strong>Java的回调机制</strong>进行实现。</li>
<li>Filter<strong>过滤器</strong>：和框架无关，可以控制最初的http请求，但是更细一点的类和方法控制不了。</li>
<li>**过滤器可以拦截到方法的请求和响应(ServletRequest request, ServletResponse response)**，并对请求响应做出像响应的过滤操作，</li>
<li>比如<strong>设置字符编码，鉴权操作</strong>等</li>
</ul>
<h3 id="Interceptor拦截器"><a href="#Interceptor拦截器" class="headerlink" title="Interceptor拦截器"></a>Interceptor拦截器</h3><ul>
<li><strong>拦截器拦截以 .action结尾的url，拦截Action的访问</strong>。 Interfactor是基于<strong>Java的反射机制</strong>（APO思想）进行实现，不依赖Servlet容器。</li>
<li><strong>拦截器可以在方法执行之前(preHandle)和方法执行之后(afterCompletion)进行操作，回调操作(postHandle)<strong>，</strong>可以获取执行的方法的名称</strong>，请求(HttpServletRequest)</li>
<li>Interceptor：<strong>可以控制请求的控制器和方法</strong>，但<strong>控制不了请求方法里的参数(只能获取参数的名称，不能获取到参数的值)</strong></li>
<li><strong>（</strong>用于处理页面提交的请求响应并进行处理，例如做国际化，做主题更换，过滤等）。</li>
</ul>
<h3 id="Spring-AOP拦截器"><a href="#Spring-AOP拦截器" class="headerlink" title="Spring AOP拦截器"></a>Spring AOP拦截器</h3><ul>
<li><strong>只能拦截Spring管理Bean的访问（业务层Service）</strong>。 具体AOP详情参照 <a target="_blank" rel="noopener" href="https://blog.csdn.net/fly910905/article/details/84025425">Spring AOP：原理、 通知、连接点、切点、切面、表达式</a></li>
<li>实际开发中，AOP常和事务结合：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fly910905/article/details/83547744">Spring的事务管理:声明式事务管理(切面)</a></li>
<li><strong>AOP操作可以对操作进行横向的拦截</strong>，最大的优势在于他可**以获取执行方法的参数( ProceedingJoinPoint.getArgs() )**，对方法进行统一的处理。</li>
<li>Aspect : 可以自定义切入的点，有方法的参数，<strong>但是拿不到http请求，可以通过其他方式如RequestContextHolder</strong>获得( ServletRequestAttributes servletRequestAttributes&#x3D; (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); )。</li>
<li>常见**使用日志，事务，请求参数安全验证</li>
</ul>
<h2 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h2><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2022/05/08/java-maven%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/08/java-maven%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">java-maven学习（六）——单元测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-07 16:10:13" itemprop="dateCreated datePublished" datetime="2022-05-07T16:10:13Z">2022-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="单元测试概念"><a href="#单元测试概念" class="headerlink" title="单元测试概念"></a>单元测试概念</h1><p><strong>单元测试（Unit Testing）</strong>：是指对软件中的最小可测试单元进行检查和验证。<br>这个定义有点抽象，这里举几个单元测试的特性：一般是一个方法配几个单元测试、单元测试不应该依赖外部系统、单元测试运行速度很快、单元测试不应该造成测试环境的脏数据、单元测试可以重复运行。</p>
<ul>
<li>单元测试就是测试某个方法是否符合设计的逻辑，而且只测试这个方法，不涉及其他依赖方法的测试。</li>
</ul>
<p>这里要注意区分<strong>集成测试</strong>和<strong>单元测试</strong>。</p>
<ul>
<li>集成测试的是测试某个模块的功能，通俗的讲就是测试模块所有用到类和方法。</li>
</ul>
<h2 id="单元测试的重要性"><a href="#单元测试的重要性" class="headerlink" title="单元测试的重要性"></a>单元测试的重要性</h2><blockquote>
<p>“每当我要进行重构的时候，第一个步骤永远相同：我得为即将修改的代码建立一组可靠的测试环境 ” ——摘自《重构：改善既有代码的设计》</p>
</blockquote>
<ol>
<li>单元测试使得我们可以放心修改、重构业务代码，而不用担心修改某处代码后带来的副作用。</li>
<li>单元测试使得系统具备更好的可维护性、具备更好的可读性。</li>
<li>单元测试能提高代码质量，可以帮助我们反思模块划分的合理性，如果一个单元测试写得逻辑非常复杂、或者说一个函数复杂到无法写单测，那就说明模块的抽象有问题。</li>
</ol>
<h2 id="单元测试基本原则"><a href="#单元测试基本原则" class="headerlink" title="单元测试基本原则"></a>单元测试基本原则</h2><p>首先要明确单元测试的一些基本原则，优秀的单元测试具有以下特点：</p>
<ul>
<li>自动的、可重复的</li>
<li>容易实现</li>
<li>一旦写好，将来都可使用</li>
<li>任何人都可运行</li>
<li>单击一个按钮就可运行</li>
<li>可以快速地运行</li>
</ul>
<p>单元测试并非是随手写来验证功能的临时代码，而是需要符合 AIR 原则，所以编写起来是需要一定的功力的。</p>
<ol>
<li>【强制】好的单元测试必须遵守AIR原则。</li>
</ol>
<p>说明：单元测试在线上运行时，感觉像空气（AIR）一样并不存在，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。</p>
<ul>
<li>A：Automatic（自动化）</li>
<li>I：Independent（独立性）</li>
<li>R：Repeatable（可重复）</li>
</ul>
<ol start="2">
<li>【强制】单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用System.out来进行人肉验证，必须使用assert来验证。</li>
<li>【强制】保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。</li>
</ol>
<p>反例：method2需要依赖method1的执行，将执行结果作为method2的输入。</p>
<ol start="4">
<li>【强制】单元测试是可以重复执行的，不能受到外界环境的影响。</li>
</ol>
<p>说明：单元测试通常会被放到持续集成中，每次有代码check in时单元测试都会被执行。如果单测对外部环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。<br>正例：为了不受外界环境影响，要求设计代码时就把SUT的依赖改成注入，在测试时用spring 这样的DI框架注入一个本地（内存）实现或者Mock实现。</p>
<ol start="5">
<li>【强制】对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。</li>
</ol>
<p>说明：只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑，那是集成测试的领域。</p>
<ol start="6">
<li>【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过。</li>
</ol>
<p>说明：新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。</p>
<h1 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h1><p>在Java的单元测试领域主流工具为JUnit与Mockito。JUnit 负责写单元测试业务逻辑，Mockito负责mock依赖。</p>
<p>JUnit5的主要特性：</p>
<ul>
<li>提供全新的断言和测试注解，支持测试类内嵌</li>
<li>更丰富的测试方式：支持动态测试，重复测试，参数化测试等</li>
<li>实现了模块化，让测试执行和测试发现等不同模块解耦，减少依赖</li>
<li>提供对 Java 8 的支持，如 Lambda 表达式，Sream API等。</li>
</ul>
<p>JUnit5 包含3个部分：</p>
<ul>
<li><p>JUnit Platform： 用于JVM上启动测试框架的基础服务，提供命令行，IDE和构建工具等方式执行测试的支持。</p>
</li>
<li><p>JUnit Jupiter：包含 JUnit 5 新的编程模型和扩展模型，主要就是用于编写测试代码和扩展代码。</p>
</li>
<li><p>JUnit Vintage：用于在JUnit 5 中兼容运行 JUnit3.x 和 JUnit4.x 的测试用例。</p>
</li>
</ul>
<h2 id="JUnit5常见用法介绍"><a href="#JUnit5常见用法介绍" class="headerlink" title="JUnit5常见用法介绍"></a>JUnit5常见用法介绍</h2><p>首先，在 Maven 工程里引入 JUnit 5 的依赖坐标，需注意的是当前JDK 环境要在 Java 8 以上。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="第一个测试用例"><a href="#第一个测试用例" class="headerlink" title="第一个测试用例"></a>第一个测试用例</h3><p>引入JUnit 5，我们可以先快速编写一个简单的测试用例，从这个测试用例来认识初步下 JUnit 5：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;我的第一个测试用例&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFirstTestCaseTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cleanup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;清理数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前测试方法开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前测试方法结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DisplayName(&quot;我的第一个测试&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testFirstTest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的第一个测试开始测试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DisplayName(&quot;我的第二个测试&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSecondTest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的第二个测试开始测试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接运行这个测试用例，可以看到控制台日志如下：</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205090926685.webp"></p>
<p>可以看到左边一栏的结果里显示测试项名称就是我们在测试类和方法上使用 <strong>@DisplayName</strong> 设置的名称，这个注解就是 JUnit 5 引入，用来定义一个测试类并指定用例在测试报告中的展示名称，这个注解可以使用在类上和方法上，在类上使用它就表示该类为测试类，在方法上使用则表示该方法为测试方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@API(status = STABLE, since = &quot;5.0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DisplayName &#123;</span><br><span class="line">	String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看下示例代码中使用到的一对注解 **@BeforeAll **和 <strong>@AfterAll <strong>，它们定义了整个测试类在开始前以及结束时的操作，</strong>只能修饰静态方法，主要用于在测试过程中所需要的全局数据和外部资源的初始化和清理。</strong></p>
<p><strong>@BeforeEach</strong> 和 <strong>@AfterEach</strong> 所标注的方法会在每个测试用例方法开始前和结束时执行，主要是负责该测试用例所需要的运行环境的准备和销毁。</p>
<h3 id="禁用执行测试：-Disabled"><a href="#禁用执行测试：-Disabled" class="headerlink" title="禁用执行测试：@Disabled"></a>禁用执行测试：@Disabled</h3><p>当我们希望在运行测试类时，跳过某个测试方法，正常运行其他测试用例时，我们就可以用上 @Disabled 注解，表明该测试方法处于不可用，执行测试类的测试方法时不会被 JUnit 执行。</p>
<p>下面看下使用 @Disbaled 之后的运行效果，在原来测试类中添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;我的第三个测试&quot;)</span></span><br><span class="line"><span class="meta">@Disabled</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testThirdTest</span><span class="params">()</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;我的第三个测试开始测试&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后看到控制台日志如下，用 @Disabled 标记的方法不会执行，只有单独的方法信息打印：</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205090929931.webp" alt="img"></p>
<p>@Disabled 也可以使用在类上，用于标记类下所有的测试方法不被执行，一般使用对多个测试类组合测试的时候。</p>
<h3 id="内嵌测试类：-Nested"><a href="#内嵌测试类：-Nested" class="headerlink" title="内嵌测试类：@Nested"></a>内嵌测试类：@Nested</h3><p>当我们编写的类和代码逐渐增多，随之而来的需要测试的对应测试类也会越来越多。为了解决测试类数量爆炸的问题，JUnit 5提供了@Nested 注解，能够以静态内部成员类的形式对测试用例类进行逻辑分组。 并且每个静态内部类都可以有自己的生命周期方法， 这些方法将按从外到内层次顺序执行。 此外，嵌套的类也可以用@DisplayName 标记，这样我们就可以使用正确的测试名称。下面看下简单的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;内嵌测试类&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NestUnitTest</span> &#123;</span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试方法执行前准备&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;第一个内嵌测试类&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FirstNestTest</span> &#123;</span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第一个内嵌测试类执行测试&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;第二个内嵌测试类&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SecondNestTest</span> &#123;</span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第二个内嵌测试类执行测试&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行所有测试用例后，在控制台能看到如下结果：</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205090929926.webp"></p>
<h3 id="重复性测试：-RepeatedTest"><a href="#重复性测试：-RepeatedTest" class="headerlink" title="重复性测试：@RepeatedTest"></a>重复性测试：@RepeatedTest</h3><p>在 JUnit 5 里新增了对测试方法设置运行次数的支持，允许让测试方法进行重复运行。当要运行一个测试方法 N次时，可以使用 @RepeatedTest 标记它，如下面的代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;重复测试&quot;)</span></span><br><span class="line"><span class="meta">@RepeatedTest(value = 3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">i_am_a_repeated_test</span><span class="params">()</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;执行测试&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后测试方法会执行3次，在 IDEA 的运行效果如下图所示：</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205090929926.webp" alt="img"></p>
<p>这是基本的用法，我们还可以对重复运行的测试方法名称进行修改，利用 @RepeatedTest  提供的内置变量，以占位符方式在其 <code>name</code> 属性上使用，下面先看下使用方式和效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;自定义名称重复测试&quot;)</span></span><br><span class="line"><span class="meta">@RepeatedTest(value = 3, name = &quot;&#123;displayName&#125; 第 &#123;currentRepetition&#125; 次&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">i_am_a_repeated_test_2</span><span class="params">()</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;执行测试&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205090929920.webp"></p>
<p>@RepeatedTest 注解内用 <code>currentRepetition</code> 变量表示已经重复的次数，<code>totalRepetitions</code> 变量表示总共要重复的次数，<code>displayName</code> 变量表示测试方法显示名称，我们直接就可以使用这些内置的变量来重新定义测试方法重复运行时的名称。</p>
<h3 id="新的断言"><a href="#新的断言" class="headerlink" title="新的断言"></a>新的断言</h3><p>在断言 API 设计上，JUnit 5 进行显著地改进，并且充分利用 Java 8 的新特性，特别是 Lambda 表达式，最终提供了新的断言类: <strong>org.junit.jupiter.api.Assertions</strong> 。许多断言方法接受 Lambda 表达式参数，在断言消息使用 Lambda 表达式的一个优点就是它是延迟计算的，如果消息构造开销很大，这样做一定程度上可以节省时间和资源。</p>
<p>现在还可以将一个方法内的多个断言进行分组，使用 assertAll 方法如下示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGroupAssertions</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] numbers = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    Assertions.assertAll(<span class="string">&quot;numbers&quot;</span>,</span><br><span class="line">            () -&gt; Assertions.assertEquals(numbers[<span class="number">1</span>], <span class="number">1</span>),</span><br><span class="line">            () -&gt; Assertions.assertEquals(numbers[<span class="number">3</span>], <span class="number">3</span>),</span><br><span class="line">            () -&gt; Assertions.assertEquals(numbers[<span class="number">4</span>], <span class="number">4</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果分组断言中任一个断言的失败，都会将以 MultipleFailuresError 错误进行抛出提示。</p>
<h3 id="超时操作的测试：assertTimeoutPreemptively"><a href="#超时操作的测试：assertTimeoutPreemptively" class="headerlink" title="超时操作的测试：assertTimeoutPreemptively"></a>超时操作的测试：assertTimeoutPreemptively</h3><p>当我们希望测试耗时方法的执行时间，并不想让测试方法无限地等待时，就可以对测试方法进行超时测试，JUnit 5 对此推出了断言方法 <code>assertTimeout</code>，提供了对超时的广泛支持。</p>
<p>假设我们希望测试代码在一秒内执行完毕，可以写如下测试用例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;超时方法测试&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test_should_complete_in_one_second</span><span class="params">()</span> &#123;</span><br><span class="line">  Assertions.assertTimeoutPreemptively(Duration.of(<span class="number">1</span>, ChronoUnit.SECONDS), () -&gt; Thread.sleep(<span class="number">2000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个测试运行失败，因为代码执行将休眠两秒钟，而我们期望测试用例在一秒钟之内成功。但是如果我们把休眠时间设置一秒钟，测试仍然会出现偶尔失败的情况，这是因为测试方法执行过程中除了目标代码还有额外的代码和指令执行会耗时，所以在超时限制上无法做到对时间参数的完全精确匹配。</p>
<h3 id="异常测试：assertThrows"><a href="#异常测试：assertThrows" class="headerlink" title="异常测试：assertThrows"></a>异常测试：assertThrows</h3><p>我们代码中对于带有异常的方法通常都是使用 try-catch 方式捕获处理，针对测试这样带有异常抛出的代码，而 JUnit 5 提供方法 <code>Assertions#assertThrows(Class&lt;T&gt;, Executable)</code> 来进行测试，第一个参数为异常类型，第二个为函数式接口参数，跟 Runnable 接口相似，不需要参数，也没有返回，并且支持 Lambda表达式方式使用，具体使用方式可参考下方代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;测试捕获的异常&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">assertThrowsException</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  Assertions.assertThrows(IllegalArgumentException.class, () -&gt; &#123;</span><br><span class="line">    Integer.valueOf(str);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Lambda表达式中代码出现的异常会跟首个参数的异常类型进行比较，如果不属于同一类异常，就会控制台输出如下类似的提示：<code>org.opentest4j.AssertionFailedError: Unexpected exception type thrown ==&gt; expected: &lt;IllegalArgumentException&gt; but was: &lt;...Exception&gt;</code></p>
<h2 id="JUnit-5-参数化测试"><a href="#JUnit-5-参数化测试" class="headerlink" title="JUnit 5 参数化测试"></a>JUnit 5 参数化测试</h2><p>要使用 JUnit 5 进行参数化测试，除了 junit-jupiter-engine 基础依赖之外，还需要另个模块依赖：<strong>junit-jupiter-params</strong>，其主要就是提供了编写参数化测试 API。同样方式，把相同版本的对应依赖引入 Maven 工程中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-params<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="基本数据源测试：-ValueSource"><a href="#基本数据源测试：-ValueSource" class="headerlink" title="基本数据源测试： @ValueSource"></a>基本数据源测试： @ValueSource</h3><p>@ValueSource 是 JUnit 5 提供的最简单的数据参数源，支持 Java 的八大基本类型和字符串，Class，使用时赋值给注解上对应类型属性，以数组方式传递，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParameterizedUnitTest</span> &#123;</span><br><span class="line">    <span class="meta">@ParameterizedTest</span></span><br><span class="line">    <span class="meta">@ValueSource(ints = &#123;2, 4, 8&#125;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testNumberShouldBeEven</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        Assertions.assertEquals(<span class="number">0</span>, num % <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ParameterizedTest</span></span><br><span class="line">    <span class="meta">@ValueSource(strings = &#123;&quot;Effective Java&quot;, &quot;Code Complete&quot;, &quot;Clean Code&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testPrintTitle</span><span class="params">(String title)</span> &#123;</span><br><span class="line">        System.out.println(title);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@ParameterizedTest 作为参数化测试的必要注解，替代了 @Test 注解。任何一个参数化测试方法都需要标记上该注解。</p>
</blockquote>
<p>运行测试，结果如下图所示，针对 @ValueSource 里每个参数都会运行目标方法，一旦哪个参数运行测试失败，就意味着该测试方法不通过。</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205090944263.webp" alt="img"></p>
<h3 id="CSV-数据源测试：-CsvSource"><a href="#CSV-数据源测试：-CsvSource" class="headerlink" title="CSV 数据源测试：@CsvSource"></a>CSV 数据源测试：@CsvSource</h3><p>通过 @CsvSource 可以注入指定 CSV 格式 (comma-separated-values)   的一组数据，用每个逗号分隔的值来匹配一个测试方法对应的参数，下面是使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvSource(&#123;&quot;1,One&quot;, &quot;2,Two&quot;, &quot;3,Three&quot;&#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDataFromCsv</span><span class="params">(<span class="type">long</span> id, String name)</span> &#123;</span><br><span class="line">	System.out.printf(<span class="string">&quot;id: %d, name: %s&quot;</span>, id, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如图所示，除了用逗号分隔参数外，@CsvSource 还支持自定义符号，只要修改它的 <code>delimiter</code> 即可，默认为 <code>，</code>。</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/202205090944245.webp" alt="img"></p>
<p>JUnit 还提供了读取外部 CSV 格式文件数据的方式作为数据源的实现，我们只要用 @CsvFileSource 指定资源文件路径即可，使用起来跟 @CsvSource 一样简单这里就不再重复演示了。</p>
<blockquote>
<p>@CsvFileSource 指定的资源文件路径时要以 <code>/</code> 开始，寻找当前测试资源目录下文件。</p>
</blockquote>
<p>除了上面提到的三种数据源方式外，JUnit 还提供了以下三种数据源：</p>
<ul>
<li><strong>@EnumSource</strong>：允许我们通过参数值，给指定 Enum 枚举类型传入，构造出枚举类型中特定的值。</li>
<li><strong>@MethodSource</strong>：指定一个返回的 Stream &#x2F; Array &#x2F; 可迭代对象 的方法作为数据源。 需要注意的是该方法必须是静态的，并且不能接受任何参数。</li>
<li><strong>@ArgumentSource</strong>：通过实现 ArgumentsProvider 接口的参数类来作为数据源，重写它的 <code>provideArguments</code> 方法可以返回自定义类型的 Stream<Arguments>  ，作为测试方法所需要的数据使用。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2022/05/07/java-maven%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94Nexus%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/07/java-maven%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94Nexus%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%8D/" class="post-title-link" itemprop="url">java-maven学习（五）——Nexus搭建私服</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-07 14:10:53" itemprop="dateCreated datePublished" datetime="2022-05-07T14:10:53Z">2022-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><h2 id="什么是私服"><a href="#什么是私服" class="headerlink" title="什么是私服"></a>什么是私服</h2><p>私服是指私有服务器,是假设在局域网的一种特殊的远程仓库,目的是代理远程仓库及部署第三方构建.有了私服之后,当maven需要下载构件时,直接请求私服,私服上存在则下载到本地仓库;否则,私服请求外部的远程仓库,将构件下载到私服,在提供给本地仓库下载。</p>
<h2 id="什么是Nexus"><a href="#什么是Nexus" class="headerlink" title="什么是Nexus"></a>什么是Nexus</h2><p>Nexus是一个强大的maven仓库管理器，它极大的简化了本地内部仓库的维护和外部仓库的访问</p>
<p>Nexus是一套开箱即用的系统不需要数据库，它使用文件系统加Lucene来组织数据</p>
<p>Nexus使用ExtJS来开发界面，利用Restlet来提供完整的REST APIs，通过IDEA和Eclipse集成使用</p>
<p>Nexus支持WebDAV与LDAP安全身份认证</p>
<p>Nexus提供了强大的仓库管理功能，构件搜索功能，它基于REST，友好的UI是一个extjs的REST客户端，占用较少的内存,基于简单文件系统而非数据库。</p>
<h2 id="Nexus搭建私服的优点"><a href="#Nexus搭建私服的优点" class="headerlink" title="Nexus搭建私服的优点"></a>Nexus搭建私服的优点</h2><ul>
<li>内网访问，节省外网带宽。</li>
<li>一次外网下载，内网所有用户就可以只下载私服缓存，加速 Maven 项目构建。</li>
<li>允许上传和下载私有库，并且不被外部访问，更加安全。</li>
<li>减少外部网络因素，提供项目构建的稳定性。</li>
<li>方便内部项目服务的依赖引用，而不需要其他项目的完整源代码。</li>
<li>有利于公共构件的维护</li>
<li>提高工作效率</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7043334312975925262">参考文章</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rhb</p>
  <div class="site-description" itemprop="description">纵浪大化中，不喜亦不惧</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">140</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RShawshank" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RShawshank" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rhb</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://lib.baomitu.com/canvas-nest.js/1.0.1/canvas-nest.js"></script>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
