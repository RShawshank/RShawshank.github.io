<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rshawshank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="贪心算法贪心算法是这样一种方法：分步骤实施，它在每一步仅作出当时看起来最佳的选择，即局部最优的选择，并希望通过这样的选择最终能找到全局最优解。 贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。） 所以，对所采用的贪心策略一定要仔细分析其是否满">
<meta property="og:type" content="article">
<meta property="og:title" content="贪心算法">
<meta property="og:url" content="http://rshawshank.github.io/2020/01/02/Algorithm_%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="rhb_blog">
<meta property="og:description" content="贪心算法贪心算法是这样一种方法：分步骤实施，它在每一步仅作出当时看起来最佳的选择，即局部最优的选择，并希望通过这样的选择最终能找到全局最优解。 贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。） 所以，对所采用的贪心策略一定要仔细分析其是否满">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-20200102212604104.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-20200102213951216.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/1364295841_4708.jpg">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/1364296506_7690.jpg">
<meta property="article:published_time" content="2020-01-02T15:47:35.000Z">
<meta property="article:modified_time" content="2020-01-08T01:32:46.000Z">
<meta property="article:author" content="rhb">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="贪心算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://rshawshank.github.io/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-20200102212604104.png">

<link rel="canonical" href="http://rshawshank.github.io/2020/01/02/Algorithm_%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>贪心算法 | rhb_blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rhb_blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">rao的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="sitemap fa-fw"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/01/02/Algorithm_%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          贪心算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-02 15:47:35" itemprop="dateCreated datePublished" datetime="2020-01-02T15:47:35Z">2020-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-08 01:32:46" itemprop="dateModified" datetime="2020-01-08T01:32:46Z">2020-01-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>贪心算法是这样一种方法：分步骤实施，它<strong>在每一步仅作出当时看起来最佳的选择</strong>，即<strong>局部最优的选择</strong>，并希望通过这样的选择最终能找到<strong>全局最优解</strong>。</p>
<p>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。）</p>
<p><strong>所以，对所采用的贪心策略一定要仔细分析其是否满足无后效性。</strong></p>
<blockquote>
<p>最优解问题大部分都可以拆分成一个个的子问题，把解空间的遍历视作对子问题树的遍历，则以某种形式对树整个的遍历一遍就可以求出最优解，大部分情况下这是不可行的。<strong>贪心算法和动态规划本质上是对子问题树的一种修剪，两种算法要求问题都具有的一个性质就是子问题最优性</strong>(组成最优解的每一个子问题的解，对于这个子问题本身肯定也是最优的)。动态规划方法代表了这一类问题的一般解法，我们自底向上构造子问题的解，对每一个子树的根，求出下面每一个叶子的值，并且以其中的最优值作为自身的值，其它的值舍弃。而贪心算法是动态规划方法的一个特例，可以证明每一个子树的根的值不取决于下面叶子的值，而只取决于当前问题的状况。换句话说，不需要知道一个节点所有子树的情况，就可以求出这个节点的值。由于贪心算法的这个特性，它对解空间树的遍历不需要自底向上，而只需要自根开始，选择最优的路，一直走到底就可以了。</p>
</blockquote>
<p>对比动态规划方法：</p>
<p>在动态规划方法中，每个步骤也都要进行一次选择，但这种选择通常依赖于子问题的解，这导致我们要先求解较小的子问题，然后才能计算较大的子问题。</p>
<p>在贪心方法中，我们总是做出当前看来最佳的选择，然后求解剩下的唯一一个子问题。尽管贪心算法进行选择时可能依赖之前做出的选择，但不依赖任何将来的选择或子问题的解。</p>
<p>动态规划要先求解子问题才能进行选择，贪心算法在进行第一次选择之前不需要求解任何子问题。</p>
<p>动态规划算法通常采用自底向上的方式完成计算，而贪心算法通常是自顶向下的，每一次选择，将给定的问题转换成一个更小的问题，然后继续求解小问题</p>
<h2 id="贪心算法的步骤"><a href="#贪心算法的步骤" class="headerlink" title="贪心算法的步骤"></a>贪心算法的步骤</h2><p>贪心算法通常采用自顶向下的设计，做出一个选择，然后求解剩下的子问题。每次选择将问题转化成一个更小规模的问题。</p>
<ul>
<li><p>确定问题的最优子结构</p>
</li>
<li><p>将最优化问题转化为这样的形式：每次对其作出选择后，只剩下一个子问题需要求解；</p>
</li>
<li><p>证明作出贪心选择后，剩余的子问题满足：其最优子解与前面的贪心选择组合即可得到原问题的最优解(具有最优子结构)。</p>
</li>
</ul>
<p>注：对应每个贪心算法，都有一个动态规划算法，但动态规划算法要繁琐的多。</p>
<h2 id="贪心算法存在的问题"><a href="#贪心算法存在的问题" class="headerlink" title="贪心算法存在的问题"></a>贪心算法存在的问题</h2><ul>
<li>不能保证求得的最后解是最佳的</li>
<li>不能用来求最大值或最小值的问题</li>
<li>只能求满足某些约束条件的可行解的范围</li>
</ul>
<h2 id="贪心算法适用的问题"><a href="#贪心算法适用的问题" class="headerlink" title="贪心算法适用的问题"></a>贪心算法适用的问题</h2><p><strong>贪心策略适用的前提是：局部最优策略能导致产生全局最优解。</strong><br>实际上，贪心算法适用的情况很少。一般对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可以做出判断。</p>
<h2 id="活动选择问题"><a href="#活动选择问题" class="headerlink" title="活动选择问题"></a>活动选择问题</h2><p>有n个需要在同一天使用同一个教室的活动a1,a2,…,an，教室同一时刻只能由一个活动使用。每个活动ai都有一个开始时间si和结束时间fi 。一旦被选择后，活动ai就占据半开时间区间[si,fi)。如果[si,fi]和[sj,fj]互不重叠，ai和aj两个活动就可以被安排在这一天。</p>
<p>活动选择问题：就是对给定的包含n个活动的集合S，在已知每个活动开始时间和结束时间的条件下，从中选出最多可兼容活动的子集合，称为最大兼容活动集合。不失一般性，设活动已经按照结束时间单调递增排序：</p>
<p>$$<br>f1&lt;&#x3D;f2&lt;&#x3D;f3&lt;&#x3D;f4&lt;&#x3D;…&lt;&#x3D;fn-1&lt;&#x3D;fn<br>$$</p>
<h3 id="活动选择问题的最优子结构"><a href="#活动选择问题的最优子结构" class="headerlink" title="活动选择问题的最优子结构"></a>活动选择问题的最优子结构</h3><p>令S<del>ij</del>表示在ai结束之后开始且在a<del>j</del>开始之前结束的那些活动的集合。</p>
<p>问题和子问题的形式定义如下：设A<del>ij</del>是S<del>ij</del>的一个最大兼容活动集，并设A<del>ij</del>包含活动a<del>k</del>，则有：<strong>A<del>ik</del>表示A<del>ij</del>中a<del>k</del>开始之前的活动子集，A<del>kj</del>表示A<del>ij</del>中a<del>k</del>结束之后的活动子集</strong>。并得到两个子问题：寻找S<del>ik</del>的最大兼容活动集合和寻找S<del>kj</del>的最大兼容活动集合。</p>
<p>活动选择问题具有最优子结构性，即：必有：A<del>ik</del>是S<del>ik</del>一个最大兼容活动子集，A<del>kj</del>是S<del>kj</del>一个最大兼容活动子集。而A<del>ij</del>&#x3D; A<del>ik</del>∪{a<del>k</del>}∪A<del>kj</del>。——最优子结构性成立。</p>
<h3 id="活动选择问题的动态规划方法"><a href="#活动选择问题的动态规划方法" class="headerlink" title="活动选择问题的动态规划方法"></a>活动选择问题的动态规划方法</h3><p>$$<br>c[i,j]表示集合s_{ij}的最优解大小，递归式如下：\<br>c[i,j]&#x3D;c[i,k]+c[k,j]+1\<br>c[i,j]&#x3D;\begin{cases}<br>0,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\quad S_{ij}&#x3D;\Phi\<br>\max\limits_{a_k\in S_{ij}}(c[i,k]+c[k,j]+1)\ \ if\quad S_{ij}\not&#x3D;\Phi<br>\end{cases}<br>$$</p>
<h3 id="活动选择问题的贪心算法"><a href="#活动选择问题的贪心算法" class="headerlink" title="活动选择问题的贪心算法"></a>活动选择问题的贪心算法</h3><p>活动选择问题的贪心选择：每次总选择具有最早结束时间的兼容活动加入到集合A中。</p>
<p>直观上，按这种方法选择兼容活动可以为未安排的活动留下尽可能多的时间。也就是说，该算法的贪心选择的意义是使剩余的可安排时间段最大化，以便安排尽可能多的兼容活动。</p>
<h4 id="贪心算法的正确性"><a href="#贪心算法的正确性" class="headerlink" title="贪心算法的正确性"></a>贪心算法的正确性</h4><p>假设A<del>ij</del>是S<del>ij</del>的某个最大兼容活动集，假设A<del>ij</del>中，最早结束的活动是a<del>n</del>，分两种情况：</p>
<p>1、如果a<del>n</del>&#x3D;a<del>i</del> ,得证</p>
<p>2、如果a<del>n</del>！&#x3D; a<del>i</del> ，则a<del>n</del>的结束时间一定会晚于a<del>1</del>的结束时间，我们用a<del>i</del>去替换A<del>ij</del>中的a<del>n</del>，于是得到A^1^，由于a<del>i</del>比a<del>n</del>结束的早，而A<del>ij</del>中的其他活动都比a<del>n</del>的结束时间开始 的要晚，所以A^1^中的其他活动 都与a<del>i</del>不想交，所以A^1^中的所有活动是兼容的，所以A^1^也是S<del>ij</del>的一个最大兼容活动集。</p>
<h4 id="贪心算法的递归实现"><a href="#贪心算法的递归实现" class="headerlink" title="贪心算法的递归实现"></a>贪心算法的递归实现</h4><p>自顶向下的设计</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s、f数组分别表示n个活动的开始时间和结束时间，假设n个活动已经按照结束时间单调递增排列好了</span></span><br><span class="line"><span class="comment">//list用来保存已选的活动</span></span><br><span class="line"><span class="comment">//对于当前的k，返回Sk的一个最大兼容活动集</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; RECURSIVE_ACTIVITY+SELECTOR(List&lt;Integer&gt; list,<span class="type">int</span>[] s ,<span class="type">int</span>[] f,<span class="type">int</span> k,<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> k+<span class="number">1</span>;<span class="comment">//表示是当前剩下没有添加到list的第一个活动</span></span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">        list.add(m);</span><br><span class="line">    <span class="comment">//往后找f[k]&lt;=s[m]的活动</span></span><br><span class="line">    <span class="keyword">while</span>(m&lt;=s.length&amp;&amp;s[m]&lt;f[k])</span><br><span class="line">    &#123;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        list.add[m+<span class="number">1</span>];<span class="comment">//m+1对应活动编号。k=0时的第一个加入的活动编号为1</span></span><br><span class="line">        RECURSIVE_ACTIVITY+SELECTOR(s,f,m,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="贪心算法的迭代实现"><a href="#贪心算法的迭代实现" class="headerlink" title="贪心算法的迭代实现"></a>贪心算法的迭代实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; GREEDY_ACTIVITY+SELECTOR(List&lt;Integer&gt; list,<span class="type">int</span>[] s ,<span class="type">int</span>[] f,<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">   	list.add(k);<span class="comment">//添加第一个活动。</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">2</span>;m&lt;=n;m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[m]&gt;=f[k])<span class="comment">//依次添加符合条件的活动，反正f都是排好序的</span></span><br><span class="line">        &#123;</span><br><span class="line">            list.add(m);</span><br><span class="line">            k=m</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="分数背包问题"><a href="#分数背包问题" class="headerlink" title="分数背包问题"></a>分数背包问题</h2><p>已知n种物品，各具有重量(w<del>1</del>,w<del>2</del>,…,w<del>n</del>)和效益值(p<del>1</del>,p<del>2</del>,…,p<del>n</del>)，及一个可容纳M重量的背包。</p>
<p>问：怎样装包才能使在不超过背包容量的前提下，装入背包的物品的总效益最大？</p>
<p>​	这里：</p>
<p>​				1）所有的w<del>i</del>&gt;0, p<del>i</del>&gt;0，1≤i≤n；</p>
<p>​				2）问题的解用向量(x<del>1</del>,x<del>2</del>,…,x<del>n</del>)表示，每个x<del>i</del>表示物品i被放入背包的比例，0≤x<del>i</del>≤1。当物品i的一部分x<del>i</del>放入背包，可得到p<del>i</del>x<del>i</del>的效益，同时会占用x<del>i</del>w<del>i</del>的重量。</p>
<p>问题分析：</p>
<ul>
<li><p>装入背包的总重量小于等于M，即：<br>$$<br>\sum_{1&lt;&#x3D;i&lt;&#x3D;n}W_iX_i&lt;&#x3D;M<br>$$</p>
</li>
<li><p>$$<br>求\sum_{1&lt;&#x3D;i&lt;&#x3D;n}P_iX_i的最大值<br>$$</p>
</li>
<li><p>可行解：满足上述约束条件的任一(x<del>1</del>,x<del>2</del>,…,x<del>n</del>) 都是问题的一个可行解。可行解可能有多个（甚至是无穷多个）。</p>
</li>
<li><p>最优解：能够使目标函数取最大值的可行解是问题的最优解。最优解也可能有多个。</p>
</li>
</ul>
<h3 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h3><p>这里我们需要思考：</p>
<p>1、策略一：以每装入一件物品，就使背包获得最大可能的效益增量作为策略</p>
<p>2、策略二：让背包容量尽可能慢地被消耗，从而可以尽可能多地装入一些物品。</p>
<p>3、如下的贪心策略</p>
<p>我们要设计一个贪心策略来使得装入背包物品的价值最大。我们的第一直觉肯定是要选择单位重量价格最高的。</p>
<p>然后再选择物品里面第二高的，一次类推直到装满背包为止！</p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>可以利用反证法求证策略一和策略二都不是最优解。</p>
<p>策略三：</p>
<p><strong>需要注意的是X<del>i</del> 的值是小于等于1的</strong></p>
<p>我们首先假设我们有一个最优解A<del>1</del>,那么我们首先找到A<del>1</del>里面单位价值最高的物品a<del>m</del></p>
<ul>
<li>情况一：a<del>m</del>&#x3D;商品里面单位价值最高的物品a<del>1</del>。那么问题得证（因为只要不断拿掉单位价值最高的即可）</li>
<li>情况二：a<del>m</del>&lt;a<del>1</del>。运用剪枝技巧，讲a<del>m</del> 剪掉，补上a<del>1</del> （a<del>1</del>将a<del>m</del>进行全部替换或者部分替换）<ul>
<li>如果a<del>m</del> 的重量比a<del>1</del> 的重量小，a<del>1</del> 全部替换a<del>m</del>，</li>
<li>如果a<del>m</del> 的重量比a<del>1</del> 的重量大，a<del>1</del> 部分替换a<del>m</del>，其余部分保留</li>
</ul>
</li>
</ul>
<h2 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h2><p>其中变长编码表是通过一种评估来源符号出现机率的方法得到的，<strong>出现机率高的字母使用较短的编码，反之出现机率低的则使用较长的编码</strong>，这便使编码之后的字符串的平均长度、期望值降低，从而达到无损压缩数据的目的。</p>
<p>前缀码(Prefix code)：任何码字都不是其它码字的前缀。</p>
<p>问题是：如何设计前缀码？</p>
<h3 id="编码树"><a href="#编码树" class="headerlink" title="编码树"></a>编码树</h3><p>一种为表示字符二进制编码而构造的二叉树。</p>
<p>叶子结点：对应给定的字符，每个字符对应一个叶子结点。</p>
<p>编码构造：字符的二进制码字由根结点到该字符叶子结点的简单路径表示：0代表转向左孩子，1代表转向右孩子。</p>
<p><img src="/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-20200102212604104.png"></p>
<p>一个文件的最优字符编码方案总对应一棵满(full)二叉树，即每个非叶子结点都有两个孩子结点。</p>
<h3 id="最优编码方案"><a href="#最优编码方案" class="headerlink" title="最优编码方案"></a>最优编码方案</h3><p>文件的最优编码方案对应一棵满二叉树。</p>
<ul>
<li><p>设C为字母表</p>
<ul>
<li>对字母表C中的任意字符c，令属性c.freq表示字符c在文件中出现的频率（设所有字符的出现频率均为正数）。</li>
<li>最优前缀码对应的树中恰好有|C|个叶子结点，每个叶子结点对应字母表中的一个字符，且恰有|C|-1个内部结点。</li>
</ul>
</li>
<li><p>令T表示一棵前缀编码树；</p>
</li>
<li><p>令d<del>T</del>(c)表示c的叶子结点在树T中的深度（根到叶子结点的路径长度）。</p>
<ul>
<li>d<del>T</del>(c)也是字符c对应的码字的长度。</li>
</ul>
</li>
</ul>
<p>令B(T)表示采用编码方案T时文件的编码长度，则：<br>$$<br>B(T)&#x3D;\sum_{c\in C}c.freq*d_T(c)<br>$$<br>即文件要用B(T)个二进制位表示.</p>
<ul>
<li>称B(T)为T的代价。</li>
<li>最优编码：对给定的字符集和文件，使文件的编码长度最小的编码称为最优编码。<ul>
<li>Huffman编码是一种最优编码。</li>
</ul>
</li>
</ul>
<h3 id="Huffman编码的贪心算法"><a href="#Huffman编码的贪心算法" class="headerlink" title="Huffman编码的贪心算法"></a>Huffman编码的贪心算法</h3><p>自底向上法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HUFFMAN(C)<span class="comment">//C表示字母表</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n=C.size();</span><br><span class="line">    <span class="type">queue</span> <span class="variable">Q</span> <span class="operator">=</span>C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">node</span> z;</span><br><span class="line">        z.left = x = EXTRACT_MIN(Q);<span class="comment">//取队列中频率最小的</span></span><br><span class="line">        z.right=y=EXTRACT_MIN(Q);</span><br><span class="line">        z.freq=x.freq+y.freq;</span><br><span class="line">        INSERT(Q,Z);<span class="comment">//频率低的拼好后，一步步往上累加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-20200102213951216.png"></p>
<h4 id="时间分析"><a href="#时间分析" class="headerlink" title="时间分析"></a>时间分析</h4><p>Q是使用最小二叉堆实现的。</p>
<ul>
<li><p>首先，Q的初始化花费O(n)的时间。</p>
</li>
<li><p>其次，循环的总代价是O(nlgn)。</p>
<ul>
<li>for循环共执行了n-1次，每次从堆中找出当前频率最小的两个结点及把合并得到的新结点插入到堆中均花费O(lgn)，所以循环的总代价是O(nlgn).</li>
</ul>
</li>
</ul>
<p><strong>所以，HUFFMAN的总运行时间O(nlgn)</strong></p>
<h4 id="HUFFMAN算法的正确性"><a href="#HUFFMAN算法的正确性" class="headerlink" title="HUFFMAN算法的正确性"></a>HUFFMAN算法的正确性</h4><p>1、第一点：令C为一个字母表，其中每个字符c∈C都有一个频率c.freq。令x和y是C中频率最低的两个字符。那么存在C的一个最优前缀码，x和y的码字长度相同，且只有最后一个二进制位不同。</p>
<p>二叉树T表示字符集C的一个最优前缀码，证明可以对T作适当修改后得到一棵新的二叉树T”，在T”中x和y是最深叶子且为兄弟，同时T”表示的前缀码也是C的最优前缀码。设b和c是二叉树T的最深叶子，且为兄弟。设f(b)&lt;&#x3D;f(c)，f(x)&lt;&#x3D;f(y)。由于x和y是C中具有最小频率的两个字符，有f(x)&lt;&#x3D;f(b)，f(y)&lt;&#x3D;f(c)。首先，在树T中交换叶子b和x的位置得到T’，然后再树T’中交换叶子c和y的位置，得到树T’’。如图所示：<br><img src="/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/1364295841_4708.jpg"></p>
<p>由此可知，树T和T’的前缀码的平均码长之差为：</p>
<p><img src="/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/1364296506_7690.jpg"></p>
<p> 因此，<em>T’’表示的前缀码也是最优前缀码</em>，且x,y具有相同的码长，同时，仅最优一位编码不同。</p>
<p>2、第二点：令C为一个给定的字母表，其中每个字符c∈C都有一个频率c.freq。</p>
<p>令x和y是C中频率最低的两个字符。<br>令C’为C去掉字符x和y，并加入一个新字符z后得到的字母表，即C’&#x3D; C -{x, y}∪{z}。</p>
<p>类似C，也为C’定义freq，且z.freq&#x3D; x.freq+ y.freq。<br>令T’为字母表C’的任意一个最优前缀码对应的编码树。则有：可以将T’中叶子结点z替换为一个以x和y为孩子的内部结点，得到树T，而T表示字母表C的一个最优前缀码。</p>
<h4 id="最优子结构性质"><a href="#最优子结构性质" class="headerlink" title="最优子结构性质"></a>最优子结构性质</h4><p>贪心选择性：</p>
<ul>
<li>1、第一点说明首次选择频率最低的两个字符和选择其它可能的字符一样，都可以构造相应的最优编码树。</li>
<li>2、第二点说明首次贪心选择，选择出频率最低的两个字符x和y，合并后将z加入元素集合，可以构造包含z的最优编码树，而还原x和y，一样还是最优编码树。</li>
<li>所以贪心选择性成立。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" rel="tag"># 贪心算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/02/OS_%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%B8%8E%E8%B0%83%E5%BA%A6/" rel="prev" title="资源分配与调度">
      <i class="fa fa-chevron-left"></i> 资源分配与调度
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/02/Algorithm_%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%9B%BE%E7%AE%97%E6%B3%95/" rel="next" title="基本的图算法">
      基本的图算法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.1.</span> <span class="nav-text">贪心算法的步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.</span> <span class="nav-text">贪心算法存在的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E9%80%82%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.</span> <span class="nav-text">贪心算法适用的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.</span> <span class="nav-text">活动选择问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.1.</span> <span class="nav-text">活动选择问题的最优子结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.2.</span> <span class="nav-text">活动选择问题的动态规划方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98%E7%9A%84%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.3.</span> <span class="nav-text">活动选择问题的贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">贪心算法的正确性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">贪心算法的递归实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">贪心算法的迭代实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%95%B0%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.5.</span> <span class="nav-text">分数背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5"><span class="nav-number">1.5.1.</span> <span class="nav-text">贪心策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%81%E6%98%8E"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">证明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Huffman%E7%BC%96%E7%A0%81"><span class="nav-number">1.6.</span> <span class="nav-text">Huffman编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E6%A0%91"><span class="nav-number">1.6.1.</span> <span class="nav-text">编码树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E7%BC%96%E7%A0%81%E6%96%B9%E6%A1%88"><span class="nav-number">1.6.2.</span> <span class="nav-text">最优编码方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Huffman%E7%BC%96%E7%A0%81%E7%9A%84%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">1.6.3.</span> <span class="nav-text">Huffman编码的贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%88%86%E6%9E%90"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">时间分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HUFFMAN%E7%AE%97%E6%B3%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">HUFFMAN算法的正确性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E6%80%A7%E8%B4%A8"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">最优子结构性质</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rhb</p>
  <div class="site-description" itemprop="description">纵浪大化中，不喜亦不惧</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">126</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RShawshank" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RShawshank" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rhb</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
