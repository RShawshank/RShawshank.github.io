<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>数据库_并发控制 | rhb_blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="并发控制概述并发的背景：  DBMS作为系统软件，对外提供数据访问服务 多个用户同时访问一个数据库 各种任务以事务为逻辑单位运行 同一时间并发运行的事务数可达数百个  多个事务的运行过程串行执行——事务依次执行，且每个事务必须等待前一个事务结束后方能运行 事务串行执行降低了系统资源利用率 事务执行过程中会占用多种资源：  CPU——比较、计算、统计等 数据 网络——收发指令和数据  单个事务执行过">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库_并发控制">
<meta property="og:url" content="http://rshawshank.github.io/2020/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/index.html">
<meta property="og:site_name" content="rhb_blog">
<meta property="og:description" content="并发控制概述并发的背景：  DBMS作为系统软件，对外提供数据访问服务 多个用户同时访问一个数据库 各种任务以事务为逻辑单位运行 同一时间并发运行的事务数可达数百个  多个事务的运行过程串行执行——事务依次执行，且每个事务必须等待前一个事务结束后方能运行 事务串行执行降低了系统资源利用率 事务执行过程中会占用多种资源：  CPU——比较、计算、统计等 数据 网络——收发指令和数据  单个事务执行过">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://rshawshank.github.io/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20200605163246424.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20200605173311455.png">
<meta property="article:published_time" content="2020-06-05T11:14:28.000Z">
<meta property="article:modified_time" content="2021-03-18T08:55:54.000Z">
<meta property="article:author" content="rhb">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://rshawshank.github.io/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20200605163246424.png">
  
    <link rel="alternate" href="/atom.xml" title="rhb_blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">rhb_blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://rshawshank.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-数据库-并发控制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2020-06-05T11:14:28.000Z" itemprop="datePublished">2020-06-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>►<a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      数据库_并发控制
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="并发控制概述"><a href="#并发控制概述" class="headerlink" title="并发控制概述"></a>并发控制概述</h1><p>并发的背景：</p>
<ul>
<li>DBMS作为系统软件，对外提供数据访问服务</li>
<li>多个用户同时访问一个数据库</li>
<li>各种任务以事务为逻辑单位运行</li>
<li>同一时间并发运行的事务数可达数百个</li>
</ul>
<h2 id="多个事务的运行过程"><a href="#多个事务的运行过程" class="headerlink" title="多个事务的运行过程"></a>多个事务的运行过程</h2><h3 id="串行执行"><a href="#串行执行" class="headerlink" title="串行执行"></a>串行执行</h3><p>——事务依次执行，且每个事务必须等待前一个事务结束后方能运行</p>
<p>事务串行执行降低了系统资源利用率</p>
<p>事务执行过程中会占用多种资源：</p>
<ul>
<li>CPU——比较、计算、统计等</li>
<li>数据</li>
<li>网络——收发指令和数据</li>
</ul>
<p>单个事务执行过程中部分资源可能处于空闲状态</p>
<h3 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h3><ul>
<li>单处理机——CPU时间片轮转，多道程序交替运行</li>
<li>多CPU——并行处理技术，多种共享内存以及硬盘策略</li>
</ul>
<p>注意，数据是临界资源。在事务执行过程中，它所访问的数据集合应该在事务终止前是一致的、相容的</p>
<h3 id="数据库事务并发带来的问题"><a href="#数据库事务并发带来的问题" class="headerlink" title="数据库事务并发带来的问题"></a>数据库事务并发带来的问题</h3><p>操作系统层面的并发控制手段：信号量<br>——保护对象明确、相对集中<br>——控制保护时间一般较短<br>——直接阻塞任务进程——信号量资源有限</p>
<p>数据库事务并发控制：<br>——事务访问的数据对象及其范围相对灵活，一致性所涉及的范围更广。<br>——事务的执行一般包括一个读写操作的序列，时间相对比简单的应用程序变量操作要长。<br>——需要被保护的对象个数可能远多于信号量数目。<br>——事务的执行可能涉及DBMS的多个进程。</p>
<h1 id="数据库系统中的并发错误"><a href="#数据库系统中的并发错误" class="headerlink" title="数据库系统中的并发错误"></a>数据库系统中的并发错误</h1><p>事务是数据库中并发控制的基本单位，事务处理需要保证事务的ACID特性，并发控制要能保证事务的隔离性和一致性。</p>
<p>当多个用户&#x2F;进程&#x2F;线程同时对数据库进行操作时，会出现3种冲突情形：</p>
<ol>
<li>读-读，不存在任何问题</li>
<li>读-写，有隔离性问题，可能遇到脏读（会读到未提交的数据） ，幻影读等。</li>
<li>写-写，可能丢失更新</li>
</ol>
<p>要解决冲突，一种办法是是锁，即基于锁的并发控制，比如2PL，这种方式开销比较高，而且无法避免死锁。</p>
<p>多版本并发控制（MVCC）是一种用来<strong>解决读-写冲突</strong>的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读</p>
<p>乐观并发控制（OCC）是一种用来<strong>解决写-写冲突</strong>的无锁并发控制，认为事务间争用没有那么多，所以先进行修改，在提交事务前，检查一下事务开始后，有没有新提交改变，如果没有就提交，如果有就放弃并重试。乐观并发控制类似自选锁。乐观并发控制适用于低数据争用，写冲突比较少的环境。</p>
<p>多版本并发控制可以结合基于锁的并发控制来解决写-写冲突，即MVCC+2PL，也可以结合乐观并发控制来解决写-写冲突。</p>
<h1 id="基于封锁的并发控制"><a href="#基于封锁的并发控制" class="headerlink" title="基于封锁的并发控制"></a>基于封锁的并发控制</h1><h2 id="封锁概述"><a href="#封锁概述" class="headerlink" title="封锁概述"></a>封锁概述</h2><h3 id="封锁的基本思想"><a href="#封锁的基本思想" class="headerlink" title="封锁的基本思想"></a>封锁的基本思想</h3><p>封锁是数据库管理系统实现并发控制的一种重要技术。</p>
<p>并发控制方法：<br>① 锁（Locking）——商用数据库典型方法<br>② 时间戳（timestamping）<br>③ 乐观（Optimistic）</p>
<p>流程——事务在对某个数据对象（表、记录集合等）进行读写操作之前，先向系统发出封锁请求，系统依据请求对数据对象加锁，事务在获得锁后才能对数据对象进行操作，操作完成后在适当时机释放锁。</p>
<p>约束——系统在事务持有锁期间提供与锁配套的对数据的并发访问保护功能，其他事务不能违反保护规则进行与锁互斥的数据操作。</p>
<h3 id="封锁的基本规则"><a href="#封锁的基本规则" class="headerlink" title="封锁的基本规则"></a>封锁的基本规则</h3><p>① 将要存取的数据须先申请加锁；</p>
<p>② 已被加锁的数据不能再加不相容锁；</p>
<p>③ 一旦完成使用应“尽早”释放锁；</p>
<p>④ 未被加锁的数据不可对之解锁。</p>
<h3 id="申请的时机"><a href="#申请的时机" class="headerlink" title="申请的时机"></a>申请的时机</h3><p>①针对事务执行确定一个时间点整体申请<br>一次封锁——无死锁<br>锁开销少——用少数的锁保护较大范围的数据<br>并发度低——锁冲突概率增加。</p>
<p>②针对单条SQL语句执行申请<br>申请频繁——申请时机增多<br>死锁——部分占有与互斥等待<br>锁开销大——被保护的数据对象集合增多<br>并发度高——细粒度的封锁</p>
<h3 id="申请的方式"><a href="#申请的方式" class="headerlink" title="申请的方式"></a>申请的方式</h3><p>①显式</p>
<p>应事务的要求直接加到数据对象上。</p>
<p>②隐式</p>
<p>该数据对象没有直接加锁，<strong>由于数据对象的多粒度层次结构中的上级结点加了锁，使该数据对象隐含的加了相同类型的锁</strong>。</p>
<h2 id="封锁的类型"><a href="#封锁的类型" class="headerlink" title="封锁的类型"></a>封锁的类型</h2><p>基本的封锁类型有两种：排它锁（exclusive locks，简称X锁）和共享锁（share locks，简称S锁）。</p>
<p>（1）排它锁（X锁）<br>若事务T持有数据D的X锁，则T可读、写D，其它任何事务不能再对D加任何锁，直至T释放该X锁。X锁一般用于写保护，可防止丢失更新。</p>
<p>（2）共享锁（S锁）<br>若事务T持有数据D的S锁，则T仅能够对D进行读操作，其它事务仍可对D加S锁，但不可加X锁，直到T释放该S锁。</p>
<p>S锁一般用于读操作，一旦施加S锁，读可共享，但其它事务不可改。</p>
<blockquote>
<p>除了X锁和S锁外，还有：</p>
<p>更新锁（U锁）：</p>
<p>意向锁：对多粒度树中的结点加意向锁，则说明该结点的下层结点正在被加锁；对任一结点加锁时，必须先对它的上层结点加意向锁。</p>
<p><strong>注：当出现解锁时，就认定解锁任务开始，在解锁阶段不能再加任何锁</strong></p>
</blockquote>
<h2 id="封锁的协议"><a href="#封锁的协议" class="headerlink" title="封锁的协议"></a>封锁的协议</h2><p>在运用X锁和S锁时，针对并发操作不正确调度可能产生的丢失修改、不可重复读和读脏问题，可以通过三级封锁协议不同程度上解决这些问题。不同的封锁协议达到的系统一致性级别是不同的。</p>
<blockquote>
<p>发生丢失更新的过程</p>
<p>T1读取库存后，T2也读取了同一个库存；T1修改库存，回写更新后的值；T2修改库存，也回写更新后的值。此时库存为T2回写的值，T1对库存的更新丢失。</p>
<table>
<thead>
<tr>
<th>顺序</th>
<th>任务</th>
<th>操作</th>
<th>库存量</th>
</tr>
</thead>
<tbody><tr>
<td>１</td>
<td>T1</td>
<td>读库存量</td>
<td>50</td>
</tr>
<tr>
<td>２</td>
<td>T2</td>
<td>读库存量</td>
<td>50</td>
</tr>
<tr>
<td>３</td>
<td>T1</td>
<td>库存量&#x3D;50+100</td>
<td></td>
</tr>
<tr>
<td>４</td>
<td>T2</td>
<td>库存量&#x3D;50-40</td>
<td></td>
</tr>
<tr>
<td>５</td>
<td>T1</td>
<td>写库存量</td>
<td>150</td>
</tr>
<tr>
<td>６</td>
<td>T2</td>
<td>写库存量</td>
<td>10</td>
</tr>
</tbody></table>
<p> T2使用T1的“脏数据”的过程</p>
<p>当T1和T2并发执行时，在T1对数据库更新的结果没有提交之前，T2使用了T1的结果，而在T2操作之后T1又回滚，这时引起的错误是T2读取了T1的“脏数据”。</p>
<table>
<thead>
<tr>
<th>顺序</th>
<th>任务</th>
<th>操作</th>
<th>库存量</th>
</tr>
</thead>
<tbody><tr>
<td>１</td>
<td>T1</td>
<td>读库存量</td>
<td>50</td>
</tr>
<tr>
<td>２</td>
<td>T1</td>
<td>库存量&#x3D;50+100</td>
<td></td>
</tr>
<tr>
<td>３</td>
<td>T1</td>
<td>写库存量</td>
<td>150</td>
</tr>
<tr>
<td>４</td>
<td>T2</td>
<td>读库存量</td>
<td>150</td>
</tr>
<tr>
<td>５</td>
<td>T2</td>
<td>库存量&#x3D;150-40</td>
<td></td>
</tr>
<tr>
<td>６</td>
<td>T1</td>
<td>ROLLBACK</td>
<td>50</td>
</tr>
<tr>
<td>７</td>
<td>T2</td>
<td>写库存量</td>
<td>110</td>
</tr>
</tbody></table>
<p> T1对数据A“不可重复读”的过程</p>
<p>当T1读取数据A后，T2执行了对A的更新，当T1 再次读取数据A（希望与第一次是相同的值）时，得到的数据与前一次不同，这时引起的错误称为“不可重复读”。</p>
<table>
<thead>
<tr>
<th>顺序</th>
<th>任务</th>
<th>操作</th>
<th>库存量A</th>
<th>入库量B</th>
</tr>
</thead>
<tbody><tr>
<td>１</td>
<td>T1</td>
<td>读A&#x3D;50</td>
<td>50</td>
<td>100</td>
</tr>
<tr>
<td>2</td>
<td>T1</td>
<td>读B&#x3D;100</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>T1</td>
<td>求和&#x3D;50+100</td>
<td></td>
<td></td>
</tr>
<tr>
<td>４</td>
<td>T2</td>
<td>读B&#x3D;100</td>
<td>50</td>
<td></td>
</tr>
<tr>
<td>５</td>
<td>T2</td>
<td>B←B×4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>６</td>
<td>T2</td>
<td>回写B&#x3D;400</td>
<td>50</td>
<td>400</td>
</tr>
<tr>
<td>７</td>
<td>T1</td>
<td>读A&#x3D;50</td>
<td>50</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>T1</td>
<td>读B&#x3D;400</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>T1</td>
<td>和&#x3D;450（验算不对）</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</blockquote>
<p>（1）1级封锁协议<br>①策略<br>事务T在修改数据D之前须先对其加X锁，直到事务T结束（commit&#x2F;rollback）才释放。<br>②功能<br>防止<strong>丢失修改</strong>；并保证事务T是可恢复的。<br>③问题<br><strong>不能防止不可重复读和读“脏”数据</strong>。（仅对修改操作申请加锁保护，若读则不加锁）</p>
<table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">T<del>A</del></th>
<th align="left">D值</th>
<th align="left">T<del>B</del></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">X lock D;<br>R(D)&#x3D;100<br></td>
<td align="left">100</td>
<td align="left"></td>
<td>T<del>A</del>对X加锁成功后读D</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">X lock D<br />等待</td>
<td>T<del>B</del>对X加锁未成功后等待</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">W(D)&#x3D;D-1</td>
<td align="left">99</td>
<td align="left">等待</td>
<td>T<del>A</del>修改，D结果写回数据库并释放X锁</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">X lock D<br />R(D)&#x3D;99<br />W(D)&#x3D;D-1<br />COMMIT<br />Unlock D</td>
<td>T<del>B</del>获得D的X锁读D得99（已更新后结果）将修改后D（98）写回数据库</td>
</tr>
</tbody></table>
<p>上述过程发生了脏数据的读取</p>
<p>1级封锁协议为什么不能避免读脏数据？</p>
<p><strong>排它锁X只能防止该数据无法被其他线程写，不能防止该数据被其他线程读。在改数据和回滚的过程有可能会产生脏数据</strong></p>
<p>（2）2级封锁协议<br>①策略<br>在1级封锁协议基础上，再<strong>加上约束</strong>：事务T在读取D之前<strong>先对D加S锁</strong>，读完后即可释放该S锁。[<strong>无需等待事务结束</strong>]<br>②功能<br>防止丢失修改；防止读脏。<br>③问题<br>不能防止读不可重复（读完即释放，重读可能其它事务对之修改）。</p>
<table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">T<del>A</del></th>
<th align="left">D值</th>
<th align="left">T<del>B</del></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">X lock D;<br>R(D)&#x3D;100<br>W(D)&#x3D;X*2</td>
<td align="left">100<br><br>200</td>
<td align="left"></td>
<td>T<del>A</del>对X加锁成功</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">S lock D<br />等待</td>
<td>T<del>B</del>申请S锁T<del>A</del>未释放，T<del>B</del>等待</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Rollback<br>(W(X)&#x3D;100)<br>UnLock D</td>
<td align="left">100</td>
<td align="left">等待</td>
<td>T<del>A</del>因故撤消D值恢复为100</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">S lock D<br />R(D)&#x3D;100<br />Unlock D</td>
<td>T<del>B</del>获得S锁T<del>B</del>读到值与数据库中值一致，防止了读脏</td>
</tr>
</tbody></table>
<p>为什么二级封锁协议可以解决脏读？</p>
<p>​       前面我们说过脏读产生的原因：因为B事务读取到了A事务修改过尚未提交的数据，根据二级封锁协议要求：读数据的时候必须加S锁，但因为A事务在修改的时候已经加了X锁，在X锁的基础上是不能加S锁的，所以B事务无法获取S锁，就会导致B事务无法读取A事务中正在操作的数据，从而避免了脏读的发生。</p>
<p>（3）3级封锁协议<br>①策略<br>在1级封锁协议的基础上，加上约束：T读D前须先对D加S锁，<strong>直至T结束后才释放该S锁</strong>。<br>②功能<br><strong>防止丢失修改；防止读脏；防止不可重复读。</strong></p>
<table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">T<del>A</del></th>
<th align="left">数据库中A和B的值</th>
<th align="left">T<del>B</del></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">S Lock A <br />R(A)&#x3D;50<br />S Lock B<br />R(B)&#x3D;100<br />C &#x3D; A+B</td>
<td align="left">A：50<br />B：100<br /><br />A：50</td>
<td align="left"></td>
<td>T<del>A</del>对A、B加S锁T<del>B</del>不能再对之加X锁</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">X lock B<br />等待</td>
<td>T<del>B</del>对B加X锁不成功T<del>B</del>等待</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">R(A)&#x3D;50<br />R(B)&#x3D;100<br />D&#x3D;A+B<br />COMMIT<br />Unlock A<br />Unlock B</td>
<td align="left"><br /><br />A：50<br />B：100</td>
<td align="left">等待</td>
<td>T<del>B</del>等待T<del>B</del>重读A、B，结果相同</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"></td>
<td align="left"><br /><br />A：50<br />B：200</td>
<td align="left">X Lock B<br />R(B)&#x3D;100<br />W(B)：&#x3D;B*2<br />写回B&#x3D;200</td>
<td>T<del>B</del>获得B的X锁</td>
</tr>
</tbody></table>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20200605163246424.png"></p>
<p>为什么三级封锁协议可以解决不可重复读？</p>
<p>​       前面我们也说过了不可重复读产生的原因：是因为B事务读取到了A事务已经修改过的数据，导致前后两次读取的数据不一致。现根据三级封锁协议的要求：读取数据时必须加S锁，在S锁的基础上只能加S锁，不能加X锁，所以在B事务读取数据期间，A事务无法对数据进行修改，从而避免了不可重复读问题的发生。</p>
<h1 id="并行调度的可串行性"><a href="#并行调度的可串行性" class="headerlink" title="并行调度的可串行性"></a>并行调度的可串行性</h1><h2 id="正确性标准"><a href="#正确性标准" class="headerlink" title="正确性标准"></a>正确性标准</h2><p>（1）单个事务</p>
<p>——若非并发的执行，每个事务都能保证DB的正确性。<br>（丢失修改、不可重复读、读脏数据，都是因事务并发执行产生）</p>
<p>（2）多个事务</p>
<p>——多个事务以任意串行方式执行都能保证DB的正确性。<br>给定三个事务：T1，T2，T3。<br>T1→T2→T3         T1→T3→T2<br>T2→T1→T3         T2→T3→T1<br>T3→T1→T2          T3→T2→T1<br>显然，任何一事务并发执行时禁止其它事务执行，总能保证DB正确性，但不利于数据共享。</p>
<p>（3）可串行化调度（serializable）</p>
<p>——当且仅当多个事务并发执行的结果与这些事务按某一顺序串行执行的结果相同时，则该并发执行是可串行化的。<br>（可串行化调度是并发事务正确性的唯一准则）</p>
<p>例：有两个事务TA，TB （A&#x3D;10, B&#x3D;2, C&#x3D;0）包含如下操作序列<br>TA：读B；A:&#x3D;B+1；写回A；<br>TB：读C；读A；B:&#x3D;A+C+1；写回B；<br>则至少可能有四种不同的调度方式:</p>
<p>1、先执行TA，再执行TB——RA(B) WA(A) RB(C) RB(A) WB(B)；结果：A&#x3D;3，B&#x3D;4，C&#x3D;0。【串行调度】</p>
<p>2、先执行TB，再执行TA——RB(C) RB(A) WB(B) RA(B) WA(A) ；执行结果：A&#x3D;12，B&#x3D;11，C&#x3D;0。【串行调度】</p>
<p>3、两事务TA、TB按ti并发执行——RA(B) RB(C) RB(A) WA(A) WB(B)，结果为A&#x3D;3，B&#x3D;11。<br>按事务并发可串行化的正确性准则，该结果与TA、TB两个串行执行的任何结果（A&#x3D;3，B&#x3D;4；A&#x3D;12，B&#x3D;11）均不同，调度结果错误。【交错执行（不可串行化）调度】</p>
<p>4、按ti交错执行——RA(B) RB(C)WA(A)RB(A)WB(B)；执行结果：A&#x3D;3，B&#x3D;4。该结果正确，因为与串行化调度1结果相同，该调度是可串行化调度【交错执行(可串行化)调度】</p>
<h2 id="冲突可串行化调度"><a href="#冲突可串行化调度" class="headerlink" title="冲突可串行化调度"></a>冲突可串行化调度</h2><p>——可串行化调度的充分而非必要条件。</p>
<p>冲突操作：① R<del>i</del>(x)与W<del>j</del>(x)    ② W<del>i</del>(x)与W<del>j</del>(x)</p>
<p>操作顺序的交换（可交换、不可交换）<br>——不同事务的冲突操作和同一事务的两个操作均是不可交换的。否则可能使操作序列的结果不等价。</p>
<p>在可交换的前提下，若干事务的操作交换顺序的结果是一个串行调度，则称这个调度是冲突可串行化的。</p>
<blockquote>
<p>前趋图：事务均为节点，事务之间存在冲突操作（读写、写读、写写）时，则事务之间存在由冲突操作的先执行事务指向后执行事务的有向边。</p>
<p><strong>前驱图中不存在环路等价于调度是冲突可串行化的</strong></p>
<p>冲突可串行化是可串行化的充分条件，不是必要条件。</p>
</blockquote>
<h1 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h1><p><a target="_blank" rel="noopener" href="https://draveness.me/database-concurrency-control/">参考文章</a></p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ul>
<li><p>并发调度的正确性标准：可串行化调度<br>n个事务的可串行化调度结果——n！种<br>可串行化的充分而非必要条件：冲突可串行化调度</p>
</li>
<li><p>基于封锁的并发控制：一种基于悲观思想的并发控制策略。<br>操作之前先查验冲突</p>
</li>
<li><p>封锁如何解决并发错误？<br>三级封锁协议<br>排它锁保护写操作——写之前申请，事务结束时释放。<br>在此基础上，共享锁保护读操作——读之前申请，释放时机（读完之后即可释放、事务结束时释放）</p>
</li>
</ul>
<h3 id="三级封锁协议的选择依据"><a href="#三级封锁协议的选择依据" class="headerlink" title="三级封锁协议的选择依据"></a>三级封锁协议的选择依据</h3><p>权衡并发调度正确性和并发性能。</p>
<p>三级封锁协议的特点之一：事务对数据的保护时间较为统一，其中比较强的往往保护至事务结束。</p>
<p>能否制定相对灵活的封锁协议?<br>                    两阶段封锁（TwoPhase Locking，简称2PL）</p>
<h2 id="基于2PL协议的调度"><a href="#基于2PL协议的调度" class="headerlink" title="基于2PL协议的调度"></a>基于2PL协议的调度</h2><p>基本思想：所有事务必须分为两个阶段对数据项加锁和解锁，第一阶段称为扩展阶段（获得锁）；第二阶段称为收缩阶段（释放锁）。</p>
<p>协议内容：<br>（1）在对任何数据读、写之前，须先获得该数据的锁；<br>（2）在释放一个封锁之后，该事务不能再申请任何其它锁。【正确的遵守2PL协议，所有获得锁均在释放锁之前。】</p>
<p>两个阶段：事务的第一个释放锁操作成为分界线。<br>扩张和收缩：事务对数据资源的占有。</p>
<p>两段锁协议的目标：实现并发事务调度的可串行化。</p>
<h2 id="两阶段锁协议的特点"><a href="#两阶段锁协议的特点" class="headerlink" title="两阶段锁协议的特点"></a>两阶段锁协议的特点</h2><ul>
<li>定理：若所有事务都遵守2PL协议，则对这些事务的所有并发调度策略都是可串行化的。</li>
</ul>
<p>证明思路：<br>前趋图——事务均为节点，事务之间存在冲突操作（读写、写读、写写）时，则事务之间存在由冲突操作的先执行事务指向后执行事务的有向边。</p>
<p>前驱图中不存在环路等价于调度是冲突可串行化的</p>
<p>反证法：假设调度遵循2PL协议但不是可串行化的 → 与2PL有矛盾。冲突可串行化是可串行化的充分而非必要条件。</p>
<p>假如调度不是可串行化的，则该调度也不是冲突可串行化的。<br>① 假设某个遵守2PL的调度不是可串行化调度；<br>② 按Lock、UnLock操作中因锁不兼容而等待的关系构造调度的前趋图G；<br>③ 依据假设，若调度不是可串行化，则G中必存在环路，不妨设为：Ti<del>1</del>→Ti<del>2</del>→……→Tj<del>p</del>→Ti<del>n</del>。<br>④ 其中某个冲突事务获得锁的前提是前面的冲突事务释放锁，则意味着Ti<del>1</del>解锁后Tj<del>p</del>才能获得锁，之后在环路中又出现Ti<del>n</del>加锁；<br>⑤ “④”中Ti违反了两阶段锁协议。</p>
<ul>
<li>2PL协议是可串行化的充分条件，不是必要条件。</li>
<li>遵守两阶段锁协议的事务可能<strong>发生死锁</strong>。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>两阶段锁（2PL）：通过事务的扩张和收缩阶段的划分，而不是提交之前与提交之时的这种划分，对锁的申请和释放流程进行的一种约定，从而实现了调度正确性的一个充分而非必要条件。</p>
<h1 id="封锁的粒度"><a href="#封锁的粒度" class="headerlink" title="封锁的粒度"></a>封锁的粒度</h1><p>到目前为止我们都没有对不同粒度的锁进行讨论，一直以来我们都讨论的都是数据行锁，但是在有些时候我们希望将多个节点看做一个数据单元，使用锁直接将这个数据单元、表甚至数据库锁定起来。这个目标的实现需要我们在数据库中定义不同粒度的锁</p>
<h2 id="多粒度封锁"><a href="#多粒度封锁" class="headerlink" title="多粒度封锁"></a>多粒度封锁</h2><p>封锁的粒度：封锁对象的大小。<br>（1）逻辑单元：整个数据库、整个关系、整个索引、关系的分区、元组、索引项、属性值集、属性值。<br>（2）物理单元：数据页（块）、索引页</p>
<p>封锁的粒度与数据库并发性能的两个重要因素相关：</p>
<ul>
<li>并发度</li>
<li>并发控制的开销</li>
</ul>
<p>粒度小——封锁开销大——并发度大</p>
<h3 id="封锁的基本策略"><a href="#封锁的基本策略" class="headerlink" title="封锁的基本策略"></a>封锁的基本策略</h3><p>宜采用多粒度封锁：<br>1）需常存取多个关系的大量元组时宜采用数据库级粒度；<br>2）需常存取单个关系大量元组时宜采用关系级；<br>3）需常存取单个关系少量元组时宜采用元组级；<br>4）一般不采用属性级；<br>5）物理单元一般不宜采用。</p>
<p>多粒度锁提供了并发度和锁开销的权衡空间。</p>
<h3 id="多粒度封锁-1"><a href="#多粒度封锁-1" class="headerlink" title="多粒度封锁"></a>多粒度封锁</h3><p>隐式封锁：某个数据对象被显式封锁后，它在多粒度层次结构中的子孙节点被隐含的加了相同类型的锁</p>
<h3 id="多粒度锁的冲突检测"><a href="#多粒度锁的冲突检测" class="headerlink" title="多粒度锁的冲突检测"></a>多粒度锁的冲突检测</h3><ul>
<li><p>显式封锁和隐式封锁的效果是一样的，因此检查封锁冲突时需要对两种封锁的结果都进行检测。</p>
<p>1）检查数据对象本身有无显式封锁与申请冲突；</p>
<p>2）检查上级结点有无封锁与本结点冲突；</p>
<p>3）检查后代结点有无封锁与本结点冲突</p>
</li>
</ul>
<h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p>对任一结点加锁时，必须先对它的上层结点加意向锁。如果对某个结点加意向锁，则表示该结点的某个子孙结点正在或拟施加相应的非意向锁。作用：提高系统并发度，减少加锁和解锁的开销。被商用产品广泛采用。</p>
<p>意向锁的类型：<br>1）IS锁：表示某个子孙结点拟加S锁<br>2）IX锁：表示某个子孙结点拟加X锁<br>3）SIX锁：表示对结点施加S锁的同时，再施加IX锁&#x3D; S+IX</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20200605173311455.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://rshawshank.github.io/2020/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" data-id="claaf6qin007ytkup9g5bbq91" data-title="数据库_并发控制" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/06/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E9%9D%99%E6%80%81%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          编译原理-静态语义分析和中间代码生成
        
      </div>
    </a>
  
  
    <a href="/2020/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E5%92%8C%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">数据库_查询处理和查询优化</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/android/">android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/javaweb/">javaweb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%BA%93/">oracle数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">函数式编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%84%E5%8E%9F%E5%8E%9F%E7%90%86/">组原原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">组成原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/">计算机系统结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D/">资源分配</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%BB%91%E4%B9%A6/">黑书</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/">工作笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AF%95%E8%AE%BE/">毕设</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CPU/" rel="tag">CPU</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KMP/" rel="tag">KMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/activity/" rel="tag">activity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/adapter/" rel="tag">adapter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/" rel="tag">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/broadcast/" rel="tag">broadcast</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/drawable/" rel="tag">drawable</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaweb/" rel="tag">javaweb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/layout/" rel="tag">layout</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oracle/" rel="tag">oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket/" rel="tag">socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">主存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/" rel="tag">分治策略</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E5%85%83%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" rel="tag">单元最短路径</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/" rel="tag">双指针法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E6%9C%AC%E5%9B%BE%E7%AE%97%E6%B3%95/" rel="tag">基本图算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/" rel="tag">处理机调度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D/" rel="tag">字符匹配</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BA%BF/" rel="tag">总线</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E5%AF%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" rel="tag">所有结点对的最短路径</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" rel="tag">操作系统概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" rel="tag">文件管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/" rel="tag">最大流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" rel="tag">最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" rel="tag">栈和队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91/" rel="tag">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/" rel="tag">概率分析和随机算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AF%95%E8%AE%BE/" rel="tag">毕设</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" rel="tag">滑动窗口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" rel="tag">线性表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag">组成原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" rel="tag">计算机系统结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" rel="tag">设备管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" rel="tag">贪心算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%B8%8E%E8%B0%83%E5%BA%A6/" rel="tag">资源分配与调度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/" rel="tag">输入输出系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" rel="tag">进程和进程管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/" rel="tag">选择算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81%E6%9C%BA%E5%88%B6/" rel="tag">锁机制</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/CPU/" style="font-size: 10px;">CPU</a> <a href="/tags/KMP/" style="font-size: 10px;">KMP</a> <a href="/tags/Leetcode/" style="font-size: 11.25px;">Leetcode</a> <a href="/tags/activity/" style="font-size: 10px;">activity</a> <a href="/tags/adapter/" style="font-size: 10px;">adapter</a> <a href="/tags/android/" style="font-size: 13.75px;">android</a> <a href="/tags/broadcast/" style="font-size: 10px;">broadcast</a> <a href="/tags/drawable/" style="font-size: 10px;">drawable</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/javaweb/" style="font-size: 17.5px;">javaweb</a> <a href="/tags/layout/" style="font-size: 10px;">layout</a> <a href="/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/tags/oracle/" style="font-size: 10px;">oracle</a> <a href="/tags/socket/" style="font-size: 10px;">socket</a> <a href="/tags/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">主存管理</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.25px;">函数式编程</a> <a href="/tags/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/" style="font-size: 10px;">分治策略</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">动态规划</a> <a href="/tags/%E5%8D%95%E5%85%83%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" style="font-size: 10px;">单元最短路径</a> <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/" style="font-size: 10px;">双指针法</a> <a href="/tags/%E5%9F%BA%E6%9C%AC%E5%9B%BE%E7%AE%97%E6%B3%95/" style="font-size: 10px;">基本图算法</a> <a href="/tags/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/" style="font-size: 10px;">处理机调度</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D/" style="font-size: 10px;">字符匹配</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">学习笔记</a> <a href="/tags/%E6%80%BB%E7%BA%BF/" style="font-size: 10px;">总线</a> <a href="/tags/%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E5%AF%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" style="font-size: 10px;">所有结点对的最短路径</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 16.25px;">操作系统</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">操作系统概述</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 17.5px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 12.5px;">数据结构</a> <a href="/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" style="font-size: 10px;">文件管理</a> <a href="/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/" style="font-size: 10px;">最大流</a> <a href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" style="font-size: 10px;">最小生成树</a> <a href="/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" style="font-size: 10px;">栈和队列</a> <a href="/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/tags/%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/" style="font-size: 10px;">概率分析和随机算法</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a> <a href="/tags/%E6%AF%95%E8%AE%BE/" style="font-size: 10px;">毕设</a> <a href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" style="font-size: 10px;">滑动窗口</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 18.75px;">算法</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" style="font-size: 11.25px;">线性表</a> <a href="/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 15px;">组成原理</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 16.25px;">编译原理</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" style="font-size: 15px;">计算机系统结构</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" style="font-size: 10px;">设备管理</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" style="font-size: 10px;">贪心算法</a> <a href="/tags/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%B8%8E%E8%B0%83%E5%BA%A6/" style="font-size: 10px;">资源分配与调度</a> <a href="/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">输入输出系统</a> <a href="/tags/%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" style="font-size: 10px;">进程和进程管理</a> <a href="/tags/%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">选择算法</a> <a href="/tags/%E9%80%92%E5%BD%92/" style="font-size: 10px;">递归</a> <a href="/tags/%E9%94%81%E6%9C%BA%E5%88%B6/" style="font-size: 10px;">锁机制</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/10/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1/">数据库-常用数据库对象</a>
          </li>
        
          <li>
            <a href="/2022/01/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a>
          </li>
        
          <li>
            <a href="/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%85%AD%EF%BC%89/">java-设计模式（六）</a>
          </li>
        
          <li>
            <a href="/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89/">java-设计模式（五）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 rhb<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>