<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rshawshank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="句柄和规范归约归约：根据文法的产生式规则，把串中出现的产生式的右部替换成左部符号 从语法树的角度看，是从叶子出发逐步向上进行构造 句柄：最左两代子树末端就是句柄 规范归约的关键是寻找句柄： 1、根据语法树找句柄 2、在栈中根据三类信息：  历史：已经移入符号栈的内容 展望：根据产生式推迟未来可能遇到的输入符号 现实：当前的输入符号  LR分析LR分析法也是一种“移进—归约”的自底向上语法分析方法，">
<meta property="og:type" content="article">
<meta property="og:title" content="编译原理-LR分析">
<meta property="og:url" content="http://rshawshank.github.io/2020/03/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="rhb_blog">
<meta property="og:description" content="句柄和规范归约归约：根据文法的产生式规则，把串中出现的产生式的右部替换成左部符号 从语法树的角度看，是从叶子出发逐步向上进行构造 句柄：最左两代子树末端就是句柄 规范归约的关键是寻找句柄： 1、根据语法树找句柄 2、在栈中根据三类信息：  历史：已经移入符号栈的内容 展望：根据产生式推迟未来可能遇到的输入符号 现实：当前的输入符号  LR分析LR分析法也是一种“移进—归约”的自底向上语法分析方法，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://rshawshank.github.io/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/image-20200427132237942.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203220121070.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203220250887.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203220947527.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203221052145.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203221104587.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181229131739897">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181229131739956">
<meta property="og:image" content="https://img-blog.csdnimg.cn/201812291317408">
<meta property="og:image" content="http://rshawshank.github.io/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/image-20200427170434108.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/image-20200427182955125.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181229131728485">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181229131728536">
<meta property="og:image" content="http://rshawshank.github.io/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20130703204706828">
<meta property="article:published_time" content="2020-03-27T15:18:39.000Z">
<meta property="article:modified_time" content="2020-07-05T12:25:00.000Z">
<meta property="article:author" content="rhb">
<meta property="article:tag" content="编译原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://rshawshank.github.io/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/image-20200427132237942.png">

<link rel="canonical" href="http://rshawshank.github.io/2020/03/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>编译原理-LR分析 | rhb_blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rhb_blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">rao的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/03/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          编译原理-LR分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-27 15:18:39" itemprop="dateCreated datePublished" datetime="2020-03-27T15:18:39Z">2020-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-05 12:25:00" itemprop="dateModified" datetime="2020-07-05T12:25:00Z">2020-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="句柄和规范归约"><a href="#句柄和规范归约" class="headerlink" title="句柄和规范归约"></a>句柄和规范归约</h1><p>归约：根据文法的产生式规则，把串中出现的产生式的右部替换成左部符号</p>
<p>从语法树的角度看，是从叶子出发逐步向上进行构造</p>
<p>句柄：最左两代子树末端就是句柄</p>
<p>规范归约的关键是寻找句柄：</p>
<p>1、根据语法树找句柄</p>
<p>2、在栈中根据三类信息：</p>
<ul>
<li>历史：已经移入符号栈的内容</li>
<li>展望：根据产生式推迟未来可能遇到的输入符号</li>
<li>现实：当前的输入符号</li>
</ul>
<h1 id="LR分析"><a href="#LR分析" class="headerlink" title="LR分析"></a>LR分析</h1><p>LR分析法也是一种“移进—归约”的自底向上语法分析方法，<strong>其本质是规范归约【句柄作为可归约串】</strong>。</p>
<p>其思想为一方面记住已移进和归约出的整个符号串，另一方面根据所用产生式推测未来可能碰到的输入符号。</p>
<p><strong>LR分析方法：把“历史”以及“展望”综合抽象成状态；由栈顶的状态和现行的输入符号唯一确定每一步工作。</strong></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/image-20200427132237942.png"></p>
<p>解释：每一个符号对应一个状态，分析栈每次弹出一个符号，就要把对应的状态也弹出。然后LR分析程序会根据输入串在LR分析表中进行查找：是进行归约、移进还是报错操作。</p>
<p>LR分析器实质上是一个带先进后出存储器（栈）的确定有限自动机，其核心部分是一张分析表，包括两部分：</p>
<p>（1）ACTION[s，a]动作表，规定当状态s面临输入符号a时，应采取什么动作（移进、归约、接受、 报错）【<strong>也就是告诉我们当栈顶状态为s时，输入的符号是a时，我们应该采取什么操作：归约、移进还是报错</strong>】</p>
<p>（2）GOTO[s，X]状态转换表规定了状态s面对文法符号X时，下一状态是什么。【<strong>当归约完了后，要把规约后的非终结符压到栈里面的时候，跟新压入栈的这个非终结符所对应的状态是什么</strong>】</p>
<h2 id="LR文法"><a href="#LR文法" class="headerlink" title="LR文法"></a>LR文法</h2><p>对于一个文法，如果能够构造一张分析表，使得它的每个入口均是唯一确定的，则这个文法就是LR文法</p>
<p>一个文法，如果能用一个每步顶多向前检查k个输入符号的LR分析器分析，则这个文法就称为LR(K)文法</p>
<p>LR文法不是二义的</p>
<h2 id="LR-0-分析"><a href="#LR-0-分析" class="headerlink" title="LR(0)分析"></a>LR(0)分析</h2><h3 id="拓广文法"><a href="#拓广文法" class="headerlink" title="拓广文法"></a>拓广文法</h3><p>对于文法 G &#x3D; (V<del>N</del>, V<del>T</del>, P , S ) , 增加如下产生式：S’-&gt;S ，其中， S’ ∈ V<del>N</del>∪ V<del>T</del> ， 得到 G 的拓广文法，G’ &#x3D; (V<del>N</del> ’, V<del>T</del>, P ’ , S’ )</p>
<p><strong>其实就是增加了一条右部为开始符号的产生式，就变成了拓广文法</strong></p>
<h3 id="可归前缀"><a href="#可归前缀" class="headerlink" title="可归前缀"></a>可归前缀</h3><p>将符号串的任意含有头符号的子串称为前缀。特别地，空串ε为任意串的前缀。</p>
<p>采取归约过程前符号栈中的内容，称做可归前缀。<br>这种前缀包含句柄且不包含句柄之后的任何符号；</p>
<h3 id="活前缀"><a href="#活前缀" class="headerlink" title="活前缀"></a>活前缀</h3><p>就是在LR分析中为了描述栈内符号的特点给出的概念</p>
<p>对于文法 G &#x3D; (V<del>N</del>, V<del>T</del>, P , S ) , 设 S’ 是其拓广文法的开始符号（即有产生式 S’-&gt; S）， 且α,β∈(V<del>N</del>∪V<del>T</del>)* , ω∈V<del>T</del><em>。<br>若 S’ &#x3D;^</em>^&#x3D;&gt;α A ω 且 A -&gt;β， 即 β 为句柄，则 αβ 的任何前缀 γ 都是文法 G 的活前缀。【<strong>活前缀就是不含句柄之后任何符号的前缀</strong>】<br>注：由于 S’ &#x3D;^*^&#x3D;&gt;S’ 且 S’ -&gt; S， 故 S 是 G 的活前缀 。</p>
<p><strong>也就是说可归前缀的所有前缀（包括可归前缀）都是活前缀。</strong></p>
<blockquote>
<p>例：文法 G[S] :<br>（1） S -&gt; AB<br>（2） A -&gt; aA<br>（3） A -&gt; ε<br>（4） B -&gt; b<br>（5） B -&gt; bB<br>句子 aaab 是一个句型，其唯一的句柄为：ε （aaaεb）； 活前缀有：ε，a，aa，aaa。</p>
</blockquote>
<p>规范归约过程中，保证分析栈中总是活前缀，就说明分析采取的移进&#x2F;归约动作是正确的</p>
<h3 id="LR-0-项目"><a href="#LR-0-项目" class="headerlink" title="LR(0)项目"></a>LR(0)项目</h3><p>对于文法G，其产生式右部添加一个特殊的符号“.”，就构成文法的一个LR(0)项目，简称项目</p>
<p><strong>每个项目的含义是：欲用改产生式归约时，圆点前面的部分为已经识别了的句柄部分，圆点后面的部分为期望的后缀部分。</strong></p>
<p>分类：</p>
<p>移进项目: 形如 A -&gt; α • aβ（a∈V<del>T</del>），对应移进状态，把a移进符号栈。<br>待约项目: 形如 A -&gt; α • Bβ，对应待约状态，需要等待分析完非终结符B的串再继续分析A的右部。<br>归约项目: 形如 A -&gt; α •，句柄已形成，可以归约。<br>接受项目: 形如 S’ -&gt; S •。【也是一个归约项目，表示整个句子已经识别完毕】<br>初始项目: 形如 S’ -&gt; • S。<br>其中a∈V<del>T</del> , α,β∈(V<del>N</del>∪V<del>T</del>)*， A,B∈V<del>T</del><br>后继项目: 表示同属于一个产生式的项目，但是圆点的位置仅相差一个文法符号，则称后者为前者的后继项目。</p>
<p> • 的左边是已经归约，右边是没有归约的</p>
<blockquote>
<p>例：对于产生式S -&gt; aAcBe，它有6个项目：<br>S -&gt; ·aAcBe<br>S -&gt; a·AcBe<br>S -&gt; aA·cBe<br>S -&gt; aAc·Be<br>S -&gt; aAcB·e<br>S -&gt; aAcBe·</p>
</blockquote>
<h2 id="LR-0-有限状态机的构造方法"><a href="#LR-0-有限状态机的构造方法" class="headerlink" title="LR(0)有限状态机的构造方法"></a>LR(0)有限状态机的构造方法</h2><h3 id="构造识别活前缀的NFA"><a href="#构造识别活前缀的NFA" class="headerlink" title="构造识别活前缀的NFA"></a>构造识别活前缀的NFA</h3><h4 id="NFA的构造方法"><a href="#NFA的构造方法" class="headerlink" title="NFA的构造方法"></a>NFA的构造方法</h4><p>(1)状态集：由每个项目所对应的状态组成的集合；</p>
<p>(2)输入字符集合：由文法符号组成，包括：终结符、非终结符和e；</p>
<p>(3)初态：对于文法G[S]的拓广文法G[S’],有项目S’® . S ,由于S’ 仅在第一个产生式的左部出现，所以规定它为初态；</p>
<p>(4)终态：每个状态均为NFA的终态（活前缀的识别态）。</p>
 <img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203220121070.png" style="zoom:75%;" />

<ul>
<li><p>若状态i为X-&gt;X<del>1</del>····X<del>i-1</del>•X<del>i</del>····X<del>n</del>；状态j为X-&gt;X<del>1</del>····X<del>i-1</del>X<del>i</del>•X<del>i+1</del>····X<del>n</del></p>
<p>则从状态i画一条标志为X<del>i</del>的有向边到状态j</p>
</li>
<li><p>若状态i为X-&gt;α• Aβ，A为非终结符，<br>则从状态i画一条ε边到所有状态A-&gt;• y【可以理解成X想要把A进行归约，然后画一条ε边，交给A需要归约的符号】</p>
</li>
</ul>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203220250887.png" style="zoom:75%;" />

<h3 id="NFA转换成DFA"><a href="#NFA转换成DFA" class="headerlink" title="NFA转换成DFA"></a>NFA转换成DFA</h3><p>DFA是用子集法得到的</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203220947527.png" style="zoom:75%;" />

<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203221052145.png" style="zoom:75%;" />

<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203221104587.png" style="zoom:75%;" />

<h3 id="求项目集规范族"><a href="#求项目集规范族" class="headerlink" title="求项目集规范族"></a>求项目集规范族</h3><p>每个项目集对应一个DFA状态，它们的全体称为这个文法的项目集规范族</p>
<h4 id="有效项目"><a href="#有效项目" class="headerlink" title="有效项目"></a>有效项目</h4><p>项目A-&gt;β<del>1</del>• β<del>2</del>对活前缀αβ<del>1</del>是有效的，其条件就是存在规范推导</p>
<h4 id="1-用闭包函数（CLOSURE）来求DFA一个状态的项目集"><a href="#1-用闭包函数（CLOSURE）来求DFA一个状态的项目集" class="headerlink" title="1.用闭包函数（CLOSURE）来求DFA一个状态的项目集"></a>1.用闭包函数（CLOSURE）来求DFA一个状态的项目集</h4><p>I是拓广文法G的任意项目集：<br>CLOSURE(I)是这样定义的：<br>首先I的项目都属于CLOSURE(I)；<br>如果A-&gt;α• Bβ,则左部为B的每个产生式中的形如B-&gt;·γ项目，也属于CLOSURE(I)；</p>
<blockquote>
<p>例子：已知文法G[E]如下:<br>(1) E -&gt; E+T<br>(2) E -&gt; T<br>(3) T -&gt;( E )<br>(4) T -&gt; d</p>
<p>可以直到它的拓广文法G’ [E’]为 ：<br>(0) E’ -&gt; E<br>(1) E -&gt; E+T<br>(2) E -&gt; T<br>(3) T -&gt; ( E )<br>(4) T -&gt; d</p>
<p>令I<del>0</del> &#x3D; CLOSURE({E’-&gt;.E})</p>
<p>则I<del>0</del> &#x3D; {<br>E’ -&gt; • E，<br>E -&gt; • E+T，<br>E -&gt; • T，<br>T -&gt; •( E ),<br>T -&gt; • d<br>}</p>
</blockquote>
<h4 id="2-LR-0-FSM-的状态转移函数"><a href="#2-LR-0-FSM-的状态转移函数" class="headerlink" title="2.LR(0) FSM 的状态转移函数"></a>2.LR(0) FSM 的状态转移函数</h4><p>从一个状态出发，到达下一个状态的转换函数：<br>GO (I,X) &#x3D; CLOSURE(J)<br>其中，I为LR(0) FSM 的状态（闭包的项目集），X为文法符号， J&#x3D;{ A -&gt; αX•β | A -&gt; α• Xβ∈I} ；【J是非终结符包进去后的集合】<br>表示对于一个状态项目集中的一个项目A -&gt; α• Xβ，在下一个输入字符是X的情况下，一定到另一个新状态 A -&gt; αX•β。</p>
<h4 id="3-LR-0-有限状态机的构造"><a href="#3-LR-0-有限状态机的构造" class="headerlink" title="3.LR(0) 有限状态机的构造"></a>3.LR(0) 有限状态机的构造</h4><p>从 LR(0) FSM 的初态出发 ，先求出初态项目集的闭包（CLOSURE({S’-&gt;.S})），然后应用上述转移函数，通过项目分析每种输入字符下的状态转移，若为新状态，则就求出新状态下的项目集的闭包，级可逐步构造出完整的 LR(0) FSM。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">构造项目集规范族的算法：</span><br><span class="line"><span class="function"><span class="keyword">PROCEDURE</span> <span class="title">ITEMSET</span><span class="params">(G<span class="string">&#x27;)；</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">BEGIN</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">C:&#123;CLOSURE&#123;S&#x27;</span>-&gt;.S&#125;&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">REPEAT</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">FOR</span> C中的每一个项目集I和G<span class="string">&#x27;的每一个符号X DO</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		IF GO(I,X)非空且不属于C THEN</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		把GO(I,X)放入C族中</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">	UNTIL C不再增大</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">End</span></span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>LR(0) FSM 的构造举例<br>给定文法G[E]：<br>(1) E -&gt; E+T<br>(2) E -&gt; T<br>(3) T -&gt; ( E )<br>(4) T -&gt; d</p>
<p>构造LR(0) FSM<br>① G[E]的拓广文法，得到G’ [E’]：<br>(0) E’ -&gt; E<br>(1) E -&gt; E+T<br>(2) E -&gt; T<br>(3) T -&gt; ( E )<br>(4) T -&gt; d</p>
<p>②构造G’[E’] 的 LR(0) FSM</p>
<p><img src="https://img-blog.csdnimg.cn/20181229131739897"></p>
</blockquote>
<p>两种构造识别活前缀的DFA的方法：</p>
<ul>
<li>项目-&gt;NFA-&gt;DFA</li>
<li>Closure-&gt;GO-&gt;DFA</li>
</ul>
<h2 id="LR-0-分析法"><a href="#LR-0-分析法" class="headerlink" title="LR(0) 分析法"></a>LR(0) 分析法</h2><h3 id="1-LR-0-文法定义"><a href="#1-LR-0-文法定义" class="headerlink" title="1.LR(0) 文法定义"></a>1.LR(0) 文法定义</h3><p>文法 G 是 LR(0) 文法，当且仅当它的LR(0)FSM中的每个状态都满足：<br><strong>①不同时含有移进项目和归约项目，即不存在移进-归约冲突。</strong><br><strong>②不含有两个以上归约项目，即不存在归约-归约冲突。</strong></p>
<h3 id="2-LR-0-分析表的构造"><a href="#2-LR-0-分析表的构造" class="headerlink" title="2.LR(0)分析表的构造"></a>2.LR(0)分析表的构造</h3><p>令每个项目集I<del>k</del>的下标k作为分析器的状态</p>
<p>ACTION 表项和 GOTO表项可按如下方法构造：</p>
<ul>
<li><p>若项目A -&gt;α • aβ属于 I<del>k</del> 且 GO (I<del>k</del>, a)&#x3D; I<del>j</del>, 期望字符a 为终结符，则置ACTION[k, a] &#x3D;s<del>j</del> (j表示新状态I<del>j</del>);</p>
</li>
<li><p>若项目A -&gt;α •属于I<del>k</del>, 那么对任何终结符a, 置ACTION[k, a]&#x3D;r<del>j</del>；其中，假定A-&gt;α为文法G 的第j个产生式；【对k到a进行归约】</p>
</li>
<li><p>若项目S’ -&gt;S • 属于I<del>k</del>, 则置ACTION[k, #]为“acc”;【单词处理完毕】</p>
</li>
<li><p>若项目A -&gt;α • Aβ属于 I<del>k</del>，且GO (I<del>k</del>, A)&#x3D; I<del>j</del>,期望字符 A为非终结符，则置GOTO(k, A)&#x3D;j (j表示文法中第j个产生式);</p>
</li>
<li><p>分析表中凡不能用上述规则填入信息的空白格均置上“出错标志”</p>
<p><strong>翻译一下：</strong></p>
<ol>
<li><strong>如果圆点不在项目k最后且圆点后的期待字符a为终结符，则ACTION[k, a] &#x3D;s<del>j</del> (j表示新状态I<del>j</del>)；</strong></li>
<li><strong>如果圆点不在项目k最后且圆点后的期待字符A为非终结符，则GOTO(k, A)&#x3D;j (j表示文法中第j个产生式)；</strong></li>
<li><strong>如果圆点在项目k最后且k不是S’ -&gt;S，那么对所有终结符a，ACTION[k, a]&#x3D;r<del>j</del> (j表示文法中第j个产生式)；</strong></li>
<li><strong>如果圆点在项目k最后且k是S’ -&gt;S，则ACTION[k, #]为“acc”;</strong></li>
</ol>
</li>
</ul>
<blockquote>
<p>例子：</p>
<p>考虑文法G[S] :<br>S → （S） | a<br>相应的LR(0) FSM如下，构造其LR(0)分析表。</p>
<p><img src="https://img-blog.csdnimg.cn/20181229131739956"></p>
<p>LR(0) FSM</p>
<p>从I<del>0</del>看，S‘-&gt;·S,期望字符是非终结符S，根据上面的规则2，得到GOTO(0,S)&#x3D;1；<br>S‘-&gt;·(S),期望字符是终结符(，根据上面的规则1，得到ACTION(0,()&#x3D;S<del>2</del>；<br>从I<del>3</del>看，S-&gt;a·，根据规则3，置ACTION[3, a]为r<del>2</del>;<br>从I<del>1</del>看，S‘-&gt;S·，根据规则4，置ACTION[1, #]为“acc”;</p>
<p><img src="https://img-blog.csdnimg.cn/201812291317408"></p>
<p>LR(0)分析表</p>
</blockquote>
<h3 id="3-LR-0-分析流程"><a href="#3-LR-0-分析流程" class="headerlink" title="3.LR(0) 分析流程"></a>3.LR(0) 分析流程</h3><p>设输入串为w，ip指向输入串w的首符号a，i指向符号栈顶；状态栈的初始栈顶为0，符号栈初始栈顶为#。</p>
<p>算法流程图为：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/image-20200427170434108.png"></p>
<h2 id="SLR-1-分析法"><a href="#SLR-1-分析法" class="headerlink" title="SLR(1)分析法"></a>SLR(1)分析法</h2><h3 id="1-SLR-1-解决的问题"><a href="#1-SLR-1-解决的问题" class="headerlink" title="1.SLR(1)解决的问题"></a>1.SLR(1)解决的问题</h3><p>LR(0)文法的要求是①不同时含有移进项目和归约项目，即不存在移进-归约冲突。②不含有两个以上归约项目，即不存在归约-归约冲突。</p>
<p>例如项目集I<del>i</del>中存在： I<del>i</del> ＝{A-&gt;α•bγ ， B→ γ•，C→β• }，此时就同时存在移进-归约冲突和归约-归约；因为你不知道下一步是选择归约还是移进，选择归约的话选择哪个产生式归约。</p>
<p>而事实上一般文法满足这种要求有一定难度，但是假如在归约时出现了移进-归约冲突或者归约-归约冲突，我们可以通过在待分析的字符串中向后再看一位，大多数情况下通过这一位字符就可以确定，选择哪一个表达式归约，或是移进操作。</p>
<p>这种方法就叫做SLR(1)分析法，即简单的LR(1)分析法。</p>
<h3 id="2-SLR-1-冲突解决方法"><a href="#2-SLR-1-冲突解决方法" class="headerlink" title="2.SLR(1)冲突解决方法"></a>2.SLR(1)冲突解决方法</h3><p>如上面所述，我们需要知道下一位待分析的字符，然后和现有项目进行比较。</p>
<p>分析过程与LR(0)一样，但是需要解决分析表上的冲突问题。</p>
<p>假如LR(0) 项目集规范族中有项目集 I<del>i</del> 含有移进-归约冲突和归约-归约冲突：<br> I<del>i</del> ＝{A<del>1</del>-&gt;α<del>1</del>•b<del>1</del>γ<del>1</del>，… ， A<del>m</del>-&gt;m•b<del>m</del> γ<del>m</del>， B<del>1</del>-&gt;β<del>1</del>• ，…， B<del>n</del>-&gt; β<del>n</del>• }，若集合{b<del>1</del> ，b<del>2</del>，… ，b<del>m</del> }、FOLLOW(B<del>1</del>) 、 FOLLOW(B<del>2</del>) ，…，FOLLOW(Bn)均两两不相交，则可用SLR(1)解决方法解决分析表上第i行上的冲突问题。</p>
<p>假设下一个移进的字符为b:</p>
<p>1、若b∈ {b<del>1</del> ，b<del>2</del>，… ，b<del>m</del> }，则移进输入符；</p>
<p>2、若b∈FOLLOW(B<del>j</del>) ，j＝1 ，… ，n，则用B<del>j</del>-&gt; β<del>j</del> 归约；</p>
<p>3、此外，报错</p>
<p>通过这个方法，就可以在知道下一位待分析的字符的情况下，解决冲突。</p>
<p>继续采用SLR(1)分析的方法，我们可以对出错情况进行优化：</p>
<p>在LR(0)和SLR(1)分析中，我们在可以归约且没有冲突时（假如归约成A），是不关心下一位待分析的字符a和follow(A)的关系的，假如a!∈follow(A)则当前字符串是不被接受的，当然这会在之后的继续移进字符过程中发现错误，但是如果不管是否有冲突看，将SLR(1)分析方法应用到所有分析表的构建过程中，可以提前发现字符串的错误。</p>
<h3 id="3-构造SLR-1-分析表的方法"><a href="#3-构造SLR-1-分析表的方法" class="headerlink" title="3.构造SLR(1)分析表的方法"></a>3.构造SLR(1)分析表的方法</h3><p>1、把G扩广成G’</p>
<p>2、对G’构造：得到LR(0)项目集规范族C；活前缀识别自动机的状态转换函数GO</p>
<p>3、使用C和GO，构造SLR分析表：构造action和goto子表：</p>
<ul>
<li>若项目A -&gt;α • aβ属于 I<del>k</del> 且 GO (I<del>k</del>, a)&#x3D; I<del>j</del>,期望字符a为终结符，则置ACTION[k, a] &#x3D;s<del>j</del> (j表示新状态I<del>j</del>);</li>
<li>若项目A -&gt;α • Aβ属于 I<del>k</del>，且GO (I<del>k</del>, A)&#x3D; I<del>j</del>,期望字符 A为非终结符，则置GOTO(k, A)&#x3D;j (j表示文法中第j个产生式);</li>
<li>若项目A -&gt;α •属于I<del>k</del>, 那么对任何终结符a，<strong>当满足a属于follow(A)时</strong>， 置ACTION[k, a]&#x3D;r<del>j</del>；其中，假定A-&gt;α为文法G 的第j个产生式；</li>
<li>若项目S’ -&gt;S • 属于I<del>k</del>, 则置ACTION[k, #]&#x3D;“acc”;</li>
<li>分析表中凡不能用上述规则填入信息的空白格均置上“出错标志”</li>
</ul>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/image-20200427182955125.png"></p>
<p>SLR分析是有选择的放置的</p>
<h3 id="4-SLR（1）文法"><a href="#4-SLR（1）文法" class="headerlink" title="4.SLR（1）文法"></a>4.SLR（1）文法</h3><p>按上述方法构造出的ACTION和GOTO表如果不含多重入口，则称该文法是SLR(1)文法。</p>
<p>使用SLR表的分析器叫做一个SLR分析器</p>
<p>每个SLR(1)文法都是无二义的。<br>$$<br>LR(0)\subset SLR(1)\subset 无二义文法<br>$$</p>
<h3 id="5-SLR-1-分析的例子"><a href="#5-SLR-1-分析的例子" class="headerlink" title="5.SLR(1)分析的例子"></a>5.SLR(1)分析的例子</h3><blockquote>
<p>算术表达式文法G[E]：<br>E→E +T | T<br>T→T * F | F<br>F→ （E）| i<br>求此文法的识别规范句型活前缀的DFA，分析句子i+i *i。</p>
</blockquote>
<ol>
<li>将文法拓广为G’[E’]：<br>(0) E’ -&gt;E<br>(1) E-&gt; E +T<br>(2) E -&gt;T<br>(3) T -&gt;T * F<br>(4) T -&gt;F<br>(5) F -&gt;(E)<br>(6) F -&gt;i</li>
<li>构造识别规范句型活前缀的DFA</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20181229131728485"></p>
<ol>
<li><p>判断有无冲突：</p>
<p>I<del>1</del> ，I<del>2</del> ，I<del>9</del>有移进_归约冲突。<br>I<del>1</del>:E´ -&gt;E· E -&gt;E·+T<br>I<del>2</del>: E -&gt;T · T -&gt;T · *F<br>I<del>9</del>: E -&gt;E+T· T -&gt;T · *F</p>
</li>
<li><p>考虑能否用SLR(1)方法解决冲突：</p>
<p>对于I<del>1</del>: <code>&#123; E´ -&gt;E· E -&gt;E·+T&#125;</code> 因为：<code>&#123;+&#125; ∈FOLLOW(E´)= &#123;+&#125; ∩ &#123;＃&#125; ＝∅</code>, 所以可用SLR(1)方法 解决I<del>1</del>的冲突。</p>
<p>对于I<del>2</del>: <code>&#123;E -&gt;T· T -&gt;T·*F&#125;</code> 因为：<code>&#123;*&#125; ∈ FOLLOW(E)= &#123;*&#125; ∩ &#123;＃，）,+&#125; ＝ ∅</code> 所以可用SLR(1)方法解决I<del>2</del>的冲突。</p>
<p>对于I<del>9</del>: <code>&#123;E -&gt;E+T· T -&gt;T ·*F&#125;</code> 因为：<code>&#123;*&#125; FOLLOW(E)= ∅</code>, 所以可用SLR(1)方法解决I<del>9</del>的冲突。</p>
</li>
<li><p>构建分析表：</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20181229131728536"></p>
<p>6.句子i+i *i的分析过程：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>状态栈</th>
<th>符号栈</th>
<th>输入符</th>
<th>剩余输   入串</th>
<th align="left">查表</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
<td>#</td>
<td>i</td>
<td>i+i*i#</td>
<td align="left">Action[0,i]&#x3D;S5</td>
<td>移进i</td>
</tr>
<tr>
<td>2</td>
<td>0 5</td>
<td># i</td>
<td>+</td>
<td>+i*i#</td>
<td align="left">Action[5,+]&#x3D;r6,GOTO(0,F)&#x3D;3</td>
<td>用F -&gt; i 归约</td>
</tr>
<tr>
<td>3</td>
<td>0 3</td>
<td># F</td>
<td>+</td>
<td>+i*i#</td>
<td align="left">Action[3,+]&#x3D;r4,GOTO(0,T)&#x3D;2</td>
<td>用F -&gt; T归约</td>
</tr>
<tr>
<td>4</td>
<td>0 2</td>
<td># T</td>
<td>+</td>
<td>+i*i#</td>
<td align="left">Action[2,+]&#x3D;r4,GOTO(0,E)&#x3D;1</td>
<td>用F -&gt; E归约</td>
</tr>
<tr>
<td>5</td>
<td>0 1</td>
<td># E</td>
<td>+</td>
<td>+i*i#</td>
<td align="left">Action[1,+]&#x3D;S6</td>
<td>移进+</td>
</tr>
<tr>
<td>6</td>
<td>0 1 6</td>
<td># E +</td>
<td>i</td>
<td>i*i#</td>
<td align="left">Action[6,i]&#x3D;S6</td>
<td>移进+</td>
</tr>
<tr>
<td>7</td>
<td>0 1 6 5</td>
<td># E + i</td>
<td>*</td>
<td>*i#</td>
<td align="left">Action[5,*]&#x3D;r6,GOTO(6,F)&#x3D;3</td>
<td>用F -&gt; i 归约</td>
</tr>
<tr>
<td>8</td>
<td>0 1 6 3</td>
<td># E + F</td>
<td>*</td>
<td>*i#</td>
<td align="left">Action[3,*]&#x3D;r6,GOTO(6,T)&#x3D;9</td>
<td>用F -&gt; F 归约</td>
</tr>
<tr>
<td>9</td>
<td>0 1 6 9</td>
<td># E + T</td>
<td>*</td>
<td>*i#</td>
<td align="left">Action[9,*]&#x3D;S7</td>
<td>移进*</td>
</tr>
<tr>
<td>10</td>
<td>0 1 6 9 7</td>
<td># E + T *</td>
<td>i</td>
<td>i#</td>
<td align="left">Action[7,i]&#x3D;S5</td>
<td>移进i</td>
</tr>
<tr>
<td>11</td>
<td>0 1 6 9 7 5</td>
<td># E + T * i</td>
<td>#</td>
<td>#</td>
<td align="left">Action[5,#]&#x3D;r6,GOTO(7,F)&#x3D;10</td>
<td>用F -&gt; i 归约</td>
</tr>
<tr>
<td>12</td>
<td>0 1 6 9 7 10</td>
<td># E + T * F</td>
<td>#</td>
<td>#</td>
<td align="left">Action[10,#]&#x3D;r3,GOTO(6,T)&#x3D;9</td>
<td>用T -&gt; T+F归约</td>
</tr>
<tr>
<td>13</td>
<td>0 1 6 9</td>
<td># E + T</td>
<td>#</td>
<td>#</td>
<td align="left">Action[9,#]&#x3D;r1,GOTO(0,E)&#x3D;1</td>
<td>用E -&gt; E+T归约</td>
</tr>
<tr>
<td>14</td>
<td>0 1</td>
<td># E</td>
<td>#</td>
<td>#</td>
<td align="left">Action[1,#]&#x3D;acc</td>
<td>接受</td>
</tr>
</tbody></table>
<h2 id="LR-1-分析法"><a href="#LR-1-分析法" class="headerlink" title="LR(1)分析法"></a>LR(1)分析法</h2><h3 id="SLR冲突消解存在的问题"><a href="#SLR冲突消解存在的问题" class="headerlink" title="SLR冲突消解存在的问题"></a>SLR冲突消解存在的问题</h3><p>在SLR方法中，如果项目集I<del>i</del>含项目A -&gt;α •而且下一输入符号α∈FOLLOW(A)，则状态i面临α时，可选用“用A -&gt;α归约”动作。</p>
<p>但是在某些情况下，当状态i显现于栈顶时，当前单词是α，栈里的活前缀βα未必允许把α归约为A，因为可能根本不存在一个形如“βAα”的规范句型。在这种情况下，用“A -&gt;α”归约不一定合适</p>
<p>【因为FOLLOW（A）集合提供的信息太泛】</p>
<h3 id="构造LR-1-分析表的方法"><a href="#构造LR-1-分析表的方法" class="headerlink" title="构造LR(1)分析表的方法"></a>构造LR(1)分析表的方法</h3><p>1、把G扩广成G’</p>
<p>2、对G’构造：得到LR(1)项目集规范族C；活前缀识别自动机的状态转换函数GO</p>
<p>3、使用C和GO，构造LR（1）分析表：</p>
<p>LR(K)项目：扩展LR(0)项目，附带有k个终结符[A-&gt;α •β,α<del>1</del>α<del>2</del>····α<del>k</del>]<br>α<del>1</del>α<del>2</del>····α<del>k</del>称为向前搜索符串（或展望串）</p>
<p>归约项目[A-&gt;α •,α<del>1</del>α<del>2</del>····α<del>k</del>]的意义：当它所属的状态呈现现在栈顶且后续的k个输入符号为α<del>1</del>α<del>2</del>····α<del>k</del>时，才可以把栈顶上的α归约为A</p>
<p> 对于任何移进或待约项目[A-&gt;α •β,α<del>1</del>α<del>2</del>····α<del>k</del>]，β不等于α，搜索符串α<del>1</del>α<del>2</del>····α<del>k</del>没有直接作用 </p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">构造项目集规范族的算法：</span><br><span class="line"><span class="function"><span class="keyword">PROCEDURE</span> <span class="title">ITEMSET</span><span class="params">(G<span class="string">&#x27;)；</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">BEGIN</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">C:&#123;CLOSURE&#123;S&#x27;</span>-&gt;.S,#&#125;&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">REPEAT</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">FOR</span> C中的每一个项目集I和G<span class="string">&#x27;的每一个符号X DO</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		IF GO(I,X)非空且不属于C THEN</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		把GO(I,X)放入C族中</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">	UNTIL C不再增大</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">End</span></span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>若项目[A -&gt;α • aβ，b]属于 I<del>k</del> 且 GO (I<del>k</del>, a)&#x3D; I<del>j</del>,期望字符a为终结符，则置ACTION[k, a] &#x3D;s<del>j</del> (j表示新状态I<del>j</del>);</li>
<li>若项目[A -&gt;α •，a]属于I<del>k</del>, 那么对任何终结符a，<strong>当满足a属于follow(A)时</strong>， 置ACTION[k, a]&#x3D;r<del>j</del>；其中，假定A-&gt;α为文法G 的第j个产生式；</li>
<li>若项目[S’ -&gt;S • ，#]属于I<del>k</del>, 则置ACTION[k, #]&#x3D;“acc”;</li>
<li>若GO[I<del>k</del>，A]&#x3D;I<del>j</del>，则置GOTO[K,A]&#x3D;j</li>
<li>分析表中凡不能用上述规则填入信息的空白格均置上“出错标志”</li>
</ul>
<p>$$<br>LR(0)\subset SLR(1)\subset LR(1)\subset 无二义文法<br>$$</p>
<p><strong>（SLR(1)和LR(1)的区别在于LR(1)多使用了一个预判信息，即项目后面的符号如A →·e,c中的c，这个预判信息是用first集而非follow集得出的）</strong></p>
<h1 id="LR-0-、SLR-1-、LL-1-等的区别"><a href="#LR-0-、SLR-1-、LL-1-等的区别" class="headerlink" title="LR(0)、SLR(1)、LL(1)等的区别"></a>LR(0)、SLR(1)、LL(1)等的区别</h1><p>LL(1)定义：一个文法G是LL（1）的，当且仅当对于G的每一个非终结符A的任何两个不同产生式 A→α|β，下面的条件成立：SELECT( A→α)∩SELECT( A→β)&#x3D;,其中，</p>
<p>α|β不能同时ε。</p>
<p>解释：LL(1)的意思是，第一个L,指的是从左往右处理输入，第二个L,指的是它为输入生成一个最左推导。1指的是向前展望1个符号。LL(1)文法是上下文无关文法的一个子集。它用的方法是自顶向下的(递归式的处理)。它要求生成的预测分析表的每一个项目至多只能有一个生成式。上面的定义说的是，任何两个不同的产生式 A→α和 A→β,选择A→α或者 A→β是不能有冲突的，即SELECT( A→α)∩SELECT( A→β)&#x3D;，具体来说，就是，第一:First( A→α) ∩ First( A→β)&#x3D;,首符集不能有交集，否则当交集中的元素出现时，选择哪个产生式进行推导是不确定的，（这其中也包含了α|β不能同时ε，否则交集就是{ε}不为空），第二：若任何一个产生式β，有ε属于First(β),应有First(A)∩Follow( A)为空（当ε属于First(β)，则A有可能被空串代替，那么就要看A的下一个字符，即Follow集，即要求Follow集和First集不能相交，否则可能发生冲突）。</p>
<p>LR文法：定义：如果某一文法能够构造一张分析表，使得表中每一个元素至多只有一种明确动作，则该文法称为LR文法。</p>
<p>拓展：由上面的定义可以看到，LL(1)和LR文法都是无二义性的：LL(1)要求生成的预测分析表的每一个项目至多只能有一个生成式，即对于读头下的每一个字符，都可以明确地选择哪个产生式来推导，LR文法要求每一步都有明确的动作，移进和归约都是可确定的，没有二义性。</p>
<p>比较两大类型（自顶向下　vs 自底向上）的文法的特点：</p>
<p>1.首先LL(1)分析法是自上而下的分析法。LR(0),LR(1),SLR(1),LALR(1)是自下而上的分析法。<br>   2.自上而下:从开始符号出发，根据产生式规则推导给定的句子。用的是推导<br>   3.自下而上:从给定的句子规约到文法的开始符号。用的是归约<br>   4.自上而下就是一种试探过程，怎么试探？需要你写出它的FIRST()集与FOLLOW()集。写出这两个集合后根据LL(1)分析表构造规则画出LL(1)分析表。现在基本完成了大半，当计算机输入句子时，分析程序便会根据输入去和分析表进行匹配，如果每步都能够匹配成功则说明符合该语法规则，分析成功。<br>   FIRST()集：其实是终结符的集合，看该非终结符A能不能产生以它里面的某个符号开头的句子。（这也是自上而下分析法的思想）<br>   5.自下而上就是把句子变成非终结符，在把非终结符变成非终结符，这样不断的进行如果能到根节点则成功。</p>
<p> LL(1)就是向前只搜索1个符号，即与FIRST()匹配，如果FIRST为空则还要考虑Follow。<br>　 LR需要构造一张LR分析表，此表用于当面临输入字符时，将它移进，规约（即自下而上分析思想），接受还是出错。<br>   LR(0)找出句柄前缀，构造分析表，然后根据输入符号进行规约。不考虑先行，只要出现终结符就移进，只要出现归约状态，就无条件归约,这样子可能出现归约－移进，归约－归约冲突。<br>   SLR(1)使用LR(0)时若有归约－归约冲突，归约－移进冲突，所以需要看先行，则只把有问题的地方向前搜索一次。</p>
<p>SLR(1)定义：满足下面两个条件的文法是SLR(1)文法</p>
<p>a.对于在s中的任何项目 A→α.Xβ,当X是一个终结符，且X在Follow(B)中时，s中没有完整的项目B→r.</p>
<p>b.对于在s中的任何两个完整项目A→α.和 B→β.,Follow(A)∩Follow(B)为空。</p>
<p>解释：a.当X是一个终结符且X出现在读头上，对于项目 A→α.Xβ应该采用移进，若有完整的项目B→r.且Follow(B)中有X，当X出现在读头上时，此时应该归约，于是，就产生了移进和归约冲突</p>
<p>b.假设Follow(A)∩Follow(B)为{ X },对于A→α.，若Follow(A)[A后面的元素]出现时，应该归约，同理B也一样，于是，会产生归约－归约冲突，SLR(1)是为了消除LR(0)的两个冲突。<br>   LR(1)1.在每个项目中增加搜索符。2.举个列子如有A-&gt;α.Bβ，则还需将B的规则也加入。<br>   LALR(1)就是假如两个产生式集相同则将它们合并为一个，几合并同心集</p>
<p><strong>总结：</strong></p>
<p><strong>见到First集就移进，见到Follow集就归约。</strong></p>
<p><strong>LR(0):见到First集就移进，见到终态就归约</strong></p>
<p><strong>SLR(1)见到First集就移进，见到终态先看Follow集，与Follow集对应的项目归约，其它报错。</strong></p>
<p><strong>SLR分析法包含的展望信息是体现在利用了Follow(A)信息，可以解决“归约－归约”冲突</strong></p>
<p><strong>SLR分析法没有包含足够的展望信息，不能完成解决“移进－归约”冲突，需要改进。</strong></p>
<p><strong>下面是LR(0),SLR(1),LALR(1),LR(1)文法处理能力的比较，圆圈越大说明能力越强。</strong></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20130703204706828"></p>

    </div>
<div>
  
    <div>
    
        <div style="text-align:center;color: #555;font-size:14px;">-------------The End-------------</div>
    
</div>
  
</div>
    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>rhb
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://rshawshank.github.io/2020/03/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/" title="编译原理-LR分析">http://rshawshank.github.io/2020/03/27/编译原理-LR分析/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag"># 编译原理</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" rel="prev" title="编译原理-语法分析">
      <i class="fa fa-chevron-left"></i> 编译原理-语法分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="next" title="数据库_关系数据库">
      数据库_关系数据库 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%A5%E6%9F%84%E5%92%8C%E8%A7%84%E8%8C%83%E5%BD%92%E7%BA%A6"><span class="nav-number">1.</span> <span class="nav-text">句柄和规范归约</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LR%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">LR分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LR%E6%96%87%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">LR文法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LR-0-%E5%88%86%E6%9E%90"><span class="nav-number">2.2.</span> <span class="nav-text">LR(0)分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E5%B9%BF%E6%96%87%E6%B3%95"><span class="nav-number">2.2.1.</span> <span class="nav-text">拓广文法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%BD%92%E5%89%8D%E7%BC%80"><span class="nav-number">2.2.2.</span> <span class="nav-text">可归前缀</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BB%E5%89%8D%E7%BC%80"><span class="nav-number">2.2.3.</span> <span class="nav-text">活前缀</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LR-0-%E9%A1%B9%E7%9B%AE"><span class="nav-number">2.2.4.</span> <span class="nav-text">LR(0)项目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LR-0-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">LR(0)有限状态机的构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E8%AF%86%E5%88%AB%E6%B4%BB%E5%89%8D%E7%BC%80%E7%9A%84NFA"><span class="nav-number">2.3.1.</span> <span class="nav-text">构造识别活前缀的NFA</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NFA%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">NFA的构造方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NFA%E8%BD%AC%E6%8D%A2%E6%88%90DFA"><span class="nav-number">2.3.2.</span> <span class="nav-text">NFA转换成DFA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82%E9%A1%B9%E7%9B%AE%E9%9B%86%E8%A7%84%E8%8C%83%E6%97%8F"><span class="nav-number">2.3.3.</span> <span class="nav-text">求项目集规范族</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E6%95%88%E9%A1%B9%E7%9B%AE"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">有效项目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%94%A8%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%EF%BC%88CLOSURE%EF%BC%89%E6%9D%A5%E6%B1%82DFA%E4%B8%80%E4%B8%AA%E7%8A%B6%E6%80%81%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%9B%86"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">1.用闭包函数（CLOSURE）来求DFA一个状态的项目集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-LR-0-FSM-%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">2.LR(0) FSM 的状态转移函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-LR-0-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E6%9E%84%E9%80%A0"><span class="nav-number">2.3.3.4.</span> <span class="nav-text">3.LR(0) 有限状态机的构造</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LR-0-%E5%88%86%E6%9E%90%E6%B3%95"><span class="nav-number">2.4.</span> <span class="nav-text">LR(0) 分析法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-LR-0-%E6%96%87%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="nav-number">2.4.1.</span> <span class="nav-text">1.LR(0) 文法定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-LR-0-%E5%88%86%E6%9E%90%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.LR(0)分析表的构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-LR-0-%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="nav-number">2.4.3.</span> <span class="nav-text">3.LR(0) 分析流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SLR-1-%E5%88%86%E6%9E%90%E6%B3%95"><span class="nav-number">2.5.</span> <span class="nav-text">SLR(1)分析法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-SLR-1-%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.5.1.</span> <span class="nav-text">1.SLR(1)解决的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-SLR-1-%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.SLR(1)冲突解决方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0SLR-1-%E5%88%86%E6%9E%90%E8%A1%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.5.3.</span> <span class="nav-text">3.构造SLR(1)分析表的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-SLR%EF%BC%881%EF%BC%89%E6%96%87%E6%B3%95"><span class="nav-number">2.5.4.</span> <span class="nav-text">4.SLR（1）文法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-SLR-1-%E5%88%86%E6%9E%90%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">2.5.5.</span> <span class="nav-text">5.SLR(1)分析的例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LR-1-%E5%88%86%E6%9E%90%E6%B3%95"><span class="nav-number">2.6.</span> <span class="nav-text">LR(1)分析法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SLR%E5%86%B2%E7%AA%81%E6%B6%88%E8%A7%A3%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.6.1.</span> <span class="nav-text">SLR冲突消解存在的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0LR-1-%E5%88%86%E6%9E%90%E8%A1%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.6.2.</span> <span class="nav-text">构造LR(1)分析表的方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LR-0-%E3%80%81SLR-1-%E3%80%81LL-1-%E7%AD%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">LR(0)、SLR(1)、LL(1)等的区别</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rhb</p>
  <div class="site-description" itemprop="description">纵浪大化中，不喜亦不惧</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">126</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RShawshank" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RShawshank" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rhb</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
