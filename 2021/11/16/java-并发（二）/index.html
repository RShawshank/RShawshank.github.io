<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rshawshank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="五、线程同步  java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。 1、使用重入锁（Lock）实现线程同步​      在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。Reentrant">
<meta property="og:type" content="article">
<meta property="og:title" content="java-并发（二）">
<meta property="og:url" content="http://rshawshank.github.io/2021/11/16/java-%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/index.html">
<meta property="og:site_name" content="rhb_blog">
<meta property="og:description" content="五、线程同步  java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。 1、使用重入锁（Lock）实现线程同步​      在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。Reentrant">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ba078291-791e-4378-b6d1-ece76c2f0b14.png">
<meta property="og:image" content="https://i.loli.net/2021/11/22/MsL1UAKey8XDptn.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f71af66b-0d54-4399-a44b-f47b58321984.png">
<meta property="og:image" content="https://i.loli.net/2021/11/22/kbPTMqx5AvcmYZu.png">
<meta property="og:image" content="https://i.loli.net/2021/11/22/gnBeVMbcx2L1a6l.png">
<meta property="og:image" content="https://i.loli.net/2021/11/22/StGsfokCVRbF2Oy.png">
<meta property="og:image" content="https://i.loli.net/2021/11/22/kay4tz3ig9UBLDP.png">
<meta property="og:image" content="https://i.loli.net/2021/11/22/WHLbGySihmJ4uwX.png">
<meta property="og:image" content="https://i.loli.net/2021/11/22/WphDRvwNO4HauMi.png">
<meta property="og:image" content="https://i.loli.net/2021/11/22/PbFxRsdYJSpUn8D.png">
<meta property="og:image" content="https://i.loli.net/2021/11/22/b8ISi7VOlQKcMsp.png">
<meta property="og:image" content="https://i.loli.net/2021/11/22/bNFwlpIDYLdrU8C.png">
<meta property="og:image" content="https://i.loli.net/2021/11/22/utyGBKSCf8aZjPo.png">
<meta property="og:image" content="https://i.loli.net/2021/11/22/VvpuyIYZdQiSnRz.png">
<meta property="article:published_time" content="2021-11-16T15:47:12.000Z">
<meta property="article:modified_time" content="2021-11-22T07:49:42.000Z">
<meta property="article:author" content="rhb">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ba078291-791e-4378-b6d1-ece76c2f0b14.png">

<link rel="canonical" href="http://rshawshank.github.io/2021/11/16/java-%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java-并发（二） | rhb_blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rhb_blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">rao的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/11/16/java-%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java-并发（二）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-16 15:47:12" itemprop="dateCreated datePublished" datetime="2021-11-16T15:47:12Z">2021-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-22 07:49:42" itemprop="dateModified" datetime="2021-11-22T07:49:42Z">2021-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="五、线程同步"><a href="#五、线程同步" class="headerlink" title="五、线程同步"></a>五、线程同步</h1><p>  java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p>
<h2 id="1、使用重入锁（Lock）实现线程同步"><a href="#1、使用重入锁（Lock）实现线程同步" class="headerlink" title="1、使用重入锁（Lock）实现线程同步"></a>1、使用重入锁（Lock）实现线程同步</h2><p>​      在<a target="_blank" rel="noopener" href="http://www.2cto.com/kf/ware/Java/">Java</a>SE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。ReenreantLock类的常用方法有：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">ReentrantLock</span><span class="params">()</span></span> : 创建一个ReentrantLock实例         </span><br><span class="line"><span class="function"><span class="title">lock</span><span class="params">()</span></span> : 获得锁        </span><br><span class="line"><span class="function"><span class="title">unlock</span><span class="params">()</span></span> : 释放锁</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只给出要修改的代码，其余代码与上同</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">account</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">            <span class="comment">//需要声明这个锁</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAccount</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> account;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里不再需要synchronized </span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">                lock.lock();<span class="comment">//</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    account += money;</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    lock.unlock();<span class="comment">//解锁线程</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        ｝ </span><br></pre></td></tr></table></figure>

<p><code>lock.lock();</code>确保只有一个线程进入临界区，一旦一个线程进入之后，会获得锁对象，其他线程无法通过lock语句。当其他线程调用lock时，它们会被阻塞，知道第一个线程释放锁对象。</p>
<p><code>lock.unlock();</code>解锁操作，一定要放到finally里，因为如果try语句里出了问题，锁必须被释放，否则其他线程将永远被阻塞</p>
<p><strong>因为系统会随机为线程分配资源，所以在线程获得锁对象之后，可能被系统剥夺运行权，这时候其他线程来访问，但是发现有锁，进不去，只能等拿到锁对象的线程把里面的代码执行完毕后，释放锁，第二个线程才能运行。</strong></p>
<h2 id="2、synchronzied关键字"><a href="#2、synchronzied关键字" class="headerlink" title="2、synchronzied关键字"></a>2、synchronzied关键字</h2><p>前面我们讲了ReentrantLock锁对象的使用，但是在系统里面我们不一定要使用ReentrantLock锁，Java中还提供了一个内部的<strong>隐式锁</strong>，关键字是<strong>synchronized</strong>.</p>
<p>举个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">Method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//do some work...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>synchronized关键字说明</strong>：</p>
<p>　　总的说来，synchronized关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果再细的分类，synchronized可作用于instance变量（成员变量）、object reference（对象实例引用）、static函数和class literals(类名称字面常量)身上。</p>
<p>在进一步阐述之前，我们需要明确几点：</p>
<ul>
<li><p><strong>无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁</strong>――而且同步方法很可能还会被其他线程的对象访问。</p>
</li>
<li><p><strong>每个对象只有一个锁（lock）与之相关联</strong>。JVM会给类的每个实例化的对象赋予一个单独的锁。</p>
</li>
<li><p>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</p>
</li>
</ul>
<p>　　注意：在同步块和同步方法中，是给类或类的对象进行加锁，而不是给方法加锁。所谓的需要获得对象的锁才能执行方法，也是针对线程而言的。</p>
<p><strong>synchronized 方法：</strong></p>
<p>通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">         <span class="built_in">this</span>.name = name;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　synchronized方法控制对类成员变量的访问：每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变量的方法均被声明为 synchronized）。</p>
<p>　　在 Java 中，不光是类实例，每一个类也对应一把锁，这样我们也可将类的静态成员函数声明为 synchronized ，以控制其对类的静态成员变量的访问。</p>
<p>　　synchronized 方法的缺陷：<strong>若将一个大的方法声明为synchronized 将会大大影响效率</strong>，典型地，若将线程类的方法 run()声明为 synchronized ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何 synchronized 方法的调用都永远不会成功。</p>
<p>synchronized 块：</p>
<p>　　synchronized 块是这样一个代码块，其中的代码必须获得对象 syncObject （如前所述，可以是类实例或类）的锁方能执行，具体机制同前所述。由于可以针对任意代码块，且可任意指定上锁的对象，故灵活性较高。</p>
<p>　　通过 synchronized关键字来声明synchronized 块。语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(syncObject)&#123;　　</span><br><span class="line">    <span class="comment">//允许访问控制的代码　　</span></span><br><span class="line">&#125;　</span><br></pre></td></tr></table></figure>

<p><strong>3. 同步一个类</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SynchronizedExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedExample</span>();</span><br><span class="line">    <span class="type">SynchronizedExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedExample</span>();</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func2());</span><br><span class="line">    executorService.execute(() -&gt; e2.func2());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>



<p><strong>synchronized (this)的理解说明</strong></p>
<ul>
<li><strong>当一个线程正在执行object的一个synchronized(this)同步代码块时，该线程就获得了这个object的对象锁。</strong></li>
<li><strong>当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</strong>　　</li>
<li><strong>当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。</strong>　　</li>
<li><strong>但是，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的除synchronized(this)同步代码块以外的部分。</strong></li>
</ul>
<p><strong>总结</strong>：</p>
<p><strong>同步块、同步方法的锁定说明：</strong></p>
<ul>
<li><strong>对于同步的方法或者代码块来说，必须获得对象锁才能够进入同步方法或者代码块进行操作；</strong></li>
<li><strong>如果采用普通方法级别的同步，则对象锁即为该方法所在的对象，如果是静态方法，对象锁即指该方法所在的类的锁（类的锁，对所有实例化对象都是唯一的）。</strong></li>
<li><strong>对于代码块，对象锁即指synchronized(obj)中的obj；</strong></li>
<li><strong>静态方法则一定会同步，非静态方法需在单例模式才生效，推荐用静态方法</strong></li>
</ul>
<h3 id="实现同步的一些技巧"><a href="#实现同步的一些技巧" class="headerlink" title="实现同步的一些技巧"></a>实现同步的一些技巧</h3><p>　　搞清楚synchronized锁定的是哪个对象，就能帮助我们设计更安全的多线程程序。 还有一些技巧可以让我们对共享资源的同步访问更加安全：</p>
<ul>
<li>定义private的instance变量(成员变量)+对应的get()方法，而不要定义public&#x2F;protected的instance变量。如果将变量定义为public，对象在外界可以绕过同步方法的控制而直接取得它，并改动它。这也是JavaBean的标准实现方式之一。</li>
<li>如果instance变量是一个对象（如数组或ArrayList），那上述方法仍然不安全，因为当外界对象通过get()方法拿到这个instance对象的引用后，又将其指向另一个对象，那么这个private变量也就变了，岂不是很危险。这个时候就需要将get()方法也加上synchronized同步，并且，只返回这个private对象的clone()，这样，调用端得到的就是对象副本的引用了。</li>
<li>还有，比较常用的就有：Collections.synchronizedMap(new HashMap())，当然这个MAP就是生命在类中的全局变量，就是一个线程安全的HashMap，web的application是全web容器公用的，所以要使用线程安全来保证数据的正确。</li>
</ul>
<p>ava中多线程锁释放的条件：</p>
<ul>
<li>执行完同步代码块，就会释放锁。（synchronized）</li>
<li>在执行同步代码块的过程中，遇到异常而导致线程终止，锁也会被释放。（exception）</li>
<li>在执行同步代码块的过程中，执行了锁所属对象的wait()方法，这个线程会释放锁，进入对象的等待池。(wait)</li>
</ul>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><strong>1. 锁的实现</strong>  </p>
<p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p>
<p><strong>2. 性能</strong>  </p>
<p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p>
<p><strong>3. 等待可中断</strong>  </p>
<p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
<p>ReentrantLock 可中断，而 synchronized 不行。</p>
<p><strong>4. 公平锁</strong>  </p>
<p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p>
<p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>
<p><strong>5. 锁绑定多个条件</strong>  </p>
<p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p>
<h2 id="3、Conditional条件对象"><a href="#3、Conditional条件对象" class="headerlink" title="3、Conditional条件对象"></a>3、Conditional条件对象</h2><p>通常，线程拿到锁对象之后，却发现需要满足某一条件才能继续向下执行。</p>
<p>拿银行程序来举例子，我们需要转账方账户有足够的资金才能转出到目标账户，这时候需要用到ReentrantLock对象，因为如果我们已经完成转账方账户有足够的资金的判断之后，线程被其他线程中断，等其他线程执行完之后，转账方的钱又没有了足够的资金，这时候因为系统已经完成了判断，所以会继续向下执行，然后银行系统就会出现问题。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Accounts[from] &gt; amount)<span class="comment">//系统在结束判断之后被剥夺运行权,然后账户通过网银转出所有钱,银行凉凉</span></span><br><span class="line">        DoTransfer(from, to, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候我们就需要使用ReentrantLock对象了，我们修改一下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    locker.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (Accounts[from] &lt; amount) &#123;</span><br><span class="line">            <span class="comment">//等待有足够的钱</span></span><br><span class="line">        &#125;</span><br><span class="line">        DoTransfer(from, to, amount);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        locker.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样又有了问题，当前线程获取了锁对象之后，开始执行代码，发现钱不够，进入等待状态，然后其他线程又因为锁的原因无法给该账户转账，就会一直进入等待状态。</p>
<p>这个问题如何解决呢？</p>
<p>条件对象登场！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">sufficientFunds</span> <span class="operator">=</span> locker.newCondition();<span class="comment">//条件对象，</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (Accounts[from] &lt; amount) &#123;</span><br><span class="line">            sufficientFunds.await();</span><br><span class="line">            <span class="comment">//等待有足够的钱</span></span><br><span class="line">        &#125;</span><br><span class="line">        DoTransfer(from, to, amount);</span><br><span class="line">        sufficientFunds.signalAll();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        locker.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>条件对象的关键字是:<strong>Condition</strong>，<strong>一个锁对象可以有一个或多个相关的条件对象</strong>。可以通过锁对象.newCondition方法获得一个条件对象.</p>
<p>在进入锁之前，我们创建一个条件，然后如果金额不足，在这里调用条件对象的<strong>await</strong>方法，通知系统当前线程进入<strong>挂起状态</strong>，让其他线程执行。这样你这次调用会被锁定，然后系统可以再次调用该方法给其他账户转账，当每一次转账完成后，执行转账操作的线程在底部调用<strong>signalAll</strong>通知所有线程可以继续运行了，因为我们有可能是转足够的钱给当前账户，这时候有可能该线程会继续执行（不一定是你，是通知所有线程，如果通知的线程还是不符合条件，会继续调用<strong>await</strong>方法，并完成转账操作，然后<strong>通知其他挂起的线程。</strong></p>
<p>你说为啥不直接通知当前线程？不行，可以调用<strong>signal</strong>方法只通知一个线程，但是如果这个线程操作的账户还是没钱（不是转账给这个账户的情况），那这个线程又进入等待了，这时候已经没有线程能通知其他线程了，程序死锁，所以还是用signal比较保险。</p>
<p>以上是使用<strong>ReentrantLock</strong>+<strong>Condition</strong>对象，那你说我要是使用<strong>synchronized</strong>隐式锁怎么办？</p>
<p>也可以，而且不需要</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">     <span class="keyword">while</span> (Accounts[from] &lt; amount) &#123;</span><br><span class="line">            wait();<span class="comment">//这个wait方法是定义在Object类里面的，可以直接用，和条件对象的await一样，挂起线程</span></span><br><span class="line">            <span class="comment">//等待有足够的钱</span></span><br><span class="line">        &#125;</span><br><span class="line">        DoTransfer(from, to, amount);</span><br><span class="line">        notifyAll();<span class="comment">//通知其他挂起的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Object类里面定义了wait、notifyAll、notify方法，对应await、signalAll和signal方法，用来操作隐式锁，<strong>synchronized只能有一个条件，而ReentrantLock显式声明的锁可以用绑定多个Condition条件.</strong></p>
<h2 id="4、同步代码块"><a href="#4、同步代码块" class="headerlink" title="4、同步代码块"></a>4、同步代码块</h2><p> 即有synchronized关键字修饰的语句块。</p>
<p>被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(SomeObject obj)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;    <span class="comment">//锁定的是对象obj的对象锁</span></span><br><span class="line">       <span class="comment">//…..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，锁就是obj这个对象，谁拿到这个锁谁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以按以上方式来写程序；当没有明确的对象作为锁时，但还想让一段代码同步时，可以创建一个特殊的instance变量（必须是一个对象）来充当锁，此时代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] lock = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>]; <span class="comment">// 特殊的instance变量；也可以用String常量作为锁</span></span><br><span class="line">        Public <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span>(lock) &#123; <span class="comment">//… &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//…..</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">synchronized</span> (locker) &#123;</span><br><span class="line">*<span class="comment">//do some work*</span></span><br><span class="line">&#125;</span><br><span class="line">*<span class="comment">//也可以直接锁当前类的对象*</span></span><br><span class="line">sychronized(<span class="built_in">this</span>)&#123;</span><br><span class="line">*<span class="comment">//do some work*</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码会获得Object类型locker对象的锁，这种锁是一个特殊的锁，在上面的代码中，创建这个Object类对象只是单纯用来使用其持有的锁.</p>
<p>这种机制叫做<strong>同步块</strong>，应用场景也很广：有的时候，我们并不是整个一个方法都需要同步，只是方法里的部分代码块需要同步，这种情况下，我们如果将这个方法声明为<strong>synchronized</strong>，尤其是方法很大的时候，会造成很大的资源浪费。所以在这种情况下我们可以使用<strong>synchronized</strong>关键字来声明同步块:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//do some work without synchronized</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">//do some synchronized operation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> &#123;  </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">0</span>;<span class="comment">//账户余额  </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存钱  </span></span><br><span class="line">    <span class="keyword">public</span>   <span class="keyword">void</span> <span class="title function_">addMoney</span><span class="params">(<span class="type">int</span> money)</span>&#123;  </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;  </span><br><span class="line">            count +=money;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(System.currentTimeMillis()+<span class="string">&quot;存进：&quot;</span>+money);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//取钱  </span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">subMoney</span><span class="params">(<span class="type">int</span> money)</span>&#123;  </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(count-money &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;余额不足&quot;</span>);  </span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            count -=money;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(+System.currentTimeMillis()+<span class="string">&quot;取出：&quot;</span>+money);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//查询  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lookMoney</span><span class="params">()</span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;账户余额：&quot;</span>+count);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。</p>
<h2 id="5、监视器的概念"><a href="#5、监视器的概念" class="headerlink" title="5、监视器的概念"></a>5、监视器的概念</h2><p>锁和条件是同步中一个很重要的工具，但是它们并不是面向对象的。多年来，Java的研究人员努力寻找一种方法，可以在不需要考虑如何加锁的情况下，就能保证多线程的安全性。最成功的的一个解决方案叫做<strong>monitor</strong>监视器，<strong>这个对象内置于每一个Object变量中，相当于一个许可证。拿到许可证就可以进行操作，没有拿到则需要阻塞等待。</strong></p>
<p>监视器具有以下特性:</p>
<p><strong>1.监视器是只包含私有域的类</strong></p>
<p><strong>2.每个监视器对象都有一个相关的锁</strong></p>
<p><strong>3.使用监视器对象的锁对所有的方法进行加锁</strong>（举个例子:如果调用<strong>obj.Method</strong>方法，<strong>obj对象的锁会在方法调用的时候自动获得</strong>，当<strong>方法结束或返回之后会自动释放该锁</strong>。<strong>因为所有的域都是私有的，这样可以确保一个线程在操作类对象的时候，没有其他线程可以访问里面的域</strong>）</p>
<p><strong>4.该锁对象可以有任意多个相关条件</strong></p>
<p>其实我们使用的<strong>synchronized</strong>关键字就是使用了<strong>monitor</strong>来实现<strong>加锁解锁</strong>，所以又被称为<strong>内部锁</strong>。<strong>因为Object类实现了监视器，所以对象又被内置于任何一个对象之中。</strong>这就是我们为什么可以使用<strong>synchronized(locker)<strong>的方式锁定一个代码块了，其实只是用到了locker对象中内置的monitor而已。</strong>每一个对象的monitor类又是唯一的，所以就是唯一的许可证，拿到许可证的线程才可以执行，执行完后释放对象的monitor才可以被其他线程获取。</strong></p>
<p>举个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">//do some synchronized operation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它在字节码文件中会被编译为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">monitorenter;<span class="comment">//get monitor，enter the synchronized block</span></span><br><span class="line">            <span class="comment">//do some synchronized operation</span></span><br><span class="line">monitorexit;<span class="comment">//leavel the synchronized block,release the monitor</span></span><br></pre></td></tr></table></figure>

<h2 id="6、死锁"><a href="#6、死锁" class="headerlink" title="6、死锁"></a>6、死锁</h2><p>产生死锁的必要条件：</p>
<p>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。<br>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。<br>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。<br>环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。</p>
<blockquote>
<p>为什么倾向于使用signalAll和notifyAll方式，如果假设使用signal和notify，随机选择的线程发现自己还是不能运行，那么它再次被阻塞。这样就又会造成死锁现象。</p>
</blockquote>
<h2 id="7、锁测试和超时"><a href="#7、锁测试和超时" class="headerlink" title="7、锁测试和超时"></a>7、锁测试和超时</h2><p>线程在调用lock方法获得另一个线程持有的锁的时候，很可能发生阻塞。<strong>应该更加谨慎的申请锁，tryLock方法试图申请一个锁，如果申请成功，返回true，否则，立刻返回false，线程就会离开去做别的事，而不是被阻塞等待锁对象。</strong></p>
<p>语法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">if</span> (locker.tryLock()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do some work</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        locker.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//do other work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以给其指定超时参数，单位有<strong>SECONDS</strong>、<strong>MILLISECONDS</strong>、<strong>MICROSEONDS</strong>和<strong>MANOSECONDS</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">if</span> (locker.tryLock(<span class="number">1000</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do some work</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        locker.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//do other work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lock方法不能被中断，如果一个线程在调用了lock方法后等待锁的时候被中断，中断线程在获得锁之前一直处于阻塞状态。</p>
<p>如果带有超时参数的<strong>tryLock</strong>方法,那么如果等待期间线程被中断，会抛出InterruptedException异常，这是一个很好的特性，允许程序打破死锁。</p>
<h2 id="8、读写锁"><a href="#8、读写锁" class="headerlink" title="8、读写锁"></a>8、读写锁</h2><p><strong>eentrantLock</strong>类属于<strong>java.util.concurrent.locks</strong>包，这个包底下还有一个<strong>ReentrantReaderWriterLock</strong>类，如果使用多线程对数据读的操作很多，但是写的操作很少的话，可以使用这个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>():</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Read</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">readLocker</span> <span class="operator">=</span> rwl.readLock();<span class="comment">//创建读取锁对象</span></span><br><span class="line">    readLocker.lock();<span class="comment">//使用读取锁对象加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do some work</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLocker.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Write</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">writeLocker</span> <span class="operator">=</span> rwl.writeLock();<span class="comment">//创建写入锁对象</span></span><br><span class="line">    writeLocker.lock();<span class="comment">//使用写入锁对象加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do some work</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        writeLocker.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9、使用特殊域变量-volatile-实现线程同步"><a href="#9、使用特殊域变量-volatile-实现线程同步" class="headerlink" title="9、使用特殊域变量(volatile)实现线程同步"></a>9、使用特殊域变量(volatile)实现线程同步</h2><p>   • volatile关键字为域变量的访问提供了一种免锁机制；</p>
<p>   • 使用volatile修饰域相当于告诉<a target="_blank" rel="noopener" href="http://www.2cto.com/os/xuniji/">虚拟机</a>该域可能会被其他线程更新；</p>
<p>   • 因此每次使用该域就要重新计算，而不是使用寄存器中的值；</p>
<p>   • volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedThread</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">account</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAccount</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> account;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 用同步方法实现</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">               account += money;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 用同步代码块实现</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save1</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                   account += money;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">class</span> <span class="title class_">NewThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">           <span class="keyword">private</span> Bank bank;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">public</span> <span class="title function_">NewThread</span><span class="params">(Bank bank)</span> &#123;</span><br><span class="line">               <span class="built_in">this</span>.bank = bank;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                   <span class="comment">// bank.save1(10);</span></span><br><span class="line">                   bank.save(<span class="number">10</span>);</span><br><span class="line">                   System.out.println(i + <span class="string">&quot;账户余额为：&quot;</span> +bank.getAccount());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 建立线程，调用内部类</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useThread</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">           <span class="type">NewThread</span> <span class="variable">new_thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewThread</span>(bank);</span><br><span class="line">           System.out.println(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">           <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(new_thread);</span><br><span class="line">           thread1.start();</span><br><span class="line">           System.out.println(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">           <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(new_thread);</span><br><span class="line">           thread2.start();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">           <span class="type">SynchronizedThread</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedThread</span>();</span><br><span class="line">           st.useThread();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用final域，有锁保护的域和volatile域可以避免非同步的问题。</p>
<h2 id="10、final变量"><a href="#10、final变量" class="headerlink" title="10、final变量"></a>10、final变量</h2><p>上一节已经了解到，除非使用锁或volatile修饰符，否则无法从多个线程安全地读取一个域。</p>
<p>还有一种情况可以安全地访问一个共享域，即这个域声明为final时。考虑以下声明：</p>
<p>finalMap&lt;String,Double〉accounts&#x3D;newHashKap&lt;&gt;0；</p>
<p>其他线程会在构造函数完成构造之后才看到这个accounts变量。</p>
<p>如果不使用final，就不能保证其他线程看到的是accounts更新后的值，它们可能都只是看到null,而不是新构造的HashMap。</p>
<p>当然，对这个映射表的操作并不是线程安全的。如果多个线程在读写这个映射表，仍然需要进行同步</p>
<h2 id="11、线程的局部变量"><a href="#11、线程的局部变量" class="headerlink" title="11、线程的局部变量"></a>11、线程的局部变量</h2><p>线程间有时要避免共享变量，使用ThreadLocal辅助类为各个线程提供各自的实例。</p>
<p>例如，SimpleDateFormat类不是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>如果两个线程都执行以下操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">dateStamp</span> <span class="operator">=</span> dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure>


<p>结果可能很混乱，因为dateFormat使用的内部数据结构可能会被并发的访问所破坏。当然可以使用同步，但开销很大；或者也可以在需要时构造一个局部SimpleDateFormat对象，不过这也太浪费了。</p>
<p>要为每个线程构造一个实例，可以使用以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormat = </span><br><span class="line">ThreadLocal.withInitial(()-&gt;<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>要访问具体的格式化方法，可以调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">dateStamp</span> <span class="operator">=</span> dateFormat.get().format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure>


<p>在一个给定线程中首次调用get时，会调用initialValue方法。在此之后，get方法会返回属于当前线程的那个实例。</p>
<p>在多个线程中生成随机数也存在类似的问题。java.util.Random类是线程安全的。但是如果多个线程需要等待一个共享的随机数生成器，这会很低效。</p>
<p>可以使用ThreadLocal辅助类为各个线程提供一个单独的生成器，不过Java SE 7还另外提供了一个便利类。只需要做以下调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(upperBound);</span><br></pre></td></tr></table></figure>


<p>ThreadLocalRandom.current()调用会返回特定于当前线程的Random类实例。</p>
<h1 id="六、线程通信"><a href="#六、线程通信" class="headerlink" title="六、线程通信"></a>六、线程通信</h1><h2 id="1、借助于Object类的wait-、notify-和notifyAll-实现通信"><a href="#1、借助于Object类的wait-、notify-和notifyAll-实现通信" class="headerlink" title="1、借助于Object类的wait()、notify()和notifyAll()实现通信"></a>1、借助于Object类的wait()、notify()和notifyAll()实现通信</h2><p>​     线程执行wait()后，就放弃了运行资格，处于冻结状态；</p>
<p>​     线程运行时，内存中会建立一个线程池，冻结状态的线程都存在于线程池中，notify()执行时唤醒的也是线程池中的线程，线程池中有多个线程时唤醒第一个被冻结的线程。<br>​      notifyall(), 唤醒线程池中所有线程。<br><strong>注：</strong> （1） wait(), notify(),notifyall()都用在同步里面，因为这3个函数是对持有锁的线程进行操作，而只有同步才有锁，所以要使用在同步中；<br>​       （2） wait(),notify(),notifyall(),  在使用时必须标识它们所操作的线程持有的锁，因为等待和唤醒必须是同一锁下的线程；而锁可以是任意对象，所以这3个方法都是Object类中的方法。</p>
<p>单个消费者生产者例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span>&#123;  <span class="comment">//生产者和消费者都要操作的资源  </span></span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> flag=<span class="literal">false</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String name)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(flag)  </span><br><span class="line">            <span class="keyword">try</span>&#123;wait();&#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;  </span><br><span class="line">        <span class="built_in">this</span>.name=name+<span class="string">&quot;---&quot;</span>+count++;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...生产者...&quot;</span>+<span class="built_in">this</span>.name);  </span><br><span class="line">        flag=<span class="literal">true</span>;  </span><br><span class="line">        <span class="built_in">this</span>.notify();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(!flag)  </span><br><span class="line">            <span class="keyword">try</span>&#123;wait();&#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...消费者...&quot;</span>+<span class="built_in">this</span>.name);  </span><br><span class="line">        flag=<span class="literal">false</span>;  </span><br><span class="line">        <span class="built_in">this</span>.notify();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Resource res;  </span><br><span class="line">    Producer(Resource res)&#123;  </span><br><span class="line">        <span class="built_in">this</span>.res=res;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;  </span><br><span class="line">            res.set(<span class="string">&quot;商品&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Resource res;  </span><br><span class="line">    Consumer(Resource res)&#123;  </span><br><span class="line">        <span class="built_in">this</span>.res=res;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;  </span><br><span class="line">            res.out();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerDemo</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;  </span><br><span class="line">        Resource r=<span class="keyword">new</span> <span class="title class_">Resource</span>();  </span><br><span class="line">        Producer pro=<span class="keyword">new</span> <span class="title class_">Producer</span>(r);  </span><br><span class="line">        Consumer con=<span class="keyword">new</span> <span class="title class_">Consumer</span>(r);  </span><br><span class="line">        Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(pro);  </span><br><span class="line">        Thread t2=<span class="keyword">new</span> <span class="title class_">Thread</span>(con);  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;<span class="comment">//运行结果正常，生产者生产一个商品，紧接着消费者消费一个商品。</span></span><br></pre></td></tr></table></figure>



<h1 id="七、同步器J-U-C-AQS"><a href="#七、同步器J-U-C-AQS" class="headerlink" title="七、同步器J.U.C-AQS"></a>七、同步器J.U.C-AQS</h1><p><strong>多线程并发的执行，之间通过某种 共享 状态来同步，只有当状态满足 xxxx 条件，才能触发线程执行 xxxx 。这个共同的语义可以称之为同步器。</strong></p>
<p>可以认为以上所有的锁机制都可以基于同步器定制来实现的。</p>
<p>而juc(java.util.concurrent)里的思想是 将这些场景抽象出来的语义通过统一的同步框架来支持。</p>
<p>juc 里所有的这些锁机制都是基于 AQS （ AbstractQueuedSynchronizer ）框架上构建的。下面简单介绍下 AQS（ AbstractQueuedSynchronizer ）。 可以参考Doug Lea的论文The java.util.concurrent Synchronizer Framework（<a target="_blank" rel="noopener" href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf%EF%BC%89">http://gee.cs.oswego.edu/dl/papers/aqs.pdf）</a></p>
<p>Java中多线程开发时，离不开线程的分工协作，常用的多线程的同步器有如下几种：</p>
<h2 id="1、CountDownLatch（倒计时门闩）"><a href="#1、CountDownLatch（倒计时门闩）" class="headerlink" title="1、CountDownLatch（倒计时门闩）"></a>1、CountDownLatch（倒计时门闩）</h2><p>应用场景：等待一组线程任务完成后在继续执行当前线程。</p>
<p>用法：定义一个CountDownLatch变量latch，在当前线程中调用latch.await()方法，在要等待的一组线程中执行完后调用latch.countDown(）方法，这样当该线程都调用过latch.countDown（）方法后就开始执行当前线程latch.await()后的方法。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ba078291-791e-4378-b6d1-ece76c2f0b14.png" width="300px"> </div><br>

<p> <strong>倒计时门闩会导致一条或多条线程在“门口”一直等待，直到另一条线程打开这扇门，线程才得以继续运行。</strong>他是由一个计数变量和两个操作组成的，这两个操作分别是“导致一条线程等待直到。</p>
<p>计数变为0”以及“递减计数变量”。</p>
<p><img src="https://i.loli.net/2021/11/22/MsL1UAKey8XDptn.png"></p>
<p>例如：</p>
<p>以下代码是用倒计时门闩实现的一个是所有线程同时执行同时结束之后，才能继续执行主线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NTHREADS</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">startSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">doneSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(NTHREADS);</span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入等待&quot;</span>);</span><br><span class="line">					startSignal.await();<span class="comment">//3个线程进入等待，直到startSignal.countDown()被调用</span></span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始执行任务&quot;</span>);</span><br><span class="line">					Thread.sleep(<span class="number">200</span>);</span><br><span class="line">					doneSignal.countDown();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(NTHREADS);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NTHREADS; i++) &#123;</span><br><span class="line">			es.execute(r);</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				startSignal.countDown();</span><br><span class="line">                <span class="comment">//3个线程全部开始执行任务，主线程进入等待</span></span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入等待&quot;</span>);</span><br><span class="line">                <span class="comment">//直到3个线程全部结束任务，doneSignal.countDown()被调用，主线程开始执行</span></span><br><span class="line">				doneSignal.await();</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">				es.shutdownNow();</span><br><span class="line">				</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、CyclicBarrier（同步屏障）"><a href="#2、CyclicBarrier（同步屏障）" class="headerlink" title="2、CyclicBarrier（同步屏障）"></a>2、CyclicBarrier（同步屏障）</h2><p>应用场景：等待一组线程到达某个点后一起执行，该组线程达到指定点后可以再次循环执行。也可用于一组线程达达某个点后再执行某个方法。</p>
<blockquote>
<p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p>
</blockquote>
<p>用法：定义一个CyclicBarrier变量barrier，线程达到某个约定点时调用barrier.await（）方法，当该组所有线程都调用了barrier.await()方法后改组线程一起向下执行。</p>
<p>CyclicBarrier和CountDownLatch的区别</p>
<ul>
<li>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。</li>
<li>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。</li>
</ul>
<p><strong>若有多条线程，他们到达屏障时将会被阻塞，只有当所有线程都到达屏障时才能打开屏障，</strong></p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f71af66b-0d54-4399-a44b-f47b58321984.png" width="300px"> </div><br>

<p>所有线程同时执行，若有这样的需求可以使用同步屏障。此外，当屏障打开的同时还能指定执行的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建同步屏障对象，并制定需要等待的线程个数 和 打开屏障时需要执行的任务</span></span><br><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>,<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//当所有线程准备完毕后触发此任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 启动三条线程</span></span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++ )&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>( <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="comment">// 等待，（每执行一次barrier.await，同步屏障数量-1，直到为0时，打开屏障）</span></span><br><span class="line">            barrier.await();</span><br><span class="line">            <span class="comment">// 任务</span></span><br><span class="line">            任务代码……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>倒计时门闩 与 同步屏障 的区别 倒计时门闩只会阻塞一条线程，目的是为了让该条任务线程满足条件后执行；</p>
<p> 而同步屏障会阻塞所有线程，目的是为了让所有线程同时执行</p>
<h2 id="3、Semaphore（信号量）"><a href="#3、Semaphore（信号量）" class="headerlink" title="3、Semaphore（信号量）"></a>3、Semaphore（信号量）</h2><p>应用场景：对于一组有限制都资源访问。比如餐厅有5个位置但同时有7个人要吃饭，则要控制7个人对餐位的并发实用。</p>
<p>用法：定义Semaphore变量semaphore包含受限的资源个数，每个人要来用餐时先调用semaphore.acquire()方法获取一个餐位（若没有餐位，则阻塞等待），用完餐后调用semaphore.release()释放餐位给其它人用。</p>
<p><strong>信号量维护了一组许可证，以约束访问被限制资源的线程数。当没有可用</strong></p>
<p><strong>的许可证时，线程的获取尝试会一直阻塞，直到其它的线程释放一个许可证。</strong></p>
<p>【信号量<br>    一个信号量管理多个许可证。<strong>为了通过信号量，线程通过调用acquire()请求许可</strong>。其实没有实际的许可对象，信号连也仅仅是维护一个计数器。<br>    <strong>许可的数目是固定的，由此限制了线程通过的数量</strong>。<strong>当一个线程执行完之后，应该调用release()释放许可证，让其他线程有机会执行</strong>。事实上，<br>    任意一个线程都有可以释放任意个数的许可证，这可能会增加许可证的个数。所以我建议，如果不是非常明确的知道为什么要释放多个许可证，就一定<br>    是让获得许可证的线程是放一个许可证。</p>
<p>【常用方法<br>    1.构造函数：<br>    　　Semaphore(int permits)：创建具有给定许可数和非公平设置的Semaphore</p>
<p>​    　　Semaphore(int permits，boolean fair)：此类的构造方法可选地接受一个公平 参数。当设置为 false 时(默认也是false)，此类不对线程获取许可的顺序做任何保证。</p>
<p>​        特别地，闯入是允许的，也就是说可以在已经等待的线程前为调用 acquire() 的线程分配一个许可，从逻辑上说，就是新线程将自己置于等待线程队列的头部。<br>​        当公平设置为 true 时，信号量保证对于任何调用获取方法的线程而言，都按照处理它们调用这些方法的顺序（即先进先出；FIFO）来选择线程、获得许可。<br>​        注意，FIFO 排序必然应用到这些方法内的指定内部执行点。所以，可能某个线程先于另一个线程调用了 acquire，但是却在该线程之后到达排序点，并且从方法返回时也类似。</p>
<p>2.Semaphore还提供一些其他方法：<br>        int availablePermits() ：返回此信号量中当前可用的许可证数。<br>        int getQueueLength()：返回正在等待获取许可证的线程数。<br>        boolean hasQueuedThreads() ：是否有线程正在等待获取许可证。<br>        void reducePermits(int reduction) ：减少reduction个许可证。是个protected方法。<br>        Collection getQueuedThreads() ：返回所有等待获取许可证的线程集合。是个protected方法。</p>
<p>【补充<br>    当许可证的个数为1时，可以充当互斥锁使用。</p>
<p>示例代码：</p>
<p>只能同时有5个线程访问的信号量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="comment">// 创建信号量对象，并给予3个资源Semaphore semaphore = new Semaphore(3);// 开启10条线程for ( int i=0; i&lt;10; i++ ) &#123;    new Thread( new Runnbale()&#123;        public void run()&#123;            // 获取资源，若此时资源被用光，则阻塞，直到有线程归还资源            semaphore.acquire();            // 任务代码            ……            // 释放资源            semaphore.release();        &#125;    &#125; ).start();&#125;`</span></span><br></pre></td></tr></table></figure>

<h2 id="4、Exchanger交换器"><a href="#4、Exchanger交换器" class="headerlink" title="4、Exchanger交换器"></a>4、Exchanger<T>交换器</h2><p><img src="https://i.loli.net/2021/11/22/kbPTMqx5AvcmYZu.png"></p>
<ul>
<li>交换值是同步的；</li>
<li>成对的线程之间交换数据；</li>
<li>可看成是双向的同步队列；</li>
<li>可应用于演算法、流水线设计；</li>
</ul>
<p>Exchanger<V>类中的主要方法就是：exchange(V x)方法，<strong>成对的两个线程之间，都调用了该方法，就能在两个线程彼此都准备好数据后，成功的交换数据给对方，然后各自返回。</strong>如果想支持成对的两个线程之间，一个没耐性，等的时间过长，或者被打断了就不交换数据了，可以使用exchange(V x, long timeout, TimeUnit unit)方法。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//球线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BallTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Exchanger&lt;String&gt; e;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BallTask</span><span class="params">(Exchanger&lt;String&gt; e)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.e = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sleepTime</span> <span class="operator">=</span> (<span class="type">long</span>)(Math.random() * <span class="number">2500</span>) ;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        System.out.println(tName+<span class="string">&quot;正在买球,用时[&quot;</span>+sleepTime+<span class="string">&quot;]才买到球,赶紧去换鱼...&quot;</span>);</span><br><span class="line">        Thread.sleep(sleepTime);</span><br><span class="line">        <span class="comment">//这里的str即为交换的东西</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> e.exchange(tName+<span class="string">&quot;:的球&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;【&quot;</span>+tName+<span class="string">&quot;:的球】换到了--&gt;【&quot;</span>+str+<span class="string">&quot;】&quot;</span>);</span><br><span class="line">		&#125;	</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鱼线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FishTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Exchanger&lt;String&gt; e;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FishTask</span><span class="params">(Exchanger&lt;String&gt; e)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.e = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sleepTime</span> <span class="operator">=</span> (<span class="type">long</span>)(Math.random() * <span class="number">2500</span>) ;</span><br><span class="line">                <span class="type">String</span> <span class="variable">tName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            System.out.println(tName+<span class="string">&quot;正在钓鱼,用时[&quot;</span>+sleepTime+<span class="string">&quot;]才钓到鱼,赶紧去换球...&quot;</span>);</span><br><span class="line">            Thread.sleep(sleepTime);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> e.exchange(tName+<span class="string">&quot;:的鱼&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;【&quot;</span>+tName+<span class="string">&quot;:的鱼】换到了--&gt;【&quot;</span>+str+<span class="string">&quot;】&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangerTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">	Exchanger&lt;String&gt; e = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="type">BallTask</span> <span class="variable">bTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BallTask</span>(e);		<span class="comment">//任务：球线程</span></span><br><span class="line">            <span class="type">FishTask</span> <span class="variable">fTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FishTask</span>(e);		<span class="comment">//任务：鱼线程</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">bThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(bTask,<span class="string">&quot;Ball&quot;</span>);</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">fThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(fTask,<span class="string">&quot;Fish&quot;</span>);</span><br><span class="line"></span><br><span class="line">            bThread.start();</span><br><span class="line">            fThread.start();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;我是主线程,准备看看你们交易情况...\n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//Thread类中的join方法的主要作用就是同步，它可以使得线程之间的并行执行变为串行执行。</span></span><br><span class="line">                bThread.join();</span><br><span class="line">                fThread.join();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception ep)&#123;&#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;\n\r我是主线程,已看到你们的交易结果...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Exchanger和Semaphore区别</strong><br>Exchanger<V>交换器和Semaphore信号量在关于生产者消费者《产1消1模式》运用的区别：</p>
<p>1·Exchanger交换器：成对的两个线程，各个线程有各个线程的自己数据V，A线程拥有V1，B线程拥有V2，V1&lt;…&gt;V2互换。<br>2·Semaphore信号量：成对的两个线程，只需一个数据池即可，生产者生产数据注入数据池，消费者从数据池取走数据消费。<br>3·Exchanger交换器：两个线程之间的通讯仅仅一个Exchanger实例即可。<br>4·Semaphore信号量：两个线程之间的通讯需要两个信号量，生产信号指示灯，消费信号指示灯。<br>5·Exchanger和Semaphore的共同点：两个线程之间需要同步通讯。生产的过快，没用，必须等消费完了，才能进行下一生产1；同理，消费的过快，也没用，必须等生产完了，才能进行下一消费1。</p>
<h2 id="5、同步队列与等待队列"><a href="#5、同步队列与等待队列" class="headerlink" title="5、同步队列与等待队列"></a>5、同步队列与等待队列</h2><p>书上：</p>
<p>【同步队列是一种将生产者与消费者线程配对的机制。当一个线程调用SynchronousQueue的put方法时，它会阻塞直到另一个线程调用take方法为止，反之亦然。与Exchanger的情况不同，数据仅仅沿一个方向传递，从生产者到消费者。即使SynchronousQueue类实现了BlockingQueue接口，概念上讲，它依然不是一个队列。它没有包含任何元素，它的size方法总是返回0。】</p>
<p><strong>简单的理解是同步队列存放着竞争同步资源的线程的引用（不是存放线程），而等待队列存放着待唤醒的线程的引用。</strong></p>
<p><strong>同步队列中存放着一个个节点，当线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点并将其加入同步队列，首节点表示的获取同步状态成功的线程节点。</strong></p>
<p><img src="https://i.loli.net/2021/11/22/gnBeVMbcx2L1a6l.png"></p>
<p><strong>Condition维护着一个等待队列与同步队列相似。主要针对await和signal的操作。</strong><br><img src="https://i.loli.net/2021/11/22/StGsfokCVRbF2Oy.png"></p>
<p>例子：</p>
<p>这里实现了三个多线程的run方法。A线程输出A然后通知B,然后B通知C。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">&quot;A进程输出&quot;</span> + <span class="string">&quot; : &quot;</span> + ++index);</span><br><span class="line">                conditionB.signal();</span><br><span class="line">                conditionA.await();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">&quot;B进程输出&quot;</span> + <span class="string">&quot; : &quot;</span> + ++index);</span><br><span class="line">                conditionC.signal();</span><br><span class="line">                conditionB.await();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadC</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">&quot;C进程输出&quot;</span> + <span class="string">&quot; : &quot;</span> + ++index);</span><br><span class="line">                conditionA.signal();</span><br><span class="line">                conditionC.await();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CondtionTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionA</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionC</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line">        <span class="type">ThreadB</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadB</span>();</span><br><span class="line">        <span class="type">ThreadC</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadC</span>();</span><br><span class="line"></span><br><span class="line">        threadA.start();<span class="comment">//（1）</span></span><br><span class="line">        threadB.start();<span class="comment">//（2）</span></span><br><span class="line">        threadC.start();<span class="comment">//（3）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当(1)(2)(3)三个线程被调用时，因为三个线程同时竞争lock，这里假设线程A拿到了lock（线程A虽然是看起来是先start()，但是正在的调用还是看调度程序的，所以这里只能假设是A线程拿到同步资源）。首节点表示的是正在操作同步资源的线程。所以现在的同步队列是：<br><img src="https://i.loli.net/2021/11/22/kay4tz3ig9UBLDP.png"></p>
<p>接着线程A输出了：“A进程输出 : 1”。然后调用conditionB.signal()，其实这一步的signal是没什么意义的，因为conditionB现在没有线程是可以被唤醒的。<br>当conditionA.await()被执行到的时候，线程A同步队列中被移除，对应操作是锁的释放； 线程A(节点A)接着被加入到ConditionA等待队列，因为线程需要singal信号。</p>
<p><strong>同步队列</strong>：<br><img src="https://i.loli.net/2021/11/22/WHLbGySihmJ4uwX.png"></p>
<p><strong>A等待队列</strong>：<br><img src="https://i.loli.net/2021/11/22/WphDRvwNO4HauMi.png"></p>
<p>现在在同步队列中的首节点是B节点，那么B线程占用了同步资源就可以开始运行了。先是输出“B进程输出 : 2”，同样的signal操作也是没有意义的，因为conditionC是没有可以被唤醒的线程。当conditionB.await()被执行到的时候，线程B同步队列中被移除，线程B(节点B)接着被加入到ConditionB等待队列</p>
<p><strong>同步队列</strong>：<br><img src="https://i.loli.net/2021/11/22/PbFxRsdYJSpUn8D.png"></p>
<p><strong>B等待队列</strong>：<br><img src="https://i.loli.net/2021/11/22/b8ISi7VOlQKcMsp.png"></p>
<p>终于轮到了C线程占用同步资源了，再输出“C进程输出：3”之后，调用conditionA.signal()，<strong>注意这个signal是有用的</strong><br>因为在conditionA的等待队列中A线程是在等待的，把它取出来加入到同步队列中去竞争，但是<strong>这个时候线程A还没唤醒。首节点还是C</strong>。</p>
<p><strong>同步队列</strong>：<br><img src="https://i.loli.net/2021/11/22/bNFwlpIDYLdrU8C.png"></p>
<p>接着conditionC.await()被执行。线程C同步队列中被移除，线程C(节点C)接着被加入到ConditionC等待队列</p>
<p><strong>同步队列</strong>：<br><img src="https://i.loli.net/2021/11/22/utyGBKSCf8aZjPo.png"></p>
<p><strong>C等待队列</strong>：<br> <img src="https://i.loli.net/2021/11/22/VvpuyIYZdQiSnRz.png">                  </p>
<p>注意到同步队列中的首节点已经变回了节点A了。所以线程A在刚刚等待的地方继续执行，最后释放了lock。但是线程B和线程C最后也没有其他线程去唤醒，状态一直为WAITING，而线程A的状态为TERMINATED。</p>
<h2 id="6、定时器"><a href="#6、定时器" class="headerlink" title="6、定时器"></a>6、定时器</h2><p>定时器是一个应用十分广泛的线程工具，可用于调度多个定时任务以后台线程的方式执行，在Java中，可以通过Timer和TimerTask类来实现定义调度的功能。</p>
<p>Timer类                  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Timer</span><span class="params">()</span>默认的构造方法</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task, <span class="type">long</span> delay)</span>	在指定的延迟后执行指定的任务</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task,<span class="type">long</span> delay,<span class="type">long</span> period)</span>	计划重复固定延迟执行指定的任务，在指定的延迟后开始</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task,  Date time)</span>	在指定的时间计划指定的任务</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task,  Date firstTime, <span class="type">long</span> period)</span>	计划重复固定延迟执行指定的任务，在指定的开始时间</span><br></pre></td></tr></table></figure>



<p>TimerTask类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>	定时器任务执行的动作</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">()</span>	取消此定时器任务</span><br></pre></td></tr></table></figure>

<p>代码演示</p>
<p>1、输出爆炸啦</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承TimerTask，需要重新rum方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Time</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;爆炸啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//new一个Timer对象，用来调方法</span></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        <span class="comment">//调用Timer对象的方法schedule，第一个参数必须是TimerTask对象，Time继承了它因此也是这个对象，第二个参数表示在2秒后运行run方法，这个参数只有在第一次使用run方法，最后一个参数是每隔1秒，运行一次run方法</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">Time</span>(),<span class="number">2000</span>,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个结果是，不停的输出爆炸啦，要想停掉的话，可以加入cancel()方法，在run方法最后加入这个话，结果会输出一个爆炸啦，因为执行第一次完后就执行到这一语句，定时器就取消了，如下。</p>
<p>2、</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">javapublic <span class="keyword">class</span> <span class="title class_">Time</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个Timer对象，到时候可以用它来调用cancel方法</span></span><br><span class="line">    Timer time;</span><br><span class="line">    <span class="comment">//通过构造器给Timer对象赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Time</span><span class="params">(Timer time)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.time=time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;爆炸啦&quot;</span>);</span><br><span class="line">        <span class="comment">//取消定时器</span></span><br><span class="line">        time.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">Time</span>(timer),<span class="number">2000</span>,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>rhb
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://rshawshank.github.io/2021/11/16/java-%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/" title="java-并发（二）">http://rshawshank.github.io/2021/11/16/java-并发（二）/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/16/java-maven%E5%AD%A6%E4%B9%A0/" rel="prev" title="java-maven学习">
      <i class="fa fa-chevron-left"></i> java-maven学习
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/17/java-%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89/" rel="next" title="java-并发（三）">
      java-并发（三） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">1.</span> <span class="nav-text">五、线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88Lock%EF%BC%89%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">1.1.</span> <span class="nav-text">1、使用重入锁（Lock）实现线程同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81synchronzied%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.2.</span> <span class="nav-text">2、synchronzied关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7"><span class="nav-number">1.2.1.</span> <span class="nav-text">实现同步的一些技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83"><span class="nav-number">1.2.2.</span> <span class="nav-text">比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81Conditional%E6%9D%A1%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.3.</span> <span class="nav-text">3、Conditional条件对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">1.4.</span> <span class="nav-text">4、同步代码块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E7%9B%91%E8%A7%86%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.5.</span> <span class="nav-text">5、监视器的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E6%AD%BB%E9%94%81"><span class="nav-number">1.6.</span> <span class="nav-text">6、死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E9%94%81%E6%B5%8B%E8%AF%95%E5%92%8C%E8%B6%85%E6%97%B6"><span class="nav-number">1.7.</span> <span class="nav-text">7、锁测试和超时</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">1.8.</span> <span class="nav-text">8、读写锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81%E4%BD%BF%E7%94%A8%E7%89%B9%E6%AE%8A%E5%9F%9F%E5%8F%98%E9%87%8F-volatile-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">1.9.</span> <span class="nav-text">9、使用特殊域变量(volatile)实现线程同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81final%E5%8F%98%E9%87%8F"><span class="nav-number">1.10.</span> <span class="nav-text">10、final变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">1.11.</span> <span class="nav-text">11、线程的局部变量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">2.</span> <span class="nav-text">六、线程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E5%80%9F%E5%8A%A9%E4%BA%8EObject%E7%B1%BB%E7%9A%84wait-%E3%80%81notify-%E5%92%8CnotifyAll-%E5%AE%9E%E7%8E%B0%E9%80%9A%E4%BF%A1"><span class="nav-number">2.1.</span> <span class="nav-text">1、借助于Object类的wait()、notify()和notifyAll()实现通信</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%90%8C%E6%AD%A5%E5%99%A8J-U-C-AQS"><span class="nav-number">3.</span> <span class="nav-text">七、同步器J.U.C-AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81CountDownLatch%EF%BC%88%E5%80%92%E8%AE%A1%E6%97%B6%E9%97%A8%E9%97%A9%EF%BC%89"><span class="nav-number">3.1.</span> <span class="nav-text">1、CountDownLatch（倒计时门闩）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81CyclicBarrier%EF%BC%88%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C%EF%BC%89"><span class="nav-number">3.2.</span> <span class="nav-text">2、CyclicBarrier（同步屏障）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81Semaphore%EF%BC%88%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%89"><span class="nav-number">3.3.</span> <span class="nav-text">3、Semaphore（信号量）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81Exchanger%E4%BA%A4%E6%8D%A2%E5%99%A8"><span class="nav-number">3.4.</span> <span class="nav-text">4、Exchanger交换器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E4%B8%8E%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="nav-number">3.5.</span> <span class="nav-text">5、同步队列与等待队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">3.6.</span> <span class="nav-text">6、定时器</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rhb</p>
  <div class="site-description" itemprop="description">纵浪大化中，不喜亦不惧</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">126</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rhb</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
