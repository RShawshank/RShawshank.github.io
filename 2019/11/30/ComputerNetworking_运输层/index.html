<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rshawshank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="运输层第一部分：概述  在学习完应用层的时候，对运输层就有了一定的认识。需要指出的是，运输层是在端系统中的而不是在路由器中的。在发送端系统中，运输层将从发送应用程序进程接收到的报文转换成运输层分组。实现的方法是将报文（Message）划分成为较小的块，并为每块加上一个运输层首部以生成运输层报文段（segment）。然后运输层将这些报文段传递给网络层，网络层将其封装成网络层分组·······在接受端">
<meta property="og:type" content="article">
<meta property="og:title" content="运输层">
<meta property="og:url" content="http://rshawshank.github.io/2019/11/30/ComputerNetworking_%E8%BF%90%E8%BE%93%E5%B1%82/index.html">
<meta property="og:site_name" content="rhb_blog">
<meta property="og:description" content="运输层第一部分：概述  在学习完应用层的时候，对运输层就有了一定的认识。需要指出的是，运输层是在端系统中的而不是在路由器中的。在发送端系统中，运输层将从发送应用程序进程接收到的报文转换成运输层分组。实现的方法是将报文（Message）划分成为较小的块，并为每块加上一个运输层首部以生成运输层报文段（segment）。然后运输层将这些报文段传递给网络层，网络层将其封装成网络层分组·······在接受端">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/20190328003506312.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203185040027.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203185306343.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203185820481.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/20180301192421945.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203200421270.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/20190328003652736.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203201158611.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203201522230.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203202020447.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203202756161.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203203413278.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203203432961.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203204332982.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203204349788.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203204921570.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203210155986.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203210214928.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203210916277.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203210929888.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203211454895.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203212024456.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203212210674.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203220031107.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203220422740.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203221213732.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203221608167.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203222134071.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203223540767.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203223744226.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203224403151.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/20190328003921619.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203230341738.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/20180301192735455.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/1233668-20180613233505890-1600510236.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191204002104341.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/20191005144432618.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/20191005144456427.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/20180605190737615.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/20180301221159481.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191204004122986.png">
<meta property="og:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191204100929736.png">
<meta property="article:published_time" content="2019-11-30T15:02:16.000Z">
<meta property="article:modified_time" content="2020-08-03T13:37:56.000Z">
<meta property="article:author" content="rhb">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://rshawshank.github.io/images/%E8%BF%90%E8%BE%93%E5%B1%82/20190328003506312.png">

<link rel="canonical" href="http://rshawshank.github.io/2019/11/30/ComputerNetworking_%E8%BF%90%E8%BE%93%E5%B1%82/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>运输层 | rhb_blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rhb_blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">rao的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2019/11/30/ComputerNetworking_%E8%BF%90%E8%BE%93%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          运输层
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-30 15:02:16" itemprop="dateCreated datePublished" datetime="2019-11-30T15:02:16Z">2019-11-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-03 13:37:56" itemprop="dateModified" datetime="2020-08-03T13:37:56Z">2020-08-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="第一部分：概述"><a href="#第一部分：概述" class="headerlink" title="第一部分：概述"></a>第一部分：概述</h2><!---more-->

<p>在学习完应用层的时候，对运输层就有了一定的认识。需要指出的是，运输层是在<strong>端系统</strong>中的而不是在路由器中的。在发送端系统中，运输层将从发送应用程序进程接收到的报文转换成运输层分组。实现的方法是<strong>将报文（Message）划分成为较小的块，并为每块加上一个运输层首部以生成运输层报文段（segment）</strong>。然后运输层将这些报文段传递给网络层，网络层将其封装成网络层分组·······在接受端，网络层从数据段中提取运输层报文段，并将该报文段向上交给运输层。接收方：把报文段重组成应用数据，交付给应用层</p>
<h3 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a>运输层和网络层的关系</h3><p><strong>网络层: 不同主机之间的逻辑通信</strong></p>
<p><strong>运输层： 应用进程之间的逻辑通信</strong></p>
<blockquote>
<p>网络层负责ip数据报的产生以及ip数据包在逻辑网络上的路由转发。</p>
<p><strong>网络层只是根据网络地址将源结点发出的数据包传送到目的结点（点到点）</strong>，其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进&#x2F;出路由等控制，将信息从一个网络设备传送到另一个网络设备。</p>
<p>传输层提供端到端通信服务层次,提供可靠及非可靠连接。</p>
<p><strong>传输层则负责将数据可靠地传送到相应的端口（端到端）</strong>，传输层提供了主机应用程序进程之间的端到端的服务。传输层利用网络层提供的服务，并通过传输层地址提供给高层用户传输数据的通信端口，使高层用户看到的只是在两个传输实体间的一条端到端的、可由用户控制和设定的、可靠的数据通路。</p>
</blockquote>
<p>类似于家庭间通信:</p>
<p>12个孩子要与另一个家庭的12个孩子相互通信</p>
<ul>
<li>进程 &#x3D; 孩子们</li>
<li>进程间报文 &#x3D; 信封中的信笺</li>
<li>主机 &#x3D; 家庭的房子</li>
<li>运输协议 &#x3D; 张三 和 李四（站在大门口的管家）</li>
<li>网络层协议 &#x3D; 邮局提供的服务</li>
</ul>
<p><strong>上例中的几种特殊场景</strong></p>
<p>1、张三和李四生病了，无法工作，换成张五和李六</p>
<p><strong>【不同的运输层协议可能提供不一样的服务】</strong></p>
<p>2、邮局不承诺信件送抵的最长时间</p>
<p><strong>【运输层协议能够提供的服务受到底层网络协议的服务模型的限制】</strong></p>
<p>3、邮局不承诺平信一定安全可靠的送达，可能在路上丢失，但张三、李四可在较长时间内没有受到对方的回信时，再次誊写信件，寄出</p>
<p><strong>【在网络层不提供某些服务的情况下，运输层自己提供】</strong></p>
<p>ps：</p>
<p><strong>网络层为主机间提供逻辑通信, 而运输层为应用进程间提供端到端的通信逻辑.</strong></p>
<p><strong>网络层提供IP数据报首部中的检验和字段, 只检验首部是否出现差错; 而运输层要检验收到的报文是否有差错.</strong></p>
<p>【邮局只负责送到家，东西坏没坏由管家去查看。管家觉得没问题再给主人（应用）】</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/20190328003506312.png"></p>
<h2 id="第二部分：多路复用和多路分解"><a href="#第二部分：多路复用和多路分解" class="headerlink" title="第二部分：多路复用和多路分解"></a>第二部分：多路复用和多路分解</h2><p><strong>TCP和UDP的最基本任务</strong></p>
<ol>
<li><p>将<strong>主机到主机之间</strong>数据的交付（由IP层提供）扩展为运行在<strong>二个主机上的进程间</strong>的数据交付。</p>
</li>
<li><p>一台主机可以同时运行多个网络进程</p>
<ul>
<li><p>发送方：<strong>多个进程通过各自端口将数据交付给运输层，共同使用运输层的服务。这叫运输层的多路复用。</strong></p>
</li>
<li><p>接收方：<strong>当运输层收到从下层网络层传递上来的数据后，通过端口号就数据向上交付给各自的应用进程。这叫运输层的多路分解。</strong></p>
</li>
</ul>
</li>
</ol>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203185040027.png" alt="多路分解和多路复用"></p>
<p>可以说多路分解和多路复用是运输层的核心作用。</p>
<blockquote>
<p><strong>端口</strong></p>
<p>端口的作用就是让应用层的各种应用进程都能将其数据<strong>通过端口向下交付给运输层</strong>，以及<strong>让运输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程（或者线程）</strong></p>
<p>从这个意义上讲，<strong>端口是用来标志应用层的进程（或者线程）</strong></p>
<p>端口用一个 16 bit 端口号进行标志</p>
<p><strong>套接字</strong></p>
<p>TCP 使用“连接”(而不仅仅是“端口”)作为最基本的抽象，同时将 TCP 连接的端点称为套接字(socket) 。</p>
<p>套接字和端口、IP 地址的关系是：</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203185306343.png" alt="套接字"></p>
</blockquote>
<h3 id="报文段（数据段）的投送过程"><a href="#报文段（数据段）的投送过程" class="headerlink" title="报文段（数据段）的投送过程"></a>报文段（数据段）的投送过程</h3><ol>
<li><p><strong>主机收到IP包</strong></p>
<ul>
<li><p>每个数据包都有源IP地址和目的IP地址</p>
</li>
<li><p>每个数据包都携带一个传输层的数据报文段</p>
</li>
<li><p>每个数据报文段都有源、目的端口号</p>
</li>
</ul>
</li>
<li><p><strong>主机根据“IP地址＋端口号”将报文段定向到相应的套接字</strong>（这里注意的是，TCP和UDP的socket的内容有差异）</p>
</li>
</ol>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203185820481.png" alt="TCP/UDP报文格式"></p>
<blockquote>
<p><strong>面向连接的复用和分用</strong></p>
<ol>
<li><p><strong>TCP 套接字由一个四元组来标识</strong> </p>
<p><strong>（源IP地址，源端口号，目的IP地址，目的端口号）</strong></p>
<p><strong>【提供源IP地址和源端口号是为了TCP连接时的握手】</strong></p>
</li>
<li><p>接收方主机根据这四个值将报文段定向到相应的套接字（网络层只管送套接字）</p>
</li>
<li><p>服务器主机同时支持多个并发的TCP套接字：</p>
<p>【每一个套接字都由其四元组来标识】</p>
</li>
<li><p>Web服务器为每一个客户连接都产生不同的套接字</p>
<p>非持久HTTP对每一个请求都建立不同的套接字（由应用层可知会影响性能）</p>
</li>
</ol>
<p><strong>无连接的复用和分用</strong></p>
<ol>
<li><p>UDP 套接字由一个二元组来标识</p>
<p><strong>（目的IP地址，目的端口号）</strong></p>
<p><strong>【无握手，故称为无连接】</strong></p>
</li>
<li><p>接收方根据目的端口号将报文段定向到相应的套接字</p>
</li>
<li><p><strong>具有不同源IP地址和&#x2F;或源端口的UDP报文如果具有相同的目的IP地址和目的端口号，则定向到相同的套接字</strong></p>
</li>
</ol>
</blockquote>
<h2 id="第三部分：无连接的UDP"><a href="#第三部分：无连接的UDP" class="headerlink" title="第三部分：无连接的UDP"></a>第三部分：无连接的UDP</h2><h3 id="一个最简单的运输层协议必须提供"><a href="#一个最简单的运输层协议必须提供" class="headerlink" title="一个最简单的运输层协议必须提供"></a><strong>一个最简单的运输层协议必须提供</strong></h3><ol>
<li><p><strong>多路复用&#x2F;多路分解服务</strong></p>
</li>
<li><p><strong>差错检查</strong>（虽然进行差错检测，但不进行差错恢复。只是丢弃出错的UDP报文或交给应用程序但发出警告）</p>
<p>请思考下为什么UDP提供的是无连接的不可靠的传输服务，却还要提供差错检测？</p>
<p>【这是为了防止一直出错而导致数据根本传递不了。不进行差错恢复不意味着可以让数据一直丢失】</p>
</li>
<li><p>几乎没有对IP增加什么东西。如果程序开发人员选择基于UDP的Socket，则应用程序几乎是直接与IP打交道。</p>
</li>
</ol>
<h3 id="UDP处理数据的流程"><a href="#UDP处理数据的流程" class="headerlink" title="UDP处理数据的流程"></a>UDP处理数据的流程</h3><p><strong>发送方</strong></p>
<ul>
<li>从应用进程得到数据</li>
<li>附加上为多路复用&#x2F;多路分解所需的源和目的端口号及差错检测信息，形成报文段（<em>数据报</em>）</li>
<li>递交给网络层，尽力而为的交付给接收主机</li>
</ul>
<p><strong>接收方</strong></p>
<ul>
<li>从网络层接收报文段（<em>数据报</em>）</li>
<li>根据目的端口号，将数据交付给相应的应用进程</li>
</ul>
<h3 id="UDP的优势"><a href="#UDP的优势" class="headerlink" title="UDP的优势"></a>UDP的优势</h3><ul>
<li>无需建立连接——建立连接会增加时延</li>
<li>简单——发送方和接收方无需维护连接状态</li>
<li>段首部开销小——TCP:20Byte vs UDP:8Byte</li>
<li>无拥塞控制——UDP 可按需要随时发送</li>
</ul>
<h3 id="UDP大量应用可能导致的严重后果"><a href="#UDP大量应用可能导致的严重后果" class="headerlink" title="UDP大量应用可能导致的严重后果"></a>UDP大量应用可能导致的严重后果</h3><p>路由器中大量的分组溢出</p>
<p>显著减小TCP通信的速率，甚至挤垮TCP会话</p>
<h3 id="使用UDP的可靠数据传输"><a href="#使用UDP的可靠数据传输" class="headerlink" title="使用UDP的可靠数据传输"></a>使用UDP的可靠数据传输</h3><p><strong>在应用层实现数据的可靠传输</strong></p>
<p>增加了应用进程的实现难度</p>
<p>这点说明我们不能单纯的凭借主观感受来说UDP是一定不能可靠数据传输的。</p>
<h3 id="UDP报文段（数据报datagram）"><a href="#UDP报文段（数据报datagram）" class="headerlink" title="UDP报文段（数据报datagram）"></a>UDP报文段（数据报datagram）</h3><p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/20180301192421945.png" alt="UDP报文段"></p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203200421270.png" alt="UDP报文段格式"></p>
<h4 id="UDP的首部格式"><a href="#UDP的首部格式" class="headerlink" title="UDP的首部格式"></a>UDP的首部格式</h4><p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/20190328003652736.png" alt="首部格式"></p>
<p><strong>源端口号以及目的端口号</strong><br>用于唯一标识套接字，指示该报文段所要交付的套接字。端口号一般是16个bit，范围[0,65535]。其中0-1023是周知端口号，比如HTTP是80端口，FTP是21端口<br><strong>长度</strong><br>UDP用户数据报的长度(首部字段和数据字段)，其最小值是8，也即是只有首部。</p>
<blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首部只有8个字节</span><br></pre></td></tr></table></figure>

<ol>
<li><code>源端口</code> : 需要对方回信时选用, 不选可全为0.</li>
<li><code>目的端口</code> : 在终点交付报文时使用.</li>
<li><code>长度</code> : UDP用户数据报的长度.</li>
<li><code>检验和</code> : 检验UDP在传输中是否有错.</li>
</ol>
</blockquote>
<p><strong>校验和</strong><br>检测UDP用户数据报在传输的过程中是不是有错，有错就丢弃。</p>
<h3 id="UDP的检查和"><a href="#UDP的检查和" class="headerlink" title="UDP的检查和"></a>UDP的检查和</h3><p>目标：检测收到的报文段的“差错” (例如, 出现突变的比特)</p>
<p>发送方</p>
<ul>
<li>把报文段看作是16比特字的序列</li>
<li>检查和：对报文段的所有16比特字的和进行1的补运算</li>
<li>发送方将计算校验和的结果写入UDP校验和字段中</li>
</ul>
<p>接收方</p>
<ul>
<li><p>计算接收到的报文段的校验和</p>
</li>
<li><p>检查计算结果是否与收到报文段的校验和字段中的值相同</p>
<p>【不同 — 检测到错误</p>
<p>​	相同 — 没有检测到错误(但仍可能存在错误)】</p>
</li>
</ul>
<h3 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h3><ol>
<li>无连接 : 发送数据之前不需要连接.</li>
<li>尽最大努力交付 : 不保证可靠交付.</li>
<li>面向报文 : 对应用层下发的报文, 添加d首部后就下发到IP层, 对下发的报文不合并也不c拆分, 仅仅保留报文的边界. 一次交付一个报文.</li>
<li>无拥塞控制 : 发送后就不在管理.</li>
<li>多种通信 : 支持一对一, 一对多, 多对多通信.</li>
<li>首部开销小 : 首部仅有8个字节.</li>
</ol>
<h2 id="第四部分-可靠数据传输（十分重要）"><a href="#第四部分-可靠数据传输（十分重要）" class="headerlink" title="第四部分:可靠数据传输（十分重要）"></a>第四部分:可靠数据传输（十分重要）</h2><p>本节只讨论<strong>单向数据传输：数据是从发送端到接受端的。</strong></p>
<p>在实际的网络传输中，信道是不可靠的，在其上传输的分组可能会损坏或丢失，甚至相对次序都不能保证。</p>
<p>在这种情况下，应用层的程序迫切需要运输层提供一个可靠的数据传输服务，可以保证无论在实际的物理传输中发生了什么，数据都可以无损按序地交付给接收端。这就是可靠数据传输协议的作用，<strong>也是 TCP 向调用它的应用所提供的服务模型。</strong></p>
<blockquote>
<p>信道 (channel）：信道一般指连接信号发送方和接收方的传输线路，包括双绞铜线、同轴电缆、光纤、陆地无线电或者卫星无线电等物理媒体。</p>
</blockquote>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203201158611.png"></p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203201522230.png"></p>
<h3 id="可靠信道上的可靠传输——-rdt-1-0"><a href="#可靠信道上的可靠传输——-rdt-1-0" class="headerlink" title="可靠信道上的可靠传输—— rdt 1.0"></a>可靠信道上的可靠传输—— <strong>rdt</strong> <strong>1.0</strong></h3><p>考虑的情况：<strong>底层信道完全可靠</strong>。即不会产生比特错误、不会丢失分组。<strong>而且也假定接收方接收数据的速率与发送端发送数据的速率一样快。</strong></p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203202020447.png"></p>
<p>可以看到，rdt 的发送端只通过 <code>rdt_send(data)</code> 事件接收来自较高层的数据发送请求。在完成一次数据发送请求中需要两个动作：</p>
<ul>
<li>产生一个包含该数据的分组（经由 <code>make_pkt(data)</code> 产生）</li>
<li>然后将该分组通过 <code>udt_send(packet)</code> 发送到信道中</li>
</ul>
<p>完成这两个动作后，重新返回原始状态，继续等待来自较高层的数据发送请求。</p>
<p>而在接收端，rdt 通过 <code>rdt_rcv(packet)</code> 事件从底层信道接收一个分组。在一次数据接收过程中同样需要两个动作：</p>
<ul>
<li>从分组中取出数据（经由 <code>extract(packet, data)</code> 产生）</li>
<li>然后将数据上传给较高层（通过 <code>deliver_data(data)</code> 动作）</li>
</ul>
<p>和发送端一样，接收端完成这两个动作后也重新返回原始状态，继续等待从底层信道接收分组。</p>
<p><strong>需要注意的是，在发送端，引起状态变迁的事件是由较高层应用的过程调用产生的；而在接收端，引起状态变迁的事件是由较低层协议的过程调用产生的。</strong></p>
<p>现在我们就构造出了适用于可靠信道的可靠数据传输协议 rdt 1.0 ，因为信道可靠，接收方也不需要提供任何反馈信息给发送方，不必担心出现差错。而且因为假定了接收方接收数据的速率能够与发送方发送数据的速率一样快，所以接收方也没有必要请求发送方慢一点发送。</p>
<h3 id="经具有比特差错信道的可靠数据传输协议-rdt-2-0（解决分组出错问题，通过ACK-x2F-NAK告知发送方）"><a href="#经具有比特差错信道的可靠数据传输协议-rdt-2-0（解决分组出错问题，通过ACK-x2F-NAK告知发送方）" class="headerlink" title="经具有比特差错信道的可靠数据传输协议 rdt 2.0（解决分组出错问题，通过ACK&#x2F;NAK告知发送方）"></a>经具有比特差错信道的可靠数据传输协议 rdt 2.0（解决分组出错问题，通过ACK&#x2F;NAK告知发送方）</h3><p>考虑的情况：<strong>分组比特可能受损，所有传输的分组都将按序被接收，不会丢失</strong></p>
<p><strong>首先需要明确的一点是：如果发送方知道了哪些分组发送出去后接收方并没有收到，那么发送方就需要重传这些分组</strong>。基于这样的重传机制的可靠数据传输协议称为<strong>自动重传请求(Automatic Repeat Request, ARQ)协议</strong> 。</p>
<p><strong>ARQ处理机制</strong></p>
<ol>
<li><p>如何判断分组受损——<strong>差错检测</strong></p>
<p>【<strong>加校验和checksum</strong>】</p>
</li>
<li><p><strong>如何通知发送方分组是否受损——接收方反馈（ACK和NAK）</strong></p>
<ul>
<li><p>确认——acknowledgements (ACKs): 接收方明确告诉发送方正确收到分组</p>
</li>
<li><p>否认——negative acknowledgements (NAKs): 接收方明确告诉发送方分组有错</p>
</li>
</ul>
</li>
<li><p>在得知分组受损后，发送方如何处理——<strong>出错重传</strong></p>
<p>【<strong>当发送方收到了接收方发送的NAKS时，选择重发</strong>】</p>
</li>
</ol>
<p>下面来看一下 rdt 2.0 的有限状态机描述图，现在该数据传输协议（自动重传请求协议）采用了差错检测、肯定确认与否定确认。</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203202756161.png"></p>
<p>rdt 2.0 的发送端有两个状态。在最左边的初始状态中，发送端协议正等待来自较高层传下来的数据。当触发 <code>rdt_send(data)</code> 事件时：</p>
<ul>
<li>通过 <code>sndpkt = make_pkt(data, checksum)</code> 产生一个包含待发送数据且带有校验和的分组</li>
<li>然后将该分组通过 <code>udt_send(sndpkt)</code> 发送到信道中</li>
</ul>
<p>执行完上述的两个动作后，发送端的状态变迁为“等待接收接收端的 ACK 或 NAK 分组”。接下来根据接收端的响应不同会有不同的变迁方案：</p>
<ul>
<li>如果收到了一个 ACK 分组（<code>rdt_rcv(rcvpkt) &amp;&amp; isACK(rcvpkt)</code>），那么发送端知道接收端已经成功接收到了刚才发送出去的分组，发送端状态回到初始状态，继续等待下一次由较高层传下来的数据发送请求</li>
<li>如果收到了一个 NAK 分组（<code>rdt_rcv(rcvpkt) &amp;&amp; isNAK(rcvpkt)</code>），那么发送端知道接收端接收到的分组是受损的，所以调用 <code>udt_send(sndpkt)</code> 重新发送该分组，然后状态不变，继续等待接收接收端的 ACK 或 NAK 分组</li>
</ul>
<p>由于 rdt 2.0 的发送端拥有这个特性，所以 rdt 2.0 这样的协议被称为<strong>停等（stop-and-wait）协议</strong>。</p>
<p>rdt 2.0 的接收端仍然只有一个状态。状态变迁取决于收到的分组是否受损，有两种方式：</p>
<ul>
<li>如果收到的分组受损，即 <code>rdt_rcv(rcvpkt) &amp;&amp; corrupt(rcvpkt)</code>，则返回 NAK 分组</li>
<li>如果收到的分组完好，即 <code>rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt)</code>，则返回 ACK 分组</li>
</ul>
<p>处理完后仍然返回自身这个状态，继续等待下一次从底层接收分组并处理。</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203203413278.png"></p>
<p>接收方发送ACK。发送方接收到ACK后无异样操作。</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203203432961.png"></p>
<p>接收方收到的报文是有错误的，于是其发送NAK给发送方。发送方收到NAK后选择重传。</p>
<p>现在我们得到了一个似乎是可以在有比特差错信道上正常工作的可靠数据传输协议了，但仔细想想，我们没有考虑 ACK 或 NAK 分组受损的情况。如果 ACK 或 NAK 分组受损的时候，我们应该怎么做？</p>
<h3 id="经具有比特差错信道的可靠数据传输协议-rdt-2-1-解决-ACK-或-NAK-分组受损问题和重传问题"><a href="#经具有比特差错信道的可靠数据传输协议-rdt-2-1-解决-ACK-或-NAK-分组受损问题和重传问题" class="headerlink" title="经具有比特差错信道的可靠数据传输协议 rdt 2.1 (解决 ACK 或 NAK 分组受损问题和重传问题)"></a>经具有比特差错信道的可靠数据传输协议 rdt 2.1 (解决 ACK 或 NAK 分组受损问题和重传问题)</h3><p>1、解决A<strong>CK 或 NAK 分组受损的问题</strong>比较简单的一个方法<strong>ACK和NAK加校验和</strong></p>
<p>Q：我们怎么知道重传的分组是我们需要的分组呢？</p>
<p>2、解决<strong>只考虑重传可能会出现大量重复分组</strong>问题的方式是：<strong>是在数据分组中添加一个新的字段，然后让发送端对其数据分组编号，将发送数据分组的序号放在该字段中。</strong>于是，接收端只需要检查序号就可以确定收到的分组是否是一次重新传送的分组。因为 rdt 2.0 是一个简单的停等协议【<strong>发送方发出一个分组，然后等待接收方的应答</strong>】，1 比特序号就足够了。</p>
<p><strong>在这里再次提醒一下我们在 rdt 2.0 开始的地方所做的假设：假设信道不丢分组，而且不会存在分组乱序的情况。</strong>所以发送端知道所接收到的 ACK 和 NAK 分组（无论是否受损）都是为响应其最近发送的数据分组而生成的。</p>
<p>完善了对 ACK 和 NAK 分组受损的情况的处理机制后，我们把完善后的协议称为 rdt 2.1，下面是 rdt 2.1 发送端的有限状态机描述图：</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203204332982.png"></p>
<p>现在的状态数是以前的两倍，是因为协议的状态必须反映出目前（由发送端）正发送的分组或（在接收端）希望接受的分组序号是 0 还是 1。看起来这个描述图很复杂，其实发送或期望接收 0 号分组的状态中的动作与发送或期望接收 1 号分组的状态中的动作是相似的，唯一不同的是序号处理的方法不同。</p>
<p>这里我按照上图来描述一下 rdt 2.1 协议发送端的状态变迁过程：</p>
<ul>
<li><p>首先由较高层触发 <code>rdt_send(data)</code> 事件，通过 <code>sndpkt = make_pkt(0, data, checksum)</code> 产生一个序号为 0，包含待发送数据且带有校验和的分组，接着通过 <code>udt_send(sndpkt)</code> 将其发送到信道中，然后状态变迁为“等待接收接收端的 ACK 或 NAK 0”</p>
</li>
<li><p>当发送端收到了一个来自接收端的分组数据：</p>
<ul>
<li>如果该分组数据受损，或者接收到的是 NAK 分组，那么通过 <code>udt_send(sndpkt)</code> 重新传送刚才的序号为 0 的分组到信道中</li>
<li>如果该分组完好且收到的是 ACK 分组，那么发送端知道接收端已经成功接收了刚才发送的序号为 0 的分组，此时发送端状态变迁到等待较高层传下来的数据发送请求</li>
</ul>
</li>
<li><p>接着再次由较高层触发 <code>rdt_send(data)</code> 事件，通过 <code>sndpkt = make_pkt(1, data, checksum)</code> 产生一个序号为 1，包含待发送数据且带有校验和的分组，接着通过 <code>udt_send(sndpkt)</code> 将其发送到信道中，然后状态变迁为“等待接收接收端的 ACK 或 NAK 1”</p>
</li>
<li><p>当发送端再次收到了一个来自接收端的分组数据：</p>
<ul>
<li>如果该分组数据受损，或者接收到的是 NAK 分组，那么通过 <code>udt_send(sndpkt)</code> 重新传送刚才的序号为 1 的分组到信道中</li>
<li>如果该分组完好且收到的是 ACK 分组，那么发送端知道接收端已经成功接收了刚才发送的序号为 1 的分组，此时发送端状态变迁到等待较高层传下来的数据发送请求（即回到本状态机的初始状态）</li>
</ul>
</li>
</ul>
<p>只要收到NAK就重发，收到ACK就发下一个。</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203204349788.png"></p>
<p>接着再来描述一下 rdt 2.1 协议接收端的状态变迁过程：</p>
<ul>
<li>首先在初始状态上，接收端等待着接收由发送端发来的序号为 0 的分组数据</li>
<li>接着由<code>rdt_rcv(rcvpkt)</code>从底层信道接收了一个分组数据：<ul>
<li>如果该分组受损（即 <code>rdt_crv(rcvpkt) &amp;&amp; corrupt(rcvpkt)</code>），那么由 <code>sndpkt = make_pkt(NAK, checksum)</code> 产生一个附带校验和的 NAK 分组，接着由 <code>udt_send(sndpkt)</code> 发送回发送端</li>
<li>如果该<strong>分组失序</strong>（即 <code>rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &amp;&amp; has_seq1(rcvpkt)</code>），那么由 <code>sndpkt = make_pkt(ACK, checksum)</code> 产生一个附带校验和的 <strong>ACK 分组</strong>，接着由 <code>udt_send(sndpkt)</code> 发送回发送端</li>
<li>如果该分组完好且顺序正确（即 <code>rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &amp;&amp; has_seq0(rcvpkt)</code>），那么通过 <code>extract(rcvpkt, data)</code> 和 <code>deliver_data(data)</code> 将分组数据上传给较高层程序。接着，由 <code>sndpkt = make_pkt(ACK, checksum)</code> 产生一个附带校验和的 ACK 分组，由 <code>udt_send(sndpkt)</code> 发送回发送端</li>
</ul>
</li>
<li>接下来等待序号为 1 的分组的处理过程与上面类似，不再赘述</li>
</ul>
<p>只要分组有错就发NAK，只要分组没错（失序或没有失序）就发ACK。</p>
<p>总结一下：</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203204921570.png"></p>
<p>发送方在发送的分组是0或者1时都需要确认是否发送的分组被正确的接受。如果没有就重发。所以有2、4两个相同的状态。</p>
<p><strong>接受端收到失序分组的原因：</strong></p>
<p>这里顺便解释一下接收端接收到失序分组的原因：假设发送端发送序号为 0 的分组，接收端收到并回复 ACK，接着接收端就开始等待接收序号为 1 的分组，但是这个接收端返回的 ACK 分组由于在传输过程中受损，发送端并不知道序号为 0 的分组已经发送成功，所以仍然重复发送序号为 0 的分组，这样，就造成了接收端在等待接收序号为 1 的分组的时候，却接收到了序号为 0 的失序分组。</p>
<p><strong>为什么当接收端接收到分组失序时要返回 ACK 分组呢？因为按照上面的假设，信道不会丢失分组，也不会乱序，所以收到失序的分组的唯一原因就是上面解释的这种，那么在这种情况下，只需要告诉发送端：我确实已经收到了你刚才一直重发的分组，可以发新的了。所以接收端回应 ACK 分组即可。</strong></p>
<h3 id="经具有比特差错信道的可靠数据传输协议-rdt-2-2-无-NAK-分组"><a href="#经具有比特差错信道的可靠数据传输协议-rdt-2-2-无-NAK-分组" class="headerlink" title="经具有比特差错信道的可靠数据传输协议 rdt 2.2 (无 NAK 分组)"></a>经具有比特差错信道的可靠数据传输协议 rdt 2.2 (无 NAK 分组)</h3><p>其实上面的 rdt 2.1 协议在上述假设的底层信道模型中已经工作的不错了，但是我们还可以再简化一下，实现一个无 NAK 的可靠数据传输协议，我们称它为 rdt 2.2。</p>
<ul>
<li><p>只使用ACK</p>
</li>
<li><p>取消NAK，接收方对最后一个正确收到的分组发送 ACK</p>
<p>【接收方必须明确指出被确认的分组的序号】</p>
</li>
<li><p>发送方收到的<strong>重复的ACK将按照NAK来进行处理</strong></p>
<p>【重传正确的分组】</p>
</li>
</ul>
<p>rdt 2.1 和 rdt 2.2 之间的细微变化在于，<strong>接收端此时必须包括由一个 ACK 报文所确认的分组序号</strong>（可以通过在接收端有限状态机中，在 <code>make_pkt()</code> 中包括参数 ACK 0 或 ACK 1 来实现），发送端此时必须检查接收到的 ACK 报文中被确认的分组序号（可通过在发送端有限状态机中，在 <code>isACK()</code> 中包括参数 0 或 1 来实现）。</p>
<p>下图是 rdt 2.2 协议发送端的有限状态机描述图：</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203210155986.png"></p>
<p>下图是接收端的有限状态机描述图：</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203210214928.png"></p>
<p>考虑在 rdt 2.1 协议中，如果接收端收到了一个受损的分组则会返回 NAK 分组。但是**&#x3D;&#x3D;如果不发送 NAK，而是对上次正确接收的分组发送一个 ACK，也能实现与发送 NAK 一样的效果。&#x3D;&#x3D;**（失序分组的话，就告诉发送方发新的，是新的分组错误的话，发之前收到的ACK也告诉发送方发新的。） <strong>发送端接收到对同一个分组的两个 ACK（即接收冗余ACK）后，就知道接收端没有正确接收到跟在被确认两次的分组后面的分组。</strong>这就是 rdt 2.2 可以取消 NAK 分组的原因。</p>
<p>具体 rdt 2.2 的流程因为和 rdt 2.1 基本类似，故不赘述。</p>
<h3 id="经具有比特差错的丢包信道的可靠数据传输协议-rdt-3-0-解决数据或者ACK会丢失问题"><a href="#经具有比特差错的丢包信道的可靠数据传输协议-rdt-3-0-解决数据或者ACK会丢失问题" class="headerlink" title="经具有比特差错的丢包信道的可靠数据传输协议 rdt 3.0(解决数据或者ACK会丢失问题)"></a>经具有比特差错的丢包信道的可靠数据传输协议 rdt 3.0(解决数据或者ACK会丢失问题)</h3><p>新的假设：<strong>底层信道会丢包 (数据或 ACK)</strong></p>
<p>Q：怎么检测丢包和丢包后怎么做？<br>A：发送方检测丢包和恢复丢包。</p>
<p>解决方法：<strong>发送方对ACK等待“适当的”时间</strong></p>
<ul>
<li><p><strong>如果在这个时间内没有收到ACK则重传</strong></p>
</li>
<li><p><strong>如果分组或ACK仅仅是延迟到达（而非丢失）:</strong></p>
</li>
<li><p><strong>重传将造成重复，但序号可以解决这个问题</strong></p>
</li>
<li><p><strong>接收方必须指出确认的分组序号</strong></p>
</li>
</ul>
<p>解释：<strong>发送端负责检测和回复丢包工作</strong>。假定发送端传输一个数据分组，该分组或者接收端对该分组的 ACK 发生了丢失。在这两种情况下，发送端都收不到应当到来的接收端的响应。所以，如果发送端愿意等待足够长的时间以确定该分组缺失已丢失，则它只需要重传该数据分组即可。</p>
<p>但是等待多长时间合适呢？很明显发送端至少需要等待：<strong>发送端与接收端之间的往返时延（可能会包括在中间路由器的缓冲时延）加上接收端处理一个分组所需的时间。但这个时间是很难估算的。在 RFC 1323 中，这个时间被假定为 3 分钟。</strong></p>
<p>在实践中，发送端明智地选择一个时间值，以判定可能发生了丢包（尽管不能确定）。如果在这个时间内没有收到 ACK，则重传该分组。注意到如果一个分组经历了特别大的时延，发送端可能会重传该分组，即使该数据分组及其 ACK 都没有丢失。这就在发送端到接收端的信道中引入了<strong>冗余数据分组</strong>的可能性。不过上面的 rdt 2.2 协议已经有足够的功能（即序号）来处理冗余分组情况。</p>
<p><strong>从发送端的观点来看，重传是万灵药</strong>。发送端不知道是一个数据分组丢失，还是一个 ACK 丢失，或者只是该分组或 ACK 过低延时。在所有这些情况下，发送端执行的动作都是<strong>重传</strong>。</p>
<p>为了实现基于时间的重传机制，需要一个倒计时计时器，在一个给定的时间量过期后，中断发送端。因此发送端需要能做到：</p>
<ul>
<li>每次发送一个分组（包括第一次分组和重传分组）时，便启动一个定时器</li>
<li>响应定时器中断（采取适当的动作）</li>
<li>终止定时器</li>
</ul>
<h4 id="rdt3-0举例："><a href="#rdt3-0举例：" class="headerlink" title="rdt3.0举例："></a>rdt3.0举例：</h4><p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203210916277.png"></p>
<p>rdt3.0收到错误序号的ack，并不是立马重传，而是超时重传。</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203210929888.png"></p>
<h4 id="rdt3-0性能分析："><a href="#rdt3-0性能分析：" class="headerlink" title="rdt3.0性能分析："></a>rdt3.0性能分析：</h4><p>rdt3.0 可以工作, 但是性能很差</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203211454895.png"></p>
<p>解释：正常情况下L&#x2F;R（分组离开发送端）的时间后发送方就要发送新的数据。但是由于rdt3.0需要接受ACK。其中发送方接受ACK的时间为RTT+L&#x2F;R（忽略ACK分组的传输时间，RTT是传播时间）。这段时间内发送方是在等待的。</p>
<p>结果：</p>
<p>发送方只有万分之2.7 的时间是忙的</p>
<p>每30ms（1个RTT）内只能发送1KB ： 1 Gbps 的链路只有33kB&#x2F;sec（1KB&#x2F;30ms） 的吞吐量</p>
<p>网络协议限制了物理资源的利用率</p>
<p>图示：</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203212024456.png"></p>
<p><strong>提高性能的一种可行方法：流水线技术</strong></p>
<h3 id="流水线可靠数据传输协议（提高效率）"><a href="#流水线可靠数据传输协议（提高效率）" class="headerlink" title="流水线可靠数据传输协议（提高效率）"></a>流水线可靠数据传输协议（提高效率）</h3><p>允许发送方发送多个分组而无需等待确认</p>
<ul>
<li>必须<strong>增大序号范围</strong>（不再局限于3.0中的一个ACK了。正是3.0如此，故采取流水线作业）ACK(1-XXX)</li>
<li><strong>协议的发送方和接收方必须对分组进行缓存</strong></li>
</ul>
<p>例如：</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203212210674.png"></p>
<p>现在有一个问题：当流水线技术中丢失了一个分组，怎么进行重传？</p>
<ul>
<li>Go-Back-N（GBN，回退N步）协议：其后分组全部重传</li>
<li>选择重传（SR）协议：仅重传该分组</li>
</ul>
<p> go-Back-N（回退N重传协议）：</p>
<p>1.发送者在流水线中最多有 N 个未确认的数据报。</p>
<p>2.接收者仅发送累计的确认 ，<strong>如果中间有数据报缺失，就不予以确认</strong>。</p>
<p>3.发送者对最久未确认的数据报进行计时，如果计时器到点, <strong>重传所有未确认的数据报</strong>。</p>
<p>4.发送窗口大于1 ≤ 2k-1，接受窗口等于1（也就意味着如果某一个报文段出现错误，那么接受窗口会停留再次，之后收到的数据将会被丢弃）</p>
<p>selective repeat（选择重传协议）：</p>
<p>1.发送者在流水线中最多有 N 个未确认的数据报。</p>
<p>2.接收者对单个数据报进行确认。</p>
<p>3.发送者对每一个未确认的数据报进行计时，如果计时器到点, 仅重传该个未确认的数据报。</p>
<p>4.发送窗口大于1，接受窗口大于1（意味着可以缓存出错位置之后的报文段），最好是两者相同，</p>
<h4 id="Go-Back-N：（累计确认）"><a href="#Go-Back-N：（累计确认）" class="headerlink" title="Go-Back-N：（累计确认）"></a>Go-Back-N：（累计确认）</h4><p>允许发送方发送多个分组而不需等待确认，但已发送但未确认的分组数不能超过N。</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203220031107.png"></p>
<p>限制滑动窗口大小：为了流量控制</p>
<p>ACK-only: 对正确按序到达的分组发送ACK</p>
<ul>
<li>可能会产生重复的ACK</li>
<li>需要记住期待序号 expectedseqnum</li>
</ul>
<p>失序分组或损坏分组:</p>
<ul>
<li>丢弃 (不缓存) -&gt; 接收方无缓存!</li>
<li><strong>重发正确按序到达的最高序号分组的ACK</strong>（告诉发送方，该分组的后序分组（ack大于此ack）有问题，要重发）</li>
<li>每次发送的ACK一定是对正确按序到达的最高序号分组的确认</li>
</ul>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203220422740.png"></p>
<p><strong>Go-Back-N协议特点</strong></p>
<ol>
<li><p>ACK(n): 接收方对序号n之前包括n在内的所有分组进行确认 - “累积 ACK”（一段ACK都确认后或者没收到后再进行重传）</p>
</li>
<li><p>对所有已发送但未确认的分组统一设置一个定时器</p>
</li>
<li><p><em>超时</em>（n):重传分组n和窗口中所有序号大于n的分组</p>
</li>
<li><p>接收方收到失序分组: </p>
<ul>
<li><p>丢弃 (不缓存) -&gt; 接收方无缓存!</p>
</li>
<li><p>重发按序到达的最高序号分组的ACK</p>
</li>
</ul>
</li>
</ol>
<h4 id="选择重传（超时重传）"><a href="#选择重传（超时重传）" class="headerlink" title="选择重传（超时重传）"></a>选择重传（超时重传）</h4><p>解决GBN大量重传分组的问题</p>
<ol>
<li><p>接收方<em>逐个</em>对所有正确收到(即使失序)的分组进行确认（不是累积确认）</p>
<p>​			<strong>对接收到的（失序）分组进行缓存（GBN不缓存）</strong>, 以便最后对上层进行有序递交</p>
</li>
<li><p>发送方只重发<strong>怀疑</strong>丢失或损坏的分组</p>
<p>​		发送方为每一个没有收到ACK的分组设置<strong>定时器</strong></p>
</li>
<li><p>发送窗口</p>
<ul>
<li><p>大小为N，范围[sendbase, sendbase + N - 1]</p>
</li>
<li><p>限制已发送但未被确认的分组数最多为N</p>
</li>
<li><p>sendbase以前的分组都被确认</p>
</li>
</ul>
</li>
<li><p>接受窗口窗口</p>
<ul>
<li><p>大小为N,范围[recvbase, recvbase + N - 1]</p>
</li>
<li><p>落在窗口内的序号都是期待收到的分组序号</p>
</li>
<li><p>recvbase前都是按序到达，已发出确认，且已递交给上层</p>
</li>
</ul>
</li>
</ol>
<p>图示：</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203221213732.png"></p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203221608167.png"></p>
<p>补充：为什么发送方会收到比sendbase还小的分组确认？</p>
<p>假设窗口位于sendbase-1时，序号sendbase-1的分组定时器时间还没收到ACK（sendbase-1），发送方重发该分组。这时又收到了ACK(sendbase-1)，窗口前移。移动后，发送方又收到了ACK(sendbase-1)</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203222134071.png"></p>
<p>前移的标志：确认收到rcvbase前的分组。</p>
<p><strong>为什么接受方会收[recvbase-N，recvbase - 1]范围内的分组？并且必须给出确认？</strong></p>
<ul>
<li>因为确认可能会丢失。假设接受方按序收到<strong>N</strong>个分组，向发送方发送确认后接受窗口向前移动N位。</li>
<li>假设确认分组全部丢失，导致发送方重发。发送方最多只能发N个，因此接受方会收到[recvbase-N，recvbase - 1]范围内的分组</li>
<li><strong>接收方这时必须给出确认，否则发送方窗口无法向前移动</strong></li>
</ul>
<p><strong>为什么接受方收到比recvbase-N更早的分组后不用发确认了？</strong></p>
<ul>
<li>因为比recvbase-N更早的分组（如recvbase-N-1），发送方一定收到确认了。</li>
<li>当接受窗口位于recvbase时，意味着接受方一定按序收到了从[recvbase-N, recvbase- 1]的分组</li>
<li>这意味着发送方窗口一定到了recvbase-N。因此发送方一定收到了比recvbase-N更早的确认</li>
</ul>
<p>总之，接受方窗口移动前一定要考虑发送方的窗口移动。要清楚一点：接受方是发出ACK的一方，它的窗口移动是在发送方的前面的。</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203223540767.png"></p>
<p>当发送窗口和接受窗口不同步会产生严重后果。</p>
<p>第一种情况:</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203223744226.png"></p>
<p>第二种情况：</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203224403151.png"></p>
<p>这是接受方在窗口太大时的两难：<strong>最后收到的分组0是新的分组还是重传的？（接受方无法判断是情况一还是二）</strong></p>
<p><strong>结论：N≤2^k-1^</strong>（窗口长度必须小于等于序列号空间大小的一半）</p>
<h2 id="第五部分：面向连接的传输-TCP"><a href="#第五部分：面向连接的传输-TCP" class="headerlink" title="第五部分：面向连接的传输 : TCP"></a>第五部分：面向连接的传输 : TCP</h2><p>TCP的特点：</p>
<p>基于字节流<br>面向连接<br>可靠传输<br>缓冲传输<br>全双工<br>流量控制</p>
<h3 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h3><p>TCP虽然是面向字节流的,但TCP传送的数据单元却是报文段.<br>TCP报文段首部前20个字节是固定的, 后4n个字节是不定的</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/20190328003921619.png"><strong>源端口和目的端口 : 各占两个字节.</strong></p>
<p>**序号 : 占4个字节, 在一个TCP连接中传送的字节流中的每一个字节都按顺序编号. 整个要传输的字节流的起始序号必须在连接建立时设置. ** <strong>序号字段的值则指的是本报文段所发送的数据的第一个字节在整个报文字节流中的序号</strong></p>
<blockquote>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191203230341738.png"></p>
</blockquote>
<p><strong>确认号 : 占4个字节, 期望收到对方下一个报文段的第一个数据字节的序号.</strong></p>
<blockquote>
<p>TCP是全双工的，主机A在向主机B传输数据的同时，也从主机B中接受数据。确认号仅当ACK标志为1时有效。确认号表示期望收到的下一个字节的序号</p>
</blockquote>
<p>数据偏移 : 占4位, TCP报文段的数据起始处距离TCP报文段的起始处有多远.</p>
<p>保留 : 占6位,保留为今后使用，但目前应置为 0</p>
<p>紧急URG : URG &#x3D; 1时, 紧急指针字段有效, 优先发送, 比如终止指令.</p>
<p>确认ACK : 当ACK &#x3D; 1时, 才有效. TCP规定, 建立连接后所有传达的报文段ACK必须置为1.</p>
<p>推送PSH :  接收 TCP 收到推送比特置 1 的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付。 </p>
<p>复位RST :当 RST &#x3D; 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</p>
<p>同步SYN : 在建立连接时同步序号. 当SYN &#x3D; 1, 而ACK &#x3D; 0时, 表明是一个连接请求报文. 如果对方同意建立连接, 则应在相应的报文段中使用SYN &#x3D; 1和ACK &#x3D; 1.</p>
<p>终止FIN : 当FIN &#x3D; 1, 表示报文发送完毕, 可以释放连接.</p>
<p>窗口 : 占2字节, 发送报文一方的接收窗口. 窗口值得意义: .作为接收方让发送方设置其发送窗口的依据. 窗口字段明确指出了现在允许对方发送的数据量. 窗口值是动态变化的. 因为接收方的数据缓存空间是有限的.</p>
<p>校验和 : 占2字节, 检验范围包括首部和数据这两部分. 和UDP的检验和类似.</p>
<p>紧急指针 : 占2字节, URG &#x3D; 1才有意义.</p>
<p>选项字段 : 长度可变, TCP 只规定了一种选项，即最大报文段长度 MSS (Maximum Segment Size)。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”</p>
<p>填充字段 ：这是为了使整个首部长度是 4 字节的整数倍。 </p>
<p><strong>序列号和确认号是整个报文段首部最重要的两个字段</strong></p>
<h3 id="TCP如何保证可靠性"><a href="#TCP如何保证可靠性" class="headerlink" title="TCP如何保证可靠性"></a>TCP如何保证可靠性</h3><p>UDP传输数据不可靠，具体表现：<br>- 发送方不知道UDP数据段传达到接收方了没有，无反馈信息<br>- 发送方有多少就发多少，不会理会接收方实际可接收的数据大小</p>
<p>因此可靠性传输需要考虑两个方面：</p>
<ol>
<li>接收到消息后的反馈机制</li>
<li>接收方对于数据的承载能力</li>
</ol>
<p>有以下几个点：</p>
<p>1）应用数据被分割成TCP认为最合适发送的数据块。称为段（Segment）传递给IP层</p>
<p>【<strong>流水线方式</strong>发送报文段】</p>
<p>2）当TCP发出一个段后，它会启动一个定时器，等待目的端确认收到这个报文段。若没有及时收到确认，将重新发送这个报文段（最早未确认的报文段）见“超时重传”</p>
<p>3）当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送的，通常将推迟几分之一秒。</p>
<p>【累积确认：只确认最后一个正确按序到达的报文段，见“反馈机制”】</p>
<p>4）TCP将保持它首部和数据的校验和，这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化。如果收到段的校验和有差错，TCP将丢弃这个报文也不进行确认（超时重传导致对方就会重复发送了）。</p>
<p>5）TCP承载与IP数据报来传输，而IP数据报可能会失序，所以TCP的报文段到达时也可能会失序。但是TCP收到数据后会重新排序到正确的顺序（通过序号）。</p>
<p>6）IP数据报会发生重复，TCP的接收端必须丢弃重复是数据</p>
<p>7）TCP还能提供流量控制，TCP连接的每一方都有一定大小的缓冲空间</p>
<h4 id="反馈机制"><a href="#反馈机制" class="headerlink" title="反馈机制"></a>反馈机制</h4><p>链路层也使用了可靠数据的传输，通过停等协议、滑动窗口协议等，但由于网络层的IP协议是不可靠的，即使在链路层上不会发生丢失和错序，但是在路由器（网络层）上可能发生丢包。<br>TCP传输使用<strong>选择性重传（</strong>selective repeat）的传输方式。不选用停等协议是因为传输层中端到端的延迟很大。选择性重传用到了序列号和确认号<br><strong>确认号+序号</strong></p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/20180301192735455.png"></p>
<p>客户端发送第一个报文段，序号为x；第一个确认号字段为y-1。<br>然后服务端成功接收报文段后，提供一个确认，确认号为x+1，表示已经收到x以及之前的数据，期待接收x+1以及之后的数据。这里的报文段序号设置为y.<br>接着第三个报文段由客户发往服务器。确认已经收到服务器发来的数据。确认号为y+1，并且序号为x+1.</p>
<h4 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h4><p>在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。<br>　　这里比较重要的是重传超时时间，怎样设置这个定时器的时间（RTO），从而保证对网络资源最小的浪费。因为若RTO太小，可能有些报文只是遇到拥堵或网络不好延迟较大而已，这样就会造成不必要的重传。太大的话，使发送端需要等待过长的时间才能发现数据丢失，影响网络传输效率。<br>　　由于不同的网络情况不一样，不可能设置一样的RTO，实际中RTO是根据网络中的RTT（传输往返时间）来自适应调整的。具体关系参考相关算法。<br>　　通过图来了解重传机制： </p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/1233668-20180613233505890-1600510236.png"></p>
<p><strong>超时间隔加倍</strong></p>
<ul>
<li><p>每一次TCP超时重传均将下一次超时间隔设为先前值的两倍</p>
</li>
<li><p>超时间隔由EstimatedRTT和DevRTT决定，每当发生下列事件之一是重新计算超时间隔</p>
<ul>
<li><p>收到上层应用的数据</p>
</li>
<li><p>收到对未确认数据的ACK</p>
</li>
</ul>
</li>
</ul>
<p><strong>快速重传</strong>（缩短了超时的时间）</p>
<p><strong>TCP采取的是累计确认机制（不是说TCP要收完全部窗口中的ACK再发下一窗口），即当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余ACK（duplicate ACK）。这个和收到错误分组，接收方不发ACK是没有关联的。换句话说，累计确认机制让TCP具备了快速重传的特点。</strong></p>
<ol>
<li><p>【增加重发丢失分组的延时】</p>
</li>
<li><p>通过重复的ACK检测丢失报文段</p>
<p>发送方常要连续发送大量报文段</p>
<p>如果一个报文段丢失，会引起很多连续的重复ACK.</p>
</li>
<li><p><strong>如果发送收到一个数据的3个重复ACK，它会认为确认数据之后的报文段丢失</strong></p>
<p><strong>快速重传: 在超时到来之前重传报文段</strong></p>
</li>
</ol>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191204002104341.png"></p>
<h3 id="TCP重传机制和GBN-x2F-SR的关系"><a href="#TCP重传机制和GBN-x2F-SR的关系" class="headerlink" title="TCP重传机制和GBN&#x2F;SR的关系"></a>TCP重传机制和GBN&#x2F;SR的关系</h3><p><strong>注意：这三者的发送窗口是收到之前的ACK就滑动到下一个分组</strong></p>
<p>TCP重传机制更多的像一种GBN和SR的混合机制</p>
<p>TCP积累是确认式的，只用一个定时器，很像GBN</p>
<p>但有区别：</p>
<ul>
<li><p>很多TCP实现缓存失序的报文段。</p>
</li>
<li><p>GBN在报文段n超时时，会重发从n开始所有未确认的报文段。而<strong>TCP只会重传报文段n</strong>。甚至如果在报文段n超时收到了对报文段n+1的确认，TCP连报文段n都不会重传。</p>
<blockquote>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/20191005144432618.png"></p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/20191005144456427.png"></p>
</blockquote>
</li>
<li><p>TCP还有快速重传机制。</p>
</li>
</ul>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>流量控制的原因：</p>
<ul>
<li>TCP接收方有一个缓存，所有上交的数据全部缓存在里面</li>
<li>应用进程从缓冲区中读取数据可能很慢</li>
</ul>
<p>所以TCP支持根据接收端能力来决定发送端的发送速度。这个机制叫做流量控制。</p>
<p>流量控制的目标：</p>
<p>发送方不会由于传得太多太快而使得接收方缓存溢出</p>
<p>流量控制的手段：</p>
<p>接收方在反馈时，将缓冲区剩余空间的大小填充在报文段首部的窗口字段中，通知发送方</p>
<p><strong>窗口大小</strong></p>
<p>（接收端向发送端主机通知自己可以接受数据的大小，这个大小限制就叫做窗口大小）</p>
<p><strong>窗口扩大因子M</strong></p>
<p>接收端如何把窗口大小告诉发送端呢? 回忆我们的TCP首部中, 有一个16位窗口字段, 就是存放了窗口大小信息;那么问题来了, 16位数字最大表示65535, 那么TCP窗口最大就是65535字节么?实际上, TCP首部40字节选项中还包含了一个窗口扩大因子M,<br>实际窗口大小是 窗口字段的值左移 M 位;</p>
<p><strong>机理</strong></p>
<p><strong>接收端将自己可以接收的缓冲区大小放入 TCP 首部中的 “窗口大小” 字段, 通过ACK端通知发送端</strong>;窗口大小字段越大, 说明网络的吞吐量越高;<br><strong>接收端一旦发现自己的缓冲区快满了, 就会将窗口大小设置成一个更小的值通知给发送端;发送端接受到这个窗口之后, 就会减慢自己的发送速度</strong>;</p>
<p><strong>如果接收端缓冲区满了, 就会将窗口置为0; 这时发送方不再发送数据, 但是需要定期发送一个窗口探测数据段, 使接收端把窗口大小告诉发送端</strong><br><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/20180605190737615.png"></p>
<p>当接收端收到从3001号开始的数据段后其缓冲区挤满。不得不暂时停止发送数据，之后窗口收到更新通知后才得以继续进行。如果这个通知在途中丢失了，可能导致无法继续通信。所以发送方会是不是发送一个窗口探测的数据段。此数据端仅含一个字节来获取最新的窗口大小。</p>
<h3 id="TCP连接的建立"><a href="#TCP连接的建立" class="headerlink" title="TCP连接的建立"></a>TCP连接的建立</h3><p>就是我们常说的通过<strong>三次握手</strong>建立TCP连接。</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/20180301221159481.png"></p>
<p>第一步：客户端的TCP想服务器端的TCP发送一个特殊的TCP报文段，称为SYN报文段（syn设置为1），不包含应用层数据，随机选择一个初始序号client_isn。该报文段会被封装到一个IP数据报中，并发送给服务器。（告诉服务器，我来了）<br>第二步：服务器收到ip数据报后，提取出TCP SYN报文段，<strong>为该TCP分配TCP缓存和变量</strong>，<strong>并向该客户TCP发送允许连接的报文段</strong>。这个报文段也不包含应用层数据。首部包含三个重要信息：SYN比特设置为1，确认号设置为client_isn+1；服务器选择自己的随机序号server_isn。该报文也被称为SYNACK segment（服务器告诉客户端你可以连接，我准备好了）<br>第三步：客户机收到SYNACK报文段后，<strong>给该连接分配缓存和变量</strong>。客户机向服务器发送另外一个报文段，对服务器的允许连接的报文段进行确认（确认字段设置为server_isn+1)。因为连接已经建立了，因此SYN比特设置为0。这一阶段可以在报文段负载中携带客户到服务器的数据。（客户告诉服务器我不会鸽你的，我马上就要来了）</p>
<p><strong>为什么要三次握手？</strong></p>
<p>第三次握手是为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误。</p>
<p>假设只需要二次握手，考虑这种情况：</p>
<p>1：主机A发出的请求报文段在某些网络节点滞留时间太长，主机A由于超时重发连接请求，B收到重发的连接请求后给出同意连接的确认，主机A收到B的确认建立连接。数据传输完毕释放连接。</p>
<p>2：这时第一个请求才到达B，主机B收到该失效的请求后，误以为A又发出请求，于是向主机A发出确认，同意建立连接。主机A则不会理睬该确认。主机B则苦等A的数据。三次握手就可以防止这种情况的发生。（主机A不会对主机B的确认发出确认，连接就建立不起来）</p>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191204004122986.png"></p>
<h4 id="SYN洪泛攻击"><a href="#SYN洪泛攻击" class="headerlink" title="SYN洪泛攻击"></a>SYN洪泛攻击</h4><p>TCP服务器为了响应一个SYN连接请求报文，需要初始化连接变量及分配缓存（需要消耗服务器的资源），然后发送SYNACK报文进行响应，并等待客户端的ACK报文段。</p>
<p>如果客户机不给出第三次ACK响应来完成第三次握手的最后一步，服务器在等待一段时间后（通常为一分钟）服务器将终止该半开连接并释放资源。</p>
<h2 id="第六部分：拥塞控制原理"><a href="#第六部分：拥塞控制原理" class="headerlink" title="第六部分：拥塞控制原理"></a>第六部分：拥塞控制原理</h2><p>在过多的源发送了过多的数据，超出了网络的处理能力。</p>
<blockquote>
<p><strong>不同于流量控制!</strong></p>
<p>流量控制是为了匹配发送方和接收方的速度，只发生在发送方和接收方之间</p>
<p>拥塞控制：网络拥塞时，所有发送方都要抑制发送速度</p>
</blockquote>
<p>拥塞的现象：</p>
<p>丢包 (路由器缓冲区溢出)</p>
<p>延时长 (在路由器缓冲区排队)</p>
<h3 id="拥塞控制的方法（TCP选择端系统自己判断是否拥塞）"><a href="#拥塞控制的方法（TCP选择端系统自己判断是否拥塞）" class="headerlink" title="拥塞控制的方法（TCP选择端系统自己判断是否拥塞）"></a>拥塞控制的方法（TCP选择端系统自己判断是否拥塞）</h3><h4 id="网络辅助的拥塞控制"><a href="#网络辅助的拥塞控制" class="headerlink" title="网络辅助的拥塞控制"></a>网络辅助的拥塞控制</h4><p>直接网络反馈：路由器以阻塞分组的形式通知发送方“网络拥塞了”</p>
<p>经由接收方的网络反馈：路由器标识从发送方流向接收方分组中的某个字段以指示拥塞的产生，由接收方通知发送方“网络拥塞了”</p>
<h4 id="端到端拥塞控制"><a href="#端到端拥塞控制" class="headerlink" title="端到端拥塞控制"></a>端到端拥塞控制</h4><p>网络层不为拥塞控制提供任何帮助和支持</p>
<p>端系统通过对网络行为（丢包或时延增加）的观测判断网络是否发生拥塞</p>
<p>目前TCP采用该种方法</p>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>由于发送方到接收方之间的信道是公用的，因此如果发送方不考虑中间信道的容量随意发送就可能出现拥塞。拥塞会导致延迟严重，甚至大量丢包</p>
<p><strong>TCP必须使用端到端拥塞控制。（区别于网络辅助手段）</strong><br><strong>方法：让每一个发送方根据所感知到的网络拥塞程度来限制其能向链接发送流量的速率。</strong><br><strong>不拥塞——加快发送流量的速率</strong><br><strong>拥塞——减慢发送流量的速率</strong></p>
<p>发送端由一个接收缓存、一个发送缓存和几个变量组成。<br>拥塞控制机制需要跟踪一个额外的变量，<strong>拥塞窗口，cwnd</strong>。它对于一个TCP发送方能向网络中发送流量的速率进行了限制。<br>$LastByteSent−LastByteAcked&lt;&#x3D;min(cwnd,rwnd)$</p>
<p>这里我们假设接收窗口无限大，发送方未被确认的数据量仅受限于cwnd<br>$ 发送速率 &#x3D; cwnd&#x2F;RTT （字节&#x2F;秒）$</p>
<p>可以通过调节cwnd来调整发送方向连接发送数据的速率<br><strong>① 限制发送流量</strong><br>运行在发送方的TCP拥塞控制机制跟踪一个额外的变量，即拥塞窗口（congestion window。cwnd）<br>调节cwnd值以控制发送速率<br><strong>② 发送方感知出现拥塞</strong><br>过度拥塞的时候，路由器的缓存会溢出，引起一个数据报被丢弃，引起发送方的丢包事件<br>丢包事件：出现超时或者收到来自接收方的三个冗余ACK<br><strong>③ 发送方在感知拥塞后确定应当发送的速率</strong><br>这里需要用到TCP拥塞控制算法：慢启动；拥塞避免；快速恢复</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>阶段行为</th>
<th>结束的方式</th>
</tr>
</thead>
<tbody><tr>
<td>慢启动</td>
<td><strong>cwnd的值以一个MSS开始</strong>并且每当传输的报文段首次被确认，就指数增加MSS，1，2，4…每经过一个RTT，发送的速率翻番。</td>
<td>第一次结束：（出现由超时指示的丢包时间）将cwnd设置为1，然后重新开始慢启动过程，并且设置ssthresh(慢启动阈值）设置为cwnd的一半。                                                             第二次结束：（当cwnd达到或者超过ssthresh），TCP转移到拥塞避免阶段。             第三次结束（检测到3个冗余ACK）：执行快速重传并进入快速恢复状态</td>
</tr>
<tr>
<td>拥塞避免</td>
<td>此时cwnd的值大约是上次拥塞的值的一半，每次收到确认，将cwnd增加一个MSS</td>
<td>出现<strong>超时</strong>时，cwnd的值被设置为1个MSS，当<strong>丢包</strong>发生时，ssthresh更新为cwnd值的一半；当<strong>收到3个冗余的ACK时</strong>，将ssthresh的值记录为cwnd的值的一半，然后进入快速恢复状态</td>
</tr>
<tr>
<td>快速恢复</td>
<td>每收到一个冗余的ACK，cwnd将增加一个MSS</td>
<td>当对丢失报文段的一个ACK到达时，TCP在降低cwnd后进入拥塞避免状态。如果出现超时事件，cwnd设置为1个MSS，并且ssthresh的值设置为cwnd值的一半，然后迁移到慢启动状态</td>
</tr>
</tbody></table>
<blockquote>
<p><em>MSS</em>,最大报文段长度</p>
</blockquote>
<p>此处引入一个概念程为拥塞窗口，拥塞窗口发送开始的时候, 定义拥塞窗口大小为1;每次收到一个ACK应答, 拥塞窗口加1;</p>
<p>每次发送数据包的时候, <strong>将拥塞窗口和接收端主机反馈的窗口大小做比较, 取较小的值作为实际发送的窗口</strong>;像上面这样的拥塞窗口增长速度, 是指数级别的. “慢启动” 只是指初使时慢, 但是增长速度非常快.为了不增长的那么快, 因此不能使拥塞窗口单纯的加倍.此处引入一个叫做慢启动的阈值。<br><strong>当拥塞窗口超过这个阈值的时候, 不再按照指数方式增长, 而是按照线性方式增长</strong></p>
<p>**当TCP开始启动的时候, 慢启动阈值等于窗口最大值;在每次超时重发的时候, 慢启动阈值会变成原来的一半, 同时拥塞窗口置回1;**少量的丢包, 我们仅仅是触发超时重传; 大量的丢包, 我们就认为网络拥塞;</p>
<p>补充：</p>
<p>1、初始速率很低但是速率的增长速度很快。</p>
<p>2、对收到3个重复ACK的反应——快速重传</p>
<ul>
<li>门限值设为当前CongWin的一半（门限值初始值65kB）</li>
<li>将CongWin减为新的门限值+3MSS</li>
<li>线性增大拥塞窗口</li>
</ul>
<p>3、对超时事件的反应：设置门限（Threshold）</p>
<ul>
<li>门限值设为当前CongWin的一半（门限值初始值65kB）</li>
<li>将CongWin设为1个 MSS大小; </li>
<li>窗口以指数速度增大</li>
<li>窗口增大到门限值之后，再以线性速度增大</li>
</ul>
<p><img src="/images/%E8%BF%90%E8%BE%93%E5%B1%82/image-20191204100929736.png"></p>
<p>在执行慢开始算法时，拥塞窗口 cwnd 的初始值为 1，发送第一个报文段 M0。 </p>
<p>发送端收到 ACK1 （确认 M0，期望收到 M1）后，将 cwnd 从 1 增大到 2，于是发送端可以接着发送 M1 和 M2 两个报文段。</p>
<p>接收端发回 ACK2 和 ACK3。发送端每收到一个对新报文段的确认 ACK，就把发送端的拥塞窗口+1MSS。现在发送端的 cwnd 从 2 增大到 4，并可发送 M3 ~ M6共 4个报文段。</p>
<p>发送端每收到一个对新报文段的确认 ACK，就把发送端的拥塞窗口+1MSS，因此拥塞窗口 cwnd 随着传输次数按指数规律增长。 </p>
<p>当拥塞窗口 cwnd 增长到慢开始门限值 ssthresh 时（即当 cwnd &#x3D; 16 时），就改为执行拥塞避免算法，拥塞窗口按线性规律增长。 </p>
<p>假定拥塞窗口的数值增长到 24 时，网络出现超时（表明网络拥塞了）。</p>
<p>更新后的 ssthresh 值变为 12（即发送窗口数值 24 的一半），拥塞窗口再重新设置为 1，并执行慢开始算法。</p>
<p>当 cwnd &#x3D; 12 时改为执行拥塞避免算法，拥塞窗口按按线性规律增长，每经过一个往返时延就增加一个 MSS 的大小。</p>
<p>假定拥塞窗口的数值增长到 24 时，网络出现冗余ACK</p>
<p><strong>TCP拥塞控制算法（Reno）总结</strong></p>
<ol>
<li>当 拥塞窗口CongWin小于门限值Threshold时，发送方处于 慢启动 阶段，窗口以指数速度增大。</li>
<li>当 拥塞窗口CongWin大于门限值Threshold时，发送方处于 拥塞避免 阶段，窗口线性增大。</li>
<li>当收到 3个重复的ACK 时,门限值Threshold设为拥塞窗口的1&#x2F;2，而拥塞窗口CongWin设为门限值Threshold+3个MSS。</li>
<li>当 超时 事件发生时，门限值Threshold设为拥塞窗口的1&#x2F;2，而拥塞窗口CongWin设为1个 MSS。</li>
</ol>
<h4 id="TCP吞吐量"><a href="#TCP吞吐量" class="headerlink" title="TCP吞吐量"></a>TCP吞吐量</h4><p>忽略慢启动。</p>
<p>假定当丢包事件发生时，窗口大小为 W.</p>
<p>​		此时 吞吐量为$W&#x2F;RTT$</p>
<p>丢包事件发生后，窗口大小减为W&#x2F;2, 吞吐量为W&#x2F;2RTT. </p>
<p>​		因此平均吞吐量为: $0.75 W&#x2F;RTT$</p>
<h4 id="TCP拥塞控制的公平性"><a href="#TCP拥塞控制的公平性" class="headerlink" title="TCP拥塞控制的公平性"></a>TCP拥塞控制的公平性</h4><p>由于TCP是具有拥塞机制的，所以TCP在带宽的处理上是公平的，但是UDP是没有拥塞控制的，所以UDP是不公平的。它会以恒定的速率传输数据。</p>
<p>在并行TCP连接中，由于TCP是公平的。当一个应用使用了多个并行的TCP连接，它就会占有更多的带宽。从应用的角度来开就不是公平的。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/11/28/Algorithm_%E9%80%92%E5%BD%92/" rel="prev" title="递归">
      <i class="fa fa-chevron-left"></i> 递归
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/02/Algorithm_%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" rel="next" title="单源最短路径">
      单源最短路径 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82"><span class="nav-number">1.</span> <span class="nav-text">运输层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">第一部分：概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82%E5%92%8C%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.1.1.</span> <span class="nav-text">运输层和网络层的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3"><span class="nav-number">1.2.</span> <span class="nav-text">第二部分：多路复用和多路分解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%A5%E6%96%87%E6%AE%B5%EF%BC%88%E6%95%B0%E6%8D%AE%E6%AE%B5%EF%BC%89%E7%9A%84%E6%8A%95%E9%80%81%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">报文段（数据段）的投送过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9A%E6%97%A0%E8%BF%9E%E6%8E%A5%E7%9A%84UDP"><span class="nav-number">1.3.</span> <span class="nav-text">第三部分：无连接的UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%BF%90%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%BF%85%E9%A1%BB%E6%8F%90%E4%BE%9B"><span class="nav-number">1.3.1.</span> <span class="nav-text">一个最简单的运输层协议必须提供</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.2.</span> <span class="nav-text">UDP处理数据的流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">1.3.3.</span> <span class="nav-text">UDP的优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP%E5%A4%A7%E9%87%8F%E5%BA%94%E7%94%A8%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E7%9A%84%E4%B8%A5%E9%87%8D%E5%90%8E%E6%9E%9C"><span class="nav-number">1.3.4.</span> <span class="nav-text">UDP大量应用可能导致的严重后果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8UDP%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="nav-number">1.3.5.</span> <span class="nav-text">使用UDP的可靠数据传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP%E6%8A%A5%E6%96%87%E6%AE%B5%EF%BC%88%E6%95%B0%E6%8D%AE%E6%8A%A5datagram%EF%BC%89"><span class="nav-number">1.3.6.</span> <span class="nav-text">UDP报文段（数据报datagram）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">UDP的首部格式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP%E7%9A%84%E6%A3%80%E6%9F%A5%E5%92%8C"><span class="nav-number">1.3.7.</span> <span class="nav-text">UDP的检查和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP%E7%89%B9%E7%82%B9"><span class="nav-number">1.3.8.</span> <span class="nav-text">UDP特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%EF%BC%88%E5%8D%81%E5%88%86%E9%87%8D%E8%A6%81%EF%BC%89"><span class="nav-number">1.4.</span> <span class="nav-text">第四部分:可靠数据传输（十分重要）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E4%BF%A1%E9%81%93%E4%B8%8A%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E2%80%94%E2%80%94-rdt-1-0"><span class="nav-number">1.4.1.</span> <span class="nav-text">可靠信道上的可靠传输—— rdt 1.0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B7%E6%9C%89%E6%AF%94%E7%89%B9%E5%B7%AE%E9%94%99%E4%BF%A1%E9%81%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-rdt-2-0%EF%BC%88%E8%A7%A3%E5%86%B3%E5%88%86%E7%BB%84%E5%87%BA%E9%94%99%E9%97%AE%E9%A2%98%EF%BC%8C%E9%80%9A%E8%BF%87ACK-x2F-NAK%E5%91%8A%E7%9F%A5%E5%8F%91%E9%80%81%E6%96%B9%EF%BC%89"><span class="nav-number">1.4.2.</span> <span class="nav-text">经具有比特差错信道的可靠数据传输协议 rdt 2.0（解决分组出错问题，通过ACK&#x2F;NAK告知发送方）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B7%E6%9C%89%E6%AF%94%E7%89%B9%E5%B7%AE%E9%94%99%E4%BF%A1%E9%81%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-rdt-2-1-%E8%A7%A3%E5%86%B3-ACK-%E6%88%96-NAK-%E5%88%86%E7%BB%84%E5%8F%97%E6%8D%9F%E9%97%AE%E9%A2%98%E5%92%8C%E9%87%8D%E4%BC%A0%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.3.</span> <span class="nav-text">经具有比特差错信道的可靠数据传输协议 rdt 2.1 (解决 ACK 或 NAK 分组受损问题和重传问题)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B7%E6%9C%89%E6%AF%94%E7%89%B9%E5%B7%AE%E9%94%99%E4%BF%A1%E9%81%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-rdt-2-2-%E6%97%A0-NAK-%E5%88%86%E7%BB%84"><span class="nav-number">1.4.4.</span> <span class="nav-text">经具有比特差错信道的可靠数据传输协议 rdt 2.2 (无 NAK 分组)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B7%E6%9C%89%E6%AF%94%E7%89%B9%E5%B7%AE%E9%94%99%E7%9A%84%E4%B8%A2%E5%8C%85%E4%BF%A1%E9%81%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-rdt-3-0-%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E6%88%96%E8%80%85ACK%E4%BC%9A%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.5.</span> <span class="nav-text">经具有比特差错的丢包信道的可靠数据传输协议 rdt 3.0(解决数据或者ACK会丢失问题)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rdt3-0%E4%B8%BE%E4%BE%8B%EF%BC%9A"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">rdt3.0举例：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rdt3-0%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%9A"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">rdt3.0性能分析：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%EF%BC%88%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%EF%BC%89"><span class="nav-number">1.4.6.</span> <span class="nav-text">流水线可靠数据传输协议（提高效率）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Go-Back-N%EF%BC%9A%EF%BC%88%E7%B4%AF%E8%AE%A1%E7%A1%AE%E8%AE%A4%EF%BC%89"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">Go-Back-N：（累计确认）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0%EF%BC%88%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%EF%BC%89"><span class="nav-number">1.4.6.2.</span> <span class="nav-text">选择重传（超时重传）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%EF%BC%9A%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93-TCP"><span class="nav-number">1.5.</span> <span class="nav-text">第五部分：面向连接的传输 : TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.5.1.</span> <span class="nav-text">TCP报文段的首部格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">1.5.2.</span> <span class="nav-text">TCP如何保证可靠性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E9%A6%88%E6%9C%BA%E5%88%B6"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">反馈机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">超时重传</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E5%92%8CGBN-x2F-SR%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.5.3.</span> <span class="nav-text">TCP重传机制和GBN&#x2F;SR的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">1.5.4.</span> <span class="nav-text">流量控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="nav-number">1.5.5.</span> <span class="nav-text">TCP连接的建立</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SYN%E6%B4%AA%E6%B3%9B%E6%94%BB%E5%87%BB"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">SYN洪泛攻击</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86%EF%BC%9A%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86"><span class="nav-number">1.6.</span> <span class="nav-text">第六部分：拥塞控制原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88TCP%E9%80%89%E6%8B%A9%E7%AB%AF%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B7%B1%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%8B%A5%E5%A1%9E%EF%BC%89"><span class="nav-number">1.6.1.</span> <span class="nav-text">拥塞控制的方法（TCP选择端系统自己判断是否拥塞）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%BE%85%E5%8A%A9%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">网络辅助的拥塞控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">端到端拥塞控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">1.6.2.</span> <span class="nav-text">TCP拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">TCP吞吐量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E5%85%AC%E5%B9%B3%E6%80%A7"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">TCP拥塞控制的公平性</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rhb</p>
  <div class="site-description" itemprop="description">纵浪大化中，不喜亦不惧</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">126</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RShawshank" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RShawshank" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rhb</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
