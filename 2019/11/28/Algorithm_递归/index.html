<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rshawshank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文希望总结一下递归的用法和理解。">
<meta property="og:type" content="article">
<meta property="og:title" content="递归">
<meta property="og:url" content="http://rshawshank.github.io/2019/11/28/Algorithm_%E9%80%92%E5%BD%92/index.html">
<meta property="og:site_name" content="rhb_blog">
<meta property="og:description" content="本文希望总结一下递归的用法和理解。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://rshawshank.github.io/images/%E9%80%92%E5%BD%92/u=1950549850,1285308786&fm=173&app=25&f=JPEG.jpg">
<meta property="og:image" content="http://rshawshank.github.io/images/%E9%80%92%E5%BD%92/20180929205852699-1574928271280.dib">
<meta property="article:published_time" content="2019-11-28T15:24:35.000Z">
<meta property="article:modified_time" content="2021-02-10T08:50:24.000Z">
<meta property="article:author" content="rhb">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="Leetcode">
<meta property="article:tag" content="递归">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://rshawshank.github.io/images/%E9%80%92%E5%BD%92/u=1950549850,1285308786&fm=173&app=25&f=JPEG.jpg">

<link rel="canonical" href="http://rshawshank.github.io/2019/11/28/Algorithm_%E9%80%92%E5%BD%92/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>递归 | rhb_blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rhb_blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">rao的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2019/11/28/Algorithm_%E9%80%92%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          递归
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-28 15:24:35" itemprop="dateCreated datePublished" datetime="2019-11-28T15:24:35Z">2019-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-10 08:50:24" itemprop="dateModified" datetime="2021-02-10T08:50:24Z">2021-02-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文希望总结一下递归的用法和理解。</p>
<span id="more"></span>

<h1 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h1><p>递归是什么呢？简单的说就是函数自身调用自身，可以间接调用也可以直接调用。在实际问题的解决中，调用递归可以把一个大型的问题层层转化成一个规模缩小的同类问题的子问题，然后递归调用方法来表示问题的解。 </p>
<p>在实际实现递归过程中，一定要理解<strong>“我们只需要关注一级递归的解决过程即可。”</strong>这句话的含义。可以把之前的多层递归体看成是一个总体，再考虑问题。</p>
<h1 id="递归和迭代的区别"><a href="#递归和迭代的区别" class="headerlink" title="递归和迭代的区别"></a>递归和迭代的区别</h1><p>迭代和<a target="_blank" rel="noopener" href="http://www.nowamagic.net/librarys/veda/tag/%E9%80%92%E5%BD%92">递归</a>的区别是：迭代使用的是循环结构，递归使用的是选择结构。</p>
<ul>
<li>递归能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。</li>
<li>迭代则不需要反复调用函数和占用额外的内存。因此我们应该视不同 情况选择不同的代码实现方式。</li>
</ul>
<h1 id="递归的基本原理"><a href="#递归的基本原理" class="headerlink" title="递归的基本原理"></a>递归的基本原理</h1><p><strong>第一：</strong>每一级的函数调用都有自己的变量。</p>
<p><strong>第二：</strong>每一次函数调用都会有一次返回。 当程序流执行到某一级递归的结尾处时，它会转移到前一级递归继续执行。</p>
<p><strong>第三：</strong>递归函数中，<strong>位于递归调用前的语句和各级被调用函数具有相同的执行顺序</strong>。</p>
<p><strong>第四：</strong>递归函数中，<strong>位于递归调用后的语句的执行顺序和各个被调用函数的顺序相反</strong>。</p>
<p><strong>第五：</strong>虽然每一级递归都有自己的变量，但是函数代码并不会得到复制。</p>
<p><strong>第六：</strong>递归函数中必须包含可以终止递归调用的语句。称为递归出口。</p>
<p>参见一个经典的例程说明上述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">up_and_down</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   up_and_down(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">up_and_down</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Level %d:n location %p\n&quot;</span>,n,&amp;n); <span class="comment">/* 1 */</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">4</span>)</span><br><span class="line">      up_and_down(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Level %d:n location %p\n&quot;</span>,n,&amp;n); <span class="comment">/* 2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出结果</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Level <span class="number">1</span>:n <span class="keyword">location</span> <span class="title">0240FF48</span></span><br><span class="line">Level <span class="number">2</span>:n <span class="keyword">location</span> <span class="title">0240FF28</span></span><br><span class="line">Level <span class="number">3</span>:n <span class="keyword">location</span> <span class="title">0240FF08</span></span><br><span class="line">Level <span class="number">4</span>:n <span class="keyword">location</span> <span class="title">0240FEE8</span></span><br><span class="line">Level <span class="number">4</span>:n <span class="keyword">location</span> <span class="title">0240FEE8</span></span><br><span class="line">Level <span class="number">3</span>:n <span class="keyword">location</span> <span class="title">0240FF08</span></span><br><span class="line">Level <span class="number">2</span>:n <span class="keyword">location</span> <span class="title">0240FF28</span></span><br><span class="line">Level <span class="number">1</span>:n <span class="keyword">location</span> <span class="title">0240FF48</span> </span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>（1）首先， main() 使用参数 1 调用了函数up_and_down() ，于是 up_and_down() 中形式参数 n 的值是 1, 故打印语句 #1 输出了 Level1 。</p>
<p>（2）然后，由于 n 的数值小于 4 ，所以 up_and_down() （第 1 级）使用参数 n+1 即数值 2 调用了 up_and_down()( 第 2 级 ). 使得 n 在第 2级调用中被赋值 2, 打印语句 #1 输出的是 Level2 。与之类似，下面的两次调用分别打印出 Level3 和 Level4 。</p>
<p>（3）当开始执行第 4 级调用时， n 的值是 4 ，因此 if 语句的条件不满足。这时候不再继续调用 up_and_down() 函数。第 4 级调用接着执行打印语句 #2 ，即输出 Level4 ，因为 n 的值是 4 。现在函数需要执行 return 语句，此时第 4 级调用结束，把控制权返回给该函数的调用函数，也就是第 3 级调用函数。第 3 级调用函数中前一个执行过的语句是在 if 语句中进行第 4 级调用。因此，它继续执行其后继代码，即执行打印语句 #2，这将会输出 Level3。当第 3 级调用结束后，第 2 级调用函数开始继续执行，即输出Level2 ．依次类推．</p>
<p><strong>注意，每一级的递归都使用它自己的私有的变量 n ．可以查看地址的值来证明．此例程也说明了第一点和第二点</strong></p>
<p>**第三点说明： 打印语句 #1 位于递归调用语句前，它按照递归调用的顺序被执行了 4 次． **</p>
<p><strong>第四点说明：#2语句的调用的顺序是相反的</strong></p>
<h1 id="递归的三大要素"><a href="#递归的三大要素" class="headerlink" title="递归的三大要素"></a>递归的三大要素</h1><p><strong>第一要素：</strong> <strong>明确你这个函数想要干什么。</strong> 先不管函数里面的代码什么，而是要先明白，你这个函数的功能是什么，要完成什么样的一件事。</p>
<p><strong>第二要素：</strong> <strong>寻找递归结束条件。</strong>我们需要找出当参数为啥时，递归结束，之后直接把结果返回，请注意，这个时候我们必须能根据这个参数的值，能够直接知道函数的结果是什么。</p>
<p><strong>在设计递归算法时，要明确该问题的子问题也一定可以用该递归求。</strong></p>
<p><strong>第三要素：</strong> <strong>找出函数的返回值。</strong></p>
<p><strong>在分析递归的时候，要从宏观的角度分析，例如树，就只看成根节点、左右节点就行了</strong></p>
<p><strong>递归的过程</strong></p>
<p><img src="/images/%E9%80%92%E5%BD%92/u=1950549850,1285308786&fm=173&app=25&f=JPEG.jpg" alt="img"></p>
<h1 id="递归和栈的关系"><a href="#递归和栈的关系" class="headerlink" title="递归和栈的关系"></a>递归和栈的关系</h1><p>总所周知，递归是一个十分消耗资源的方式。当递归的次数很大的时候会导致函数栈溢出而死机。</p>
<p>调用栈:描述函数之间的调用关系,当函数之间相互调用的时候会使用调用栈;<br>调用栈由多个栈帧组成,每个栈帧记录着一个未运行完的函数; 栈帧中保存着该函数的返回地址以及局部变量;<br>在递归中,递归函数的每一次的”递进去”,栈帧都会将上个函数的返回地址局部变量保存以便在返回的过程中找得到相应的”回归出来的方向”<br><strong>栈帧</strong></p>
<p>1：栈帧将栈分割成N个记录块，每一个记录块的大小是不一样的；<br>2：这个记录块实际上是编译器用来实现函数调用的数据结构，通俗来讲就是用于活动记录，他用于记录每次函数调用所涉及的相关信息的记录单元；<br>3：栈帧也是一个函数的执行环境，它包括函数的参数，函数的局部变量函数，执行完之后要返回到哪里等等；</p>
<p>栈帧是用于调用函数的，你每调用一次函数他就会形成一个栈帧用于这个被调用函数的运行环境；</p>
<p>e.g.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">n</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n * <span class="title function_">test</span>(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">test</span>(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E9%80%92%E5%BD%92/20180929205852699-1574928271280.dib"></p>
<p>test(5)先调用，然后栈帧填入递归调用函数的信息。</p>
<p>分析：<br>要求计算5的阶乘；<br>1）：调用test函数时传入5，即首先在栈中划出一个记录块做为函数test（5）的执行环境；执行到最后结果为： 5 * test（4）；<br>2）：上一个函数的返回值中调用函数test（4），因此继续指向新的记录块，用于执行函数test（4）；执行到最后结果为： 4 * test（3）；<br>3）：上一个函数的返回值中调用函数test（3），因此继续指向新的记录块，用于执行函数test（3）；执行到最后结果为： 3 * test（2）；<br>4）：上一个函数的返回值中调用函数test（2），因此继续指向新的记录块，用于执行函数test（2）；执行到最后结果为： 2 * test（1）；<br>5）：上一个函数的返回值中调用函数test（1），因此继续指向新的记录块，用于执行函数test（1）；执行到最后test（1）&#x3D;1；<br>此时进栈操作已经到达了递归终止的条件，为了计算出最后的test（5）的值需要执行出栈操作；</p>
<p>如上图，我画了一幅出栈示意图；栈是先进后出的，所以最后进的要先出。<br>1）：test（1）出栈，返回值为1；<br>2）：栈帧test（2）接收test（1）返回值进行计算得出test（2） &#x3D; 2 * 1 &#x3D; 2；<br>3）：test（2）出栈，栈帧test（3）接收test（2）返回值进行计算得出test（3） &#x3D; 3 * 2 &#x3D; 6；<br>4）：test（3）出栈，栈帧test（4）接收test（3）返回值进行计算得出test（4） &#x3D; 4 * 6 &#x3D; 24；<br>5）：test（4）出栈，栈帧test（5）接收test（4）返回值进行计算得出test（5） &#x3D; 5 * 24 &#x3D; 120；<br>6）：test（5）出栈，返回值120，此时表示这一段程序已经执行完毕，计算得出5的阶乘是120；<br><strong>总结：在每一次递归函数调用的时候，栈帧都要记录下一个栈帧的返回值，所以调用的层数就和栈帧数相同</strong></p>
<h1 id="递归的优化方式"><a href="#递归的优化方式" class="headerlink" title="递归的优化方式"></a>递归的优化方式</h1><h2 id="考虑是否重复计算"><a href="#考虑是否重复计算" class="headerlink" title="考虑是否重复计算"></a>考虑是否重复计算</h2><p>在有重复计算的时候，可以考虑采用map容器将计算过的节点保存起来 每次递归先查找该容器中是否存在该节点(key)，如果存在则直接返回对应的值(value)；否则计算，并将新的节点(key)和值(value)存入map中 。</p>
<h2 id="考虑尾递归"><a href="#考虑尾递归" class="headerlink" title="考虑尾递归"></a>考虑尾递归</h2><p>传统的递归是首先执行递归调用，然后获取递归调用的返回值并计算结果。在每次递归调用返回之前是不会得到计算结果的。</p>
<p><strong>在尾递归中，首先执行计算，然后执行递归调用，将当前步骤的结果传递给下一个递归步骤</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">n，total=<span class="number">0</span></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">test</span>(n-<span class="number">1</span>,toal+n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(total);</span><br></pre></td></tr></table></figure>

<p>分析：执行的顺序</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="title">test</span><span class="params">(<span class="number">5</span>, <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">test</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">test</span><span class="params">(<span class="number">3</span>, <span class="number">9</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">test</span><span class="params">(<span class="number">2</span>, <span class="number">12</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">test</span><span class="params">(<span class="number">1</span>, <span class="number">14</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">test</span><span class="params">(<span class="number">0</span>, <span class="number">15</span>)</span></span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>每次递归调用的时候，total的值会更新。</p>
<h3 id="尾递归的原理"><a href="#尾递归的原理" class="headerlink" title="尾递归的原理"></a>尾递归的原理</h3><p> 当编译器检测到一个函数调用是尾递归的时候，<strong>它就覆盖当前的活动记录而不是在栈中去创建一个新的</strong>。编译器可以做到这点，<strong>因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。</strong>通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。</p>
<h1 id="一些例程的学习"><a href="#一些例程的学习" class="headerlink" title="一些例程的学习"></a>一些例程的学习</h1><p>在上网总结和学习了别人有关递归的博客后，现在分享几道例题来熟悉递归的使用。</p>
<p> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">Leetcode 104. 二叉树的最大深度</a> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//终止条件：当树为空的时候结束递归，并返回此时的深度为0</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//明确此次递归需要干什么 ：找到当前树的左子树或者右子树中最大深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="comment">//明确返回值是什么：当前树的最大深度</span></span><br><span class="line">        <span class="keyword">return</span> (right&gt;left)?right+<span class="number">1</span>:left+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">Leetcode 24. 两两交换链表中的节点</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">            <span class="comment">//把head next 排号的部分切换成next head 排号的部分</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">            head.next = swapPairs(next.next);</span><br><span class="line">            next.next = head;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/comments/">Leetcode 110. 平衡二叉树</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//平衡树的要求：左子树和右子树都是平衡树，并且左子树和右子树的高度差小于等于1</span></span><br><span class="line">        <span class="keyword">if</span>(isBalanced(root.left)&amp;&amp;isBalanced(root.right)&amp;&amp;(Math.abs(depth(root.left)-depth(root.right))&lt;=<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)java</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> depth(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> depth(root.left);</span><br><span class="line">        <span class="keyword">return</span> (r&gt;l)?r+<span class="number">1</span>:l+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/comments/">Leetcode 101. 对称二叉树</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isS(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isS</span><span class="params">(TreeNode a,TreeNode b)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="literal">null</span>&amp;&amp;b==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="literal">null</span>||b==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//对称树的要求</span></span><br><span class="line">        <span class="comment">//递归过程：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断两个指针当前节点值是否相等</span></span><br><span class="line"><span class="comment">//判断 A 的右子树与 B 的左子树是否对称</span></span><br><span class="line"><span class="comment">//判断 A 的左子树与 B 的右子树是否对称</span></span><br><span class="line">        <span class="keyword">if</span>(a.val==b.val)</span><br><span class="line">        <span class="keyword">return</span> isS(a.left,b.right)&amp;&amp;isS(a.right,b.left);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">Leetcode 111. 二叉树的最小深度</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//求最小深度的时候，要注意是和叶子的距离。也就是说，当你左子树或者右子树没有节点的时候，你只能和另一边的叶子比较最短距离</span></span><br><span class="line">        <span class="comment">//在计算最大深度的时候，这点是包含在算法里面的。</span></span><br><span class="line">      <span class="keyword">if</span>(root.left==<span class="literal">null</span>)<span class="keyword">return</span> minDepth(root.right)+java1;</span><br><span class="line">        <span class="keyword">if</span>(root.right==<span class="literal">null</span>)<span class="keyword">return</span> minDepth(root.left)+<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> Math.min(minDepth(root.left),minDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">Leetcode 226. 翻转二叉树</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//翻转二叉树：左右子树交换即可。</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.right;</span><br><span class="line">        root.right = invertTree(root.left);</span><br><span class="line">        root.left = invertTree(temp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">Leetcode 617. 合并二叉树</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-binary-tree/">Leetcode 654. 最大二叉树</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">Leetcode 83. 删除排序链表中的重复元素</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/comments/">Leetcode 206. 翻转链表</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-and-say/">Leetcode 38.报数</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">Leetcode 46.全排序</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">Leetcode 39.组合总和</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">Leetcode 40.组合总和2</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/">Leetcode 22.括号生成</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">Leetcode 98.验证二叉搜索树</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下列做法不能满足节点的左右子树中的所有节点都满足要求</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>&amp;&amp;root.left.val&gt;=root.val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>&amp;&amp;root.right.val&lt;=root.val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line">        <span class="keyword">return</span> left&amp;&amp;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正确做法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;<span class="comment">//保证右子树中的所有节点都满足要求</span></span><br><span class="line">            pre=root.right;</span><br><span class="line">            <span class="keyword">while</span>(pre.left!=<span class="literal">null</span>)&#123;pre=pre.left;&#125;</span><br><span class="line">            <span class="keyword">if</span>(pre.val&lt;=root.val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;<span class="comment">//保证左子树中的所有节点都满足要求</span></span><br><span class="line">            pre=root.left;</span><br><span class="line">            <span class="keyword">while</span>(pre.right!=<span class="literal">null</span>)&#123;pre=pre.right;&#125;</span><br><span class="line">            <span class="keyword">if</span>(pre.val&gt;=root.val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line">        <span class="keyword">return</span> left&amp;&amp;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历递归版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> Long.MIN_VALUE; <span class="comment">// 记录上一个节点的值，初始值为Long的最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inorder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">inorder</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//访问左子树</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">l</span> <span class="operator">=</span> inorder(node.left);</span><br><span class="line">        <span class="comment">//访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。</span></span><br><span class="line">        <span class="keyword">if</span>(node.val &lt;= pre) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = node.val;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">r</span> <span class="operator">=</span> inorder(node.right);</span><br><span class="line">        <span class="keyword">return</span> l &amp;&amp; r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">Leetcode 395.至少有k个重复字符的最长子串</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/integer-replacement/">Leetcode 397.整数替换</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">leetcode 538.把二叉搜索树转换为累加树</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将每个节点的值修改为原来的节点值加上所有大于它的节点值之和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;        </span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            convertBST(root.right);</span><br><span class="line">            sum+=root.val;</span><br><span class="line">            root.val=sum;</span><br><span class="line">            convertBST(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/submissions/">Leetcode 669.修剪二叉搜索树</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; low) &#123;</span><br><span class="line">            <span class="comment">//因为是二叉搜索树,节点.left &lt; 节点 &lt; 节点.right</span></span><br><span class="line">            <span class="comment">//节点数字比low小,就把左节点全部裁掉.</span></span><br><span class="line">            root = root.right;</span><br><span class="line">            <span class="comment">//裁掉之后,继续看右节点的剪裁情况.剪裁后重新赋值给root.</span></span><br><span class="line">            root = trimBST(root, low, high);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; high) &#123;</span><br><span class="line">            <span class="comment">//如果数字比high大,就把右节点全部裁掉.</span></span><br><span class="line">            root = root.left;</span><br><span class="line">            <span class="comment">//裁掉之后,继续看左节点的剪裁情况</span></span><br><span class="line">            root = trimBST(root, low, high);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果数字在区间内,就去裁剪左右子节点.</span></span><br><span class="line">            root.left = trimBST(root.left, low, high);</span><br><span class="line">            root.right = trimBST(root.right, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="递归改非递归的一般算法"><a href="#递归改非递归的一般算法" class="headerlink" title="递归改非递归的一般算法"></a>递归改非递归的一般算法</h1><p>递归的本质是通过栈来保存状态，然后再次调用自己进入新的状态，然后函数返回的时候回到上次保存的状态。</p>
<p>尾递归可以直接转化成循环，这里不多做分析</p>
<p>更一般的递归，想要转化为非递归，就需要模拟栈的行为。</p>
<p>例如：DFS的递归和非递归算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">假设给定图G的初态是所有顶点均未曾访问过。在G中任选一顶点v为初始出发点(源点)，则深度优先遍历可定义如下：首先访问出发点v，并将其标记为已访问过；然后依次从v出发搜索v的每个邻接点w。若w未曾访问过，则以w为新的出发点继续进行深度优先遍历，直至图中所有和源点v有路径相通的顶点(亦称为从源点可达的顶点)均已被访问为止。若此时图中仍有未访问的顶点，则另选一个尚未访问的顶点作为新的源点重复上述过程，直至图中所有顶点均已被访问为止。</span></span><br><span class="line"><span class="comment">　　图的深度优先遍历类似于树的前序遍历。采用的搜索方法的特点是尽可能先对纵深方向进行搜索。这种搜索方法称为深度优先搜索(Depth-First Search)。相应地，用此方法遍历图就很自然地称之为图的深度优先遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">（1）访问顶点v；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">（2）从v的未被访问的邻接点中选取一个顶点w，从w出发进行深度优先遍历；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">（3）重复上述两步，直至图中所有和v有路径相通的顶点都被访问到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreorderRecursive</span><span class="params">(Bitree root)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    visit(root);</span><br><span class="line">    PreorderRecursive(root-&gt;lchild); </span><br><span class="line">    PreorderRecursive(root-&gt;rchild); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1首先初始化待使用栈，然后将第一个结点入栈</span></span><br><span class="line"><span class="comment">2然后只要栈不空，重复下面的操作：将栈顶元素弹出，然后看该元素是否访问过</span></span><br><span class="line"><span class="comment">3若没访问过，则访问，置访问标记，然后将该元素的所有相邻顶点入栈（注意是全部，所以应用一个for或while循环来判断哪些元素该入栈）</span></span><br><span class="line"><span class="comment">4重复2，直至全部顶点均被访问过。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreorderNonRecursive</span><span class="params">(Bitree root)</span>&#123;</span><br><span class="line">  <span class="built_in">stack</span> stk;</span><br><span class="line">  stk.push(root);<span class="comment">//节点入栈</span></span><br><span class="line">  <span class="keyword">while</span>(!stk.empty())&#123;</span><br><span class="line">    p = stk.top();<span class="comment">//栈顶元素出栈并且访问该节点</span></span><br><span class="line">    visit(p);</span><br><span class="line">    stk.pop();</span><br><span class="line">    <span class="keyword">if</span>(p.rchild) stk.push(p.rchild);<span class="comment">//右边节点入栈</span></span><br><span class="line">    <span class="keyword">if</span>(p.lchild) stk.push(p.lchild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的非递归中使用栈将结点的相邻结点入栈就是模拟了递归中当一个结点被访问回退时，其相邻结点是和该结点处于同一层次的，故要一起入栈</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
              <a href="/tags/%E9%80%92%E5%BD%92/" rel="tag"># 递归</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/11/28/ComputerNetworking_%E5%BA%94%E7%94%A8%E5%B1%82/" rel="prev" title="应用层">
      <i class="fa fa-chevron-left"></i> 应用层
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/11/30/ComputerNetworking_%E8%BF%90%E8%BE%93%E5%B1%82/" rel="next" title="运输层">
      运输层 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%92%E5%BD%92"><span class="nav-number">1.</span> <span class="nav-text">什么是递归</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.</span> <span class="nav-text">递归和迭代的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">递归的基本原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%89%E5%A4%A7%E8%A6%81%E7%B4%A0"><span class="nav-number">4.</span> <span class="nav-text">递归的三大要素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%92%8C%E6%A0%88%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">5.</span> <span class="nav-text">递归和栈的关系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">递归的优化方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%80%83%E8%99%91%E6%98%AF%E5%90%A6%E9%87%8D%E5%A4%8D%E8%AE%A1%E7%AE%97"><span class="nav-number">6.1.</span> <span class="nav-text">考虑是否重复计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%80%83%E8%99%91%E5%B0%BE%E9%80%92%E5%BD%92"><span class="nav-number">6.2.</span> <span class="nav-text">考虑尾递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%BE%E9%80%92%E5%BD%92%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">6.2.1.</span> <span class="nav-text">尾递归的原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E4%BE%8B%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0"><span class="nav-number">7.</span> <span class="nav-text">一些例程的学习</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%94%B9%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%80%E8%88%AC%E7%AE%97%E6%B3%95"><span class="nav-number">8.</span> <span class="nav-text">递归改非递归的一般算法</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rhb</p>
  <div class="site-description" itemprop="description">纵浪大化中，不喜亦不惧</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">126</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rhb</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
