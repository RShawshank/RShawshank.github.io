<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rshawshank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="纵浪大化中，不喜亦不惧">
<meta property="og:type" content="website">
<meta property="og:title" content="rhb_blog">
<meta property="og:url" content="http://rshawshank.github.io/page/7/index.html">
<meta property="og:site_name" content="rhb_blog">
<meta property="og:description" content="纵浪大化中，不喜亦不惧">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rhb">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rshawshank.github.io/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>rhb_blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rhb_blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">rao的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">55</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">23</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">126</span></a>

  </li>
        <li class="menu-item menu-item-photos">

    <a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/RShawshank" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/" class="post-title-link" itemprop="url">编译原理-代码优化和目标代码生成</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-30 11:36:21" itemprop="dateCreated datePublished" datetime="2020-04-30T11:36:21Z">2020-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-16 19:00:22" itemprop="dateModified" datetime="2021-01-16T19:00:22Z">2021-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="优化技术介绍"><a href="#优化技术介绍" class="headerlink" title="优化技术介绍"></a>优化技术介绍</h1><p>代码优化，是指对中间代码或目标代码进行等价变换，使得变换后的代码运行速度加快和存储空间减少。</p>
<p>代码优化按照优化的代码块尺度分为：局部优化、循环优化和全局优化。即</p>
<ol>
<li>局部优化：只有一个控制流入口、一个控制流出口的基本程序块上进行的优化；</li>
<li>循环优化：对循环中的代码进行的优化；</li>
<li>全局优化：在整个程序范围内进行的优化。</li>
</ol>
<h1 id="常见的代码优化手段"><a href="#常见的代码优化手段" class="headerlink" title="常见的代码优化手段"></a>常见的代码优化手段</h1><p>常见的代码优化技术有：删除多余运算、合并已知量和复写传播，删除无用赋值等。</p>
<p>针对目标代码：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">P</span> := <span class="number">0</span></span><br><span class="line"><span class="attribute">for</span> I := <span class="number">1</span> to <span class="number">20</span> do </span><br><span class="line">    <span class="attribute">P</span> := P + A[I]*B[I] </span><br></pre></td></tr></table></figure>

<p>假设其翻译所得的中间代码如下</p>
<p><img src="https://i.loli.net/2021/01/17/D6wA2XkBIuGHhYE.png"></p>
<ol>
<li><p><strong>删除多余运算</strong><br> 分析上图的中间代码，可以发现(3)和式(6)属于重复计算（因为I并没有发生变化），故而式(6)是多余的，完全可以采用T<del>4</del>∶&#x3D;T<del>1</del>代替。</p>
</li>
<li><p><strong>代码外提</strong><br> 减少循环中代码总数的一个重要办法是循环中不变的代码段外提。这种变换把循环不变运算，即结果独立于循环执行次数的表达式，提到循环的前面,使之只在循环外计算一次。针对改定的例子，显然数组A和 B的首地址在计算过程中并不改变，则作出的改动如下</p>
</li>
</ol>
<p>  <img src="https://i.loli.net/2021/01/17/NirHpLcfsoCmdla.png"></p>
<ol start="3">
<li><strong>强度削弱</strong><br> 强度削弱的本质是把<strong>强度大的运算换算成强度小</strong>的运算，例如将乘法换成加法运算。针对上面的循环过程，每循环一次，I的值增加1，T<del>1</del>的值与I保持线性关系，每次总是增加4。因此，可以把循环中计算T<del>1</del>值的乘法运算变换成在循环前进行一次乘法运算，而在循环中将其变换成加法运算。</li>
</ol>
<p>  <img src="https://i.loli.net/2021/01/17/jkxtV8F3sfoOQI9.png"></p>
<ol start="4">
<li><p><strong>变换循环控制条件</strong><br> I和T<del>1</del>始终保持T<del>1</del>＝4*I的线性关系，因此可以把四元式（12）的循环控制条件I≤20变换成T<del>1</del>≤80，这样整个程序的运行结果不变。这种变换称为变换循环控制条件。经过这一变换后，循环中I的值在循环后不会被引用，四元式（11）成为多余运算，可以从循环中删除。变换循环控制条件可以达到代码优化的目的。</p>
</li>
<li><p><strong>合并已知量和复写传播</strong><br> 四元式（3）计算4 * I时，I必为1。即4*I的两个运算对象都是编码时的已知量，可在编译时计算出它的值，即四元式（3）可变为T<del>1</del>＝4，这种变换称为合并已知量。</p>
</li>
</ol>
<p>  四元式(6)把T<del>1</del>的值复写到T<del>4</del>中，四元式（8）要引用T<del>4</del>的值，而从四元式（6）到四元式（8）之间未改变T<del>4</del>和T<del>1</del>的值，则将四元式（8）改为T<del>6</del>∶&#x3D;T<del>5</del>[T<del>1</del>]，这种变换称为复写传播。</p>
<p>  <img src="https://i.loli.net/2021/01/17/jfz2uI8gO7UYNDQ.png"></p>
<ol start="6">
<li><strong>删除无用赋值</strong><br> 式（6）对T<del>4</del>赋值，但T<del>4</del>未被引用；另外，（2）和（11）对I赋值，但只有（11）引用I。所以，只要程序中其它地方不需要引用T<del>4</del>和I，则（6），（2）和（11）对程序的运行结果无任何作用。我们称之为无用赋值，无用赋值可以从程序中删除。至此，我们可以得到删减后简洁的代码</li>
</ol>
<p>  <img src="https://i.loli.net/2021/01/17/5QshwyeKM6UdCkv.png"></p>
<h2 id="基本块内的局部优化"><a href="#基本块内的局部优化" class="headerlink" title="基本块内的局部优化"></a>基本块内的局部优化</h2><h3 id="基本块的划分"><a href="#基本块的划分" class="headerlink" title="基本块的划分"></a>基本块的划分</h3><p>入口语句的定义如下：<br>　　① 程序的第一个语句；或者，<br>　　② 条件转移语句或无条件转移语句的转移目标语句；<br>　　③ 紧跟在条件转移语句后面的语句。<br>有了入口语句的概念之后，就可以给出划分中间代码（四元式程序）为基本块的算法，<br>　　其步骤如下：<br>　　① 求出四元式程序中各个基本块的入口语句。<br>　　② 对每一入口语句，构造其所属的基本块。<strong>它是由该入口语句到下一入口语句（不包括下一入口语句），或到一转移语句（包括该转移语句），或到一停语句（包括该停语句）之间的语句序列组成的。</strong><br>　 ③ 凡未被纳入某一基本块的语句、都是程序中控制流程无法到达的语句，因而也是不会被执行到的语句，可以把它们删除。</p>
<h3 id="基本块的优化手段"><a href="#基本块的优化手段" class="headerlink" title="基本块的优化手段"></a>基本块的优化手段</h3><p>由于基本块内的逻辑清晰，故而要做的优化手段都是较为直接浅层次的。目前基本块内的常见的块内优化手段有：</p>
<ol>
<li><p>删除公共子表达式</p>
</li>
<li><p>删除无用代码</p>
</li>
<li><p>重新命名临时变量 （一般是用来应对创建过多临时变量的，如t<del>2</del> :&#x3D; t<del>1</del> + 3如果后续并没有对t<del>1</del>的引用，则可以t<del>1</del> :&#x3D; t<del>1</del> + 3来节省一个临时变量的创建）</p>
</li>
<li><p>交换语句顺序</p>
</li>
<li><p>在结果不变的前提下，更换代数操作（如$x∶&#x3D;y<strong>2$是需要根据 $</strong>$运算符重载指数函数的，这是挺耗时的操作，故而可以用强度更低的$x∶&#x3D;y*y$来代替）</p>
</li>
</ol>
<p>根据以上原则，对如下代码进行优化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t1 := <span class="number">4</span> - <span class="number">2</span></span><br><span class="line">t2 := t1 / <span class="number">2</span> </span><br><span class="line">t3 := a * t2</span><br><span class="line">t4 := t3 * t1</span><br><span class="line">t5 := b + t4</span><br><span class="line"> c := t5 * t5</span><br></pre></td></tr></table></figure>

<p>给出优化的终版代码</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">t1</span> := a + a</span><br><span class="line"><span class="built_in">t1</span> := <span class="keyword">b </span>+ <span class="built_in">t1</span></span><br><span class="line"> c := <span class="built_in">t1</span> * <span class="built_in">t1</span></span><br></pre></td></tr></table></figure>

<p>显然代码优化的工作不能像上面那样的人工一步步确认和遍历，显然必然要将这些优化工作公理化。而一般到涉及到数据流和控制流简化的这种阶段，都是到了图论一展身手的时候。</p>
<h3 id="DAG（无环路有向图）应用于基本块的优化工作"><a href="#DAG（无环路有向图）应用于基本块的优化工作" class="headerlink" title="DAG（无环路有向图）应用于基本块的优化工作"></a>DAG（无环路有向图）应用于基本块的优化工作</h3><p><strong>利用DAG进行基本块优化的基本思想是：按照构造DAG结点的顺序，对每一个结点写出其相应的三地址代码表示</strong></p>
<p>在DAG图中，通过节点间的连线和层次关系来表示表示式或运算的归属关系：<br>① 图的叶结点，即无后继的结点，以一标识符（变量名）或常数作为标记，表示这个结点代表该变量或常数的值。如果叶结点用来代表某变量A的地址，则用addr（A）作为这个结点的标记。<br>② 图的内部结点，即有后继的结点,以一运算符作为标记，表示这个结点代表应用该运算符对其后继结点所代表的值进行运算的结果。<br>（注：该部分内容转载自教材《编译原理》第11章DAG无环路有向图应用于代码优化）</p>
<p>DAG构建的流程如下</p>
<blockquote>
<p>对基本块的每一四元式，依次执行：<br>　　1． </p>
<p>​	   如果NODE（B）无定义，则构造一标记为B的叶结点并定义NODE（B）为这个结点；<br>　　如果当前四元式是0型，则记NODE（B）的值为n，转4。<br>　　如果当前四元式是1型，则转2.（1）。<br>　　如果当前四元式是2型，则：（Ⅰ）如果NODE（C）无定义，则构造一标记为C的叶结点并定义NODE（C）为这个结点，（Ⅱ）转2.（2）。<br>　　2．<br>　　（1） 如果NODE（B）是标记为常数的叶结点，则转2.（3），否则转3.（1）。<br>　　（2） 如果NODE（B）和NODE（C）都是标记为常数的叶结点，则转2.（4），否则转3.（2）。<br>　　（3） 执行op　B（即合并已知量），令得到的新常数为P。如果NODE（B）是处理当前四元式时 新构造出来的结点，则删除它。如果NODE（P）无定义，则构造一用P做标记的叶结点n。置NODE（P）＝n，转4.。<br>　　（4） 执行B　op　C(即合并已知量)，令得到的新常数为P。如果NODE（B）或NODE（C）是处理当前四元式时新构造出来的结点，则删除它。如果NODE（P）无定义，则构造一用P做标记的叶结点n。置NODE（P）＝n，转4.。<br>　　3．<br>　　（1） 检查DAG中是否已有一结点，其唯一后继为NODE（B），且标记为op（即找公共子表达式）。如果没有，则构造该结点n，否则就把已有的结点作为它的结点并设该结点为n，转4.。<br>　　（2） 检查DAG中是否已有一结点，其左后继为NODE（B），右后继为NODE（C），且标记为op(即找公共子表达式)。如果没有，则构造该结点n，否则就把已有的结点作为它的结点并设该结点为n。转4.。<br>　　4．<br>　　如果NODE（A）无定义，则把A附加在结点n上并令NODE（A）＝n；否则先把A从NODE（A）结点上的附加标识符集中删除（注意，如果NODE（A）是叶结点，则其标记A不删除），把A附加到新结点n上并令NODE（A）＝n。转处理下一四元式。</p>
</blockquote>
<p>说着很复杂，下面看一个案例</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) <span class="built_in">T0</span>∶=<span class="number">3</span>.<span class="number">14</span></span><br><span class="line">(<span class="number">2</span>) <span class="built_in">T1</span>∶=<span class="number">2</span> * <span class="built_in">T0</span></span><br><span class="line">(<span class="number">3</span>) <span class="built_in">T2</span>∶=R + r</span><br><span class="line">(<span class="number">4</span>) A∶=<span class="built_in">T1</span> * <span class="built_in">T2</span></span><br><span class="line">(<span class="number">5</span>) <span class="keyword">B∶=A</span></span><br><span class="line"><span class="keyword"></span>(<span class="number">6</span>) <span class="built_in">T3</span>∶=<span class="number">2</span> * <span class="built_in">T0</span></span><br><span class="line">(<span class="number">7</span>) <span class="built_in">T4</span>∶=R + r</span><br><span class="line">(<span class="number">8</span>) <span class="built_in">T5</span>∶=<span class="built_in">T3</span> * <span class="built_in">T4</span></span><br><span class="line">(<span class="number">9</span>) <span class="built_in">T6</span>∶=R - r</span><br><span class="line">(<span class="number">10</span>) <span class="keyword">B∶=T5 </span>* <span class="built_in">T6</span></span><br></pre></td></tr></table></figure>

<p>其DAG图的构建过程如下</p>
<p><img src="https://i.loli.net/2021/01/17/3fgHueUhVzjFGWr.png"></p>
<p>通过DAG图可以发现诸多的优化信息，如重复定义、无用定义等，则根据上图的DAG图可以构建最后的优化代码序列</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　(<span class="number">1</span>) <span class="built_in">S1</span>∶=R+r</span><br><span class="line">　　(<span class="number">2</span>) A∶=<span class="number">6</span>.<span class="number">28</span>*<span class="built_in">S1</span></span><br><span class="line">　　(<span class="number">3</span>) <span class="built_in">S2</span>∶=R-r</span><br><span class="line">　　(<span class="number">4</span>) <span class="keyword">B∶=A </span>*<span class="built_in">S2</span></span><br></pre></td></tr></table></figure>

<h2 id="循环优化"><a href="#循环优化" class="headerlink" title="循环优化"></a>循环优化</h2><p>循环优化的主要手段有：循环次数无关性代码外提、删除归纳变量和运算强度削弱。关于这三种手段的理解可以借助此前的描述进行类比，基本并无太多差异。</p>
<h3 id="流图"><a href="#流图" class="headerlink" title="流图"></a>流图</h3><p>结点是基本块的有向图G &#x3D; ( N, E, root)</p>
<ul>
<li>N是结点的集合，每个结点表示一个基本块</li>
<li>E是边的集合，如果结点n<del>i</del>和n<del>j</del>间存在前驱和后继的关系，则在存在一条从n<del>i</del>到n<del>j</del>的有向边（此时意味着，在n<del>i</del>执行后，可能会执行n<del>j</del>）<ul>
<li>n<del>i</del>的出口语句是goto(s)或if … goto(s)，且(s)是的n<del>j</del>入口语句</li>
<li>n<del>j</del>在程序中的位置紧跟在n<del>i</del>后，且n<del>i</del>的出口语句不是无条件转移语句和停语句</li>
</ul>
</li>
<li>root是流图的首结点（或称为根结点），是包含程序第一个语句的基本块</li>
</ul>
<p>每个流图都可以等价变换为单入口，且每个结点最多有两个后继的图</p>
<p>根据上面基本块的定义，我们将诸多基本块组装在一起，构建成程序循环图，如针对下面这个例子</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="comment">(1)</span> read x</span><br><span class="line">　　<span class="comment">(2)</span> read y</span><br><span class="line">　　<span class="comment">(3)</span> r∶=x mod y</span><br><span class="line">　　<span class="comment">(4)</span> <span class="keyword">if</span> r=<span class="number">0</span> <span class="keyword">goto</span> <span class="comment">(8)</span></span><br><span class="line">　　<span class="comment">(5)</span> x∶=y</span><br><span class="line">　　<span class="comment">(6)</span> y∶=r</span><br><span class="line">　　<span class="comment">(7)</span> <span class="keyword">goto</span> <span class="comment">(3)</span></span><br><span class="line">　　<span class="comment">(8)</span> write y</span><br><span class="line">　　<span class="comment">(9)</span> halt</span><br></pre></td></tr></table></figure>

<p>则按照上面基本块的划分，可以分成四个部分，四个部分的控制流分析可知可以得到一个循环图（流图）</p>
<p><img src="https://i.loli.net/2021/01/17/empRxLUdXWEMIhO.png"></p>
<p>循环块最主要的特点是<strong>只有一个数据流和控制流入口，而出口可能有多个。</strong></p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87/" class="post-title-link" itemprop="url">编译原理-运行时存储组织</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-30 11:36:01" itemprop="dateCreated datePublished" datetime="2020-04-30T11:36:01Z">2020-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-05 06:39:48" itemprop="dateModified" datetime="2020-07-05T06:39:48Z">2020-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="运行时存储组织概述"><a href="#运行时存储组织概述" class="headerlink" title="运行时存储组织概述"></a>运行时存储组织概述</h1><p>编译程序是将源程序的<strong>算法描述部分和数据说明部分</strong>，分别翻译成<strong>机器目标代码和数据存储单元</strong>，最终获得目标程序。</p>
<p>目标程序在目标机环境中运行时，都置身于自己的一个运行时存储空间。在基于操作系统之上运行的情况下，目标程序将在自己的逻辑地址空间内运行并存储数据。编译程序在生成代码时，负责明确各类对象在逻辑地址空间是如何存放的，以及目标代码运行时，如何使用逻辑地址空间。</p>
<p>在编译过程中，源程序的对象地址分配往往是相对于运行存储空间的偏移量，对象访问采用“基地址＋偏移量”寻址方式进行，使得可以选择内存的任意可用区域作为目标程序运行时的存储区。这样生成的目标代码称为浮动地址代码</p>
<blockquote>
<p><strong>注：“基地址”是指运行存储空间之首址。</strong></p>
</blockquote>
<p><strong>重点：符号表的内容、组织，过程调用实现，</strong>      </p>
<p>   <strong>静态存储分配、动态存储分配的基本方法。</strong></p>
<p><strong>难点：参数传递，过程说明语句代码结构，</strong></p>
<p>​    <strong>过程调用语句的代码结构，</strong></p>
<p>​    <strong>过程调用语句的语法制导定义，</strong></p>
<p>​    <strong>栈式存储分配。</strong></p>
<h1 id="运行时存储组织的任务和作用"><a href="#运行时存储组织的任务和作用" class="headerlink" title="运行时存储组织的任务和作用"></a>运行时存储组织的任务和作用</h1><p>编译程序生成的代码大小通常是固定的，一般存放在专用的区域，即代码区；<br>目标程序运行过程中，需要创建和访问的数据对象存放在数据区。</p>
<h1 id="程序运行时存储空间的布局"><a href="#程序运行时存储空间的布局" class="headerlink" title="程序运行时存储空间的布局"></a>程序运行时存储空间的布局</h1><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87/image-20200705134412828.png"></p>
<h2 id="存储分配策略"><a href="#存储分配策略" class="headerlink" title="存储分配策略"></a>存储分配策略</h2><p>数据空间分配是将<strong>源程序数据对象名与给定的数据存储空间地址建立映射关系</strong>。数据对象名与数据存储地址可能是一对多的关系，因为在源程序中说明的一个数据对象，在运行时可能对应不同的存储地址，如递归程序中的局部变量。</p>
<h3 id="静态存储分配"><a href="#静态存储分配" class="headerlink" title="静态存储分配"></a>静态存储分配</h3><p>静态存储管理是一种最简单的存储管理。<strong>当在编译阶段能够确定源程序中各个数据实体的存储空间大小</strong>时，就可以采用静态存储管理。一般而言，适于静态管理的语言必须满足下面的条件：</p>
<p>( 1 )、数组的上下界必须是常数；</p>
<p>( 2 )、过程调用不允许递归；</p>
<p>( 3 )、不允许用户动态地建立数据实体。</p>
<p>对于静态存储分配，数据空间仅需要有静态数据区即可。在源程序翻译时，对于所有数据对象，其分配的存储地址都是相对于静态数据区的偏移量。这个偏移量就是登记在符号表中数据对象的地址( .place)属性值。在目标程序运行时，访问数据对象的绝对地址是：</p>
<p><strong>绝对地址＝静态数据区首址+偏移量。</strong> </p>
<h3 id="动态存储分配"><a href="#动态存储分配" class="headerlink" title="动态存储分配"></a>动态存储分配</h3><p>如果源语言允许递归调用、可变数组和允许运行期间自由申请与释放空间，那么其需占用的存储空间在编译阶段无法确定，这样数据对象就需要采用动态存储分配的策略。</p>
<p>所谓动态存储分配是指在运行期间，动态进行存储地址分配。</p>
<p>•<strong>基于控制栈的原理，存储空间被组织成栈，活动记录的推入和弹出分别对应于活动的开始和结束。</strong></p>
<p>•<strong>与静态分配不同，在每次活动中把局部名字和新的存储单元绑定，在活动结束时，活动记录从栈中弹出，因此局部名字的存储空间也随之消失。</strong></p>
<h4 id="栈式动态存储分配"><a href="#栈式动态存储分配" class="headerlink" title="栈式动态存储分配"></a>栈式动态存储分配</h4><p>由于过程允许递归，在某一时刻一个过程A 很可能已被自己调用了若干次，但只有最近一次正处于执行状态，而其余各次则处于等待返回被中断的那次调用的状态。这样，属于每次调用相应的数据区中的内容就必须保存起来，以便于调用返回时继续使用<strong>。对于这种语言来说，其存储分配策略必须采用栈式存储管理，即引入一个运行栈，让过程的每一次执行和过程的调用记录相对应，每调用一次过程，就把该过程的相应调用记录推入栈中，过程执行结束时再把栈顶的调用记录从找中弹出。</strong></p>
<blockquote>
<p>在运行期间以子程序数据区为基本单位，在数据空间栈中进行动态地址分配。</p>
<p>当调用子程序时，在数据空间栈顶，给子程序分配所需的子程序数据区；</p>
<p>当子程序返回时，从数据空间栈顶，收回分配给子程序所占用存储区。</p>
<p>当子程序被递归调用时，同一个子程序可能在数据空间中同时拥有多个子程序数据区，每个数据区对应于同一个子程序的一次执行过程。</p>
</blockquote>
<h4 id="堆式动态存储分配"><a href="#堆式动态存储分配" class="headerlink" title="堆式动态存储分配"></a>堆式动态存储分配</h4><p>某些程序设计语言(如C 和PASCAL等）允许程序在运行时，为其中的一些变量动态地申请和释放所需的存储空间，并且申请和释放这两类操作可以在任何时间、以任意的顺序来进行，这就需要一种更为灵活和更加有效的动态分配策略，即堆式存储分配来完成上述工作。</p>
<p>堆式分配的基本思想是：<strong>为正运行的程序划出一适当大的存储区域，称之为堆（Heap) ; 每当该程序提出申请时, 就按某种分配原则在堆的自由区（可占用区） 中，找出一块能满足其需求的存储空间分配给它，对于释放操作，则是将程序不再占用的存储空间归还给堆的自由区。</strong><br>可能遇到的各种情况与操作系统给进程分配存储空间时遇到的极其相似，如同样会出现“碎片”现象等，其根本差异就在于分配的层次和分配对象的粒度。</p>
<h2 id="活动记录"><a href="#活动记录" class="headerlink" title="活动记录"></a>活动记录</h2><p>1.活动记录本质是什么？</p>
<blockquote>
<p>活动记录本质上是每次为函数调用时分配的一大块内存。一个函数的活动记录只由在函数被调用时才会创建，并且当函数返回时就会被销毁。</p>
</blockquote>
<p>2.活动记录是如何存在的？</p>
<blockquote>
<p>活动记录被组织在栈中，栈可以是物理上的实体也可以是逻辑上的概念。在数据结构中的栈是一个逻辑上的概念，而芯片中也可以根据这个概念来设计一部分电路，这部分能够模拟栈操作的电路就是物理意义上的栈了。<br>主函数的活动记录位于栈底，当一个函数调用另外一个函数时，被调用函数的活动记录就会被压入栈。或当记录所在的栈满足数据结构中的栈的特性：FILO(first in last out)。这个限制使得当主调函数和被调函数中出现了同名函数时，在执行被调函数时主调函数的变量对被调函数来说是不可见的。<br>特别提醒：大部分计算机为活动记录栈分配内存地址都是从高到低！</p>
</blockquote>
<p>3.活动记录是如何进行入栈出栈的？</p>
<blockquote>
<p>由于活动记录是位于一个栈中的，所以要近栈就需要知道栈结束处的位置，当出栈时就需要知道当前活动记录之前的一个活动记录的结束点。<br>所以编译器和硬件都会维护两个很重要的值：栈指针，帧指针。<br>栈指针：始终指向战结束处（注意不是栈底！）的地址，如果有新的活动记录入栈，那里就是新活动记录的起始地址所在。<br>帧指针：保存着先前那个活动记录的结束处的地址，在当前函数返回后，栈指针就会指向那里。<br>In short,栈指针和帧指针就是用来界定活动记录的，并操作活动记录。</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87/20171025112910951"></p>
</blockquote>
<h2 id="过程调用"><a href="#过程调用" class="headerlink" title="过程调用"></a>过程调用</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97/" class="post-title-link" itemprop="url">编译原理-语法制导的语义计算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-30 11:35:26" itemprop="dateCreated datePublished" datetime="2020-04-30T11:35:26Z">2020-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-07 09:33:14" itemprop="dateModified" datetime="2020-06-07T09:33:14Z">2020-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="语法制导的语义计算"><a href="#语法制导的语义计算" class="headerlink" title="语法制导的语义计算"></a>语法制导的语义计算</h1><p>编译原理的几个核心阶段：词法分析、语法分析和语义分析，其实<strong>编译的本质便是翻译，其各个阶段便是承担不同的翻译任务，词法分析阶段的任务是将程序输入的字符串流翻译成语言认可的字符流（剔除空格和注释等部分）；语法分析便是将程序按照语言文法的规则构建成语法树；语义分析便是在语法树构建的基础上完成语言规则的语义动作（类型检查、作用域和可视性检查、一致性检查等）。</strong></p>
<h2 id="属性文法（属性翻译文法）"><a href="#属性文法（属性翻译文法）" class="headerlink" title="属性文法（属性翻译文法）"></a>属性文法（属性翻译文法）</h2><p>对于语言而言，无论变量、函数、过程在程序中都是用一个标识符来代替，但如果给定了一个标识符，我们如何确定这个标识符的意义呢？其实这便引导出属性文法的概念（其实语义分析的公式化有多种方式，比如操作语义学、公理语义学、属性文法等，其中属性文法最为直观，也是当前绝大多数编译器采用的编译方式），比如变量有int\float\double之类的区别，那显然给定一个变量标识符，必须要指明该标识符的“数据类型属性”，所以必须给所有标识符配备一系列的属性。利用标识符的这些属性，便可以用来配合此前构建的语法树进行一系列的语义动作（类型检查、可见性是否合法等）。</p>
<p>语义分析一般是和语法分析组合在一起执行的，语法分析完成前一步语法树分析的构建（调用某个产生式完成一步规约，形成当前的树节点），然后语义分析便接着调用相应产生式配备的语义动作或子程序，完成属性文法所要求的语义动作（比如类型转换或生成中间代码）。所以对于属性文法而言，属性的加工和使用过程便是语义处理的意义。</p>
<p>形式上讲，一个属性文法是一个三元组，A＝（G，V，F），一个上下文无关文法G；一个属性的有穷集V和关于属性的谓词函数的有穷集F。每个断言与文法的某产生式相联。如果对G中的某一输入串而言（句子），A中的所有断言对该输入串的语法树结点的属性全为真，则该串也是A语言中的句子。</p>
<p>以上下文无关文法为基础：</p>
<ol>
<li>它为每个文法符号（终结符或者非终结符）配备若干相关的“值”（称为属性），代表与文法符号相关信息，如类型、值、代码序列、符号表内容等</li>
<li>对于文法的每个产生式都配备了一组属性的语义规则，对属性进行计算和传递。【凡是能够用程序实现的信息处理都可以称为语义规则】</li>
</ol>
<h3 id="S-属性文法"><a href="#S-属性文法" class="headerlink" title="S-属性文法"></a>S-属性文法</h3><p>只含有综合属性的属性文法</p>
<ul>
<li>如果一个SDD是<code>S</code>属性的，可以按照语法分析树节点的任何自底向上顺序来计算它的各个属性值</li>
<li>S-属性定义可以在<strong>自底向上的语法分析</strong>过程中实现</li>
</ul>
<h3 id="L-属性文法"><a href="#L-属性文法" class="headerlink" title="L-属性文法"></a>L-属性文法</h3><p>直观含义：在一个产生式所关联的各属性之间，依赖图的边可以<strong>从左到右，但不能从右到左</strong>。【 产生式右边符号的继承属性不能依赖他右边的符号的属性】<br>正式定义：一个SDD是L-属性定义，当且仅当它的每个属性要么是一个综合属性，要么是满足如下条件的继承属性：假设存在一个产生式$A\rightarrow{X_1X_2…X_n}$其右部符号$X_i$的继承属性仅依赖于下列属性：</p>
<ul>
<li>A的继承属性</li>
<li>产生式中$X_i$左边的符号$X_1,X_2,…,X_{i-1}$的属性<br>$X_i$本身的属性，但$X_i$的全部属性不能在依赖图中形成环路</li>
<li>注：每个S-属性定义都是L-属性定义</li>
</ul>
<h3 id="综合属性"><a href="#综合属性" class="headerlink" title="综合属性"></a>综合属性</h3><p><strong>自下而上传递信息</strong></p>
<p>语法规则：根据右部候选式中的符号的属性计算左部被定义符号的综合属性</p>
<p>语法树：根据子结点的属性和父结点自身的属性计算父结点的综合属性</p>
<p>由此可知，综合属性是自下而上传递的。</p>
<h3 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h3><p><strong>主要是用来自上而下传递信息。</strong></p>
<p>语法规则：根据右部候选式中的符号的属性和左部被定义符号的属性计算右部候选式中的符号的继承属性</p>
<p>语法树：根据父结点的属性和兄弟结点自身的属性计算子结点的继承属性</p>
<h3 id="属性依赖"><a href="#属性依赖" class="headerlink" title="属性依赖"></a>属性依赖</h3><p>对应每个产生式A -&gt; α都有一套与之相关联的语义规则，每条规则的形式为：<br>b:f(c<del>1</del>,c<del>2</del>····c<del>k</del>)；f是一个函数，c<del>1</del>,c<del>2</del>····c<del>k</del>是某些属性，b是需要计算的属性。</p>
<p>我们称b依赖属性c<del>1</del>,c<del>2</del>····c<del>k</del>：</p>
<ul>
<li>b是A的一个综合属性并且c<del>1</del>,c<del>2</del>····c<del>k</del>是产生式右边符号的属性</li>
<li>b是产生式右边某个文法符号的一个继承属性并且c<del>1</del>,c<del>2</del>····c<del>k</del>是A或产生式右边任何文法符号的属性</li>
</ul>
<p>注意：<br>(1)终结符只有综合属性，它由词法分析器提供<br>(2)非终结符既可以有综合属性也可以有继承属性，文法开始符号的所有继承属性作为属性计算前的初始值。<br>(3) 产生式<strong>右边符号的继承属性</strong>和产生式<strong>左边符号的综合属性</strong>都必须提供一个计算规则<br>(4) 产生式<strong>左边符号的继承属性</strong>和产生式<strong>右边符号的综合属性</strong>不由所给的产生式的属性计算规则进行计算，它们<strong>由其它产生式的属性规则计算</strong></p>
<p>所以在对属性计算的过程即是对语义处理的过程，对于文法的每一个产生式配备一组属性的计算规则，则称为语义规则。</p>
<h2 id="语义规则"><a href="#语义规则" class="headerlink" title="语义规则"></a>语义规则</h2><p>语义规则也是属性文法，对上下文无关文法做的一个扩充。每个产生式应该配备的语义规则，要说明该产生式中出现的语法符号的对应的属性的计算方法，以表达这个产生式所对应的语法结构的意义。</p>
<p>语义规则是描述该产生式中出现的语法符号的属性之间的相互关系，是以函数计算的方式体现。</p>
<p>注意：<br>(1)语义规则可能产生副作用（如产生代码），<br>(2)也可能是过程，不是严格的函数（即不一定有返回值）</p>
<h2 id="带注释的语法树"><a href="#带注释的语法树" class="headerlink" title="带注释的语法树"></a>带注释的语法树</h2><p>在语法树中：</p>
<ul>
<li>一个结点的综合属性的值由其子结点和它本身的属性值确定</li>
<li>一个结点的继承属性由其父结点、其兄弟结点和其本身的某些属性确定</li>
<li>用继承属性来表示程序涉及语言结构中的上下文依赖关系很方便</li>
</ul>
<p>使用自底向上的方法在每一个结点处使用语义规则计算综合属性的值</p>
<h1 id="属性计算"><a href="#属性计算" class="headerlink" title="属性计算"></a>属性计算</h1><p>语义规则的计算：</p>
<ul>
<li>产生代码</li>
<li>在符号表中存放信息</li>
<li>给出错误信息</li>
<li>执行任何其它动作</li>
</ul>
<p>对输出串的翻译就是根据语义规则进行计算</p>
<p>在属性文法的基础上进行处理</p>
<p><strong>输入串语法树-&gt;依赖图-&gt;语义规则计算次序-&gt;计算结果</strong><br>这种由源程序的语法结构所驱动的处理办法就是语法制导翻译法。</p>
<h1 id="基于属性文法的处理方法"><a href="#基于属性文法的处理方法" class="headerlink" title="基于属性文法的处理方法"></a>基于属性文法的处理方法</h1><h2 id="依赖图"><a href="#依赖图" class="headerlink" title="依赖图"></a>依赖图</h2><p>在一颗语法树中的结点的继承属性和综合属性之间的相互依赖关系可以用称作<strong>依赖图</strong>的一个有向图来描述。依赖图可以确定属性计算的先后顺序。</p>
<p>依赖图中为每一个属性设置一个结点，如果属性b依赖于属性c，则从属性c的结点有一条有向边连到属性b的结点。</p>
<h3 id="良定义的属性文法"><a href="#良定义的属性文法" class="headerlink" title="良定义的属性文法"></a>良定义的属性文法</h3><p><strong>如果一属性文法不存在属性之间的循环依赖关系，那么该文法为良定义的。为了设计编译程序，我们只处理良定义的属性文法。</strong></p>
<p>一个依赖图的任何拓扑排序都给出一个语法树中结点的语义规则计算的有效顺序。</p>
<h3 id="属性的计算次序"><a href="#属性的计算次序" class="headerlink" title="属性的计算次序"></a>属性的计算次序</h3><p>一个有向非循环图的拓扑序是图中结点的任何顺序m<del>1</del>,m<del>2</del>, …m<del>k</del>,使得边必须是从序列中前面的结点指向后面的结点。也就是说，如果m<del>i</del>m<del>j</del>是m<del>i</del>到m<del>j</del>的一条边，那么在序列中m<del>i</del>必须出现在m<del>j</del>之前。<br>一个依赖图的任何拓扑排序都给出一个语法树中结点的语义规则计算的有效顺序。这就是说，在拓扑排序中，在一个结点上，语义规则b:&#x3D;f（c<del>1</del>,c<del>2</del>,…c<del>k</del>)中的属性c<del>1</del>,c<del>2</del>…c<del>k</del>在计算b以前都是可用的。</p>
<h2 id="树遍历的属性计算方法"><a href="#树遍历的属性计算方法" class="headerlink" title="树遍历的属性计算方法"></a>树遍历的属性计算方法</h2><p>通过树遍历的方法计算属性的值</p>
<ul>
<li>假设语法树已经建立，且树中带有开始符号的继承属性和终结符的综合属性</li>
<li>以某种次序遍历语法树，直至计算出所有属性</li>
<li>深度优先，从左到右进行遍历</li>
<li>基于<strong>递归</strong></li>
</ul>
<p>输入串-&gt;语法树-&gt;遍历语法树计算属性</p>
<h2 id="一遍扫描的处理方法"><a href="#一遍扫描的处理方法" class="headerlink" title="一遍扫描的处理方法"></a>一遍扫描的处理方法</h2><p>与语法分析方法相关，将属性计算穿插在语法分析的过程中进行。</p>
<p>产生语法结构的顺序决定了属性计算的顺序。【语法制导的思想】</p>
<p><strong>所谓的语法制导翻译法，直观上说就是为文法中每个产生式配上一组语义规则，并且在语法分析的同时执行这些语义规则。</strong></p>
<ul>
<li>在自上而下分析，一个产生式匹配输入串成功时，就执行相应的语义规则</li>
<li>在自下而上分析，一个产生式被归约时，就执行相应的语义规则</li>
</ul>
<h2 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h2><p>从语法树中去掉对翻译不必要的信息，而获得更有效的源程序中间表示。<br>这种经变换后的语法树称之为抽象语法树（Abstract Syntax Tree）。<br>在抽象语法树中，操作符和关键字都不作为叶结点出现，而是把它们作为内部结点，即这些叶结点的父结点。</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97/20180612214932367.png" style="zoom:50%;" />

<h1 id="S-属性文法的自下而上计算"><a href="#S-属性文法的自下而上计算" class="headerlink" title="S-属性文法的自下而上计算"></a>S-属性文法的自下而上计算</h1><p>s-属性文法：只含有综合属性</p>
<p>在自下而上的分析器分析输入符号串的同时计算综合属性</p>
<ul>
<li>分析栈中保存语法符号和有关的综合属性值</li>
<li>每当进行归约时，新的语法符号的属性值由栈中正在归约的产生式右边符号的属性值进行计算</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>原来自下而上分析栈一般只保存状态和语法符号。</p>
<p>现在，我们在分析栈中增加附加域存放综合属性值。</p>
<h1 id="L-属性文法的自顶向下翻译"><a href="#L-属性文法的自顶向下翻译" class="headerlink" title="L-属性文法的自顶向下翻译"></a>L-属性文法的自顶向下翻译</h1><p>按照深度优先遍历语法树，计算所有属性值</p>
<p>与LL(1)自上而下分析方法结合</p>
<ul>
<li>深度优先建立语法树</li>
<li>按照语义规则计算属性</li>
</ul>
<h1 id="翻译模式"><a href="#翻译模式" class="headerlink" title="翻译模式"></a>翻译模式</h1><p>语义规则：给出了属性计算的定义，没有属性计算的次序等实现细节。所以，我们得通过依赖图、树遍历等方法确定属性计算的顺序。</p>
<p>翻译模式：给出使用语义规则进行计算的次序，把实现细节表现出来</p>
<p>（1）在翻译模式中，和文法符号相关的属性和语义规则用花括号括起来，插入到产生式右部的合适位置上，可被插入到产生式右部的任何合适的位置上。</p>
<p>（2）这是一种语法分析和语义动作交错的表示法，他表达在按深度优先遍历分析树的过程中何时执行语义动作。</p>
<p>（3）翻译模式给出了使用语义规则进行计算的顺序。可看成是分析过程中翻译的注释。</p>
<h2 id="设计翻译模式（根据语法制导定义）"><a href="#设计翻译模式（根据语法制导定义）" class="headerlink" title="设计翻译模式（根据语法制导定义）"></a>设计翻译模式（根据语法制导定义）</h2><p>条件：<strong>语法制导定义是L-属性定义</strong><br><strong>保证语义动作不会引用还没有计算的属性值。【必须保证当某个动作引用一个属性时它必须是有定义的】</strong></p>
<h3 id="只需要综合属性的情况"><a href="#只需要综合属性的情况" class="headerlink" title="只需要综合属性的情况"></a>只需要综合属性的情况</h3><p>为每一个语义规则建立一个包含赋值的动作，并把这个动作放在相应的产生式右边的末尾。<br>例如：<br>产生式：T-&gt;T<del>1</del>*F<br>语义规则：T.val:&#x3D;T<del>1</del>.valxF.val<br>翻译模式:T-&gt;T<del>1</del>*F {T.val:&#x3D;T<del>1</del>.valxF.val}</p>
<blockquote>
<p>因为父节点的综合属性的值只依赖于子节点，把综合属性的值计算放在最右边，它的子节点已经扩展完毕了。我们也就得到子节点的属性值</p>
</blockquote>
<h3 id="既有综合属性又有继承属性的情况"><a href="#既有综合属性又有继承属性的情况" class="headerlink" title="既有综合属性又有继承属性的情况"></a>既有综合属性又有继承属性的情况</h3><p>要求：</p>
<p>①产生式右边的符号的继承属性必须在这个符号以前的动作中计算出来。<br>②一个动作不能引用这个动作右边符号的综合属性。<br>③产生式左边非终结符号的综合属性只有在它所引用的所有属性都计算出来以后才能计算。计算这种属性的动作通常可放在产生式右端的未尾。</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97/20180612215501603.png" style="zoom:50%;" />

<p>此时Pt（A1.in）是不好的，这个翻译模式不对。因为A1.in还没有出来（在最右边）</p>
<p>改进翻译模式：</p>
<p>S-&gt;{A1.in:&#x3D;1}A1{A2.in:&#x3D;2}A2       A-&gt;a{print(A.in)}</p>
<h2 id="语义动作执行时机统一"><a href="#语义动作执行时机统一" class="headerlink" title="语义动作执行时机统一"></a>语义动作执行时机统一</h2><p>把所有的语义动作都放在产生式的末尾</p>
<ul>
<li><p>语义动作的执行时机统一</p>
</li>
<li><p>转换方法</p>
<ul>
<li>加入新产生式M-&gt;ε</li>
<li>把嵌入在产生式中的每个语义动作用不同的非终结符M代替，并把这个动作放在产生式M-&gt;ε的末尾</li>
</ul>
</li>
</ul>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97/image-20200507184555454.png"></p>
<h2 id="消除翻译模式的左递归"><a href="#消除翻译模式的左递归" class="headerlink" title="消除翻译模式的左递归"></a>消除翻译模式的左递归</h2><p>语义动作是在相同位置上的符号被展开（匹配成功）时执行的。为了构造不带回溯的自顶向下语法分析，必须消除文法中的左递归</p>
<p>当消除一个翻译模式的基本文法的左递归时同时考虑属性计算</p>
<ul>
<li>适合带综合属性的翻译模式</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8/" class="post-title-link" itemprop="url">计算机系统结构-多处理器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-15 12:50:43 / 修改时间：04:50:44" itemprop="dateCreated datePublished" datetime="2020-04-15T12:50:43Z">2020-04-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机系统结构-互连网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 12:50:06" itemprop="dateCreated datePublished" datetime="2020-04-15T12:50:06Z">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-18 12:11:24" itemprop="dateModified" datetime="2020-04-18T12:11:24Z">2020-04-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机系统结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="互连网络（ICN）"><a href="#互连网络（ICN）" class="headerlink" title="互连网络（ICN）"></a>互连网络（ICN）</h1><p>互连网络是计算机部件、计算机节点或计算机系统之间的连接。</p>
<p>例如：CPU和CPU之间、CPU内的多核之间、CPU和内存之间、内存和内存之间、计算机节点之间、网络和网络之间。</p>
<p>互连网络的直接设计目标是：在最少传输延迟约束内，传输尽可能多的数据，避免成为系统的瓶颈。</p>
<p>高速互连网络（&lt;100s时钟周期）</p>
<p>片上&#x2F;系统高速互连网络是一种由网络元件按照一定的拓扑结构和控制方式构成的网络，用来实现计算机系统中部件之间的高速连接。</p>
<ul>
<li>三大要素：网络元件、互连结构、控制方式</li>
<li>结点：处理器、存储模块或其它设备</li>
<li>在拓扑上，互连网络为输入结点到输出结点之间的一组互连或映象。<ul>
<li>互连结构是静态连接拓扑</li>
<li>控制方式是基于静态拓扑结构的动态传输机制</li>
</ul>
</li>
</ul>
<p>互连网络的主要操作：</p>
<ul>
<li>置换（N-N）</li>
<li>广播（1-N）</li>
<li>选播（1-部分）</li>
</ul>
<h2 id="互连网络的结构参数和指标"><a href="#互连网络的结构参数和指标" class="headerlink" title="互连网络的结构参数和指标"></a>互连网络的结构参数和指标</h2><h3 id="结构参数"><a href="#结构参数" class="headerlink" title="结构参数"></a>结构参数</h3><p>网络通常是用有向边或无向边连接有限个结点的图来表示。</p>
<p>互连网络的主要特性参数：</p>
<ul>
<li>网络规模N：网络中接点的个数</li>
<li>结点度d：与结点相连接的边数，包括入度和出度</li>
<li>结点距离：对于网络中任意两个结点，从一个结点出发到另一个结点终止所需要跨越的边数的最小值</li>
<li>网络直径D：网络中任意两结点间距离的最大值<ul>
<li>网络直径应尽可能小</li>
</ul>
</li>
<li>等分宽度b：把由N个结点构成的网络切成结点数相同（N&#x2F;2）的两半，在各种切法中，沿切口边数的最小值。<ul>
<li>线等分宽度：B&#x3D;b X w，w为通道宽度</li>
<li>该参数反映了网络最大流量</li>
</ul>
</li>
<li>对称性：从任何结点看到的拓扑结构都相同的网络称为对称网络。</li>
</ul>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p><strong>时延和带宽</strong></p>
<ul>
<li>通信时延：指从源节点到目的结点传送一条消息所需的总时间<br>【&#x3D;软件开销+通道时延+选路时延+竞争时延】</li>
<li>网络时延：通道时延与选路时延的和<ul>
<li>由网络硬件特征决定，与程序行为和网络传输状态无关</li>
</ul>
</li>
<li>端口带宽<ul>
<li>对于互连网络中任意一个端口来说，其端口带宽是指单位时间内从该端口传送到其他端口的最大信息量。</li>
</ul>
</li>
<li>聚集带宽<ul>
<li>网络从一半结点向另一半结点传输时，单位时间内能够传送的最大信息量</li>
</ul>
</li>
</ul>
<h1 id="互连函数"><a href="#互连函数" class="headerlink" title="互连函数"></a>互连函数</h1><p>反映了网络输入数组和输出数组之间对应的置换关系或排列关系（置换函数或排列函数）</p>
<p>变量x：输入  函数f(x)：输出</p>
<p>在互连函数f的作用下，输入端x连接到输出端f(x)</p>
<p>互连函数采用循环表示：（x<del>0</del>,x<del>1</del>,x<del>2</del>,x<del>3</del>,···x<del>j-2</del>,x<del>j-1</del>）表示f(x<del>0</del>)&#x3D;x<del>1</del>,f(x<del>1</del>)&#x3D;x<del>2</del>,f(x<del>j-1</del>)&#x3D;x<del>0</del></p>
<h2 id="基本的互连函数"><a href="#基本的互连函数" class="headerlink" title="基本的互连函数"></a>基本的互连函数</h2><ol>
<li><p>恒等函数：实现同号输入端和输出端之间的连接<br>$I(X_{n-1}X_{n-2}···X_{1}X_{0})&#x3D;X_{n-1}X_{n-2}···X_{1}X_{0}$</p>
</li>
<li><p>交换函数：实现<strong>二进制地址编码</strong>中第K位互反的输入端和输出端之间的连接<br>$E(X_{n-1}X_{n-2}···X_{k+1}X_{k}X_{k-1}···X_{1}X_{0})&#x3D;X_{n-1}X_{n-2}···X_{k+1}\bar{X_{k}}X_{k-1}···X_{1}X_{0}$</p>
<ul>
<li><p>主要用于构造立方体互连网络和各种超立方体互连网络</p>
</li>
<li><p>供有n&#x3D;log<del>2</del>N种互连函数（N为结点个数）</p>
</li>
<li><p>$$<br>Cube_0(x_2x_1x_0)&#x3D;x_2x_1\overline{x_0}\<br>Cube_1(x_2x_1x_0)&#x3D;x_2\overline{x_1}x_0\<br>Cube_2(x_2x_1x_0)&#x3D;\overline{x_2}x_1x_0\<br>$$</p>
</li>
</ul>
</li>
<li><p>均匀洗牌函数（混洗函数、置换函数,shuffle函数）：将输入端分成数目相等的两半，前一半和后一半按类似均匀混洗扑克牌的方式交叉地连接到输出端（输出端相当于混洗的结果）<br>$\sigma(X_{n-1}X_{n-2}···X_{1}X_{0})&#x3D;X_{n-2}X_{n-3}···X_{0}X_{n-1}$</p>
<ul>
<li>即把输入端的二进制编号循环左移一位</li>
<li>$shuffle^{n}(j)&#x3D;j$</li>
<li>$shuffle_n(j)&#x3D;j$</li>
</ul>
</li>
<li><p>子函数和超函数</p>
<ul>
<li>互连函数(s)的第k个子函数s<del>k</del>：把s作用输入端的二进制编号的低k位</li>
<li>互连函数(s)的第k个超函数s^k^：把s作用输入端的二进制编号的高k位</li>
</ul>
</li>
<li><p>逆函数</p>
<ul>
<li>对于任意一种函数f(x),如果存在g(x)，使得$f(x)\times g(x)&#x3D;I(x)$。则称g(x)是f(x)的逆函数，记作$f^{-1}(x)&#x3D;g(x)$</li>
</ul>
</li>
<li><p>逆均匀洗牌函数：将输入端的二进制编号<strong>循环右移一位</strong>而得到所连接的输出端编号<br>$\sigma^{-1}(X_{n-1}X_{n-2}···X_{1}X_{0})&#x3D;X_{0}X_{n-1}···X_{2}X_{1}$</p>
</li>
<li><p>碟式函数（$\beta$）：把输入端的二进制编号的最高位与最低位互换位置得到输出端的编号。</p>
<ul>
<li>第k个子函数：<br>$\beta_{(k)}(X_{n-1}X_{n-2}···X_{k}X_{k-1}X_{k-2}···X_{1}X_{0})&#x3D;X_{n-1}X_{n-2}···X_{k}X_{0}X_{k-2}···X_{1}X_{k-1}$</li>
<li>第k个超函数：<br>$\beta^{(k)}(X_{n-1}X_{n-2}···X_{n-k+1}X_{n-k}X_{n-k-1}···X_{1}X_{0})&#x3D;X_{n-k}X_{n-2}···X_{n-k+1}X_{n-1}X_{n-k-1}···X_{1}X_{0}$</li>
<li>碟式变换与交换变换的多级组合是构成多级立方体网络的基础</li>
</ul>
</li>
<li><p>反位序函数：将输入端二进制编号的位序颠倒过来求得相应输出端的编号<br>$\rho(X_{n-1}X_{n-2}···X_{1}X_{0})&#x3D;X_{0}X_{1}···X_{n-2}X_{n-1}$</p>
<ul>
<li>第k个子函数<br>$\rho_{(k)}(X_{n-1}X_{n-2}···X_{k}X_{k-1}X_{k-2}···X_{1}X_{0})&#x3D;X_{n-1}X_{n-2}···X_{k}X_{0}X_{1}···X_{k-2}X_{k-1}$</li>
<li>第k个超函数<br>$\rho^{(k)}(X_{n-1}X_{n-2}···X_{n-k+1}X_{n-k}X_{n-k-1}···X_{1}X_{0})&#x3D;X_{n-k}X_{n-k+1}···X_{n-2}X_{n-1}X_{n-k-1}···X_{1}X_{0}$</li>
</ul>
</li>
<li><p>移数函数：将各输入端都错开一定的位置（模N）后连到输出端</p>
</li>
<li><p>PM2I函数（加减2^i^函数）</p>
<ul>
<li>P和M分别表示加和减，2I表示2^i^</li>
<li>一种移数函数<br>$PM2_{+i}(x)&#x3D;x+2^i\quad mod(N)$<br>$PM2_{-i}(x)&#x3D;x-2^i\quad mod(N)$<br>$0\leq x\leq N-1\quad o\leq i\leq n-1\quad n&#x3D;log_2N,N表示结点数$</li>
<li>PM2I互连网络共有2n个互连函数</li>
</ul>
</li>
</ol>
<h1 id="静态互连网络"><a href="#静态互连网络" class="headerlink" title="静态互连网络"></a>静态互连网络</h1><p>各结点之间有固定的连接通路、且在运行中不能改变的网络。</p>
<h2 id="1、2维互连函数"><a href="#1、2维互连函数" class="headerlink" title="1、2维互连函数"></a>1、2维互连函数</h2><h3 id="线性阵列"><a href="#线性阵列" class="headerlink" title="线性阵列"></a>线性阵列</h3><p>一种一维的线性网络，其中N个结点由N-1个链路连成一行。</p>
<ul>
<li>端结点的度：1</li>
<li>其余结点的度：2</li>
<li>直径：N-1</li>
<li>等分宽度b&#x3D;1</li>
</ul>
<h3 id="环和带弦环"><a href="#环和带弦环" class="headerlink" title="环和带弦环"></a>环和带弦环</h3><p>环：线性阵列的两个端点连接起来。可以单向工作也可以双向工作。</p>
<ul>
<li>对称</li>
<li>结点的度：2</li>
<li>双向环的直径：N&#x2F;2</li>
<li>单向环的直径：N-1</li>
<li>环的等分宽度b&#x3D;2</li>
</ul>
<h3 id="带弦环"><a href="#带弦环" class="headerlink" title="带弦环"></a>带弦环</h3><p>增加的链路越多，结点度越高，网络直径越小</p>
<ol>
<li><p>全连接网络：两两结点之间都有链路</p>
</li>
<li><p>循环移数网络：通过在环上每个结点到所有与其距离为2的整数幂的结点之间都增加一条附加链</p>
</li>
<li><p>树形和星形：<br>树形是二叉树</p>
<ul>
<li>最大结点度：3</li>
<li>直径：2(k-1)【k层完全平衡的二叉树】</li>
<li>等分宽度b&#x3D;1</li>
</ul>
<p>星形：<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C/image-20200418185318359.png"></p>
<ul>
<li>结点度：N-1</li>
<li>直径较小：2</li>
<li>等分宽度b&#x3D;[N&#x2F;2]【向下取整】</li>
</ul>
</li>
<li><p>胖树形</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C/image-20200418185441475.png" style="zoom:67%;" />
</li>
<li><p>网格形和环网形</p>
<ul>
<li>网格形：<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C/image-20200418185559655.png" style="zoom:50%;" />
一个由N=n^k^个结点构成的k维网格形网络（每维n个结点）的内部结点度d=2k，网络直径D=k(n-1)</li>
<li>Illiac网络：把2维网格形网络的每一列的两个端结点连接起来，再把每一行的尾结点与下一行的头结点连接起来，并把最后一行的尾结点与第一行的头结点连接起来<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C/image-20200418185935578.png" style="zoom:50%;" />
一个规模为nxn的Illiac网格：
- 所有结点的度d=4
- 网络直径D=n-1
- 等分宽度：2n</li>
<li>环网形：把2维网格形网络的每一列的两个端结点连接起来，再把每一行的两个端结点连接起来。<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C/image-20200418190203697.png" style="zoom:50%;" />
一个nxn的环网形网
- 结点度：4
- 网络直径：2x[n/2]【向下取整】
- 等分宽度b=2n</li>
</ul>
</li>
</ol>
<h2 id="超立方体和寻径"><a href="#超立方体和寻径" class="headerlink" title="超立方体和寻径"></a>超立方体和寻径</h2><h3 id="超立方体"><a href="#超立方体" class="headerlink" title="超立方体"></a>超立方体</h3><p>一种二元n-立方体结构，由N&#x3D;2^n^个结点组成；分布在n维上，每维有两个结点。<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C/image-20200418190523155.png" style="zoom:50%;" /></p>
<p>为实现一个n-立方体，只要把两个（n-1）立方体中相对应的结点用链路连接起来即可。共需要2^n-1^条链路。</p>
<p>n-立方体中结点的度都是n，直径也是n，等分宽度为b&#x3D;N&#x2F;2。</p>
<h3 id="带环立方体（3-CCC）"><a href="#带环立方体（3-CCC）" class="headerlink" title="带环立方体（3-CCC）"></a>带环立方体（3-CCC）</h3><p>将k-立方体的每个结点用由k个结点的环来代替，组成带环k-立方体。<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C/image-20200418190859708.png" style="zoom:67%;" /></p>
<ul>
<li>网络规模：$N&#x3D;k\times2^k$</li>
<li>网络直径：$D&#x3D;2k-1+\lfloor k&#x2F;2\rfloor$</li>
<li>等分宽度：$b&#x3D;\frac{N}{2k}$</li>
</ul>
<h3 id="k元n-立方体网络"><a href="#k元n-立方体网络" class="headerlink" title="k元n-立方体网络"></a>k元n-立方体网络</h3><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C/image-20200418194426267.png" style="zoom:67%;" />

<ul>
<li>环形、网格、环网形、二元n-立方体（超立方体）都是k元n-立方体网络系列的拓扑同构体</li>
<li>在k元n-立方体网络中，参数n是立方体的维数，k是基数，即每一维上的结点个数$N&#x3D;N^n$</li>
<li>k元n-立方体的结点可以用基数为k的n位地址A&#x3D;a<del>1</del>a<del>2</del>a<del>3</del>a<del>4</del>来表示【a<del>i</del>表示该结点在第i维上的位置】</li>
<li>通常把低维k元n-立方体称为环网，而把高维k元n-立方体称为超立方体</li>
</ul>
<h3 id="基于静态互连网络的寻径机制"><a href="#基于静态互连网络的寻径机制" class="headerlink" title="基于静态互连网络的寻径机制"></a>基于静态互连网络的寻径机制</h3><ul>
<li>确定性寻径：通信路径完全由源结点地址和目的地址来决定，寻径路径是预先唯一确定好了的，与网络状况无关</li>
<li>自适应寻径：通信的通路每一次都要根据资源或者网络的情况来选择【TCP&#x2F;IP网络】</li>
</ul>
<h3 id="二维网格网络的X-Y寻径"><a href="#二维网格网络的X-Y寻径" class="headerlink" title="二维网格网络的X-Y寻径"></a>二维网格网络的X-Y寻径</h3><p>先沿X维方向进行寻径，然后再沿Y维方向寻找路径</p>
<h3 id="超立方体E-cube寻径"><a href="#超立方体E-cube寻径" class="headerlink" title="超立方体E-cube寻径"></a>超立方体E-cube寻径</h3><h1 id="动态互连网络"><a href="#动态互连网络" class="headerlink" title="动态互连网络"></a>动态互连网络</h1><p>由交换开关构成、可按运行程序的要求动态地改变连接状态的网络。</p>
<h2 id="总线和交叉开关"><a href="#总线和交叉开关" class="headerlink" title="总线和交叉开关"></a>总线和交叉开关</h2><h3 id="总线网络"><a href="#总线网络" class="headerlink" title="总线网络"></a>总线网络</h3><p>由一组导线和插座构成，经常被用来实现计算机系统中处理机模块、存储模块和外围设备等之间的互连。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-I-O%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-I-O%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">计算机系统结构-I/O系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 12:49:40" itemprop="dateCreated datePublished" datetime="2020-04-15T12:49:40Z">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-17 12:14:12" itemprop="dateModified" datetime="2020-04-17T12:14:12Z">2020-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机系统结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="IO系统的基本概念"><a href="#IO系统的基本概念" class="headerlink" title="IO系统的基本概念"></a>IO系统的基本概念</h1><p>通常包含IO设备和IO设备与处理机的连接接口两个主要部分。</p>
<h1 id="系统评价"><a href="#系统评价" class="headerlink" title="系统评价"></a>系统评价</h1><p>参数指标：连接特性、IO系统的容量、响应时间和吞吐率</p>
<p>吞吐率反映单位时间内完成的I&#x2F;O数量，响应时间则反映了完成一次I&#x2F;O所花费的时间</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">计算机系统结构-存储系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 12:49:31" itemprop="dateCreated datePublished" datetime="2020-04-15T12:49:31Z">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-17 12:01:02" itemprop="dateModified" datetime="2020-04-17T12:01:02Z">2020-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机系统结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="存储系统性能量化分析"><a href="#存储系统性能量化分析" class="headerlink" title="存储系统性能量化分析"></a>存储系统性能量化分析</h1><p>存储器越靠近CPU，则CPU对它的访问频度越高，但是容量也越低，单位存储容量价格越高。</p>
<p>存储容量S：一般来说，整个存储系统的容量即是第二级存储器M<del>2</del> ，即S&#x3D;S<del>2</del></p>
<p>命中率H：CPU访问存储系统时，在M<del>1</del> 中找到所需信息的概率$H&#x3D;\frac{N_1}{N_1+N_2}$</p>
<p>平均访问时间T<del>A</del> ：</p>
<ul>
<li><p>当命中时，访问时间即是T<del>1</del> （命中时间）</p>
</li>
<li><p>当没命中时，$T_2+T_1+T_B&#x3D;T_1+T_M\T_m&#x3D;T_2+T_B\传递一个信息块所需的时间为T_B\不命中开销T_M:从向M_2发出访问请求到整个数据块调入M_1中所需的时间$</p>
</li>
</ul>
<h1 id="Cache基本知识"><a href="#Cache基本知识" class="headerlink" title="Cache基本知识"></a>Cache基本知识</h1><p>Cache-利用局部性原理，加快经常性事件原理，将程序和数据放到与CPU速度匹配的高速存储器中。</p>
<p>cache关注的四个问题：</p>
<ul>
<li><p>如何放</p>
<ul>
<li>全相联映象</li>
<li>直接映象</li>
<li>组相联映象</li>
</ul>
</li>
<li><p>如何找</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200416191002374.png" style="zoom:80%;" />
</li>
<li><p>如何写</p>
<ul>
<li>写穿：写cache的同时也在写内存</li>
<li>写回：只写cache，只有被替换时才写回内存</li>
</ul>
</li>
<li><p>如何换</p>
<ul>
<li>轮换法</li>
<li>LRU算法</li>
</ul>
</li>
</ul>
<p>具体见《组原原理》</p>
<h1 id="映象规则及其变换"><a href="#映象规则及其变换" class="headerlink" title="映象规则及其变换"></a>映象规则及其变换</h1><p>见《组成原理》</p>
<h1 id="降低cache不命中率"><a href="#降低cache不命中率" class="headerlink" title="降低cache不命中率"></a>降低cache不命中率</h1><h2 id="三种类型的不命中"><a href="#三种类型的不命中" class="headerlink" title="三种类型的不命中"></a>三种类型的不命中</h2><ul>
<li>强制性不命中：当第一次访问一个块时，该块不在cache中，需从下一级存储器中调入cache。（冷启动不命中，首次访问不命中。）</li>
<li>容量不命中：如果程序执行时所需的块不能全部调入cache中，则当某些块被替换后，若重新被访问，就会发生不命中。</li>
<li>冲突不命中：在组相联或者直接映象cache中，如果太多的块映象到同一组（块）中，则该组中某个块被别的块替换（即使别的组或块有空闲位置），然后又被重新访问的情况。（碰撞不命中，干扰不命中）</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>相联度越高，冲突不命中就越少；</li>
<li>强制性不命中和容量不命中不受相联度的影响</li>
<li>强制性不命中不受cache容量的影响，但是容量不命中却随着容量的增加而减少</li>
</ol>
<h2 id="减少三种不命中的方法"><a href="#减少三种不命中的方法" class="headerlink" title="减少三种不命中的方法"></a>减少三种不命中的方法</h2><ul>
<li>强制性不命中：增加块大小，预取</li>
<li>容量不命中：增加容量</li>
<li>冲突不命中：提高相关度</li>
</ul>
<p><strong>许多降低不命中率的方法会增加命中时间或不命中开销</strong></p>
<h3 id="增加cache块的大小"><a href="#增加cache块的大小" class="headerlink" title="增加cache块的大小"></a>增加cache块的大小</h3><p>对于给定的cache容量，当块大小增加时，不命中率开始是下降的，但是后来就上升了。</p>
<ul>
<li>一方面它减少了强制性不命中；</li>
<li>另一方面，由于增加块大小会减少Cache中块的数目，可能会增加冲突不命中</li>
</ul>
<p><strong>增加块的大小会增加不命中开销</strong></p>
<h3 id="增加cache的容量"><a href="#增加cache的容量" class="headerlink" title="增加cache的容量"></a>增加cache的容量</h3><p>缺点：</p>
<ul>
<li>增加成本</li>
<li>增加命中时间</li>
</ul>
<h3 id="提高相联度"><a href="#提高相联度" class="headerlink" title="提高相联度"></a>提高相联度</h3><p>采取相联度超过8的方案实际意义不大</p>
<p><strong>容量为N的直接映象cache的不命中率和容量为N&#x2F;2的两路组相联cache的不命率差不多相同</strong></p>
<p>提高相联度是以增加命中时间为代价的</p>
<h2 id="伪相联cache和列相联cache"><a href="#伪相联cache和列相联cache" class="headerlink" title="伪相联cache和列相联cache"></a>伪相联cache和列相联cache</h2><p>基本思想：在逻辑上把直接映象cache分为上下两个区。对于任何一次访问，伪相联cache先按直接映象cache的方式去处理：如果命中，则其访问过程和直接映象cache的情况一样；如果不命中，则再对另一区相应的位置去查找。如果找到了，则发生了伪命中，否则只好访问下一级存储器。</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200417152901445.png" style="zoom:50%;" />

<h2 id="硬件预取"><a href="#硬件预取" class="headerlink" title="硬件预取"></a>硬件预取</h2><ol>
<li>指令和数据都可以预取</li>
<li>预取内容即可放入cache中，也可放在外缓冲器中</li>
<li>指令预取通常由cache之外的硬件完成</li>
</ol>
<p>预取应利用存储器的空闲带宽，不能影响对正常不命中的处理，否则会降低性能。</p>
<h2 id="编译器控制的预取"><a href="#编译器控制的预取" class="headerlink" title="编译器控制的预取"></a>编译器控制的预取</h2><p>在编译的时候加入预取指令，在数据被用到之前发出预取请求。</p>
<ol>
<li>按照预取数据所放的位置，可把预取分为两种类型：<ul>
<li>寄存器预取：把数据放在寄存器中</li>
<li>cache预取：只将数据放在cache中</li>
</ul>
</li>
<li>按照预取的处理方式不同，分为：<ul>
<li>故障性预取：在预取时，如果出现虚地址故障或违反保护权限，就会发生异常</li>
<li>非故障性预取：不会发生异常，编译器会放弃预取，转为空操作</li>
</ul>
</li>
<li>在预取数据的同时，处理器应能继续执行</li>
<li>编译器控制预取的目的：使得执行指令和读取数据能重叠执行</li>
<li>每次预取需要花费一条指令的开销<ul>
<li>保证开销低于收益</li>
<li>编译器可以通过把重点放在那些可能会导致不命中的访问上，使得程序避免不必要的预取</li>
</ul>
</li>
</ol>
<h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><p>通过对软件进行优化来降低不命中率</p>
<ol>
<li>程序代码和数据重组<ul>
<li>重新组织程序而不影响程序的正确性<ul>
<li>把一个程序的过程重新排序，减少冲突不命中，降低指令不命中率</li>
<li>把基本块对齐，提高大cache块的效率</li>
</ul>
</li>
<li>假设编译器知道分支指令会成功转移：<ul>
<li>将转移目标处的基本块和紧跟着该分支指令后的基本块进行对调</li>
<li>把该分支指令转为操作语义相反的分支指令（？）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="牺牲cache"><a href="#牺牲cache" class="headerlink" title="牺牲cache"></a>牺牲cache</h2><p>在cache和它的下一级存储器之间设置一个全相联的小cache；用来存放被替换出去的块（牺牲者），以备重新使用</p>
<p>对于减小冲突不命中很有效，特别是对于小容量的直接映象数据cache，作用尤其明显。</p>
<h2 id="采取两级cache"><a href="#采取两级cache" class="headerlink" title="采取两级cache"></a>采取两级cache</h2><p>第一级cache小且快；第二级cache容量大。</p>
<p>全部不命中率和局部不命中率：$全局不命中率&#x3D;不命中率_{L1} X 不命中率_{L2}$</p>
<ul>
<li><p>评价第二级Cache需要使用全局不命中率；</p>
</li>
<li><p>第二级cache不会影响CPU的时钟频率；</p>
</li>
</ul>
<p>$平均访存时间&#x3D;命中时间L_1+不命中率L_1X()$</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ol>
<li>容量：第二级cache的容量一般比第一级cache的大很多</li>
<li>相联度：第二级cache可以采用较高的相联度或伪相联方法</li>
<li>块大小：第二级cache可以采用较大的块</li>
</ol>
<h2 id="让读不命中优先于写"><a href="#让读不命中优先于写" class="headerlink" title="让读不命中优先于写"></a>让读不命中优先于写</h2><ol>
<li>cache中的写缓冲器导致对存储器访问的复杂化：在读不命中时，所读单元的最新值可能还在写缓冲器中，还没有进入主存。</li>
<li>读不命中的处理：<ul>
<li>推迟对读不命中的处理，直到写缓冲器清空</li>
<li>检查写缓冲器的内容</li>
</ul>
</li>
<li>在写回法cache中，可采取写缓冲器</li>
</ol>
<h2 id="写缓冲合并"><a href="#写缓冲合并" class="headerlink" title="写缓冲合并"></a>写缓冲合并</h2><p>写直达cache：</p>
<p>依靠写缓冲来减少对下一级存储器写操作的时间。</p>
<p>如果写缓冲器为空，就把数据和相应地址写入该缓冲器【从CPU的角度来看，该写操作就算完成了】</p>
<p>如果写缓冲器中已经有了待写入数据，就要把这次写入地址与写缓冲器中已有的所有地址进行比较，看看是否有匹配的项。如果有地址匹配而对应的位置又空闲，就把这次要写入的数据与该项合并。【这就是写缓冲合并】</p>
<p>如果写缓冲器满并且没有能进行写合并的项，就等待。</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200417163741394.png" style="zoom:67%;" />

<h2 id="请求字处理技术"><a href="#请求字处理技术" class="headerlink" title="请求字处理技术"></a>请求字处理技术</h2><p>请求字：从下一级存储器调入cache块中，只有一个字是立即需要的，该字就是请求字。</p>
<p>应尽早把请求字发送给CPU</p>
<ul>
<li>尽早重启动：调块时，从块的起始位置开始读起。一旦请求字到达了，就立即发送给CPU，让CPU继续执行。【请求字优先】</li>
</ul>
<h2 id="非阻塞cache技术"><a href="#非阻塞cache技术" class="headerlink" title="非阻塞cache技术"></a>非阻塞cache技术</h2><p>cache不命中时依旧允许CPU进行其他的命中访问。</p>
<h1 id="减少命中时间"><a href="#减少命中时间" class="headerlink" title="减少命中时间"></a>减少命中时间</h1><p>命中时间直接影响处理器的时钟频率。</p>
<p>Cache的访问时间限制了处理器的时钟频率。</p>
<h2 id="容量小、结构简单的Cache"><a href="#容量小、结构简单的Cache" class="headerlink" title="容量小、结构简单的Cache"></a>容量小、结构简单的Cache</h2><p>硬件越简单，速度就越快。</p>
<h2 id="虚拟cache"><a href="#虚拟cache" class="headerlink" title="虚拟cache"></a>虚拟cache</h2><h3 id="物理cache"><a href="#物理cache" class="headerlink" title="物理cache"></a>物理cache</h3><p>使用物理地址进行访问的传统cache。</p>
<p>标识存储器中存放的是物理地址，进行地址检测越是用物理地址。</p>
<p>缺点就是：地址转换和访问cache串行进行，访问速度慢。</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200417185513804.png" style="zoom:67%;" />

<h3 id="虚拟cache-1"><a href="#虚拟cache-1" class="headerlink" title="虚拟cache"></a>虚拟cache</h3><p>直接使用虚拟地址进行访问的cache。标识存储器存放的是虚拟地址，进行地址检测用的也是虚拟地址</p>
<p>优点：在命中时不需要进行地址转换，省去了地址转换的时间。就算是不命中，地址转换和访问cache也是并行进行的，速度比物理cache快。</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200417185536512.png" style="zoom:50%;" />

<p>虚拟地址和进程相关。</p>
<p>虚拟地址&#x3D;虚拟索引+物理标识<br>用虚地址中页内位移作为cache的索引，标识用物理地址；</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200417190140461.png" style="zoom:67%;" />

<h2 id="Cache访问流水化"><a href="#Cache访问流水化" class="headerlink" title="Cache访问流水化"></a>Cache访问流水化</h2><p>对第一级cache访问按流水线方式组织</p>
<p>访问cache需要多个时钟周期才能完成</p>
<p>不能够真正减少cache命中时间，但是可以提高时钟频率，提高cache的带宽。</p>
<h2 id="踪迹Cache"><a href="#踪迹Cache" class="headerlink" title="踪迹Cache"></a>踪迹Cache</h2><p>存放CPU所执行的动态指令序列：包含了由分支预测展开的指令，该分支预测是否需要在取到该指令时进行确认。</p>
<ul>
<li>地址映象机制复杂</li>
<li>相同的指令序列有可能被当作条件分支的不同选择而重复存放</li>
<li>能够提高指令cache的空间利用率</li>
</ul>
<h1 id="并行主存系统"><a href="#并行主存系统" class="headerlink" title="并行主存系统"></a>并行主存系统</h1><p>主存的主要性能指标：<strong>延迟</strong>和<strong>带宽</strong></p>
<p>定义：是在一个访存周期内能并行访问多个存储字的存储器</p>
<p>在单体单字宽的存储器中：存储器的访问周期为T<del>M</del> ,字长为W位，则<br>带宽为$B_M&#x3D;\frac{W}{T_M}$</p>
<h2 id="单体多字存储器"><a href="#单体多字存储器" class="headerlink" title="单体多字存储器"></a>单体多字存储器</h2><p>存储器能够每个存储周期读出m个CPU字</p>
<p>$B_M&#x3D;\frac{mW}{T_M}$</p>
<p>单体多字存储器的实际带宽比最大带宽小</p>
<p>缺点：访存效率不高</p>
<ul>
<li>如果一次去读的m个指令字中有分支指令，而且分支成功，则该分支指令之后的指令是无用的。</li>
<li>一次取出的m个数据不一定都是有用的。此外，当前执行指令所需要的多个操作数也不一定正好都存放在同一个长存储字中</li>
<li>写入可能变得复杂</li>
<li>当要读出的数据字和要写入的数据字处于同一个长存储字内时，读和写的操作就无法在同一个存储周期内完成</li>
</ul>
<h2 id="多体交叉存储器"><a href="#多体交叉存储器" class="headerlink" title="多体交叉存储器"></a>多体交叉存储器</h2><p>由多个单字存储体构成，每个体都有自己的地址寄存器以及地址译码和读&#x2F;写驱动等电路。</p>
<p>编址方式：</p>
<ul>
<li>高位交叉编址</li>
<li>低位交叉编址</li>
</ul>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200417195600835.png" style="zoom:67%;" />

<h3 id="高位交叉编址"><a href="#高位交叉编址" class="headerlink" title="高位交叉编址"></a>高位交叉编址</h3><p>对存储单元矩阵按列优先的方式进行编址</p>
<h3 id="低位交叉编址"><a href="#低位交叉编址" class="headerlink" title="低位交叉编址"></a>低位交叉编址</h3><p>对存储单元矩阵按行优先进行编址</p>
<h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><blockquote>
<p>进程保护：</p>
<ol>
<li>界地址寄存器：基地址、上界地址；检测条件：（基地址+地址）&lt;&#x3D;上界地址</li>
<li>虚拟存储器：给每个页面增加访问权限标识</li>
<li>环形保护</li>
<li>加锁和解锁</li>
</ol>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C/" class="post-title-link" itemprop="url">计算机系统结构-指令级并行</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 12:49:03" itemprop="dateCreated datePublished" datetime="2020-04-15T12:49:03Z">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-16 09:47:08" itemprop="dateModified" datetime="2020-04-16T09:47:08Z">2020-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机系统结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="指令级并行的概念"><a href="#指令级并行的概念" class="headerlink" title="指令级并行的概念"></a>指令级并行的概念</h1><p>提高处理速度：</p>
<ul>
<li>提高主频【高到一定程序，发热能耗都会升高】</li>
<li>并行工作：多个部件同时工作</li>
</ul>
<p>理想流水线的CPI加上各类停顿的时钟周期数：<br>$$<br>CPI_{流水线}&#x3D;CPI_{理想}+停顿_{结构冲突}+停顿_{数据冲突}+停顿_{控制冲突}<br>$$</p>
<h2 id="需要解决的具体问题"><a href="#需要解决的具体问题" class="headerlink" title="需要解决的具体问题"></a>需要解决的具体问题</h2><p><strong>相关和流水线冲突</strong>：</p>
<p>相关是程序固有的一种属性，它反映了程序中指令之间的相互依赖关系。相关是引起冲突的主要原因（并非唯一？结构冲突无对应相关）。因此消除相关是减少冲突停顿的一种有效方法。</p>
<p><strong>相关是引发冲突的主要原因，其中数据相关与名相关可能导致数据冲突，而控制相关可能导致控制冲突。</strong></p>
<h3 id="相关的两类解决方案"><a href="#相关的两类解决方案" class="headerlink" title="相关的两类解决方案"></a>相关的两类解决方案</h3><ul>
<li><p>保持相关，但避免发生冲突</p>
<ul>
<li>指令调度</li>
</ul>
</li>
<li><p>通过代码变换，消除相关</p>
<ul>
<li>寄存器重命名</li>
</ul>
</li>
</ul>
<h1 id="指令调度分类"><a href="#指令调度分类" class="headerlink" title="指令调度分类"></a>指令调度分类</h1><ul>
<li><p>静态调度</p>
<ul>
<li>依靠编译器对代码进行静态调度，以减少相关和冲突。</li>
<li>它不是在程序执行的过程中、而是在编译期间进行代码调度和优化。</li>
<li>通过把相关的指令拉开距离来减少可能产生的停顿。</li>
</ul>
</li>
<li><p>动态调度</p>
<ul>
<li>在程序的执行过程中，依靠专门硬件对代码进行调度，减少数据相关导致的停顿。</li>
<li>优点：<ul>
<li>能够处理一些在编译时情况不明的相关（比如涉及到存储器访问的相关），并简化了编译器；</li>
<li>能够使本来是面向某一流水线优化编译的代码在其它的流水线（动态调度）上也能高效地执行。</li>
<li>以硬件复杂性的显著增加为代价</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="经典（顺序）流水线的局限性"><a href="#经典（顺序）流水线的局限性" class="headerlink" title="经典（顺序）流水线的局限性"></a>经典（顺序）流水线的局限性</h2><p>由于指令是按序流出和按序执行的。</p>
<p>例如：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">DIV.D</span>	<span class="built_in">F4</span>，<span class="built_in">F0</span>，<span class="built_in">F2</span></span><br><span class="line"><span class="symbol">ADD.D</span>	F10，<span class="built_in">F4</span>，<span class="built_in">F6</span> </span><br><span class="line"><span class="symbol">SUB.D</span>	F12，<span class="built_in">F6</span>，F14</span><br></pre></td></tr></table></figure>

<p>假设DIV（除法）指令执行时间（EX）是10个时钟周期，ADD（加法）与SUB（减法）分别为1个，（由于除法与加法之间的数据相关）那么ADD必须等待9个时钟周期才能进入EX阶段。在我们学过的顺序流水线中，由于ID部件被ADD指令占据，SUB指令只有在ADD指令流入EX（执行）阶段后才能进入ID阶段，即其也需要等待9个时钟周期。然而，如果这些指令不用按顺序执行，则SUB（减法）无需等待。</p>
<p>SUB指令需要等待的原因：在ID阶段会检测结构冲突与数据冲突，当发现冲突后，导致冲突的指令中较晚进入流水线的那条（ADD指令），将冻结在流水寄存器中，不在向前流动。由于流水寄存器只能存放一条指令，一旦这条指令受阻，其后的指令（SUB指令）都将停顿。</p>
<p>解决方法：<strong>允许指令乱序执行</strong></p>
<h3 id="指令乱序执行"><a href="#指令乱序执行" class="headerlink" title="指令乱序执行"></a>指令乱序执行</h3><p>将ID段分为两个阶段：流出（IS）和读操作数(RO)。IS阶段执行指令译码，检查是否存在结构冲突；RO阶段等待数据冲突消失，再进行读操作数的操作。</p>
<p>两个方法：</p>
<ul>
<li>引入指令缓冲区：不能流出的指令就在缓冲区里排队等待，直到冲突消除</li>
<li>部署更多的执行部件（这里的执行部件是广义的执行，包括：运算器、访存设备等），使得多条指令能都同时执行或访存</li>
</ul>
<h3 id="乱序执行的问题"><a href="#乱序执行的问题" class="headerlink" title="乱序执行的问题"></a>乱序执行的问题</h3><h4 id="WAR冲突和WAW冲突"><a href="#WAR冲突和WAW冲突" class="headerlink" title="WAR冲突和WAW冲突"></a>WAR冲突和WAW冲突</h4><p>乱序执行可能会导致WAR冲突和WAW冲突。</p>
<p>可以使用寄存器重命名来消除冲突。值得注意的是，寄存器的数量是有限的，更多的寄存器会导致编译器变慢。</p>
<h4 id="多条指令同时处于执行或访存中"><a href="#多条指令同时处于执行或访存中" class="headerlink" title="多条指令同时处于执行或访存中"></a>多条指令同时处于执行或访存中</h4><p>乱序执行将使得多条指令处于执行当中，因此要求，具有<strong>多个功能部件</strong>、或者功能部件流水化、或者兼而有之。</p>
<h4 id="复杂的异常处理"><a href="#复杂的异常处理" class="headerlink" title="复杂的异常处理"></a>复杂的异常处理</h4><p>乱序指令引入的最大问题在于，异常处理比较复杂。异常可以分为精确异常与不精确异常。</p>
<ul>
<li><p>精确异常：如果发生异常时，处理机的现场跟严格按程序顺序执行时指令i的现场相同。</p>
</li>
<li><p>不精确异常：当执行指令i导致发生异常时，处理机的现场（状态）与严格按程序顺序执行时指令i的现场不同。</p>
<ul>
<li><p>发生不精确异常的原因：因为当发生异常（设为指令i）时</p>
<ul>
<li>流水线可能已经执行完按程序顺序是位于指令i之后的指令；</li>
<li>流水线可能还没完成按程序顺序是指令i之前的指令。</li>
</ul>
</li>
<li><p>不精确异常使得在异常处理后难以接着继续执行程序。</p>
</li>
</ul>
</li>
</ul>
<p>显然，动态调度的处理机要保持正确的异常行为。具体而言，对于一条会产生异常的指令来说，只有当处理机确切地知道该指令将被执行时，才允许它产生异常。举个例子，指令i，j顺序流入流水线。j位于条件语句中（选择执行），会引起异常但不会被执行。j被调度到i之前执行，执行过程中发生了异常（实际不会被执行，所以也不会引起异常）。这样是不允许的。</p>
<p>然而，即使保持了正确的异常行为，动态调度处理机仍可能发生不精确异常。 举个例子：指令i，j顺序流入流水线，指令i会导致异常，但其被调度到j之后执行，假设j执行完后直接改变了上下文，那么i产生异常时，上下文与顺序执行的上下文已经不同了。</p>
<h1 id="动态分支预测"><a href="#动态分支预测" class="headerlink" title="动态分支预测"></a>动态分支预测</h1><p>ILP（指令级并行）越多，控制相关的制约就越大，分支预测就要有更高的准确度。解决方法就是：动态分支预测。</p>
<h2 id="动态分支预测-1"><a href="#动态分支预测-1" class="headerlink" title="动态分支预测"></a>动态分支预测</h2><ul>
<li>在程序运行时，根据分支指令过去的表现来预测其将来的行为。</li>
<li>如果分支行为发生了变化，预测结果也跟着改变。</li>
<li>有更好的预测准确度和适应性。</li>
</ul>
<p>分支预测的有效性取决于</p>
<ul>
<li>预测的准确性</li>
<li>预测正确和不正确两种情况下的分支开销</li>
<li>决定分支开销的因素：<ul>
<li>流水线的结构</li>
<li>预测的方法</li>
<li>预测错误时的恢复策略等</li>
</ul>
</li>
</ul>
<h2 id="目标与关键问题"><a href="#目标与关键问题" class="headerlink" title="目标与关键问题"></a>目标与关键问题</h2><ul>
<li><p>采用动态分支预测技术的目标【只有尽快做到下面两点，才能避免控制相关造成流水线停顿】</p>
<ul>
<li>预测分支是否成功</li>
<li>尽快找到分支目标地址（或指令）（避免控制相关造成流水线停顿）</li>
</ul>
</li>
<li><p>需要解决的关键问题</p>
<ul>
<li>如何记录分支的历史信息，要记录哪些信息？ </li>
<li>如何根据这些信息来预测分支的去向，甚至提前取出分支目标处的指令</li>
</ul>
</li>
</ul>
<h2 id="预测错误时的处理方法"><a href="#预测错误时的处理方法" class="headerlink" title="预测错误时的处理方法"></a>预测错误时的处理方法</h2><p>在预测错误时，要作废已经预取和分析的指令，恢复现场，并从另一条分支路径重新取指令。</p>
<h2 id="分支历史表BHT"><a href="#分支历史表BHT" class="headerlink" title="分支历史表BHT"></a>分支历史表BHT</h2><p>基本思想是使用一张表（BHT）来记录分支指令最近一次或几次的执行情况（成功还是失败），并据此进行预测。</p>
<h3 id="最简单的分支历史表"><a href="#最简单的分支历史表" class="headerlink" title="最简单的分支历史表"></a>最简单的分支历史表</h3><p>只有1个预测位的分支预测表</p>
<p>仅记录分支指令最近一次的历史，只需要1位二进制位。其规则也很简单，一句话，上次是分支成功就认为下次分支成功，上次失败就认为下次失败。</p>
<h3 id="两位预测位的分支历史表"><a href="#两位预测位的分支历史表" class="headerlink" title="两位预测位的分支历史表"></a>两位预测位的分支历史表</h3><p>两个位记录分支最近两次的执行情况（成功1或失败0）</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C/image-20200416150630044.png"></p>
<p>研究结果表明：两位分支预测的性能与n位（n&gt;2）分支预测的性能差不多。</p>
<h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul>
<li><p>分支预测</p>
<ul>
<li>当分支指令到达译码段（ID）时，根据从BHT读出的信息进行分支预测 。</li>
<li>若预测正确，就继续处理后续的指令，流水线没有断流。否则，就要作废已经预取和分析的指令，恢复现场，并从另一条分支路径重新取指令。</li>
</ul>
</li>
<li><p>状态修改。【根据状态变迁图修改状态】</p>
</li>
</ul>
<h3 id="BHT的作用范围"><a href="#BHT的作用范围" class="headerlink" title="BHT的作用范围"></a>BHT的作用范围</h3><p>关键在于比较判定分支是否成功所需的时间和确定分支目标地址所需的时间哪个更大。</p>
<p>【在5段经典流水线中，判断分支是否成功和计算分支目标地址都是在ID段完成的，故BHT方法不会给该流水线带去什么好处。】</p>
<p>BHT技术只管了预测部份，没管预测后的处理部分。</p>
<h3 id="BHT的实现"><a href="#BHT的实现" class="headerlink" title="BHT的实现"></a>BHT的实现</h3><p>BHT可以跟分支指令一起存放在指令Cache中，也可以用一块专门的硬件来实现。 </p>
<h2 id="分支目标缓冲器BTB"><a href="#分支目标缓冲器BTB" class="headerlink" title="分支目标缓冲器BTB"></a>分支目标缓冲器BTB</h2><p>BTB的目标是将分支的开销降为 0。具体方法是分支目标缓冲，即，将分支成功的分支指令的地址和它的分支目标地址都放到一个缓冲区中保存起来，缓冲区以分支指令的地址作为标识。</p>
<p>BTB可以看成是用专门的硬件实现的一张表格。表格中的<strong>每一项至少有两个字段。一是，执行过的成功分支指令的地址，用作该表的匹配标识。二是预测的分支目标地址。</strong>只有这两项的就是最简单的BTB。</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C/image-20200416160452576.png"></p>
<p>注：在预测失败的情况下，会承受2个周期的延迟。</p>
<p>与BHT相比，BTB的优点在于IF周期就能找到分支地址，能够将分支成功且预测准确时的分支开销降到0。</p>
<h3 id="改进BTB"><a href="#改进BTB" class="headerlink" title="改进BTB"></a>改进BTB</h3><p>1、在分支目标缓冲器中增设一个至少是两位的“分支历史表”字段 </p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C/image-20200416160749450.png" style="zoom:67%;" />

<p>2、在表中对于每条分支指令都存放若干条分支目标处的指令，就形成了分支目标指令缓冲器。</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C/image-20200416160711828.png" style="zoom:67%;" />

<p>这里，BTB中不在保存分支目标地址，而是保存分支目标指令。</p>
<p>为什么存指令，而非指令地址呢？因为IF是通过指令地址取指令，分支成功，程序的空间局部性spatial locality被破坏，取指令的时延很可能会增加</p>
<h1 id="多指令流出技术"><a href="#多指令流出技术" class="headerlink" title="多指令流出技术"></a>多指令流出技术</h1><p>多指令流出技术通过降低理想CPI，以改善实际CPI。</p>
<h2 id="多流出处理机的两种基本风格"><a href="#多流出处理机的两种基本风格" class="headerlink" title="多流出处理机的两种基本风格"></a>多流出处理机的两种基本风格</h2><h3 id="超标量"><a href="#超标量" class="headerlink" title="超标量"></a>超标量</h3><ul>
<li>在每个时钟周期流出的指令条数不固定，依代码的具体情况而定。（有个上限）</li>
<li>设这个上限为n，就称该处理机为n-流出。</li>
<li>可以通过编译器进行静态调度，也可以基于Tomasulo算法进行动态调度。</li>
</ul>
<p>超标量结构对程序员是透明的，处理机能自己检测下一条指令能否流出，不需要由编译器或专门的变换程序对程序中的指令进行重新排列</p>
<p>即使是没有经过编译器针对超标量结构进行调度优化的代码或是旧的编译器生成的代码也可以运行，当然运行的效果不会很好【若要想达到很好的效果，方法之一是：使用动态超标量调度技术。】</p>
<h3 id="超长指令字VLIW"><a href="#超长指令字VLIW" class="headerlink" title="超长指令字VLIW"></a>超长指令字VLIW</h3><ul>
<li>在每个时钟周期流出的指令条数是固定的，这些指令构成一条长指令或者一个指令包。</li>
<li>指令包中，指令之间的并行性是通过指令显式地表示出来的。</li>
<li>指令调度是由编译器静态完成的。</li>
</ul>
<h2 id="基于静态调度的超标量流水线技术"><a href="#基于静态调度的超标量流水线技术" class="headerlink" title="基于静态调度的超标量流水线技术"></a>基于静态调度的超标量流水线技术</h2><p>指令按序流出，在流出时进行冲突检测。由硬件检测当前流出的指令之间是否存在冲突以及当前流出的指令与正在执行的指令是否有冲突。</p>
<h2 id="超长指令字技术"><a href="#超长指令字技术" class="headerlink" title="超长指令字技术"></a>超长指令字技术</h2><p>超长指令字技术把能并行执行的多条指令组装成一条很长的指令，成为一个指令字。这条指令通常为100多位到几百位。为了支持多条指令的同时执行，需要设置多个功能部件。指令字被分割成一些字段，每个字段称为一个操作槽，直接独立地控制一个功能部件。在超长指令字处理机中，<strong>在指令流出时不需要进行复杂的冲突检测，而是依靠编译器全部安排好了。</strong></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p>程序代码长度增加了。原因在于，为提高并行性而进行的大量的循环展开；此外，指令字中的操作槽也并非总能填满。 对于这个问题，可以通过采用指令共享立即数字段的方法，或者采用指令压缩存储、调入Cache或译码时展开的方法予以解决。</p>
</li>
<li><p>采用了锁步机制。任何一个操作部件出现停顿时，整个处理机都要停顿。</p>
</li>
<li><p>机器代码的不兼容性，一旦体系结构发生了变化，代码就必须重新编译。</p>
</li>
</ul>
<h2 id="超流水线处理机"><a href="#超流水线处理机" class="headerlink" title="超流水线处理机"></a>超流水线处理机</h2><p>超流水线处理机的基本概念：将每个流水段进一步细分，这样在一个时钟周期内能够分时流出多条指令。这种处理机称为超流水线处理机。</p>
<p>对于一台每个时钟周期能流出n条指令的超流水线计算机来说，这n条指令不是同时流出的，而是每隔1&#x2F;n个时钟周期流出一条指令。实际上该超流水线计算机的流水线周期为1&#x2F;n个时钟周期。</p>
<h1 id="指令调度和循环展开"><a href="#指令调度和循环展开" class="headerlink" title="指令调度和循环展开"></a>指令调度和循环展开</h1><h2 id="指令调度的基本方法"><a href="#指令调度的基本方法" class="headerlink" title="指令调度的基本方法"></a>指令调度的基本方法</h2><p>指令调度一般由编译器完成。通过找出不相关的指令序列，让它们在流水线上重叠并行执行。</p>
<p>编译器做指令调度时，通常会收两个方面的制约。一是程序固有的指令级并行，二是流水线功能部件的延迟。</p>
<h2 id="循环展开的基本概念和方法"><a href="#循环展开的基本概念和方法" class="headerlink" title="循环展开的基本概念和方法"></a>循环展开的基本概念和方法</h2><p>循环展开是把循环体的代码复制多次并按顺序排放， 然后相应调整循环的结束条件。它是开发循环级并行的有效方法。</p>
<h2 id="循环展开和指令调度的注意事项"><a href="#循环展开和指令调度的注意事项" class="headerlink" title="循环展开和指令调度的注意事项"></a>循环展开和指令调度的注意事项</h2><p>（1）保证正确性</p>
<p>（2）注意有效性</p>
<p>（3）使用不同的寄存器</p>
<p>（4）删除多余的测试指令和分支指令，并对循环结束代码和新的循环体代码进行相应的修正。</p>
<p>（5）注意对存储器数据的相关性分析</p>
<p>（6）注意新的相关性</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">计算机系统结构-流水线技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 12:48:37" itemprop="dateCreated datePublished" datetime="2020-04-15T12:48:37Z">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 14:55:26" itemprop="dateModified" datetime="2020-07-18T14:55:26Z">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机系统结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="流水线的基本概念"><a href="#流水线的基本概念" class="headerlink" title="流水线的基本概念"></a>流水线的基本概念</h1><ul>
<li>流水线的段（级）：流水线中的<strong>每个子过程及其功能部件</strong>称为流水线的级或段，段与段相互连接形成流水线</li>
<li>流水线的瓶颈：执行时间最长的段</li>
<li>流水线的深度：流水线的段数称为流水线的深度</li>
<li>流水线的通过时间：第一个任务从进入流水线到流出结果所需的时间。</li>
<li>排空时间：最后一个任务从进入流水线到流出结果所需的时间。</li>
</ul>
<p><strong>流水线不适用的场景：</strong></p>
<ul>
<li><p>只有一个任务需要执行。【任务并没有在更短的时间内完成，反而有可能会使得单个任务的执行时间变长】</p>
</li>
<li><p>多个稀疏任务（来的不够密集）。【使用流水线并不能提升工作效率（执行这些任务的有效时间并没有缩短）】</p>
</li>
<li><p>多个不同任务。【多个密集任务，但各任务的子过程完全无重合（不能使用同一部件处理）】</p>
<blockquote>
<p>但是可以通过其它并行技术加速（增加更多的不同部件，使得不同任务的不同子过程能并行执行）</p>
</blockquote>
</li>
</ul>
<p><strong>流水线适用的场景：</strong></p>
<ul>
<li>多个密集且相同或类似的任务。【流水技术适合于大量重复的时序过程，只有在输入端不断地提供任务，才能充分发挥流水线的效率。】</li>
</ul>
<h2 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h2><p>按用于计算机系统的等级划分，流水线可分为：部件级、处理机级及处理机间流水线</p>
<ul>
<li><p>部件级流水线（运算操作流水线）</p>
<blockquote>
<p>把处理机中的<strong>部件分段</strong>，再把这些分段相互连接起来，使得各种类型的运算操作能够按流水方式进行。</p>
<p>eg：浮点加法流水线，包含4个段：求阶差，对阶，尾数相加，规格化</p>
</blockquote>
</li>
<li><p>处理机流水线（指令流水线）</p>
<blockquote>
<p>把指令的执行过程按照流水方式处理。把一条指令的执行过程分解为若干个子过程，每个子过程在独立的功能部件中执行。</p>
<p> eg：经典5段MIPS指令流水线，包含5个段：取址，译码，执行，访存，写回。</p>
</blockquote>
</li>
<li><p>处理机间流水线（宏流水线）</p>
<blockquote>
<p>把多台处理机串行连接起来，对同一数据流进行处理，每个处理机完成整个任务中的一部分。</p>
<p>eg：map reduce</p>
</blockquote>
</li>
</ul>
<p>按流水线所完成的功能可划分为：单功能流水线与多功能流水线</p>
<ul>
<li>单功能流水线：只能完成一种固定功能的流水线</li>
<li>多功能流水线：流水线的各段可以进行不同的连接，以实现不同的功能【某些段可以不执行，直接跳过】。<ul>
<li>静态流水线：在同一时间内，多功能流水线中的各段只能按同一种功能的连接方式工作。</li>
<li>动态流水线：在同一时间内，多功能流水线中的各段可以按照不同的方式连接，同时执行多种功能</li>
</ul>
</li>
</ul>
<p>按流水线中是否有反馈回路，流水线技术可分为线性流水线与非线性流水线</p>
<ul>
<li>线性流水线：若流水线的各段串行连接，没有反馈回路，则其为线性流水线。再线性流水线中，数据通过流水线中的各段时，每一个段最多只流过一次。</li>
<li>非线性流水线：若流水线中除了有串行的连接外，还有反馈回路，则其为非线性流水线。</li>
</ul>
<p>按任务流入和流出的顺序是否相同划分：顺序流水线与乱序流水线</p>
<ul>
<li><p>顺序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序完全相同。每一个任务在流水线的各段中是一个跟着一个顺序流动的。</p>
</li>
<li><p>乱序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序可以不同，允许后进入流水线的任务先完成（从输出端流出）。</p>
</li>
</ul>
<h1 id="流水线的性能指标"><a href="#流水线的性能指标" class="headerlink" title="流水线的性能指标"></a>流水线的性能指标</h1><h2 id="吞吐率TP"><a href="#吞吐率TP" class="headerlink" title="吞吐率TP"></a>吞吐率TP</h2><p>吞吐率通常使用缩写TP表示，是指在单位时间内流水线所完成的任务数量或输出结果的数量。<br>$$<br>TP&#x3D;\frac{n}{T_k}\<br>n:任务数\<br>T_k:处理完成n个任务所用的时间<br>$$</p>
<blockquote>
<p>CPU的吞吐率是指CPU每秒执行的指令数。</p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>假设各段时间均等：</p>
<p>（k段线性）流水线完成n个连续任务所需要的总时间<br>$$<br>T_k&#x3D;(k+n-1)\Delta t\<br>k\Delta t:流水线通过时间\<br>(n-1)\Delta t:流水线排出时间\<br>实际吞吐率：TP&#x3D;\frac{n}{(k+n-1)\Delta t}\<br>最大吞吐率：TP_{max}&#x3D;\lim_{n\to\infty}{\frac{n}{(k+n-1)\Delta t}}&#x3D;\frac{1}{\Delta t}\<br>当n趋近于无穷大时，流水线吞吐率趋近于最大值（又称流水线的最大吞吐率）\<br>TP&#x3D;\frac{n}{(k+n-1)}TP_{max}<br>$$<br>假设各段时间不全相等：</p>
<p>（k段线性）流水线完成n个连续任务所需要的总时间<br>$$<br>T_k&#x3D;\sum\Delta t_i+(n-1)max(\Delta t_i)\quad (i&#x3D;1,2,3···k)\<br>\sum\Delta t_i:单个任务的执行时间(通过时间)\<br>(n-1)max(\Delta t_i):n-1个瓶颈段的执行时间\<br>实际吞吐率：TP&#x3D;\frac{n}{\sum\Delta t_i+(n-1)max(\Delta t_1,\Delta t_2,···\Delta t_k)}\<br>最大吞吐率：TP_{max}&#x3D;\frac{1}{(n-1)max(\Delta t_1,\Delta t_2,···\Delta t_k)}\<br>$$</p>
<h2 id="流水线瓶颈问题"><a href="#流水线瓶颈问题" class="headerlink" title="流水线瓶颈问题"></a>流水线瓶颈问题</h2><blockquote>
<p>流水线中执行时间最长的段称为流水线的瓶颈段</p>
</blockquote>
<p>瓶颈段使得流水线性能下降</p>
<p>解决流水线瓶颈的方法</p>
<ul>
<li>细分瓶颈段（细分流水线）</li>
<li>重复设置瓶颈段</li>
</ul>
<h3 id="细分瓶颈段"><a href="#细分瓶颈段" class="headerlink" title="细分瓶颈段"></a>细分瓶颈段</h3><p>就是降低：$(n-1)max(\Delta t_i)$的值。将数值大的$\Delta t_i$值进行细分，差分成数值更小的$\Delta t_i$</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20200415174416181.png"></p>
<h3 id="重复设置瓶颈段"><a href="#重复设置瓶颈段" class="headerlink" title="重复设置瓶颈段"></a>重复设置瓶颈段</h3><p>就是在采取同时多次进行瓶颈段的操作来降低$\Delta t_i$</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20200415174622869.png"></p>
<h2 id="加速比S"><a href="#加速比S" class="headerlink" title="加速比S"></a>加速比S</h2><p>完成<strong>同样一批任务</strong>，不使用流水线所用的时间与使用流水线所用的时间之比。<br>$$<br>S&#x3D;\frac{T_s}{T_k}\<br>T_s：不使用流水线（即顺序执行）所用的时间\<br>T_k：使用流水线后所用的时间<br>$$</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>假设各段时间均等</p>
<p>$$<br>一条k段流水线完成n个连续任务所需要的时间:T_k&#x3D;(k+n-1)\Delta t\<br>顺序执行n个任务所需要的时间：T_s&#x3D;nk\Delta t\<br>实际加速比：S&#x3D;\frac{nk}{n+k-1}\<br>最大加速比：S_{max}&#x3D;\lim_{n\to\infty}\frac{nk}{k+n-1}&#x3D;k<br>$$<br>假设各段时间不全相等<br>$$<br>实际加速比：S&#x3D;\frac{n\sum_{i&#x3D;1}^{k}\Delta t_i}{\sum_{i&#x3D;1}^{k}\Delta t_i+(n-1)max(\Delta t_1,\Delta t_2,···\Delta t_k)}\<br>$$<br>每段执行时间并不完全相等，那么流水线完成n个连续任务所需要的总时间T<del>k</del>等于单个任务的执行时间（通过时间），加上n-1个瓶颈段的执行时间。而顺序执行这n个任务，所需要的时间为n倍的单个任务的执行时间。</p>
<h2 id="效率E"><a href="#效率E" class="headerlink" title="效率E"></a>效率E</h2><p>流水线中的设备实际使用时间与整个运行时间的比值。</p>
<p>【由于流水线有通过时间和排空时间，所以在连续完成n个任务的时间内，各段并不是满负荷地工作】</p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>各段时间均等：</p>
<p>假设各段的效率e<del>i</del> 相等<br>$$<br>e_1&#x3D;e_2&#x3D;e_3&#x3D;···&#x3D;e_k&#x3D;\frac{n\Delta t}{T_k}&#x3D;\frac{n}{k+n-1}\<br>整条流水线的效率：E&#x3D;\frac{e_1+e_2+e_3+···+e_k}{k}&#x3D;\frac{ke_1}{k}&#x3D;\frac{n}{k+n-1}\<br>$$</p>
<blockquote>
<p>效率和其他指标的关系</p>
<p>当流水线各段时间相等时，流水线的效率与吞吐率成正比$E&#x3D;TP·\Delta t$</p>
<p>流水线的效率是流水线的实际加速比S与它的最大加速比k的比值$E&#x3D;\frac{S}{K}$</p>
</blockquote>
<p>直观的描述：<br>$$<br>E&#x3D;\frac{n个任务实际占用的时空区}{k个段总的时空区}<br>$$<br>各段时间不全相等：<br>$$<br>E&#x3D;\frac{n\sum_{i&#x3D;1}^{k}\Delta t_i}{K[\sum_{i&#x3D;1}^{k}\Delta t_i+(n-1)max(\Delta t_1,\Delta t_2,···\Delta t_k)]}\<br>$$</p>
<h2 id="多功能流水线性能指标"><a href="#多功能流水线性能指标" class="headerlink" title="多功能流水线性能指标"></a>多功能流水线性能指标</h2><p>影响（多功能）流水线性能的原因</p>
<p>–多功能流水线在做某一种运算时，总有一些段是空闲的；</p>
<p>–静态流水线在进行功能切换时，要等前一种运算全部流出流水线后才能进行后面的运算；</p>
<p>–运算之间存在关联，后面有些运算要用到前面运算的结果；</p>
<p>流水线的工作过程有建立与排空部分。</p>
<p>eg：设在下图所示的静态流水线上计算<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20200415193432445.png">的吞吐率、效率和加速比</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20200415193419542.png"></p>
<p><strong>选择适合于流水线工作的算法</strong></p>
<p>先计算A<del>1</del>+B<del>1</del>、A<del>2</del>+B<del>2</del>、A<del>3</del>+B<del>3</del>和A<del>4</del>+B<del>4</del>；再计算(A<del>1</del>+B<del>1</del>)×(A<del>2</del>+B<del>2</del>)和(A<del>3</del>+B<del>3</del>)×(A<del>4</del>+B<del>4</del>)；然后求总的乘积结果。</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20200415193617077.png"></p>
<h1 id="流水线设计中的重要问题"><a href="#流水线设计中的重要问题" class="headerlink" title="流水线设计中的重要问题"></a>流水线设计中的重要问题</h1><h2 id="瓶颈问题"><a href="#瓶颈问题" class="headerlink" title="瓶颈问题"></a>瓶颈问题</h2><ul>
<li>理想情况下，流水线在工作时，其中的任务是同步地每一个时钟周期往前流动一段。</li>
<li>当流水线各段不均匀时，机器的时钟周期取决于瓶颈段的延迟时间。</li>
<li>在设计流水线时，要尽可能使各段时间相等。</li>
</ul>
<h2 id="流水线的额外开销"><a href="#流水线的额外开销" class="headerlink" title="流水线的额外开销"></a>流水线的额外开销</h2><ul>
<li><p>流水寄存器需要建立时间和传输延迟</p>
<ul>
<li>建立时间：在触发写操作的时钟信号到达之前，寄存器输入必须保持稳定的时间。</li>
<li>传输延迟：时钟信号到达后到寄存器输出可用的时间。</li>
</ul>
</li>
<li><p>时钟偏移开销</p>
<ul>
<li>流水线中，时钟到达各流水寄存器的最大差值时间。（时钟到达各流水寄存器的时间不是完全相同）</li>
</ul>
</li>
</ul>
<h2 id="由流水线性能与开销得到的重要结论"><a href="#由流水线性能与开销得到的重要结论" class="headerlink" title="由流水线性能与开销得到的重要结论"></a>由流水线性能与开销得到的重要结论</h2><ul>
<li>流水线并不能减少（而且一般是增加）单条指令的执行时间，但却能提高吞吐率。</li>
<li>增加流水线的深度（段数）可以提高流水线的性能。</li>
<li>流水线的深度受限于流水线的额外开销。</li>
<li>当时钟周期小到与额外开销相同时，流水已没意义。因为这时在每一个时钟周期中已没有时间来做有用的工作。【所以，流水段的段数越多不一定就越好】</li>
</ul>
<h1 id="单功能非线性流水线的调度"><a href="#单功能非线性流水线的调度" class="headerlink" title="单功能非线性流水线的调度"></a>单功能非线性流水线的调度</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><p>启动距离：向一条非线性流水线的输入端连续输入两个任务之间的时间间隔称为非线性流水线的启动距离。</p>
</li>
<li><p>禁用启动距离：会引起非线性流水线功能段使用冲突的启动距离则称为禁用启动距离。</p>
</li>
</ul>
<p>启动距离和禁用启动距离一般都用时钟周期数来表示，是一个正整数。</p>
<p>除去禁用启动距离外，其它的启动距离都是可用的，这也意味着，<strong>若两个任务进入非线性流水线的时间间隔不是禁用启动距离，那么这两个任务之间不会产生冲突</strong>。</p>
<ul>
<li><p>预约表：时间和执行的功能段之间的二维表</p>
</li>
<li><p>禁止表F：一个由禁用启动距离构成的集合</p>
<blockquote>
<p>对于预约表的每一行的任何一对√，用它们所在的列号相减（大的减小的），列出各种可能的差值，然后删除相同的，剩下的就是禁止表的元素。</p>
</blockquote>
</li>
</ul>
<h3 id="冲突向量"><a href="#冲突向量" class="headerlink" title="冲突向量"></a>冲突向量</h3><p>冲突向量：一个N位的二进制位串：</p>
<p>初始冲突向量C<del>0</del> 决定了下一个任务需间隔多少个时钟周期才可以流入</p>
<p>设C<del>0</del>&#x3D;（c<del>N</del>c<del>N-1</del>…c<del>i</del>…c<del>2</del>c<del>1</del>）;$C_i&#x3D;\begin{cases}1,&amp;i\in F\0,&amp;i\notin F\end{cases}$<br>c<del>i</del>&#x3D;0 ：允许间隔i个时钟周期后送入后续任务<br>c<del>i</del>&#x3D;1 ：不允许间隔i个时钟周期后送入后续任务</p>
<p>假设第二个任务是在与第一个任务间隔j个时钟周期流入，这时，由于第一个任务已经在流水线中前进了j个时钟周期，其相应的禁止表中各元素的值都应该减去j，并丢弃小于等于0的值。对原始冲突向量C<del>0</del>来说，就是<strong>逻辑右移j位（左边补0）</strong>。</p>
<p>第二个任务也会有着自己的冲突向量C。</p>
<p>由于后续任务既不能与第一个任务冲突，又不能与第二个任务冲突，所以<strong>当前（第二个任务进入流水线后的那个时钟周期）冲突向量（禁止表）是第一个任务与第二个任务的当前冲突向量的按位或（并集）</strong>。</p>
<p>假设: C<del>k</del>为当前的冲突向量，j: 允许的时间间隔，则，新的冲突向量为：SHR(j)（C<del>k</del>）∨C<del>0</del>（将当前冲突向量逻辑右移j位，再与新任务的冲突向量C<del>0</del>做按位或），得到，任意一个任务进入后的新冲突向量。</p>
<p>（通过遍历）获得所有可能的冲突向量，构成流水线状态集合：</p>
<p>从初始冲突向量C<del>0</del>出发，对于所有允许的时间间隔（所有i，满足C<del>i</del>&#x3D;0）都按上述步骤求出其新的冲突向量，并且把新的冲突向量作为当前冲突向量，反复使用上述步骤，直到不再产生新的冲突向量为止。</p>
<h2 id="流水线状态转移图"><a href="#流水线状态转移图" class="headerlink" title="流水线状态转移图"></a>流水线状态转移图</h2><p>得到所有可能的冲突向量后，可以画出其状态转移图。</p>
<p>三要素</p>
<ul>
<li>流水线状态集合（所有可能的冲突向量）</li>
<li>有向弧：表示状态转移的方向</li>
<li>弧上的数字：表示引入后续任务（从而产生新的冲突向量）所用的时间间隔（时钟周期数）</li>
</ul>
<h2 id="调度方案与最优调度方案"><a href="#调度方案与最优调度方案" class="headerlink" title="调度方案与最优调度方案"></a>调度方案与最优调度方案</h2><ul>
<li><p>调度方案：根据流水线状态图，由初始状态出发，<strong>任何一个闭合回路</strong>即为一种调度方案。 </p>
</li>
<li><p>最优调度方案：（任务进入流水线的）平均时间间隔最小的调度方案</p>
</li>
</ul>
<p>列出所有可能的调度方案，计算出每种方案的平均时间间隔，从中找出其最小者即为最优调度方案。</p>
<h2 id="等时间间隔调度方案"><a href="#等时间间隔调度方案" class="headerlink" title="等时间间隔调度方案"></a>等时间间隔调度方案</h2><p>不等时间间隔的调度方案，与等间隔的调度方案相比，在控制上要复杂得多。</p>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><p>流水线冲突（例如：在第二条指令需要第一条指令在第五周期的结果，那么第二条指令必须等到第一条指令产生相关结果才能进入流水线）会导致流水线停顿，使其性能下降。</p>
<p>相关是导致流水线冲突的主要原因。</p>
<p><strong>相关是指两条指令之间存在某种依赖关系，如果两条指令相关，则它们就有可能不能在流水线中重叠执行或者只能部分重叠执行。</strong></p>
<p>需要注意的是：相关是程序属性而非流水线属性。</p>
<p>相关可分为三类：数据相关（也称真数据相关），名相关，以及控制相关。</p>
<h2 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h2><p>定义：对于两条指令i（在前，下同）和j（在后，下同），如果下述条件之一成立，则称指令j与指令i数据相关。</p>
<p>（1）指令j使用指令i产生的结果；</p>
<p>（2）指令j与指令k数据相关，而指令k又与指令i数据相关。【传递性】</p>
<h3 id="数据相关检测"><a href="#数据相关检测" class="headerlink" title="数据相关检测"></a>数据相关检测</h3><p>当数据的流动是经过寄存器时，相关的检测比较直观和容易。</p>
<p>当数据的流动是经过存储器时，检测比较复杂。【有可能两条相关指令之间对相关数据进行过修改导致两条指令之间没有相关性】</p>
<h2 id="名相关"><a href="#名相关" class="headerlink" title="名相关"></a>名相关</h2><p>名：指令所访问的寄存器或存储器单元的名称</p>
<p>名相关：如果两条指令使用相同的名，但是它们之间并<strong>没有数据流动</strong>，则称这两条指令存在名相关</p>
<h3 id="反相关"><a href="#反相关" class="headerlink" title="反相关"></a>反相关</h3><p>如果指令j写的名与指令i读的名相同，则称指令i和j发生了反相关。</p>
<p>指令j写的名＝指令i读的名</p>
<p>这里“反”是指与数据相关的顺序（先写后读）相反（反相关是先读后写）。</p>
<h3 id="输出相关"><a href="#输出相关" class="headerlink" title="输出相关"></a>输出相关</h3><p>如果指令j和指令i写相同的名，则称指令i和j发生了输出相关</p>
<p>指令j写的名＝指令i写的名</p>
<h3 id="名相关解决方案"><a href="#名相关解决方案" class="headerlink" title="名相关解决方案"></a>名相关解决方案</h3><p>名相关特点</p>
<ul>
<li>名相关的两条指令之间并没有数据的传送。</li>
<li>如果一条指令中的名改变了，并不影响另外一条指令的执行。</li>
</ul>
<p>消除名相关的方法：换名技术</p>
<p>换名技术：通过改变指令中操作数的名来消除名相关。</p>
<ul>
<li>对于寄存器操作数进行换名称为寄存器换名<ul>
<li>既可以用编译器静态实现，也可以用硬件动态完成。</li>
</ul>
</li>
</ul>
<h2 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h2><p>控制相关是指由分支指令引起的相关。传统情况下，为了保证程序应有的执行顺序，必须严格按控制相关确定的顺序执行。</p>
<p>与一条分支指令控制相关的指令不能被移到该分支之前。</p>
<h1 id="流水线冲突"><a href="#流水线冲突" class="headerlink" title="流水线冲突"></a>流水线冲突</h1><p>流水线冲突是指对于具体的流水线来说，由于相关等原因的存在使得指令流中的下一条指令不能在指定的时钟周期执行。</p>
<p>流水线冲突分类</p>
<ul>
<li>结构冲突：因硬件资源满足不了指令重叠执行的要求而发生的冲突。</li>
<li>数据冲突：当指令在流水线中重叠执行时，因需要用到前面指令的执行结果而发生的冲突。</li>
<li>控制冲突：流水线遇到分支指令和其它会改变PC值的指令所引起的冲突。</li>
</ul>
<h2 id="问题与基本解决方法"><a href="#问题与基本解决方法" class="headerlink" title="问题与基本解决方法"></a>问题与基本解决方法</h2><p>问题</p>
<ul>
<li>导致错误的执行结果。</li>
<li>流水线可能会出现停顿，从而降低流水线的效率和实际的加速比。</li>
</ul>
<p>基本解决方法</p>
<ul>
<li>暂停部分指令执行：当一条指令被暂停时，在该暂停指令之后流出的所有指令都要被暂停，而在该暂停指令之前流出的指令则继续进行（否则就永远无法消除冲突）。</li>
</ul>
<h2 id="结构冲突"><a href="#结构冲突" class="headerlink" title="结构冲突"></a>结构冲突</h2><p>常见的导致结构冲突的原因有两个。一是功能部件不是完全流水，二是资源份数不够。</p>
<p> 解决方法：</p>
<ul>
<li><p>插入暂停周期【通过拉开两条冲突指令在流水线之间的距离来避免冲突发生的】</p>
<ul>
<li>为消除结构冲突而插入的流水线气泡</li>
</ul>
</li>
<li><p>设置相互独立的存储器，使之分别存储指令与数据【通过增加资源数量，来避免访问同一资源导致的冲突】</p>
<ul>
<li>通过让读取指令与读写数据的访存请求落到不同的存储器中，从而避免访问同一存储器引起的冲突。对应的就是组成原理课程中讲过的哈弗结构。在现代通用处理器中，这种技术被普遍用于一级cache中。</li>
</ul>
</li>
</ul>
<p><strong>不一定需要消除所有的结构冲突：</strong></p>
<p>主要是为了考虑减少硬件成本。</p>
<h2 id="数据冲突"><a href="#数据冲突" class="headerlink" title="数据冲突"></a>数据冲突</h2><h3 id="写后读冲突（RAW）"><a href="#写后读冲突（RAW）" class="headerlink" title="写后读冲突（RAW）"></a>写后读冲突（RAW）</h3><p>对应的相关：最常见的一种数据冲突，对应于真数据相关。 </p>
<p>发生条件</p>
<ul>
<li>有两条指令i和j，i在j之前进入流水线</li>
<li>在 i 写入之前，j 先去读</li>
</ul>
<p>结果</p>
<ul>
<li>j 读出的内容是错误的</li>
</ul>
<h3 id="写后写冲突（WAW）"><a href="#写后写冲突（WAW）" class="headerlink" title="写后写冲突（WAW）"></a>写后写冲突（WAW）</h3><p>对应相关：对应于输出相关。</p>
<p>发生条件：</p>
<ul>
<li>流水线中不只一个段可以进行写操作，且指令被重新排序了</li>
<li>有两条指令i和j，i在j之前进入流水线</li>
<li>在 i 写入之前，j 先写。</li>
</ul>
<p>结果</p>
<ul>
<li>最后写入的结果是 i 的。错误！</li>
</ul>
<h3 id="读后写冲突（WAR）"><a href="#读后写冲突（WAR）" class="headerlink" title="读后写冲突（WAR）"></a>读后写冲突（WAR）</h3><p>对应相关：反相关</p>
<p>发生条件</p>
<ul>
<li>有些指令的写结果操作提前了，而且有些指令的读操作滞后了；或是指令被重新排序了。 </li>
<li>有两条指令i和j，i在j之前进入流水线。在 i 读取之前，j 先写入。</li>
</ul>
<p>结果</p>
<ul>
<li>i读到的结果是错误的。</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>定向（短路、旁路）：（减少冲突引起的停顿时间）<ul>
<li>在计算结果尚未出来之前，后面等待使用该结果的指令并不真正立即需要该计算结果，如果能够将该计算结果从其产生的地方直接送到其它指令需要它的地方，那么就可以避免停顿。</li>
</ul>
</li>
</ul>
<p>定向技术实际上是在原有的寄存器传递数据的基础上，增加了新的指令间传递数据的路径。</p>
<ul>
<li>指令调度（流水线调度）：让编译器重新组织指令顺序来消除冲突</li>
</ul>
<blockquote>
<p>定向技术是基于硬件的运行时解决方案；指令调度是基于软件的的预处理方案</p>
</blockquote>
<h2 id="控制冲突"><a href="#控制冲突" class="headerlink" title="控制冲突"></a>控制冲突</h2><p>起因：执行分支指令的结果有两种</p>
<ul>
<li><p>分支成功：PC值改变为分支转移的目标地址。在条件判定和转移地址计算都完成后，才改变PC值。</p>
</li>
<li><p>不成功或者失败：PC的值保持正常递增，指向顺序的下一条指令。</p>
</li>
</ul>
<p>控制冲突</p>
<ul>
<li>分支延迟：分支指令引起的延迟</li>
</ul>
<p>最简单的处理方法</p>
<ul>
<li>“冻结”或者“排空”流水线 <ul>
<li>前述5段流水线中，改变PC值是在MEM段进行的。给流水线带来了3个时钟周期的延迟</li>
</ul>
</li>
</ul>
<h3 id="基本解决方案"><a href="#基本解决方案" class="headerlink" title="基本解决方案"></a>基本解决方案</h3><p><strong>通过设置专用的处理单元，在流水线中尽早判断出分支转移是否成功，以及分支目标地址。</strong>【硬件】</p>
<p>进一步：基于编译器的软件方法</p>
<h4 id="预测分支失败"><a href="#预测分支失败" class="headerlink" title="预测分支失败"></a>预测分支失败</h4><p>允许分支指令后的指令继续在流水线中流动，就好象什么都没发生似的；若确定分支失败，将分支指令看作是一条普通指令，流水线正常流动；若确定分支成功，流水线就把在分支指令之后取出的所有指令转化为空操作，并按分支目地重新取指令执行。</p>
<h4 id="预测分支成功"><a href="#预测分支成功" class="headerlink" title="预测分支成功"></a>预测分支成功</h4><p>假设分支转移成功，并从分支目标地址处取指令执行。这种方法起作用的前题是，需要先知道分支目标地址，后知道分支是否成功。显然，前述5段流水线中，这种方法没有任何好处。原因在于，分支目标地址与分支是否成功是同时计算出来的。</p>
<h4 id="延迟分支"><a href="#延迟分支" class="headerlink" title="延迟分支"></a>延迟分支</h4><p>从逻辑上“延长”分支指令的执行时间。把延迟分支看成是由原来的分支指令和若干个延迟槽构成，不管分支是否成功，都要按顺序执行延迟槽中的指令。<br>延迟分支的优点在于无论分支成功还是失败都能够减少（掩盖）一个时钟周期的延迟。</p>
<blockquote>
<p>通过在分支指令后增加延迟槽，并将有用的指令从别处调度到延迟槽执行，当分支是否成功与分支目标地址被算出时，恰好能够进行对应的取指操作，从而有效的消除了分支延迟。</p>
</blockquote>
<p>–要点：在延迟槽中放入有用的指令，由编译器完成。能否带来好处取决于编译器能否把有用的指令调度到延迟槽中。</p>
<p>从调度的角度，延迟分支又可分为三类：从前调度，从目标处调度，从失败处调度。</p>
<ul>
<li>从前调度：从分支指令之前调度一条与该分支无关的指令到分支延迟槽中。</li>
<li>从目标处调度：将分支目标地址对应的指令调度到延迟槽中。</li>
<li>从失败处调度：将分支失败处的指令（下一条顺序地址）调入延迟槽。</li>
</ul>
<blockquote>
<p>由于只有当调入到延迟槽的指令实际上会被执行时，分支延迟技术才会真正起效，因此，可以认为：无论分支是否成功，从前调度均能消除控制冲突；只有当分支成功时，从目标处调度才能消除控制冲突；只有当分支失败时，从失败处调度才能消除控制冲突。</p>
<p> 既然从前调度的效果远胜于后两种调度，为什么还要有后两种方法呢？原因在于，前面提到的从前调度需要找到一条与该分支无关的指令，这样的指令通常是极少的。</p>
</blockquote>
<p>分支延迟的改善受到两个方面的限制：一是需要在延迟槽中放入有用的指令（由编译器完成）；二是能否带来好处取决于编译器能否把有用的指令调度到延迟槽中。</p>
<p>此外，对于预测错误的情况，需要进一步的改进。引入分支取消机制，当分支的实际执行方向和事先所预测的一样时，执行分支延迟槽中的指令，否则就将分支延迟槽中的指令转化成一个空操作。</p>
<h1 id="流水线的实现"><a href="#流水线的实现" class="headerlink" title="流水线的实现"></a>流水线的实现</h1><p>MIPS的流水化：每一个时钟周期完成的工作看作是流水线的一段，每个时钟周期启动一条新的指令。</p>
<p>流水寄存器的位置和作用：</p>
<ul>
<li><p>位置：段与段之间设置流水寄存器</p>
</li>
<li><p>作用</p>
<ul>
<li>将各段的工作隔开，使得它们不会互相干扰。</li>
<li>保存相应段的处理结果。</li>
<li>向后传递后面将要用到的数据或者控制信息<br>所有有用的数据和控制信息每个时钟周期会随着指令在流水线中的流动往后流动一段</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/08/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">java-设计模式（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-07 21:58:36" itemprop="dateCreated datePublished" datetime="2020-04-07T21:58:36Z">2020-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-29 02:37:52" itemprop="dateModified" datetime="2021-12-29T02:37:52Z">2021-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GOF23种设计模式"><a href="#GOF23种设计模式" class="headerlink" title="GOF23种设计模式"></a>GOF23种设计模式</h1><p>设计模式主要分三个类型:创建型、结构型和行为型。 </p>
<p><strong>创建型</strong></p>
<ol>
<li>Singleton，单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点 </li>
<li>Abstract Factory，抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。 </li>
<li>Factory Method，工厂方法：定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。 </li>
<li>Builder，建造模式：将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。 </li>
<li>Prototype，原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。</li>
</ol>
<p><strong>行为型</strong></p>
<ol>
<li>Iterator，迭代器模式：提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。 </li>
<li>Observer，观察者模式：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。 </li>
<li>Template Method，模板方法：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该算法得某些特定步骤。 </li>
<li>Command，命令模式：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。 </li>
<li>State，状态模式：允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。 </li>
<li>Strategy，策略模式：定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。 </li>
<li>China of Responsibility，职责链模式：使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系 </li>
<li>Mediator，中介者模式：用一个中介对象封装一些列的对象交互。 </li>
<li>Visitor，访问者模式：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。 </li>
<li>Interpreter，解释器模式：给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子</li>
<li>Memento，备忘录模式：在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</li>
</ol>
<p><strong>结构型</strong> </p>
<ol>
<li>Composite，组合模式：将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使用具有一致性。 </li>
<li>Facade，外观模式：为子系统中的一组接口提供一致的界面，fa?ade提供了一高层接口，这个接口使得子系统更容易使用。</li>
<li>Proxy，代理模式：为其他对象提供一种代理以控制对这个对象的访问 </li>
<li>Adapter,适配器模式：将一类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作那些类可以一起工作。 </li>
<li>Decrator，装饰模式：动态地给一个对象增加一些额外的职责，就增加的功能来说，Decorator模式相比生成子类更加灵活。 </li>
<li>Bridge，桥模式：将抽象部分与它的实现部分相分离，使他们可以独立的变化。 </li>
<li>Flyweight，享元模式</li>
</ol>
<h2 id="一、工厂模式"><a href="#一、工厂模式" class="headerlink" title="一、工厂模式"></a>一、工厂模式</h2><h3 id="1-1、简单工厂模式（静态工厂模式）"><a href="#1-1、简单工厂模式（静态工厂模式）" class="headerlink" title="1.1、简单工厂模式（静态工厂模式）"></a>1.1、简单工厂模式（静态工厂模式）</h3><p>“<strong>当你需要某个对象的时候，通常你是new出来的，但是这样代码耦合度太高，因此我们通过一个工厂来生产出来这个对象</strong>”</p>
<ul>
<li>工厂：负责实现创建所有实例的内部逻辑，并且提供一个外界调用的方法，创建所需产品对象</li>
<li>抽象产品：用来描述产品的公共接口</li>
<li>具体产品：描述生产的具体产品</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @ Product.java</span></span><br><span class="line"><span class="comment"> *  抽象产品</span></span><br><span class="line"><span class="comment"> *  描述产品的公共接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span>  <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="comment">//产品介绍</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ AProduct.java</span></span><br><span class="line"><span class="comment"> * 具体产品A</span></span><br><span class="line"><span class="comment"> * （可以看成是一种饮料：可乐）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;可乐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ BProduct.java</span></span><br><span class="line"><span class="comment"> * @具体产品B</span></span><br><span class="line"><span class="comment"> * @（可以看成是一种饮料：奶茶）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奶茶&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ CProduct.java</span></span><br><span class="line"><span class="comment"> * 具体产品C</span></span><br><span class="line"><span class="comment"> * （可以看成是一种饮料：咖啡）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;咖啡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Factory.java*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂</span></span><br><span class="line"><span class="comment"> * 负责实现创建所有实例的内部逻辑，并提供一个外界调用的方法，创建所需的产品对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供外界调用的方法</span></span><br><span class="line"><span class="comment">     * （可以看成是对外提供的三种按钮）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 产品实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">getProduct</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AProduct</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BProduct</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;C&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CProduct</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*test.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建具体的工厂</span></span><br><span class="line">        <span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factory</span>();</span><br><span class="line">        <span class="comment">//根据传入的参数生产不同的产品实例</span></span><br><span class="line">        <span class="comment">//(按下不同的按钮，获取饮料)</span></span><br><span class="line">        <span class="type">Product</span> <span class="variable">A</span> <span class="operator">=</span> Factory.getProduct(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        A.intro();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">B</span> <span class="operator">=</span> Factory.getProduct(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        B.intro();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">C</span> <span class="operator">=</span> Factory.getProduct(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        C.intro();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：将创建使用工作分开，不必关心类对象如何创建，实现了解耦；<br>缺点：违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。</p>
<h3 id="1-2、工厂方法模式（工厂模式）"><a href="#1-2、工厂方法模式（工厂模式）" class="headerlink" title="1.2、工厂方法模式（工厂模式）"></a>1.2、工厂方法模式（工厂模式）</h3><p>可以理解成将上述的静态工厂模式中的工厂进行拆分，让对应的实例产品都有一个单独的工厂对其进行生产。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ Product.java </span></span><br><span class="line"><span class="comment"> *   抽象产品</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="comment">//产品介绍</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ ProductA.java </span></span><br><span class="line"><span class="comment"> * 具体产品A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductA</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;饮料A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ ProductB.java </span></span><br><span class="line"><span class="comment"> * 具体产品B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductB</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;饮料B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂：Factory.java、FactoryA.java 、FactoryB.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @ Factory.java</span></span><br><span class="line"><span class="comment"> *    抽象工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">//生产产品</span></span><br><span class="line">    <span class="keyword">abstract</span> Product <span class="title function_">getProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ FactoryA.java</span></span><br><span class="line"><span class="comment"> * 具体工厂A</span></span><br><span class="line"><span class="comment"> * 负责具体的产品A生产</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryA</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Product <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ FactoryB.java</span></span><br><span class="line"><span class="comment"> * @具体工厂B</span></span><br><span class="line"><span class="comment"> * 负责具体的产品B生产</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryB</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Product <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：Test.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建具体的工厂</span></span><br><span class="line">        <span class="type">FactoryA</span> <span class="variable">factoryA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FactoryA</span>();</span><br><span class="line">        <span class="comment">//生产相对应的产品</span></span><br><span class="line">        factoryA.getProduct().intro();</span><br><span class="line">        <span class="type">FactoryB</span> <span class="variable">factoryB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FactoryB</span>();</span><br><span class="line">        factoryB.getProduct().intro();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一个抽象产品类，可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类只能创建一个具体产品类的实例</strong>。</p>
<p>优点：</p>
<ol>
<li>符合开-闭原则：新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可</li>
<li>符合单一职责原则：每个具体工厂类只负责创建对应的产品</li>
</ol>
<p>缺点：</p>
<ol>
<li>增加了系统的复杂度：类的个数将成对增加</li>
<li>增加了系统的抽象性和理解难度</li>
<li>一个具体工厂只能创建一种具体产品</li>
</ol>
<h3 id="1-3、抽象工厂模式"><a href="#1-3、抽象工厂模式" class="headerlink" title="1.3、抽象工厂模式"></a>1.3、抽象工厂模式</h3><p>为了解决工厂模式中一个工厂只能生产一个具体产品的问题。抽象工厂模式使用抽象类添加了抽象工厂，然后让具体工厂继承该抽象工厂达到一个具体工厂可以生产多种具体产品的效果。</p>
<p><strong>抽象工厂</strong>：描述具体工厂的公共接口<br><strong>具体工厂</strong>：描述具体工厂，创建产品的实例，供外界调用<br><strong>抽象产品族</strong>：描述抽象产品的公共接口<br><strong>抽象产品</strong>：描述具体产品的公共接口<br><strong>具体产品</strong>：具体产品</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ Product.java</span></span><br><span class="line"><span class="comment"> * 抽象产品族 (食品)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="comment">//产品介绍</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ ProductA.java</span></span><br><span class="line"><span class="comment"> * 抽象产品  (饮料)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ProductA</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ ProductB.java</span></span><br><span class="line"><span class="comment"> * 抽象产品  (零食)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ProductB</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ ProductAa.java</span></span><br><span class="line"><span class="comment"> * 具体产品  (矿泉水)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">ProductAa</span> <span class="keyword">extends</span> <span class="title class_">ProductA</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;矿泉水&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ ProductBb.java</span></span><br><span class="line"><span class="comment"> * 具体产品  (面包)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductBb</span> <span class="keyword">extends</span> <span class="title class_">ProductB</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;面包&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂：Factory.java、FactoryA.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ Factory.java</span></span><br><span class="line"><span class="comment"> * 抽象工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">//生产饮料</span></span><br><span class="line">    <span class="keyword">abstract</span> Product <span class="title function_">getProductA</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//生产零食</span></span><br><span class="line">    <span class="keyword">abstract</span> Product <span class="title function_">getProductB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ FactoryA.java</span></span><br><span class="line"><span class="comment"> * 具体工厂A</span></span><br><span class="line"><span class="comment"> * 负责具体的A类产品生产</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryA</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Product <span class="title function_">getProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//生产矿泉水</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductAa</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Product <span class="title function_">getProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//生产面包</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductBb</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：Test.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建零食售卖机（具体工厂），</span></span><br><span class="line">        <span class="type">FactoryA</span> <span class="variable">factoryA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FactoryA</span>();</span><br><span class="line">        <span class="comment">//获取矿泉水与面包（具体产品）</span></span><br><span class="line">        factoryA.getProductA().intro();</span><br><span class="line">        factoryA.getProductB().intro();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类可以创建多个具体产品类的实例</strong>。.</p>
<p>优点：</p>
<ol>
<li>降低耦合</li>
<li>符合开-闭原则</li>
<li>符合单一职责原则</li>
<li>不使用静态工厂方法，可以形成基于继承的等级结构。</li>
</ol>
<p>缺点：难以扩展新种类产品</p>
<h2 id="二、单例模式（singleton）"><a href="#二、单例模式（singleton）" class="headerlink" title="二、单例模式（singleton）"></a>二、单例模式（singleton）</h2><p>确保一个类只有一个实例，并提供该实例的全局访问点。</p>
<p><strong>单例的实现主要是通过以下两个步骤</strong>：</p>
<ol>
<li><strong>将该类的构造方法定义为私有方法</strong>，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，<strong>只有通过该类提供的静态方法来得到该类的唯一实例</strong>；</li>
<li>在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</li>
</ol>
<h3 id="1、单例模式的应用场景和优缺点"><a href="#1、单例模式的应用场景和优缺点" class="headerlink" title="1、单例模式的应用场景和优缺点"></a>1、单例模式的应用场景和优缺点</h3><p>举一个小例子，在我们的windows桌面上，我们打开了一个回收站，当我们试图再次打开一个新的回收站时，Windows系统并不会为你弹出一个新的回收站窗口。，也就是说在整个系统运行的过程中，系统只维护一个回收站的实例。这就是一个典型的单例模式运用。</p>
<p> 继续说回收站，我们在实际使用中并不存在需要同时打开两个回收站窗口的必要性。假如我每次创建回收站时都需要消耗大量的资源，而每个回收站之间资源是共享的，那么在没有必要多次重复创建该实例的情况下，创建了多个实例，这样做就会给系统造成不必要的负担，造成资源浪费。</p>
<p> <strong>适用场景：</strong></p>
<ul>
<li><strong>1.需要生成唯一序列的环境</strong></li>
<li><strong>2.需要频繁实例化然后销毁的对象。</strong></li>
<li><strong>3.创建对象时耗时过多或者耗资源过多，但又经常用到的对象。</strong> </li>
<li><strong>4.方便资源相互通信的环境</strong></li>
</ul>
<p><strong>常见应用场景：</strong></p>
<ul>
<li>Windows的Task Manager（任务管理器）</li>
<li>windows的Recycle Bin（回收站）也是典型的单例应用</li>
<li>应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作 ，否则内容不好追加。</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源</li>
<li>操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统</li>
<li>Application 也是单例的典型应用（Servlet编程中会涉及到）</li>
<li>在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理</li>
<li>在servlet编程中，每个Servlet也是单例</li>
<li>在spring MVC框架&#x2F;struts1框架中，控制器对象也是单例</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>在内存中只有一个对象，节省内存空间；</li>
<li>避免频繁的创建销毁对象，可以提高性能；</li>
<li>避免对共享资源的多重占用，简化访问；</li>
<li>为整个系统提供一个全局访问点。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>不适用于变化频繁的对象；</li>
<li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；</li>
<li>如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失；</li>
</ul>
<p>单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p>
<p> <img src="/images/android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/1475571-20190112110023891-1922874460.png"></p>
<p>单例模式的实现代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="literal">null</span>;  <span class="comment">//静态私有成员变量</span></span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span></span><br><span class="line">    &#123;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">//静态公有工厂方法，返回唯一实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)</span><br><span class="line">            instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();    </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在单例模式的实现过程中，需要注意如下三点：</p>
<p>  • 单例类的构造函数为私有；</p>
<p>  • 提供一个自身的静态私有成员变量；</p>
<p>  • 提供一个公有的静态工厂方法。</p>
<h3 id="2、饿汉式——线程安全、调用效率高、无法延时加载"><a href="#2、饿汉式——线程安全、调用效率高、无法延时加载" class="headerlink" title="2、饿汉式——线程安全、调用效率高、无法延时加载"></a>2、饿汉式——线程安全、调用效率高、无法延时加载</h3><p><strong>类加载的方式是按需加载，且加载一次</strong>。。因此，在上述单例类被加载时，就会实例化一个对象并交给自己的引用，供系统使用；而且，由于这个类在整个生命周期中只会被加载一次，因此只会创建一个实例，即能够充分保证单例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 指向自己实例的私有静态引用，主动创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton1</span> <span class="variable">singleton1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 私有的构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 以自己实例为返回值的静态的公有方法，静态工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getSingleton1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p>
<p>缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</p>
<h3 id="3、懒汉式——线程安全、调用效率低、延时加载"><a href="#3、懒汉式——线程安全、调用效率低、延时加载" class="headerlink" title="3、懒汉式——线程安全、调用效率低、延时加载"></a>3、懒汉式——线程安全、调用效率低、延时加载</h3><p>单例实例被<strong>延迟加载</strong>，即只有在真正使用的时候才会实例化一个对象并交给自己的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 指向自己实例的私有静态引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 singleton2;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 私有的构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 以自己实例为返回值的静态的公有方法，静态工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton2 <span class="title function_">getSingleton2</span><span class="params">()</span>&#123;<span class="comment">//synchronized保证getSingleton2是一个同步方法，可以保证在多线程情况下单例对象唯一性</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//没有synchronized，只能在单线程下使用。如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 被动创建，在真正需要使用时才去创建</span></span><br><span class="line">        <span class="keyword">if</span> (singleton2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            singleton2 = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：单例只有在使用时才会被实例化，在一定程度上节约了资源</p>
<p>缺点：第一次加载时需要及时进行实例化，反应稍慢，最大的问题是每次调用getInstance都进行同步，造成不必要的同步开销。这种模式一般不建议使用。</p>
<h3 id="4、双重加锁机制（Double-Check-Lock）——线程安全"><a href="#4、双重加锁机制（Double-Check-Lock）——线程安全" class="headerlink" title="4、双重加锁机制（Double Check Lock）——线程安全"></a>4、双重加锁机制（Double Check Lock）——线程安全</h3><p>Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次if (singleton &#x3D;&#x3D; null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton &#x3D;&#x3D; null)，直接return实例化对象。</p>
<p>使用双重检测同步延迟加载去创建单例的做法是一个非常优秀的做法，<strong>其不但保证了单例，而且切实提高了程序运行效率</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">        <span class="comment">//程序运行时创建一个静态只读的进程辅助对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> readonly <span class="type">object</span> <span class="variable">syncRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">object</span>();</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dosomething</span><span class="params">()</span></span><br><span class="line">    	&#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;do sth.&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">GetInstance</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//先判断是否存在，不存在再加锁处理</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//在同一个时刻加了锁的那部分程序只有一个线程可以进入</span></span><br><span class="line">                <span class="comment">//lock(syncRoot) 获取对象syncRoot的互斥锁，可以简单理解为，当多个线程同时执行到lock的时候，大家排队，一个一个地进行。</span></span><br><span class="line">                lock (syncRoot)<span class="comment">//可以使用synchronized (Singleton.class)</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//当声明对象的引用为volatile后，“问题的根源”的三行伪代码中的2和3之间的重排序，在多线程环境中将会被禁止，类在实例化过程中会严格按照1、2、3顺序执行下去。</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">        <span class="comment">//程序运行时创建一个静态只读的进程辅助对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dosomething</span><span class="params">()</span></span><br><span class="line">    	&#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;do sth.&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">GetInstance</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//先判断是否存在，不存在再加锁处理</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//在同一个时刻加了锁的那部分程序只有一个线程可以进入</span></span><br><span class="line">                <span class="keyword">synchronized</span> (Singleton.class)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一次 if (instance &#x3D;&#x3D; null)主要是为了避免不必要的同步，第二次的判断是为了在null的情况下创建实例。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20211229102745.png"></p>
<p>优点：既能够在需要时才初始化单例，又能够保证线程安全，且单例对象初始化后调用getInstance不进行同步锁。<br>资源利用率高，第一次执行getInstance时单例对象才会被实例化，效率高。</p>
<p>缺点：第一次加载慢</p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/double-checked-locking-with-delay-initialization/">参考文章</a></p>
<h3 id="5、静态初始化"><a href="#5、静态初始化" class="headerlink" title="5、静态初始化"></a>5、静态初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻止发生派生，而派生可能会增加实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在第一次引用类的任何成员时创建实例，公共语言运行库负责处理变量初始化</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> readonly Singleton instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">GetInstance</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、静态内部类"><a href="#6、静态内部类" class="headerlink" title="6、静态内部类"></a>6、静态内部类</h3><p>解决DCL在某些情况下出现失效的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Slingleton</span><span class="params">()</span></span><br><span class="line">    &#123;   &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> SingleHolder.sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">sInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当第一次加载singleton类时并不会初始化sInstance，只有在第一次调用Singleton的getInstance方法时才会导致sInstance被初始化。</p>
<p>第一次调用getInstance方法会导致虚拟机加载SingletonHolder类，这种方式不仅能够确保线程安全，也可以确保单例对象的唯一性，同时也延迟了单例的实例化。推荐。</p>
<h3 id="7、枚举单例"><a href="#7、枚举单例" class="headerlink" title="7、枚举单例"></a>7、枚举单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SingletonEnum</span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dosomething</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、使用容器实现"><a href="#8、使用容器实现" class="headerlink" title="8、使用容器实现"></a>8、使用容器实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonManager</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; objMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonManager</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerService</span><span class="params">(String key,Object instance)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!objMap.containsKey(key))</span><br><span class="line">        &#123;</span><br><span class="line">            objMap.put(key,instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getService</span><span class="params">(String key)</span></span><br><span class="line">        <span class="keyword">return</span> objMap.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程序的初始时，可以将多种单例类型注入到一个统一的管理类中，在使用时根据key获取对象对应类型的对象。</p>
<p>优点：可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低用户的使用成本，降低耦合度。</p>
<p>要想实现效率高的线程安全的单例，我们必须注意以下两点：</p>
<ul>
<li><strong>尽量减少同步块的作用域；</strong></li>
<li><strong>尽量使用细粒度的锁。</strong></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rhb</p>
  <div class="site-description" itemprop="description">纵浪大化中，不喜亦不惧</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">126</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RShawshank" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RShawshank" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rhb</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://lib.baomitu.com/canvas-nest.js/1.0.1/canvas-nest.js"></script>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
