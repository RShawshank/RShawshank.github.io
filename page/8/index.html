<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rshawshank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="纵浪大化中，不喜亦不惧">
<meta property="og:type" content="website">
<meta property="og:title" content="rhb_blog">
<meta property="og:url" content="http://rshawshank.github.io/page/8/index.html">
<meta property="og:site_name" content="rhb_blog">
<meta property="og:description" content="纵浪大化中，不喜亦不惧">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rhb">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rshawshank.github.io/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>rhb_blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rhb_blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">rao的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">55</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">23</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">126</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/RShawshank" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/" class="post-title-link" itemprop="url">数据库_数据库完整性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-01 11:12:38" itemprop="dateCreated datePublished" datetime="2020-04-01T11:12:38Z">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-02 13:03:06" itemprop="dateModified" datetime="2020-06-02T13:03:06Z">2020-06-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h1><ul>
<li><p>数据库的完整性</p>
<ul>
<li>数据的正确性和相容性</li>
</ul>
</li>
<li><p>数据的完整性和安全性是两个不同概念：</p>
<ul>
<li>数据的完整性：防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据</li>
<li>数据的安全性：保护数据库防止恶意的破坏和非法的存取</li>
</ul>
</li>
<li><p>为维护数据库的完整性，DBMS必须：</p>
<ul>
<li>提供定义完整性约束条件的机制</li>
<li>提供完整性检查的方法</li>
<li>违约处理</li>
</ul>
</li>
</ul>
<p>DBMS完整性控制机制应具有的功能：</p>
<ul>
<li>违约反应</li>
<li>定义功能</li>
<li>检查功能</li>
</ul>
<h2 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h2><p>实体完整性的定义机制：<br>–CREATE  TABLE中用PRIMARY KEY定义<br>–列级约束条件 或表级约束条件</p>
<p>实体完整性的检查和违约处理：</p>
<p>在插入或对主码列进行更新操作时，RDBMS按照实体完整性规则自动进行检查。包括：<br>–检查主码值是否唯一，如果不唯一则拒绝插入或修改<br>–检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改</p>
<h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2><p>参照完整性，指多表之间的设计，主要使用外键约束【多表设计有：一对多，多对多，一对一】</p>
<p>主要是定义外码，将一个关系的主码放在另一个关系中，作为该关系的属性，就称其为外码。外码的取值有两种情况，一种为空，另外一种就是被参照表的主码的域。</p>
<p>子表的删除更新策略一共有4种：</p>
<ul>
<li><p>CASCADE 级联策略。<br>主表的修改会被同步到子表中。</p>
</li>
<li><p>NO ACTION 无动作策略。<br>要删改主表，必须要先删改子表对应数据。</p>
</li>
<li><p>RSTRICT 主表约束策略。<br>此策略，对主表的约束跟NO ACTION一样。即删、更新主表前的主键，必须要先删、更新子表中对应的。</p>
</li>
<li><p>SET NO 置空策略。<br>使用此策略时，当主表主键删改，则子表中的外键 设置为NULL。<br>但如果子表的外键是主键，或者子表外键设置NOT NULL，则此时就相当于NO ACTION策略。</p>
</li>
</ul>
<p>参照完整性的定义机制：<br>–在CREATE  TABLE中用FOREIGN KEY短语定义哪些列为外码，<br>–用REFERENCES短语指明这些外码参照哪些表的主码</p>
<table>
<thead>
<tr>
<th>被参照表</th>
<th>参照表</th>
<th>违约处理</th>
</tr>
</thead>
<tbody><tr>
<td>可能破坏参照完整性</td>
<td>插入元组</td>
<td>拒绝</td>
</tr>
<tr>
<td>可能破坏参照完整性</td>
<td>修改外码值</td>
<td>拒绝&#x2F;级联修改&#x2F;设置为空值</td>
</tr>
<tr>
<td>修改主码值</td>
<td>可能破坏参照完整性</td>
<td>拒绝&#x2F;级联修改&#x2F;设置为空值</td>
</tr>
<tr>
<td>删除元组</td>
<td>可能破坏参照完整性</td>
<td>拒绝&#x2F;级联修改&#x2F;设置为空值</td>
</tr>
</tbody></table>
<p>若要在参照完整性中采用级联更新的修改方式，则应该在<strong>外码定义</strong>中说明。</p>
<h1 id="用户定义完整性"><a href="#用户定义完整性" class="headerlink" title="用户定义完整性"></a>用户定义完整性</h1><p>用户定义的完整性就是针对某一具体应用的数据必须满足的语义要求</p>
<p>分为：属性上的约束和元组上的约束。</p>
<p>属性上的约束：在CREATE TABLE中定义属性时定义<br>–列值非空（NOT NULL），列值唯一（UNIQUE），检查列值是否满足一个布尔表达式（CHECK）<br>–插入元组或修改属性值时检查，不满足则拒绝执行。</p>
<p>元组上的约束<br>–在CREATE TABLE时可以用CHECK短语定义元组上的约束条件，即元组级的限制<br>–同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件<br>–插入元组或修改属性值时检查，不满足则拒绝执行</p>
<p>在一张表上可以定义多个完整性约束，为方便起见，在CREATE TABLE中可用CONSTRAINT语句对所定义的约束条件命名</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONSTRAINT</span>&lt;完整性约束条件名&gt;&lt;完整性约束条件&gt;</span><br><span class="line">其中，&lt;完整性约束条件&gt;包括：<span class="keyword">NOT</span>  <span class="keyword">NULL</span>、<span class="keyword">UNIQUE</span>、PRIMARYKEY、<span class="keyword">FOREIGN KEY</span>、<span class="keyword">CHECK</span>短语等。</span><br></pre></td></tr></table></figure>

<p>语义: 对定义的约束条件命名</p>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>是用户定义在关系表上的一类由事件驱动的特殊过程。亦称为：事件-条件-动作规则。</p>
<ul>
<li>一旦定义，触发器将被保存在数据库服务器中。</li>
<li><strong>任何用户对表的增、删、改操作均由服务器自动激活相应的触发器</strong>，在DBMS核心层进行集中的完整性控制。</li>
<li>比约束更为灵活，规则中的动作可以很复杂，可以包含 if&#x2F; while&#x2F;case 等程序控制指令，可以涉及其他表和其他数据库对象，实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力。</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> &lt;触发器名&gt;  </span><br><span class="line">&#123; <span class="keyword">BEFORE</span>| <span class="keyword">AFTER</span>&#125; &lt;触发事件&gt;</span><br><span class="line"><span class="keyword">ON</span>&lt;表名&gt;</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span>  &#123; <span class="keyword">ROW</span> | <span class="keyword">STATEMENT</span> &#125;</span><br><span class="line">［<span class="keyword">WHEN</span>&lt;触发条件&gt;］</span><br><span class="line">&lt;触发动作体&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>触发时机：AFTER 表示 执行条件，有 BEFORE（之前 ） AFTER（之后）</p>
</li>
<li><p>触发事件：INSERT ON 表示在执行了 插入操作 ,有INSERT&#x2F;UPDATE&#x2F;DELETE 三种 </p>
</li>
<li><p>触发者类型：FOR EACH ROW BEGIN 固定语法</p>
<ul>
<li>行级触发器（FOR EACH ROW）</li>
<li>语句级触发器（FOR EACH STATEMENT）【那么执行完该语句后，触发动作只发生一次】</li>
</ul>
</li>
<li><p>触发动作体：是一段程序。如果触发器是行级触发器，则这段程序中还可以使用NEW和OLD分别引用触发事件发生前后的元组值。</p>
</li>
</ul>
<h2 id="激活触发器"><a href="#激活触发器" class="headerlink" title="激活触发器"></a>激活触发器</h2><ul>
<li><p>触发器的执行，由触发事件激活，并由数据库服务器自动执行。</p>
</li>
<li><p>一个数据表上可能定义了多个触发器，同一个表上的多个触发器激活时遵循如下的执行顺序：</p>
<p>​	 （1） 执行该表上的BEFORE触发器；<br>​    （2） 执行激活触发器的SQL语句；<br>​    （3） 执行该表上的AFTER触发器。</p>
</li>
<li><p>有多个触发器时，按创建时间顺序依次执行。</p>
</li>
<li><p>任一触发器的执行失败都将中止整个操作。</p>
</li>
</ul>
<h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><p>删除触发器的SQL语法：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> &lt;触发器名&gt; <span class="keyword">ON</span>&lt;表名&gt;;</span><br></pre></td></tr></table></figure>

<p>触发器必须是一个已经创建的触发器，并且只能由具有相应权限的用户删除。</p>
<p><strong>注意：不同的DBMS对于触发器的支持方式和语法是有所区别的！</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/" class="post-title-link" itemprop="url">数据库_数据库安全性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-01 11:12:26" itemprop="dateCreated datePublished" datetime="2020-04-01T11:12:26Z">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-02 12:23:48" itemprop="dateModified" datetime="2020-06-02T12:23:48Z">2020-06-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库安全性概述"><a href="#数据库安全性概述" class="headerlink" title="数据库安全性概述"></a>数据库安全性概述</h1><p>1.数据库安全性定义数据库的安全性是指保护数据库以防止不合法的使用所造成的数据泄露、更改或破坏。</p>
<p>2.重要性</p>
<ul>
<li><p>数据库的一大特点是数据可以共享</p>
</li>
<li><p>数据共享必然带来数据库的安全性问题</p>
</li>
<li><p>数据库系统中的数据共享不能是无条件的共享</p>
</li>
</ul>
<p>系统的安全保护措施是否有效是数据库系统的主要性能指标之一。</p>
<h2 id="数据库的不安全因素"><a href="#数据库的不安全因素" class="headerlink" title="数据库的不安全因素"></a>数据库的不安全因素</h2><p>1）非授权用户对数据库的恶意存取和破坏</p>
<ul>
<li>安全措施：用户身份鉴别、存取控制、和视图等</li>
</ul>
<p>2）数据库中重要或敏感数据被泄露</p>
<ul>
<li>安全措施：审计、日志、入侵检测、数据加密等</li>
</ul>
<p>3）安全环境的脆弱性，包括：硬件、OS、网络等。</p>
<ul>
<li>可信计算机系统</li>
</ul>
<h2 id="数据库安全技术"><a href="#数据库安全技术" class="headerlink" title="数据库安全技术"></a>数据库安全技术</h2><ul>
<li>用户身份验证</li>
<li>多层存取控制</li>
<li>审计</li>
<li>视图</li>
<li>数据加密等</li>
</ul>
<h3 id="用户身份鉴别"><a href="#用户身份鉴别" class="headerlink" title="用户身份鉴别"></a>用户身份鉴别</h3><ul>
<li>用户标识与鉴别（Identification &amp;  Authentication）：<ul>
<li>系统提供的最外层安全保护措施；</li>
<li>系统提供一定的方式让用户标识自己的名字和身份，系统进行核实，通过鉴定后才提供系统使用权。</li>
</ul>
</li>
<li>常用鉴别方法：<ul>
<li>口令：静态（易被窃取）、动态（一次一密）</li>
<li>生物特征识别：指纹、声音、照片等</li>
<li>智能卡</li>
<li>回答问题</li>
</ul>
</li>
</ul>
<h3 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h3><p>1.什么是存取控制？对于获得上机权的用户还要根据系统预先定义好的外模式（视图）或用户权限进行存取控制，保证用户只能存取他有权存取的数据。</p>
<p>2.方法</p>
<ul>
<li>定义用户权限</li>
<li>合法权限检查</li>
</ul>
<p>3.常用存取控制方法</p>
<ul>
<li>自主存取控制（Discretionary Access Control，DAC），C2级，灵活</li>
<li>强制存取控制（Mandatory Access Control，MAC），B1级，严格</li>
</ul>
<h3 id="视图机制"><a href="#视图机制" class="headerlink" title="视图机制"></a>视图机制</h3><ul>
<li>视图能够把要保密的数据对无权存取这些数据的用户隐藏起来，因此对数据提供一定程度的安全保护。</li>
<li>视图机制间接实现了支持存取谓词的用户权限定义。<br>[例]  建立计算机系学生的视图，把对该视图的SELECT权限授于王平，把该视图上的所有操作权限授于张明。<br>-先建立计算机系学生的视图CS_Student<br>CREATE VIEW CS_Student AS SELECT  *    FROM   Student    WHERE  Sdept&#x3D;’CS’；<br>-在视图上进一步定义存取权限：<br>GRANT  SELECT   ON   CS_Student TO 王平；<br>GRANT ALL PRIVILIGES     ON  CS_Student TO  张明</li>
</ul>
<h3 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h3><ul>
<li><p>审计</p>
<ul>
<li>系统自动建立审计日志，将用户对数据库的所有操作记录在上面。</li>
<li>DBA利用审计日志找出非法存取数据的人、时间和内容。</li>
<li>C2以上安全级别的DBMS必须具有。</li>
</ul>
</li>
<li><p>审计分类</p>
<p>–用户级审计：针对自己创建的数据库表或视图进行审计。<br>记录所有用户对这些表或视图的一切成功和（或）不成功的访问要求以及各种类型的SQL操作 。</p>
<p>–系统级审计：由DBA设置</p>
<ul>
<li><p>监测成功或失败的登录要求；</p>
</li>
<li><p>监测GRANT和REVOKE操作以及其他数据库级权限下的操作。</p>
</li>
</ul>
</li>
</ul>
<h4 id="审计AUDIT语句"><a href="#审计AUDIT语句" class="headerlink" title="审计AUDIT语句"></a>审计AUDIT语句</h4><ul>
<li><p>AUDIT语句：设置审计功能</p>
</li>
<li><p>NOAUDIT语句：取消审计功能</p>
</li>
</ul>
<h3 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h3><ol>
<li>思想<br>数据库中的数据以密码形式存放，使用时由用户设计的解码程序将其转换成用户可读的数据。这样，数据库中的数据即使被窃取，也只能是一些无法辨认的代码。</li>
<li>数据库加密：存储加密、传输加密</li>
<li>数据库加密在哪个层次实现？<ol>
<li>OS层</li>
<li>DBMS内核层</li>
<li>DBMS外层</li>
</ol>
</li>
</ol>
<h2 id="自主存取控制技术"><a href="#自主存取控制技术" class="headerlink" title="自主存取控制技术"></a>自主存取控制技术</h2><h3 id="自主存取控制"><a href="#自主存取控制" class="headerlink" title="自主存取控制"></a>自主存取控制</h3><p><strong>用户“自主”决定将数据的存取权限授予何人、决定是否将“授权”的权限授予别人，称为“自主存取控制”。</strong></p>
<ul>
<li>定义：用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可将其拥有的存取权限转授给其他用户。</li>
<li>用户权限组成要素 ：数据对象、操作类型</li>
<li>授权：定义用户可以在哪些数据库对象上进行哪些类型的操作。</li>
</ul>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/image-20200602200358779.png" style="zoom:67%;" />

<h3 id="授权与回收"><a href="#授权与回收" class="headerlink" title="授权与回收"></a>授权与回收</h3><p>SQL中使用GRANT语句和REVOKE语句来实现自主存取控制。</p>
<h4 id="GRANT语句"><a href="#GRANT语句" class="headerlink" title="GRANT语句"></a>GRANT语句</h4><ul>
<li><p>GRANT语句的一般格式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GRANT<span class="tag">&lt;<span class="name">权限</span>&gt;</span>[,<span class="tag">&lt;<span class="name">权限</span>&gt;</span>]...</span><br><span class="line">[ON<span class="tag">&lt;<span class="name">对象类型</span>&gt;</span> <span class="tag">&lt;<span class="name">对象名</span>&gt;</span>]</span><br><span class="line">TO<span class="tag">&lt;<span class="name">用户</span>&gt;</span>[,<span class="tag">&lt;<span class="name">用户</span>&gt;</span>]...</span><br><span class="line">[WITH GRANT OPTION];</span><br></pre></td></tr></table></figure>


</li>
<li><p>语义：将对指定操作对象的指定操作权限授予指定的用户</p>
<ul>
<li>授权人：DBA、数据库对象创建者、拥有该权限的用户</li>
<li>被授权限的用户： 一个或多个具体用户、PUBLIC（全体用户）</li>
<li>WITH GRANT OPTION子句：指定：可以再授予，没有指定：不能传播</li>
<li>不允许循环授权</li>
</ul>
</li>
</ul>
<h4 id="REVOKE语句"><a href="#REVOKE语句" class="headerlink" title="REVOKE语句"></a>REVOKE语句</h4><ul>
<li><p>授予的权限可以由DBA或其他授权者用REVOKE语句收回。</p>
</li>
<li><p>REVOKE语句的一般格式为：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REVOKE<span class="variable">&lt;权限&gt;</span>[,<span class="variable">&lt;权限&gt;</span>]...</span><br><span class="line">[ON<span class="variable">&lt;对象类型&gt;</span> <span class="variable">&lt;对象名&gt;</span>]</span><br><span class="line">FROM<span class="variable">&lt;用户&gt;</span>[,<span class="variable">&lt;用户&gt;</span>]...[CASCADE |<span class="string"> RESTRICT];</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="创建数据库模式的权限"><a href="#创建数据库模式的权限" class="headerlink" title="创建数据库模式的权限"></a>创建数据库模式的权限</h3><p>DBA在创建用户时，可以创建数据库模式的权限。</p>
<p>CREATE USER语句格式：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">USER</span>  &lt;username&gt; </span><br><span class="line">［<span class="keyword">WITH</span>］［DBA| RESOURCE| <span class="keyword">CONNECT</span>］</span><br></pre></td></tr></table></figure>

<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/image-20200602200936024.png" style="zoom:67%;" />

<h4 id="数据库角色"><a href="#数据库角色" class="headerlink" title="数据库角色"></a>数据库角色</h4><p>被命名的一组与数据库操作相关的权限</p>
<ul>
<li>角色是权限的集合</li>
<li>可以为一组具有相同权限的用户创建一个角色</li>
<li>简化授权的过程</li>
</ul>
<p>1、角色的创建</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE  <span class="keyword">ROLE</span>  <span class="title">&lt;角色名&gt; </span></span><br></pre></td></tr></table></figure>

<p>2、给角色授权</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT<span class="tag">&lt;<span class="name">权限</span>&gt;</span>［，<span class="tag">&lt;<span class="name">权限</span>&gt;</span>］... </span><br><span class="line">ON<span class="tag">&lt;<span class="name">对象类型</span>&gt;</span>对象名</span><br><span class="line">TO<span class="tag">&lt;<span class="name">角色</span>&gt;</span>［，<span class="tag">&lt;<span class="name">角色</span>&gt;</span>］...</span><br></pre></td></tr></table></figure>

<p>3、将一个角色授予其他的角色或用户</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT<span class="tag">&lt;<span class="name">角色1</span>&gt;</span>［，<span class="tag">&lt;<span class="name">角色2</span>&gt;</span>］...</span><br><span class="line">TO<span class="tag">&lt;<span class="name">角色3</span>&gt;</span>［，<span class="tag">&lt;<span class="name">用户1</span>&gt;</span>］... </span><br><span class="line">［WITH ADMIN OPTION］</span><br></pre></td></tr></table></figure>

<p>4、角色权限收回</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REVOKE<span class="tag">&lt;<span class="name">权限</span>&gt;</span>［，<span class="tag">&lt;<span class="name">权限</span>&gt;</span>］...</span><br><span class="line">ON<span class="tag">&lt;<span class="name">对象类型</span>&gt;</span> <span class="tag">&lt;<span class="name">对象名</span>&gt;</span></span><br><span class="line">FROM<span class="tag">&lt;<span class="name">角色</span>&gt;</span>［，<span class="tag">&lt;<span class="name">角色</span>&gt;</span>］...</span><br></pre></td></tr></table></figure>

<p>示例如下：</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/image-20200602201218195.png" style="zoom:67%;" />

<h3 id="自主存取控制缺点"><a href="#自主存取控制缺点" class="headerlink" title="自主存取控制缺点"></a>自主存取控制缺点</h3><ul>
<li>可能存在数据的“无意泄露”</li>
<li>原因：这种机制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记</li>
</ul>
<h2 id="强制存取控制机制"><a href="#强制存取控制机制" class="headerlink" title="强制存取控制机制"></a>强制存取控制机制</h2><p>对系统控制下的所有主客体赋予安全性标记，系统根据标记安全策略，实施强制存取控制</p>
<p>强制存取控制（MAC)</p>
<ul>
<li>保证更高程度的安全性</li>
<li>用户不能直接感知或进行控制</li>
<li>适用于对数据有严格而固定密级分类的部门<ul>
<li>军事部门</li>
<li>政府部门</li>
</ul>
</li>
</ul>
<h3 id="强制存取控制方法"><a href="#强制存取控制方法" class="headerlink" title="强制存取控制方法"></a>强制存取控制方法</h3><ul>
<li>主体是系统中的活动实体<ul>
<li>DBMS所管理的实际用户</li>
<li>代表用户的各进程</li>
</ul>
</li>
<li>客体是系统中的被动实体，是受主体操纵的<ul>
<li>文件、基表、索引、视图</li>
</ul>
</li>
<li>敏感度标记（Label）<ul>
<li>绝密（Top Secret）&gt;  机密（Secret）&gt;  可信（Confidential）&gt; 公开（Public）</li>
</ul>
</li>
<li>主体的敏感度标记称为许可证级别（Clearance Level）</li>
<li>客体的敏感度标记称为密级（Classification Level）</li>
<li>强制存取控制就是通过对比主体的许可证级别和客体的密级，最终确定主体能否存取客体。</li>
</ul>
<p><strong>主体可更新密级高于他的客体</strong></p>
<h3 id="强制存取控制规则"><a href="#强制存取控制规则" class="headerlink" title="强制存取控制规则"></a>强制存取控制规则</h3><ul>
<li>强制存取控制规则：<ol>
<li>仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体</li>
<li>仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体</li>
</ol>
</li>
<li>规则的关键点：<br><strong>禁止拥有高许可证级别的主体更新低密级的数据对象</strong></li>
</ul>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/image-20200602201608002.png" style="zoom:80%;" />

<h3 id="强制存取控制的优点"><a href="#强制存取控制的优点" class="headerlink" title="强制存取控制的优点"></a>强制存取控制的优点</h3><ul>
<li>禁止拥有高许可证级别的主体更新低密级的数据对象，从而保证了敏感数据的可靠性；</li>
<li>禁止低许可证级别的主体浏览高密级的数据，避免了敏感数据的泄漏；</li>
<li>MAC对数据本身进行密级标记，无论数据如何复制，标记与数据是不可分割的整体。只有符合密级标记要求的用户才可以操作相应数据，提高了安全性级别。</li>
</ul>
<h3 id="强制存取控制方法-1"><a href="#强制存取控制方法-1" class="headerlink" title="强制存取控制方法"></a>强制存取控制方法</h3><ul>
<li>DAC与MAC共同构成DBMS的安全机制</li>
<li>实现MAC时要首先实现DAC<ul>
<li>原因：较高安全性级别提供的安全保护要包含较低级别的所有保护</li>
</ul>
</li>
<li>先进行DAC检查，通过DAC检查的数据对象再由系统进行MAC检查，只有通过MAC检查的数据对象方可存取。</li>
</ul>
<p>数据库安全机制的设计目标：试图破坏安全的人所花费的代价 &gt;&gt; 得到的利益</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">数据库_关系数据库SQL语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-01 11:12:12" itemprop="dateCreated datePublished" datetime="2020-04-01T11:12:12Z">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-25 06:46:32" itemprop="dateModified" datetime="2022-04-25T06:46:32Z">2022-04-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SQL语言概述"><a href="#SQL语言概述" class="headerlink" title="SQL语言概述"></a>SQL语言概述</h1><p>SQL语言是面向集合的非过程化的语言。是介于关系代数和关系演算之间的标准查询语言。</p>
<p>集数据定义语言DDL、数据操纵语言DML、数据控制语言DCL功能于一体。</p>
<p>核心功能：9个动词</p>
<ul>
<li><p>数据查询：SELECT（最为复杂的操作）</p>
</li>
<li><p>数据定义：CREATE（创建）、DROP（删除）、ALTER（更新）</p>
</li>
<li><p>数据操纵DML：INSERT、UPDATE、DELETE</p>
</li>
<li><p>数据控制DCL：GRANT（授权）、REVOKE（撤销，回收权限）</p>
</li>
<li><p>基本概念：</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/20220421104803.png"></p>
</li>
</ul>
<h1 id="数据定义概述"><a href="#数据定义概述" class="headerlink" title="数据定义概述"></a>数据定义概述</h1><p>数据定于语言DDL：是SQL中提供给用户定义DBMS支持的抽象对象的SQL语句。</p>
<p>DBMS支持4种抽象对象：模式、表、视图、索引</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/20220421104825.png"></p>
<p>一个RDBMS的实例中，可建立多个数据库；</p>
<p>一个数据库中可以建立多个外模式，只有一个内模式；</p>
<p>一个模式下可以建立多个表、视图和索引等数据库对象</p>
<h2 id="基本表的定义、修改和删除"><a href="#基本表的定义、修改和删除" class="headerlink" title="基本表的定义、修改和删除"></a>基本表的定义、修改和删除</h2><h3 id="定义基本表"><a href="#定义基本表" class="headerlink" title="定义基本表"></a>定义基本表</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE<span class="tag">&lt;<span class="name">表名</span>&gt;</span>（<span class="tag">&lt;<span class="name">列名</span>&gt;</span> <span class="tag">&lt;<span class="name">数据类型</span>&gt;</span>[ <span class="tag">&lt;<span class="name">列级完整性约束条件</span>&gt;</span> ][，<span class="tag">&lt;<span class="name">列名</span>&gt;</span> <span class="tag">&lt;<span class="name">数据类型</span>&gt;</span>[ <span class="tag">&lt;<span class="name">列级完整性约束条件</span>&gt;</span>]]...[，<span class="tag">&lt;<span class="name">表级完整性约束条件</span>&gt;</span> ]）；</span><br></pre></td></tr></table></figure>

<p>可以加多个列级完整性约束条件。</p>
<p><strong>根据已有的表创建新表：</strong><br><strong>A：create table tab_new like tab_old (使用旧表创建新表)</strong><br><strong>B：create table tab_new as select col1,col2… from tab_old definition only</strong></p>
<h4 id="模式和表"><a href="#模式和表" class="headerlink" title="模式和表"></a>模式和表</h4><ul>
<li>每一个基本表都属于某一个模式，一个模式包含多个基本表</li>
<li>定义基本表所属模式：<ul>
<li>方法一：在表名中明显地给出模式名<br>CREATE TABLE S-T.Student（……）; &#x2F;<em>模式名为S-T</em>&#x2F;</li>
<li>方法二：在创建模式语句中同时创建表<br>CREATE SCHEMA S-T AUTHORIZATION WANG<br>CREATE TABLE  Student（……）;</li>
</ul>
</li>
</ul>
<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>&lt;表名&gt;</span><br><span class="line">[ <span class="keyword">ADD</span>&lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ]  ]</span><br><span class="line">[ <span class="keyword">DROP</span>[<span class="keyword">COLUMN</span>]&lt;列名&gt; [<span class="keyword">CASCADE</span>|<span class="keyword">RESTRICT</span>]]</span><br><span class="line">[<span class="keyword">ADD</span>&lt;表级完整性约束名&gt; ] </span><br><span class="line">[<span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span>&lt;完整性约束名&gt; [<span class="keyword">CASCADE</span>|<span class="keyword">RESTRICT</span>]] </span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span>&lt;列名&gt; &lt;数据类型&gt; ]；</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;新增加的列一律为空值。</p>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> &lt;表名&gt;［<span class="keyword">RESTRICT</span>| <span class="keyword">CASCADE</span>］;</span><br></pre></td></tr></table></figure>

<p>RESTRICT：删除表是有限制的。欲删除的基本表不能被其他表的约束所引用，如果存在依赖该表的对象，则此表不能被删除</p>
<p>CASCADE：删除该表没有限制。在删除基本表的同时，相关的依赖对象一起删除</p>
<h1 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h1><p>基本语法：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">SELECT</span> <span class="built_in">A1</span>,<span class="built_in">A2</span>··· FROM <span class="built_in">R1</span>,<span class="built_in">R2</span>··· WHERE F</span><br></pre></td></tr></table></figure>

<p>这里R1,…,Rm为关系，F是公式，A1,…,An为属性。</p>
<p>完整语法：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>[<span class="keyword">ALL</span>|<span class="keyword">DISTINCT</span>]&lt;目标列表达式&gt;[，&lt;目标列表达式&gt;]...</span><br><span class="line"><span class="keyword">FROM</span> &lt;表名或视图名&gt;[，&lt;表名或视图名&gt; ] ...</span><br><span class="line">[<span class="keyword">WHERE</span>&lt;条件表达式&gt;]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span>&lt;列名<span class="number">1</span>&gt;[<span class="keyword">HAVING</span>&lt;条件表达式&gt;] ]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span>&lt;列名<span class="number">2</span>&gt;[ <span class="keyword">ASC</span>|<span class="keyword">DESC</span> ] ]；</span><br></pre></td></tr></table></figure>

<ul>
<li>SELECT子句，投影运算，选择表中的若干列；</li>
<li>WHERE子句，行筛选条件，选择表中的若干行；</li>
<li>GROUP子句，分组运算；</li>
<li>HAVING子句，分组条件；</li>
<li>ORDER子句，排序计算。</li>
</ul>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/20220421104843.png"></p>
<h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><ul>
<li><p>消除重复元组Distinct</p>
</li>
<li><p>where子句：如何从表中选择指定元组？</p>
<ul>
<li><p>对应于关系代数运算σ<del>P</del>，SQL提供WHERE子句解决表元组的选择。</p>
</li>
<li><p>格式：WHERE &lt;条件表达式&gt;【&lt;条件表达式&gt;是包含属性名的逻辑表达式P】</p>
</li>
<li><p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/20220421104857.png"></p>
</li>
<li><p>范围查询：</p>
<ul>
<li>比较运算符：&#x3D;、&lt;、&gt;、&gt;&#x3D;、&lt;&#x3D;、!&#x3D;、&lt;&gt;、!&gt;、!</li>
<li>&lt;确定范围：BETWEEN …  AND  …NOT BETWEEN  …  AND  …</li>
</ul>
</li>
<li><p>集合查询：</p>
<ul>
<li>x IN &lt;值表&gt;,  x NOT IN &lt;值表&gt;</li>
</ul>
</li>
<li><p>字符匹配查询：</p>
<ul>
<li><p>[NOT]LIKE‘&lt;匹配串&gt;’[ESCAPE‘ &lt;换码字符&gt;’]</p>
<p>查找指定的属性列值与&lt;匹配串&gt;相匹配的元组。&lt;匹配串&gt;可以是一个完整的字符串，也可以含有通配符。<br>通配符：SQL规定符号百分号%及下划线__ 具有其他含义:<br>百分号%：代表任意长度的字符串<br>下划线__ ：代表任意一个字符<br>ESCAPE：是将百分号% 或下划线__转回其本意</p>
</li>
</ul>
</li>
<li><p>涉及空值查询：</p>
<ul>
<li>IS NULL 或IS NOT NULL</li>
</ul>
</li>
<li><p>多重条件查询：</p>
<ul>
<li>逻辑运算符：AND和OR可以用来将多个简单查询条件复合成更加复杂的条件</li>
<li>优先级：NOT&gt;AND&gt;OR</li>
</ul>
</li>
</ul>
</li>
<li><p>Order By子句：将查询结果的元组按照一个或多个属性列的排列次序显示</p>
<ul>
<li>格式：SELECT 块 ORDER BY 子句；<br>其中，ORDER BY子句可以按一个或多个属性列排序；<br>每列可选择：升序：ASC；降序：DESC；缺省值为升序</li>
</ul>
</li>
</ul>
<h3 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h3><p>函数只是将取出的数据进行处理，不会改变数据库中的值。</p>
<h4 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h4><p>1、字符函数</p>
<table>
<thead>
<tr>
<th align="center">函 数</th>
<th>功 能</th>
<th>示 例</th>
<th>结 果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">INITCAP  (char)</td>
<td>首字母大写</td>
<td>initcap  (‘hello’)</td>
<td>Hello</td>
</tr>
<tr>
<td align="center">LOWER  (char)</td>
<td>转换为小写</td>
<td>lower (‘FUN’)</td>
<td>fun</td>
</tr>
<tr>
<td align="center">UPPER  (char)</td>
<td>转换为大写</td>
<td>upper (‘sun’)</td>
<td>SUN</td>
</tr>
<tr>
<td align="center">LTRIM  (char, set)</td>
<td>左剪裁</td>
<td>ltrim (‘xyzadams’,  ‘xyz’)</td>
<td>adams</td>
</tr>
<tr>
<td align="center">RTRIM  (char, set)</td>
<td>右剪裁</td>
<td>rtrim (‘xyzadams’,  ‘ams’)</td>
<td>xyzad</td>
</tr>
<tr>
<td align="center">TRANSLATE  (char, from, to)</td>
<td>按字符翻译</td>
<td>translate (‘jack’, ‘abcd’,  ‘1234’)</td>
<td>j13k</td>
</tr>
<tr>
<td align="center">REPLACE  (char, search_str, replace_str)</td>
<td>字符串替换</td>
<td>replace (‘jack andjue’,  ‘j’, ‘bl’)</td>
<td>black and blue</td>
</tr>
<tr>
<td align="center">INSTR  (char, substr[, pos])</td>
<td>查找子串位置</td>
<td>instr  (‘worldwide’, ‘d’)</td>
<td>5</td>
</tr>
<tr>
<td align="center">SUBSTR  (char, pos, len)</td>
<td>取子字符串</td>
<td>substr  (‘abcdefg’,3,2)</td>
<td>cd</td>
</tr>
<tr>
<td align="center">CONCAT  (char1, char2)</td>
<td>连接字符串</td>
<td>concat  (‘Hello’, ‘world’)</td>
<td>Helloworld</td>
</tr>
</tbody></table>
<h4 id="多行函数"><a href="#多行函数" class="headerlink" title="多行函数"></a>多行函数</h4><p>1、SQL支持聚集函数来解决求集合特征值问题：如该集合的个数、最小值等</p>
<p><strong>集函数只能用于SELECT子句和HAVING子句中</strong></p>
<p>2、GROUP BY子句：将一个查询结果集合进行分组</p>
<ul>
<li>GROUP BY A1，A2，…,An（其中：Ai为属性名）【按指定的一列或多列，对一个SELECT块按值分组，值相等的为一组】</li>
</ul>
<p>3、HAVING子句：使用限定条件选择部分分组，则可以使用HAVING子句</p>
<p><strong>注意：HAVING短语与WHERE子句的区别：</strong><br><strong>– WHERE子句作用于基表或视图，从中选择满足条件的元组</strong><br><strong>– HAVING短语作用于组，从中选择满足条件的组。</strong></p>
<h2 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a>多表连接查询</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SQL1999规范中规定的连接查询语法</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 字段列表</span><br><span class="line"><span class="keyword">from</span> table1</span><br><span class="line">[<span class="keyword">cross</span> <span class="keyword">join</span> table2] |                                    //<span class="number">1</span>：交叉连接</span><br><span class="line">[<span class="keyword">natural</span> <span class="keyword">join</span> table2] |                                  //<span class="number">2</span>：自然连接</span><br><span class="line">[<span class="keyword">join</span> table2 <span class="keyword">using</span> (字段名)] |                      //<span class="number">3</span>：<span class="keyword">using</span>子句</span><br><span class="line">[<span class="keyword">join</span> table2 <span class="keyword">on</span> (table1.<span class="built_in">column_name</span> </span><br><span class="line">	= table2.<span class="built_in">column_name</span>)] |      //<span class="number">4</span>：<span class="keyword">on</span>子句</span><br><span class="line">[(left | right | <span class="keyword">full</span> <span class="keyword">outer</span>) <span class="keyword">join</span> table2</span><br><span class="line"><span class="keyword">on</span> (table1.<span class="built_in">column_name</span> = table2.<span class="built_in">column_name</span>)]; //<span class="number">5</span>：左/右/满外连接</span><br></pre></td></tr></table></figure>

<ul>
<li>合并：FROM</li>
<li>选择：WHERE</li>
<li>投影：SELECT</li>
</ul>
<h2 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h2><p>两种连接表示方法：</p>
<p>1、在FROM子句中指明进行连接的表名，在WHERE子句中指明连接的列名及其连接条件</p>
<p>2、利用关键字JOIN进行连接，通过关键词ON与JOIN相对应，指明连接条件。具体分为以下几种：</p>
<h3 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h3><ul>
<li>Cross join产生了一个笛卡尔集，其效果等同于在两个表进行连接时未使用WHERE子句限定连接条件;</li>
<li>可以使用where条件从笛卡尔集中选出满足条件的记录。</li>
</ul>
<p>用法举例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="operator">!</span><span class="comment">--两张表连接--&gt;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp,dept </span><br><span class="line">	<span class="keyword">where</span> emp.deptno<span class="operator">=</span>dept.deptno</span><br><span class="line"><span class="comment">--等价于</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">cross</span> <span class="keyword">join</span> dept</span><br><span class="line">	<span class="keyword">where</span> emp.deptno<span class="operator">=</span>dept.deptno</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">!</span><span class="comment">--三张表连接--&gt;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp,dept,salgrade </span><br><span class="line">	<span class="keyword">where</span> emp.deptno<span class="operator">=</span>dept.deptno <span class="keyword">and</span></span><br><span class="line">	(emp.sal<span class="operator">&gt;</span>salgrade.lostl <span class="keyword">and</span> emp.sal<span class="operator">&lt;</span>salgrade.hisal)</span><br><span class="line"><span class="comment">--等价于</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp &quot;E&quot; </span><br><span class="line">	<span class="keyword">cross</span> <span class="keyword">join</span> dept &quot;D&quot; </span><br><span class="line">	<span class="keyword">cross</span> <span class="keyword">join</span> salgrade &quot;S&quot;</span><br><span class="line">	<span class="keyword">where</span> &quot;E&quot;.deptno<span class="operator">=</span>&quot;D&quot;.deptno <span class="keyword">and</span></span><br><span class="line">	(&quot;E&quot;.sal<span class="operator">&gt;</span>&quot;S&quot;.lostl <span class="keyword">and</span> &quot;E&quot;.sal<span class="operator">&lt;</span>&quot;S&quot;.hisal)</span><br></pre></td></tr></table></figure>

<h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><ul>
<li>Natural join基于两个表中的全部同名列建立连接（连接两个table之后，两个table共用的属性就会合并在一起）</li>
<li>如果连个table没有共有的属性，则进行笛卡尔乘积，也就是进行两两相乘，如果table 1有3行，table 2有4行，自然连接后就有12行。<ul>
<li>从两个表中选出同名列的值均对应相等的所有行</li>
<li>如果两个表中同名列的数据类型不同，则出错</li>
<li>不允许在参照列上使用表名或者别名作为前缀</li>
<li>自然连接的结果不保留重复的属性</li>
</ul>
</li>
</ul>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> empno, ename, sal, deptno, dname</span><br><span class="line"><span class="keyword">from</span> emp <span class="keyword">natural</span> <span class="keyword">join</span> dept</span><br><span class="line"><span class="keyword">where</span> deptno <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Using子句"><a href="#Using子句" class="headerlink" title="Using子句"></a>Using子句</h3><blockquote>
<p>using等价于join操作中的on</p>
</blockquote>
<ul>
<li><p>使用using必须满足如下两个条件：</p>
<ol>
<li><p>查询必须是等值连接。</p>
</li>
<li><p>等值连接中的列必须具有相同的名称和数据类型。</p>
</li>
</ol>
</li>
<li><p>using子句引用的列在sql任何地方不能使用表名或者别名做前缀。</p>
</li>
<li><p>可以在using子句中指定多个列名</p>
</li>
</ul>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> my_test_user a , my_test_teacher b <span class="keyword">where</span> a.userid <span class="operator">=</span> b.userid;</span><br><span class="line"><span class="operator">=</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> my_test_user <span class="keyword">inner</span> <span class="keyword">join</span> my_test_teacher <span class="keyword">using</span>(userid);</span><br></pre></td></tr></table></figure>

<h3 id="join连接"><a href="#join连接" class="headerlink" title="join连接"></a>join连接</h3><p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/20220421161942.png" alt="img"></p>
<ul>
<li>INNER JOIN：返回符合连接条件的记录；</li>
<li>LEFT [OUTER] JOIN：返回符合连接条件的数据行以及左边表中不符合条件的数据行，此时右边数据行以NULL来显示，称为左连接；</li>
<li>RIGHT  [OUTER]  JOIN：返回符合连接条件的数据行以及右边表中不符合条件的数据行，此时左边数据行以NULL来显示，称为右连接；</li>
<li>FULL  [OUTER]  JOIN：返回符合连接条件的数据行以及左边表和右边表中不符合条件的数据行，此时缺乏数据的数据行会以NULL来显示</li>
</ul>
<h3 id="on子句"><a href="#on子句" class="headerlink" title="on子句"></a>on子句</h3><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><p>LEFT  JOIN、RIGHT  JOIN与  FULL  JOIN统称为外连接。可用来显示不满足连接条件的元组。某些查询要求只能用外连接来表达</p>
<h2 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h2><p>一个SELECT-FROM-WHERE语句称为一个查询块；将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询，相当于在SELECT中调用另一段SELECT。</p>
<ul>
<li><strong>子查询不能使用ORDER BY子句；</strong></li>
<li><strong>层层嵌套方式反映了SQL语言的结构化；</strong></li>
<li><strong>有些嵌套查询可以用连接运算替代</strong></li>
<li>AS的作用是起别名</li>
</ul>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><ul>
<li>特点<ul>
<li>子查询在主查询前执行一次</li>
<li>主查询使用子查询的结果</li>
</ul>
</li>
<li><strong>使用子查询注意事项</strong><ul>
<li>在查询是基于未知值时应考虑使用子查询</li>
<li>子查询必须包含在括号内 </li>
<li>建议将子查询放在比较运算符的右侧，以增强可读性。</li>
<li>除非进行Top-N 分析，否则不要在子查询中使用ORDER BY 子句。</li>
<li>如果子查询返回单行结果，则为单行子查询，可以在主查询中对其使用相应的单行记录比较运算符</li>
<li>如果子查询返回多行结果，则为多行子查询，此时不允许对其使用单行记录比较运算符</li>
</ul>
</li>
</ul>
<h4 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a>单行子查询</h4><ul>
<li>单行子查询只返回一行记录</li>
<li>对单行子查询可使用单行记录比较运算符</li>
<li>&lt; 、 &gt; 、 &#x3D; 、 &gt;&#x3D;、 &lt;&#x3D; 、 &lt;&gt;</li>
</ul>
<h4 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a>多行子查询</h4><ul>
<li><p>多行子查询返回多行记录</p>
</li>
<li><p>对多行子查询只能使用多行记录比较运算符</p>
<ul>
<li>ALL 和子查询返回的所有值比较</li>
<li>ANY 和子查询返回的任意一个值比较</li>
<li>IN 等于列表中的任何一个</li>
</ul>
</li>
</ul>
<h4 id="带EXISTS谓词的子查询"><a href="#带EXISTS谓词的子查询" class="headerlink" title="带EXISTS谓词的子查询"></a>带EXISTS谓词的子查询</h4><p>EXISTS：本质上是一个返回值为“真”&#x2F;“假”的集函数，用于判断一个集合是否为空。<br>EXISTS（R），R为非空则返回真。</p>
<p>NOT EXISTS：语义与EXISTS函数相反的逻辑函数。</p>
<p>带EXISTS的子查询的用法：</p>
<p>1.不同形式的查询间的替换:带IN谓词、比较运算符、ANY和ALL谓词的子查询 与 带EXISTS谓词的子查询 等价替换</p>
<p>2.用EXISTS&#x2F;NOT EXISTS实现全称量词(难点)</p>
<p>3.用EXISTS&#x2F;NOT EXISTS实现逻辑蕴函(难点)</p>
<p>作用：<strong>把带有全称量词的谓词转换为等价的带有存在量词的谓词</strong></p>
<h1 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO <span class="variable">&lt;表名&gt;</span> [(<span class="variable">&lt;属性列1&gt;</span>[,<span class="variable">&lt;属性列2&gt;</span>]...)]</span><br><span class="line">VALUES （<span class="variable">&lt;常量1&gt;</span>[,<span class="variable">&lt;常量2&gt;</span>]....）</span><br><span class="line">|<span class="string"> SELECT子查询；</span></span><br></pre></td></tr></table></figure>

<p>INTO子句 属性列的顺序可与表定义中的顺序不一致，可以不指定或指定部分属性列</p>
<p>VALUES子句 提供的值必须与INTO子句匹配</p>
<h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE<span class="tag">&lt;<span class="name">表名</span>&gt;</span> </span><br><span class="line">SET<span class="tag">&lt;<span class="name">列名</span>&gt;</span>=<span class="tag">&lt;<span class="name">表达式</span>&gt;</span>[, <span class="tag">&lt;<span class="name">列名</span>&gt;</span>=<span class="tag">&lt;<span class="name">表达式</span>&gt;</span>]...</span><br><span class="line">[WHERE<span class="tag">&lt;<span class="name">条件</span>&gt;</span>]；</span><br></pre></td></tr></table></figure>

<p>SET子句给出&lt;表达式&gt;的值用于取代相应的属性列值。</p>
<p>省略WHERE子句，则表示要修改表中的所有元组。</p>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> </span><br><span class="line"><span class="keyword">FROM</span>&lt;表名&gt;</span><br><span class="line">[<span class="keyword">WHERE</span>&lt;条件&gt;]；</span><br></pre></td></tr></table></figure>

<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><ul>
<li>视图的特点：<ul>
<li>是从一个或几个基本表（或视图）导出的表，是虚表</li>
<li>数据库只存放视图的定义，不存放视图对应的数据</li>
<li>基表中的数据发生变化，从视图中查询出的数据也随之改变</li>
</ul>
</li>
<li>基于视图的操作：<ul>
<li>查询</li>
<li>删除</li>
<li>定义基于该视图的新视图</li>
<li>受限更新</li>
</ul>
</li>
</ul>
<h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><p>创建视图语句格式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE  VIEW <span class="tag">&lt;<span class="name">视图名</span>&gt;</span>  [(<span class="tag">&lt;<span class="name">列名</span>&gt;</span>  [，<span class="tag">&lt;<span class="name">列名</span>&gt;</span>]...)]</span><br><span class="line">AS<span class="tag">&lt;<span class="name">子查询</span>&gt;</span></span><br><span class="line">[WITH  CHECKOPTION]；</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li>组成视图的属性列名：全部省略或全部指定</li>
<li>子查询是否可含有ORDER BY子句和DISTINCT短语，取决于具体系统的实现。</li>
<li>WITH CHECK OPTION表示对视图进行增删改时要保证删除、插入、更新的行满足视图定义中的谓词条件（即子查询中的条件表达式）。</li>
</ul>
<h2 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h2><p>删除视图语句格式：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span>  <span class="keyword">VIEW</span>  &lt;视图名&gt; [<span class="keyword">CASCADE</span>]；</span><br></pre></td></tr></table></figure>

<p>从数据字典中删除指定的视图定义。</p>
<ul>
<li>如果该视图上还导出了其他视图，使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除</li>
<li>删除基表时，由该基表导出的所有视图定义都必须显式删除</li>
</ul>
<h2 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h2><p>RDBMS采用视图消解法实现视图查询。</p>
<h2 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h2><p>视图不实际存储数据，因此，对视图的更新最终要转换为对基本表的更新。为防止用户通过视图更新，对不属于视图范围内的基本表数据进行更新操作，在定义视图时加上WITH   CHECK   OPTION操作。</p>
<ul>
<li>一般RDBMS允许对行列子集视图进行更新</li>
<li>对其他类型视图的更新不同系统有不同限制</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>视图能够简化用户的操作</li>
<li>视图使用户能以多种角度看待同一数据</li>
<li>视图对重构数据库提供了一定程度的逻辑独立性</li>
<li>视图能够对机密数据提供安全保护</li>
<li>适当的利用视图可以更清晰的表达查询</li>
</ul>
<h1 id="key、index、primary-key和unique-key"><a href="#key、index、primary-key和unique-key" class="headerlink" title="key、index、primary key和unique key"></a>key、index、primary key和unique key</h1><p>[参考文章](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zjfjava/p/6922494.html">https://www.cnblogs.com/zjfjava/p/6922494.html</a></p>
<h1 id="SQL-约束（Constraints）"><a href="#SQL-约束（Constraints）" class="headerlink" title="SQL 约束（Constraints）"></a>SQL 约束（Constraints）</h1><p>SQL 约束用于规定表中的数据规则。</p>
<p>如果存在违反约束的数据行为，行为会被约束终止。</p>
<p>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</p>
<h1 id="SQL-CREATE-TABLE-CONSTRAINT-语法"><a href="#SQL-CREATE-TABLE-CONSTRAINT-语法" class="headerlink" title="SQL CREATE TABLE + CONSTRAINT 语法"></a>SQL CREATE TABLE + CONSTRAINT 语法</h1><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name</span><br><span class="line">(</span><br><span class="line">column_name1 data<span class="constructor">_type(<span class="params">size</span>)</span> constraint_name,</span><br><span class="line">column_name2 data<span class="constructor">_type(<span class="params">size</span>)</span> constraint_name,</span><br><span class="line">column_name3 data<span class="constructor">_type(<span class="params">size</span>)</span> constraint_name,</span><br><span class="line">....</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在 SQL 中，我们有如下约束：</p>
<ul>
<li><strong>NOT NULL</strong> - 指示某列不能存储 NULL 值。</li>
<li><strong>UNIQUE</strong> - 保证某列的每行必须有唯一的值。</li>
<li><strong>PRIMARY KEY</strong> - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>
<li><strong>FOREIGN KEY</strong> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li>
<li><strong>CHECK</strong> - 保证列中的值符合指定的条件。</li>
<li><strong>DEFAULT</strong> - 规定没有给列赋值时的默认值。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">数据库_关系数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-01 11:11:23" itemprop="dateCreated datePublished" datetime="2020-04-01T11:11:23Z">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-01 08:56:32" itemprop="dateModified" datetime="2020-06-01T08:56:32Z">2020-06-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="关系模型概述"><a href="#关系模型概述" class="headerlink" title="关系模型概述"></a>关系模型概述</h1><p>关系数据理论是建立在<strong>集合代数理论基础上</strong>的，有着坚实的数学基础</p>
<ul>
<li>数据结构：二维表</li>
<li>关系操作：<ul>
<li>增加(insert)、删除(delete)、修改(updated)</li>
<li>查询(Query):•选择(select)、投影(project)、连接(join)<ul>
<li>除(divide)、并(union)、交(intersection)</li>
<li>差(difference)</li>
</ul>
</li>
<li>关系代数，关系演算，SQL</li>
</ul>
</li>
<li>关系的三类完整性约束：<ul>
<li>实体完整性、参照完整性、用户自定义的完整性</li>
</ul>
</li>
</ul>
<blockquote>
<p>关系代数是用对关系的运算来表达查询要求的方式。</p>
<p>关系演算是用谓词表达查询要求的方式。</p>
<ul>
<li>按谓词变元的基本对象是元组变量还是域变量分为元组关系演算和域关系演算</li>
</ul>
</blockquote>
<h2 id="关系数据结构"><a href="#关系数据结构" class="headerlink" title="关系数据结构"></a>关系数据结构</h2><ul>
<li><p>域</p>
<ul>
<li>域是一组具有相同数据类型的值的集合</li>
</ul>
</li>
<li><p>笛卡儿积</p>
<ul>
<li><p>一组域D<del>1</del> , D<del>2</del> ,…, D<del>n</del>的笛卡尔积为：D<del>1</del>×D<del>2</del>×…×D<del>n</del>&#x3D; {(d<del>1</del> , d<del>2</del> , … , d<del>n</del>) | d<del>i</del>∈D<del>i</del>, i&#x3D;1,…,n}</p>
</li>
<li><p>笛卡尔积的每个元素(d<del>1</del> , d<del>2</del> , … , d<del>n</del>)称作一个n-元组（n-tuple）</p>
</li>
<li><p>元组的每一个值d<del>i</del>叫做一个分量（Component）</p>
</li>
<li><p>若D<del>i</del>的基数（元组个数）为m<del>i</del>，则笛卡尔积的基数为<br>$$<br>\prod^n_{i&#x3D;1}m_i<br>$$</p>
<blockquote>
<p>一个域允许的不同取值个数称为这个域的基数</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>笛卡儿积可以表示成一张二维表。表中的每行对应一个元组，表中的每一列的值来自一个域。</p>
<ul>
<li><p>关系</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200401153303890.png" style="zoom:50%;" />

<ul>
<li><p>笛卡尔积D<del>1</del>×D<del>2</del>×…×D<del>n</del>的子集叫做在域D<del>1</del> , D<del>2</del> ,…, D<del>n</del>上的关系，用R(D<del>1</del> , D<del>2</del> ,…, D<del>n</del>)表示</p>
</li>
<li><p>R是关系的名字，n是关系的度或目</p>
<blockquote>
<p>当n&#x3D;1时，称该关系为单元关系</p>
</blockquote>
</li>
<li><p>关系是笛卡尔积中有意义的子集，关系中的每个元素是关系中的元组</p>
<blockquote>
<p>一般来说，笛卡儿积是没有实际语义的，只有它的某个真子集才有实际含义</p>
</blockquote>
</li>
<li><p>关系也可以表示为二维表</p>
</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li>关系中不同列可以对应相同的域，为了加以区分，必须对每列起一个名字，称为属性</li>
<li>n目关系必有n个属性</li>
</ul>
</li>
</ul>
<h3 id="关系数据结构-1"><a href="#关系数据结构-1" class="headerlink" title="关系数据结构"></a>关系数据结构</h3><p>关系的性质</p>
<ul>
<li>列是同质的；即每一列中的分量是同一类型的数据，来自同一个域。</li>
<li>行列的顺序无关紧要；行列的次序是可以任意交换的</li>
<li>任意两个元组不能完全相同</li>
<li>每一分量必须是不可再分的数据</li>
<li>不同的属性，属性名不能相同</li>
</ul>
<p>候选码（Candidate Key）</p>
<ul>
<li><strong>关系中的一个属性组，其值能唯一标识一个元组</strong>。若从属性组中去掉任何一个属性，它就不具有这一性质了，这样的属性组称作候选码如DEPT中的D#，DN都可作为候选码</li>
<li>任何一个候选码中的属性称作主属性如SC中的S#，C#</li>
</ul>
<p>主码（Primary Key）</p>
<ul>
<li>若一个关系有多个候选码，则选定其中一个作为主码如可选定D#作为DEPT的主码</li>
</ul>
<p>外码（Foreign Key）</p>
<ul>
<li>关系R中的一个属性组，它不是R的码，但它与另一个关系S的码相对应，则称这个属性组为R的外码<br>如S关系中的D#属性</li>
</ul>
<h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><p>形式化的表示为R(U,D,DOM,F)</p>
<blockquote>
<p>R为关系名，U为组成该关系的属性名集合；D为U中属性所来自的域；DOM为属性向域的映象集合；F为属性间数据的依赖关系集合。</p>
</blockquote>
<ul>
<li>关系的描述称作关系模式，包括关系名、关系中的属性名、属性向域的映象、属性间的数据依赖关系等，记作R(A<del>1</del> , A<del>2</del> ,…, A<del>n</del> ) </li>
<li>属性向域的映象一般直接说明为属性的类型、长度等</li>
<li>某一时刻对应某个关系模式的内容(元组的集合)称作关系</li>
<li>关系模式是型，是稳定的<br>关系是某一时刻的值，是随时间不断变化的</li>
</ul>
<h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><ul>
<li><p>其型是关系模式的集合，即数据库描述，称作数据库的内涵(Intension)，或关系数据库模式</p>
</li>
<li><p>其值是某一时刻关系的集合，称作数据库的外延(Extension)，或关系数据库</p>
</li>
</ul>
<h2 id="关系的完整性约束"><a href="#关系的完整性约束" class="headerlink" title="关系的完整性约束"></a>关系的完整性约束</h2><h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><ul>
<li>关系的主码中的属性值不能为空值</li>
<li>空值：不知道或无意义</li>
<li>意义：关系对应到现实世界中的实体集，元组对应到实体，实体是相互可区分的，通过主码来唯一标识，若主码为空，则出现不可标识的实体，这是不容许的</li>
</ul>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><ul>
<li>如果关系R<del>2</del>的外码F<del>k</del>与关系R<del>1</del>的主码P<del>k</del>相对应，则R<del>2</del>中的每一个元组的F<del>k</del>值或者等于R<del>1</del> 中某个元组的P<del>k</del>值，或者为空值【即属性Fk本身不是主属性，则可以取空值，否则不能取空值。】</li>
<li>意义：如果关系R<del>2</del>的某个元组t<del>2</del>参照了关系R<del>1</del>的某个元组t<del>1</del>，则t<del>1</del>必须存在</li>
<li>例如：关系S在D#上的取值有两种可能<ul>
<li>空值，表示该学生尚未分到任何系中</li>
<li>若非空值，则必须是DEPT关系中某个元组的D#值，表示该学生不可能分到一个不存在的系中<br>DEPT(D#, DN , DEAN)S(S#, SN , SEX , AGE , D#)</li>
</ul>
</li>
</ul>
<h3 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h3><ul>
<li><p>用户定义的完整性</p>
<ul>
<li><p>用户针对具体的应用环境定义的完整性约束条件</p>
</li>
<li><p>如S#要求是8位整数，SEX要求取值为“男”或“女”</p>
</li>
</ul>
</li>
<li><p>系统支持</p>
<ul>
<li>实体完整性和参照完整性由系统自动支持</li>
<li>系统应提供定义和检验用户定义的完整性的机制</li>
</ul>
</li>
</ul>
<h1 id="关系代数概述"><a href="#关系代数概述" class="headerlink" title="关系代数概述"></a>关系代数概述</h1><ul>
<li>属于关系操作的一种</li>
<li>关系代数是一种抽象的查询语言</li>
<li>通过对关系的运算来表达查询操作</li>
<li>运算对象、结果均为关系</li>
<li>运算包括四类：<ul>
<li>集合运算、关系运算、比较运算、逻辑运算</li>
</ul>
</li>
</ul>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><h3 id="并运算"><a href="#并运算" class="headerlink" title="并运算"></a>并运算</h3><ul>
<li><p>所有至少出现在两个关系中之一的元组集合</p>
</li>
<li><p>两个关系R和S若进行并运算，则它们必须是相容的:</p>
<ul>
<li>关系R和S必须是同元的，即它们的属性数目必须相同</li>
<li>对i，R的第i个属性的域必须和S的第i个属性的域相同</li>
</ul>
</li>
</ul>
<h3 id="差运算"><a href="#差运算" class="headerlink" title="差运算"></a>差运算</h3><p>所有出现在一个关系而不在另一关系中的元组集合</p>
<p>R和S必须是相容的</p>
<h3 id="交运算"><a href="#交运算" class="headerlink" title="交运算"></a>交运算</h3><ul>
<li>所有同时出现在两个关系中的元组集合</li>
<li>交运算可以通过差运算来重写</li>
</ul>
<h2 id="基本关系运算"><a href="#基本关系运算" class="headerlink" title="基本关系运算"></a>基本关系运算</h2><h3 id="选择运算"><a href="#选择运算" class="headerlink" title="选择运算"></a>选择运算</h3><p>在关系R中选择满足给定条件的元组（从行的角度）</p>
<h3 id="投影运算"><a href="#投影运算" class="headerlink" title="投影运算"></a>投影运算</h3><p>投影的结果中要去掉相同的行</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200401174458046.png" style="zoom:67%;" />

<h3 id="广义笛卡儿积"><a href="#广义笛卡儿积" class="headerlink" title="广义笛卡儿积"></a>广义笛卡儿积</h3><ul>
<li><p>元组的连串（Concatenation）</p>
<ul>
<li>若r &#x3D; (r<del>1</del>，…，r<del>n</del>)，s &#x3D; (s<del>1</del> ，… ，s<del>m</del>)，则定义r与s的连串为：rs &#x3D; (r<del>1</del>，…，r<del>n</del>，s<del>1</del> ，…，s<del>m</del>)</li>
</ul>
</li>
<li><p>广义笛卡尔积两个关系R，S，其度分别为n，m，则它们的笛卡尔积是所有这样的元组集合：元组的前n个分量是R中的一个元组，后m个分量是S中的一个元组<br>RxS&#x3D;{rs|r属于R并且s属于S}</p>
</li>
<li><p>RxS的度为R与S的度之和，RxS的元组个数为R和S的元组个数的乘积</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601164930592.png"></p>
</li>
</ul>
<h2 id="其它关系运算"><a href="#其它关系运算" class="headerlink" title="其它关系运算"></a>其它关系运算</h2><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601165011840.png"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601165118331.png"></p>
<p>0连接就是有附加条件的自然连接。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601165210237.png"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601165223860.png"></p>
<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>把上述中舍弃的元组也保存在结果关系中，在其他属性上填上NULL。</p>
<p>左外连接：只把左边关系R中要舍弃的元组保留。同理：右外连接。</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601165444957.png" style="zoom:50%;" />

<h3 id="除运算"><a href="#除运算" class="headerlink" title="除运算"></a>除运算</h3><p>把S和R中相同的属性组拿出来，然后取R中独有的属性</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601165522272.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/03/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">编译原理-LR分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-27 15:18:39" itemprop="dateCreated datePublished" datetime="2020-03-27T15:18:39Z">2020-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-05 12:25:00" itemprop="dateModified" datetime="2020-07-05T12:25:00Z">2020-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="句柄和规范归约"><a href="#句柄和规范归约" class="headerlink" title="句柄和规范归约"></a>句柄和规范归约</h1><p>归约：根据文法的产生式规则，把串中出现的产生式的右部替换成左部符号</p>
<p>从语法树的角度看，是从叶子出发逐步向上进行构造</p>
<p>句柄：最左两代子树末端就是句柄</p>
<p>规范归约的关键是寻找句柄：</p>
<p>1、根据语法树找句柄</p>
<p>2、在栈中根据三类信息：</p>
<ul>
<li>历史：已经移入符号栈的内容</li>
<li>展望：根据产生式推迟未来可能遇到的输入符号</li>
<li>现实：当前的输入符号</li>
</ul>
<h1 id="LR分析"><a href="#LR分析" class="headerlink" title="LR分析"></a>LR分析</h1><p>LR分析法也是一种“移进—归约”的自底向上语法分析方法，<strong>其本质是规范归约【句柄作为可归约串】</strong>。</p>
<p>其思想为一方面记住已移进和归约出的整个符号串，另一方面根据所用产生式推测未来可能碰到的输入符号。</p>
<p><strong>LR分析方法：把“历史”以及“展望”综合抽象成状态；由栈顶的状态和现行的输入符号唯一确定每一步工作。</strong></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/image-20200427132237942.png"></p>
<p>解释：每一个符号对应一个状态，分析栈每次弹出一个符号，就要把对应的状态也弹出。然后LR分析程序会根据输入串在LR分析表中进行查找：是进行归约、移进还是报错操作。</p>
<p>LR分析器实质上是一个带先进后出存储器（栈）的确定有限自动机，其核心部分是一张分析表，包括两部分：</p>
<p>（1）ACTION[s，a]动作表，规定当状态s面临输入符号a时，应采取什么动作（移进、归约、接受、 报错）【<strong>也就是告诉我们当栈顶状态为s时，输入的符号是a时，我们应该采取什么操作：归约、移进还是报错</strong>】</p>
<p>（2）GOTO[s，X]状态转换表规定了状态s面对文法符号X时，下一状态是什么。【<strong>当归约完了后，要把规约后的非终结符压到栈里面的时候，跟新压入栈的这个非终结符所对应的状态是什么</strong>】</p>
<h2 id="LR文法"><a href="#LR文法" class="headerlink" title="LR文法"></a>LR文法</h2><p>对于一个文法，如果能够构造一张分析表，使得它的每个入口均是唯一确定的，则这个文法就是LR文法</p>
<p>一个文法，如果能用一个每步顶多向前检查k个输入符号的LR分析器分析，则这个文法就称为LR(K)文法</p>
<p>LR文法不是二义的</p>
<h2 id="LR-0-分析"><a href="#LR-0-分析" class="headerlink" title="LR(0)分析"></a>LR(0)分析</h2><h3 id="拓广文法"><a href="#拓广文法" class="headerlink" title="拓广文法"></a>拓广文法</h3><p>对于文法 G &#x3D; (V<del>N</del>, V<del>T</del>, P , S ) , 增加如下产生式：S’-&gt;S ，其中， S’ ∈ V<del>N</del>∪ V<del>T</del> ， 得到 G 的拓广文法，G’ &#x3D; (V<del>N</del> ’, V<del>T</del>, P ’ , S’ )</p>
<p><strong>其实就是增加了一条右部为开始符号的产生式，就变成了拓广文法</strong></p>
<h3 id="可归前缀"><a href="#可归前缀" class="headerlink" title="可归前缀"></a>可归前缀</h3><p>将符号串的任意含有头符号的子串称为前缀。特别地，空串ε为任意串的前缀。</p>
<p>采取归约过程前符号栈中的内容，称做可归前缀。<br>这种前缀包含句柄且不包含句柄之后的任何符号；</p>
<h3 id="活前缀"><a href="#活前缀" class="headerlink" title="活前缀"></a>活前缀</h3><p>就是在LR分析中为了描述栈内符号的特点给出的概念</p>
<p>对于文法 G &#x3D; (V<del>N</del>, V<del>T</del>, P , S ) , 设 S’ 是其拓广文法的开始符号（即有产生式 S’-&gt; S）， 且α,β∈(V<del>N</del>∪V<del>T</del>)* , ω∈V<del>T</del><em>。<br>若 S’ &#x3D;^</em>^&#x3D;&gt;α A ω 且 A -&gt;β， 即 β 为句柄，则 αβ 的任何前缀 γ 都是文法 G 的活前缀。【<strong>活前缀就是不含句柄之后任何符号的前缀</strong>】<br>注：由于 S’ &#x3D;^*^&#x3D;&gt;S’ 且 S’ -&gt; S， 故 S 是 G 的活前缀 。</p>
<p><strong>也就是说可归前缀的所有前缀（包括可归前缀）都是活前缀。</strong></p>
<blockquote>
<p>例：文法 G[S] :<br>（1） S -&gt; AB<br>（2） A -&gt; aA<br>（3） A -&gt; ε<br>（4） B -&gt; b<br>（5） B -&gt; bB<br>句子 aaab 是一个句型，其唯一的句柄为：ε （aaaεb）； 活前缀有：ε，a，aa，aaa。</p>
</blockquote>
<p>规范归约过程中，保证分析栈中总是活前缀，就说明分析采取的移进&#x2F;归约动作是正确的</p>
<h3 id="LR-0-项目"><a href="#LR-0-项目" class="headerlink" title="LR(0)项目"></a>LR(0)项目</h3><p>对于文法G，其产生式右部添加一个特殊的符号“.”，就构成文法的一个LR(0)项目，简称项目</p>
<p><strong>每个项目的含义是：欲用改产生式归约时，圆点前面的部分为已经识别了的句柄部分，圆点后面的部分为期望的后缀部分。</strong></p>
<p>分类：</p>
<p>移进项目: 形如 A -&gt; α • aβ（a∈V<del>T</del>），对应移进状态，把a移进符号栈。<br>待约项目: 形如 A -&gt; α • Bβ，对应待约状态，需要等待分析完非终结符B的串再继续分析A的右部。<br>归约项目: 形如 A -&gt; α •，句柄已形成，可以归约。<br>接受项目: 形如 S’ -&gt; S •。【也是一个归约项目，表示整个句子已经识别完毕】<br>初始项目: 形如 S’ -&gt; • S。<br>其中a∈V<del>T</del> , α,β∈(V<del>N</del>∪V<del>T</del>)*， A,B∈V<del>T</del><br>后继项目: 表示同属于一个产生式的项目，但是圆点的位置仅相差一个文法符号，则称后者为前者的后继项目。</p>
<p> • 的左边是已经归约，右边是没有归约的</p>
<blockquote>
<p>例：对于产生式S -&gt; aAcBe，它有6个项目：<br>S -&gt; ·aAcBe<br>S -&gt; a·AcBe<br>S -&gt; aA·cBe<br>S -&gt; aAc·Be<br>S -&gt; aAcB·e<br>S -&gt; aAcBe·</p>
</blockquote>
<h2 id="LR-0-有限状态机的构造方法"><a href="#LR-0-有限状态机的构造方法" class="headerlink" title="LR(0)有限状态机的构造方法"></a>LR(0)有限状态机的构造方法</h2><h3 id="构造识别活前缀的NFA"><a href="#构造识别活前缀的NFA" class="headerlink" title="构造识别活前缀的NFA"></a>构造识别活前缀的NFA</h3><h4 id="NFA的构造方法"><a href="#NFA的构造方法" class="headerlink" title="NFA的构造方法"></a>NFA的构造方法</h4><p>(1)状态集：由每个项目所对应的状态组成的集合；</p>
<p>(2)输入字符集合：由文法符号组成，包括：终结符、非终结符和e；</p>
<p>(3)初态：对于文法G[S]的拓广文法G[S’],有项目S’® . S ,由于S’ 仅在第一个产生式的左部出现，所以规定它为初态；</p>
<p>(4)终态：每个状态均为NFA的终态（活前缀的识别态）。</p>
 <img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203220121070.png" style="zoom:75%;" />

<ul>
<li><p>若状态i为X-&gt;X<del>1</del>····X<del>i-1</del>•X<del>i</del>····X<del>n</del>；状态j为X-&gt;X<del>1</del>····X<del>i-1</del>X<del>i</del>•X<del>i+1</del>····X<del>n</del></p>
<p>则从状态i画一条标志为X<del>i</del>的有向边到状态j</p>
</li>
<li><p>若状态i为X-&gt;α• Aβ，A为非终结符，<br>则从状态i画一条ε边到所有状态A-&gt;• y【可以理解成X想要把A进行归约，然后画一条ε边，交给A需要归约的符号】</p>
</li>
</ul>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203220250887.png" style="zoom:75%;" />

<h3 id="NFA转换成DFA"><a href="#NFA转换成DFA" class="headerlink" title="NFA转换成DFA"></a>NFA转换成DFA</h3><p>DFA是用子集法得到的</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203220947527.png" style="zoom:75%;" />

<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203221052145.png" style="zoom:75%;" />

<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203221104587.png" style="zoom:75%;" />

<h3 id="求项目集规范族"><a href="#求项目集规范族" class="headerlink" title="求项目集规范族"></a>求项目集规范族</h3><p>每个项目集对应一个DFA状态，它们的全体称为这个文法的项目集规范族</p>
<h4 id="有效项目"><a href="#有效项目" class="headerlink" title="有效项目"></a>有效项目</h4><p>项目A-&gt;β<del>1</del>• β<del>2</del>对活前缀αβ<del>1</del>是有效的，其条件就是存在规范推导</p>
<h4 id="1-用闭包函数（CLOSURE）来求DFA一个状态的项目集"><a href="#1-用闭包函数（CLOSURE）来求DFA一个状态的项目集" class="headerlink" title="1.用闭包函数（CLOSURE）来求DFA一个状态的项目集"></a>1.用闭包函数（CLOSURE）来求DFA一个状态的项目集</h4><p>I是拓广文法G的任意项目集：<br>CLOSURE(I)是这样定义的：<br>首先I的项目都属于CLOSURE(I)；<br>如果A-&gt;α• Bβ,则左部为B的每个产生式中的形如B-&gt;·γ项目，也属于CLOSURE(I)；</p>
<blockquote>
<p>例子：已知文法G[E]如下:<br>(1) E -&gt; E+T<br>(2) E -&gt; T<br>(3) T -&gt;( E )<br>(4) T -&gt; d</p>
<p>可以直到它的拓广文法G’ [E’]为 ：<br>(0) E’ -&gt; E<br>(1) E -&gt; E+T<br>(2) E -&gt; T<br>(3) T -&gt; ( E )<br>(4) T -&gt; d</p>
<p>令I<del>0</del> &#x3D; CLOSURE({E’-&gt;.E})</p>
<p>则I<del>0</del> &#x3D; {<br>E’ -&gt; • E，<br>E -&gt; • E+T，<br>E -&gt; • T，<br>T -&gt; •( E ),<br>T -&gt; • d<br>}</p>
</blockquote>
<h4 id="2-LR-0-FSM-的状态转移函数"><a href="#2-LR-0-FSM-的状态转移函数" class="headerlink" title="2.LR(0) FSM 的状态转移函数"></a>2.LR(0) FSM 的状态转移函数</h4><p>从一个状态出发，到达下一个状态的转换函数：<br>GO (I,X) &#x3D; CLOSURE(J)<br>其中，I为LR(0) FSM 的状态（闭包的项目集），X为文法符号， J&#x3D;{ A -&gt; αX•β | A -&gt; α• Xβ∈I} ；【J是非终结符包进去后的集合】<br>表示对于一个状态项目集中的一个项目A -&gt; α• Xβ，在下一个输入字符是X的情况下，一定到另一个新状态 A -&gt; αX•β。</p>
<h4 id="3-LR-0-有限状态机的构造"><a href="#3-LR-0-有限状态机的构造" class="headerlink" title="3.LR(0) 有限状态机的构造"></a>3.LR(0) 有限状态机的构造</h4><p>从 LR(0) FSM 的初态出发 ，先求出初态项目集的闭包（CLOSURE({S’-&gt;.S})），然后应用上述转移函数，通过项目分析每种输入字符下的状态转移，若为新状态，则就求出新状态下的项目集的闭包，级可逐步构造出完整的 LR(0) FSM。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">构造项目集规范族的算法：</span><br><span class="line"><span class="function"><span class="keyword">PROCEDURE</span> <span class="title">ITEMSET</span><span class="params">(G<span class="string">&#x27;)；</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">BEGIN</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">C:&#123;CLOSURE&#123;S&#x27;</span>-&gt;.S&#125;&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">REPEAT</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">FOR</span> C中的每一个项目集I和G<span class="string">&#x27;的每一个符号X DO</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		IF GO(I,X)非空且不属于C THEN</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		把GO(I,X)放入C族中</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">	UNTIL C不再增大</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">End</span></span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>LR(0) FSM 的构造举例<br>给定文法G[E]：<br>(1) E -&gt; E+T<br>(2) E -&gt; T<br>(3) T -&gt; ( E )<br>(4) T -&gt; d</p>
<p>构造LR(0) FSM<br>① G[E]的拓广文法，得到G’ [E’]：<br>(0) E’ -&gt; E<br>(1) E -&gt; E+T<br>(2) E -&gt; T<br>(3) T -&gt; ( E )<br>(4) T -&gt; d</p>
<p>②构造G’[E’] 的 LR(0) FSM</p>
<p><img src="https://img-blog.csdnimg.cn/20181229131739897"></p>
</blockquote>
<p>两种构造识别活前缀的DFA的方法：</p>
<ul>
<li>项目-&gt;NFA-&gt;DFA</li>
<li>Closure-&gt;GO-&gt;DFA</li>
</ul>
<h2 id="LR-0-分析法"><a href="#LR-0-分析法" class="headerlink" title="LR(0) 分析法"></a>LR(0) 分析法</h2><h3 id="1-LR-0-文法定义"><a href="#1-LR-0-文法定义" class="headerlink" title="1.LR(0) 文法定义"></a>1.LR(0) 文法定义</h3><p>文法 G 是 LR(0) 文法，当且仅当它的LR(0)FSM中的每个状态都满足：<br><strong>①不同时含有移进项目和归约项目，即不存在移进-归约冲突。</strong><br><strong>②不含有两个以上归约项目，即不存在归约-归约冲突。</strong></p>
<h3 id="2-LR-0-分析表的构造"><a href="#2-LR-0-分析表的构造" class="headerlink" title="2.LR(0)分析表的构造"></a>2.LR(0)分析表的构造</h3><p>令每个项目集I<del>k</del>的下标k作为分析器的状态</p>
<p>ACTION 表项和 GOTO表项可按如下方法构造：</p>
<ul>
<li><p>若项目A -&gt;α • aβ属于 I<del>k</del> 且 GO (I<del>k</del>, a)&#x3D; I<del>j</del>, 期望字符a 为终结符，则置ACTION[k, a] &#x3D;s<del>j</del> (j表示新状态I<del>j</del>);</p>
</li>
<li><p>若项目A -&gt;α •属于I<del>k</del>, 那么对任何终结符a, 置ACTION[k, a]&#x3D;r<del>j</del>；其中，假定A-&gt;α为文法G 的第j个产生式；【对k到a进行归约】</p>
</li>
<li><p>若项目S’ -&gt;S • 属于I<del>k</del>, 则置ACTION[k, #]为“acc”;【单词处理完毕】</p>
</li>
<li><p>若项目A -&gt;α • Aβ属于 I<del>k</del>，且GO (I<del>k</del>, A)&#x3D; I<del>j</del>,期望字符 A为非终结符，则置GOTO(k, A)&#x3D;j (j表示文法中第j个产生式);</p>
</li>
<li><p>分析表中凡不能用上述规则填入信息的空白格均置上“出错标志”</p>
<p><strong>翻译一下：</strong></p>
<ol>
<li><strong>如果圆点不在项目k最后且圆点后的期待字符a为终结符，则ACTION[k, a] &#x3D;s<del>j</del> (j表示新状态I<del>j</del>)；</strong></li>
<li><strong>如果圆点不在项目k最后且圆点后的期待字符A为非终结符，则GOTO(k, A)&#x3D;j (j表示文法中第j个产生式)；</strong></li>
<li><strong>如果圆点在项目k最后且k不是S’ -&gt;S，那么对所有终结符a，ACTION[k, a]&#x3D;r<del>j</del> (j表示文法中第j个产生式)；</strong></li>
<li><strong>如果圆点在项目k最后且k是S’ -&gt;S，则ACTION[k, #]为“acc”;</strong></li>
</ol>
</li>
</ul>
<blockquote>
<p>例子：</p>
<p>考虑文法G[S] :<br>S → （S） | a<br>相应的LR(0) FSM如下，构造其LR(0)分析表。</p>
<p><img src="https://img-blog.csdnimg.cn/20181229131739956"></p>
<p>LR(0) FSM</p>
<p>从I<del>0</del>看，S‘-&gt;·S,期望字符是非终结符S，根据上面的规则2，得到GOTO(0,S)&#x3D;1；<br>S‘-&gt;·(S),期望字符是终结符(，根据上面的规则1，得到ACTION(0,()&#x3D;S<del>2</del>；<br>从I<del>3</del>看，S-&gt;a·，根据规则3，置ACTION[3, a]为r<del>2</del>;<br>从I<del>1</del>看，S‘-&gt;S·，根据规则4，置ACTION[1, #]为“acc”;</p>
<p><img src="https://img-blog.csdnimg.cn/201812291317408"></p>
<p>LR(0)分析表</p>
</blockquote>
<h3 id="3-LR-0-分析流程"><a href="#3-LR-0-分析流程" class="headerlink" title="3.LR(0) 分析流程"></a>3.LR(0) 分析流程</h3><p>设输入串为w，ip指向输入串w的首符号a，i指向符号栈顶；状态栈的初始栈顶为0，符号栈初始栈顶为#。</p>
<p>算法流程图为：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/image-20200427170434108.png"></p>
<h2 id="SLR-1-分析法"><a href="#SLR-1-分析法" class="headerlink" title="SLR(1)分析法"></a>SLR(1)分析法</h2><h3 id="1-SLR-1-解决的问题"><a href="#1-SLR-1-解决的问题" class="headerlink" title="1.SLR(1)解决的问题"></a>1.SLR(1)解决的问题</h3><p>LR(0)文法的要求是①不同时含有移进项目和归约项目，即不存在移进-归约冲突。②不含有两个以上归约项目，即不存在归约-归约冲突。</p>
<p>例如项目集I<del>i</del>中存在： I<del>i</del> ＝{A-&gt;α•bγ ， B→ γ•，C→β• }，此时就同时存在移进-归约冲突和归约-归约；因为你不知道下一步是选择归约还是移进，选择归约的话选择哪个产生式归约。</p>
<p>而事实上一般文法满足这种要求有一定难度，但是假如在归约时出现了移进-归约冲突或者归约-归约冲突，我们可以通过在待分析的字符串中向后再看一位，大多数情况下通过这一位字符就可以确定，选择哪一个表达式归约，或是移进操作。</p>
<p>这种方法就叫做SLR(1)分析法，即简单的LR(1)分析法。</p>
<h3 id="2-SLR-1-冲突解决方法"><a href="#2-SLR-1-冲突解决方法" class="headerlink" title="2.SLR(1)冲突解决方法"></a>2.SLR(1)冲突解决方法</h3><p>如上面所述，我们需要知道下一位待分析的字符，然后和现有项目进行比较。</p>
<p>分析过程与LR(0)一样，但是需要解决分析表上的冲突问题。</p>
<p>假如LR(0) 项目集规范族中有项目集 I<del>i</del> 含有移进-归约冲突和归约-归约冲突：<br> I<del>i</del> ＝{A<del>1</del>-&gt;α<del>1</del>•b<del>1</del>γ<del>1</del>，… ， A<del>m</del>-&gt;m•b<del>m</del> γ<del>m</del>， B<del>1</del>-&gt;β<del>1</del>• ，…， B<del>n</del>-&gt; β<del>n</del>• }，若集合{b<del>1</del> ，b<del>2</del>，… ，b<del>m</del> }、FOLLOW(B<del>1</del>) 、 FOLLOW(B<del>2</del>) ，…，FOLLOW(Bn)均两两不相交，则可用SLR(1)解决方法解决分析表上第i行上的冲突问题。</p>
<p>假设下一个移进的字符为b:</p>
<p>1、若b∈ {b<del>1</del> ，b<del>2</del>，… ，b<del>m</del> }，则移进输入符；</p>
<p>2、若b∈FOLLOW(B<del>j</del>) ，j＝1 ，… ，n，则用B<del>j</del>-&gt; β<del>j</del> 归约；</p>
<p>3、此外，报错</p>
<p>通过这个方法，就可以在知道下一位待分析的字符的情况下，解决冲突。</p>
<p>继续采用SLR(1)分析的方法，我们可以对出错情况进行优化：</p>
<p>在LR(0)和SLR(1)分析中，我们在可以归约且没有冲突时（假如归约成A），是不关心下一位待分析的字符a和follow(A)的关系的，假如a!∈follow(A)则当前字符串是不被接受的，当然这会在之后的继续移进字符过程中发现错误，但是如果不管是否有冲突看，将SLR(1)分析方法应用到所有分析表的构建过程中，可以提前发现字符串的错误。</p>
<h3 id="3-构造SLR-1-分析表的方法"><a href="#3-构造SLR-1-分析表的方法" class="headerlink" title="3.构造SLR(1)分析表的方法"></a>3.构造SLR(1)分析表的方法</h3><p>1、把G扩广成G’</p>
<p>2、对G’构造：得到LR(0)项目集规范族C；活前缀识别自动机的状态转换函数GO</p>
<p>3、使用C和GO，构造SLR分析表：构造action和goto子表：</p>
<ul>
<li>若项目A -&gt;α • aβ属于 I<del>k</del> 且 GO (I<del>k</del>, a)&#x3D; I<del>j</del>,期望字符a为终结符，则置ACTION[k, a] &#x3D;s<del>j</del> (j表示新状态I<del>j</del>);</li>
<li>若项目A -&gt;α • Aβ属于 I<del>k</del>，且GO (I<del>k</del>, A)&#x3D; I<del>j</del>,期望字符 A为非终结符，则置GOTO(k, A)&#x3D;j (j表示文法中第j个产生式);</li>
<li>若项目A -&gt;α •属于I<del>k</del>, 那么对任何终结符a，<strong>当满足a属于follow(A)时</strong>， 置ACTION[k, a]&#x3D;r<del>j</del>；其中，假定A-&gt;α为文法G 的第j个产生式；</li>
<li>若项目S’ -&gt;S • 属于I<del>k</del>, 则置ACTION[k, #]&#x3D;“acc”;</li>
<li>分析表中凡不能用上述规则填入信息的空白格均置上“出错标志”</li>
</ul>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/image-20200427182955125.png"></p>
<p>SLR分析是有选择的放置的</p>
<h3 id="4-SLR（1）文法"><a href="#4-SLR（1）文法" class="headerlink" title="4.SLR（1）文法"></a>4.SLR（1）文法</h3><p>按上述方法构造出的ACTION和GOTO表如果不含多重入口，则称该文法是SLR(1)文法。</p>
<p>使用SLR表的分析器叫做一个SLR分析器</p>
<p>每个SLR(1)文法都是无二义的。<br>$$<br>LR(0)\subset SLR(1)\subset 无二义文法<br>$$</p>
<h3 id="5-SLR-1-分析的例子"><a href="#5-SLR-1-分析的例子" class="headerlink" title="5.SLR(1)分析的例子"></a>5.SLR(1)分析的例子</h3><blockquote>
<p>算术表达式文法G[E]：<br>E→E +T | T<br>T→T * F | F<br>F→ （E）| i<br>求此文法的识别规范句型活前缀的DFA，分析句子i+i *i。</p>
</blockquote>
<ol>
<li>将文法拓广为G’[E’]：<br>(0) E’ -&gt;E<br>(1) E-&gt; E +T<br>(2) E -&gt;T<br>(3) T -&gt;T * F<br>(4) T -&gt;F<br>(5) F -&gt;(E)<br>(6) F -&gt;i</li>
<li>构造识别规范句型活前缀的DFA</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20181229131728485"></p>
<ol>
<li><p>判断有无冲突：</p>
<p>I<del>1</del> ，I<del>2</del> ，I<del>9</del>有移进_归约冲突。<br>I<del>1</del>:E´ -&gt;E· E -&gt;E·+T<br>I<del>2</del>: E -&gt;T · T -&gt;T · *F<br>I<del>9</del>: E -&gt;E+T· T -&gt;T · *F</p>
</li>
<li><p>考虑能否用SLR(1)方法解决冲突：</p>
<p>对于I<del>1</del>: <code>&#123; E´ -&gt;E· E -&gt;E·+T&#125;</code> 因为：<code>&#123;+&#125; ∈FOLLOW(E´)= &#123;+&#125; ∩ &#123;＃&#125; ＝∅</code>, 所以可用SLR(1)方法 解决I<del>1</del>的冲突。</p>
<p>对于I<del>2</del>: <code>&#123;E -&gt;T· T -&gt;T·*F&#125;</code> 因为：<code>&#123;*&#125; ∈ FOLLOW(E)= &#123;*&#125; ∩ &#123;＃，）,+&#125; ＝ ∅</code> 所以可用SLR(1)方法解决I<del>2</del>的冲突。</p>
<p>对于I<del>9</del>: <code>&#123;E -&gt;E+T· T -&gt;T ·*F&#125;</code> 因为：<code>&#123;*&#125; FOLLOW(E)= ∅</code>, 所以可用SLR(1)方法解决I<del>9</del>的冲突。</p>
</li>
<li><p>构建分析表：</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20181229131728536"></p>
<p>6.句子i+i *i的分析过程：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>状态栈</th>
<th>符号栈</th>
<th>输入符</th>
<th>剩余输   入串</th>
<th align="left">查表</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
<td>#</td>
<td>i</td>
<td>i+i*i#</td>
<td align="left">Action[0,i]&#x3D;S5</td>
<td>移进i</td>
</tr>
<tr>
<td>2</td>
<td>0 5</td>
<td># i</td>
<td>+</td>
<td>+i*i#</td>
<td align="left">Action[5,+]&#x3D;r6,GOTO(0,F)&#x3D;3</td>
<td>用F -&gt; i 归约</td>
</tr>
<tr>
<td>3</td>
<td>0 3</td>
<td># F</td>
<td>+</td>
<td>+i*i#</td>
<td align="left">Action[3,+]&#x3D;r4,GOTO(0,T)&#x3D;2</td>
<td>用F -&gt; T归约</td>
</tr>
<tr>
<td>4</td>
<td>0 2</td>
<td># T</td>
<td>+</td>
<td>+i*i#</td>
<td align="left">Action[2,+]&#x3D;r4,GOTO(0,E)&#x3D;1</td>
<td>用F -&gt; E归约</td>
</tr>
<tr>
<td>5</td>
<td>0 1</td>
<td># E</td>
<td>+</td>
<td>+i*i#</td>
<td align="left">Action[1,+]&#x3D;S6</td>
<td>移进+</td>
</tr>
<tr>
<td>6</td>
<td>0 1 6</td>
<td># E +</td>
<td>i</td>
<td>i*i#</td>
<td align="left">Action[6,i]&#x3D;S6</td>
<td>移进+</td>
</tr>
<tr>
<td>7</td>
<td>0 1 6 5</td>
<td># E + i</td>
<td>*</td>
<td>*i#</td>
<td align="left">Action[5,*]&#x3D;r6,GOTO(6,F)&#x3D;3</td>
<td>用F -&gt; i 归约</td>
</tr>
<tr>
<td>8</td>
<td>0 1 6 3</td>
<td># E + F</td>
<td>*</td>
<td>*i#</td>
<td align="left">Action[3,*]&#x3D;r6,GOTO(6,T)&#x3D;9</td>
<td>用F -&gt; F 归约</td>
</tr>
<tr>
<td>9</td>
<td>0 1 6 9</td>
<td># E + T</td>
<td>*</td>
<td>*i#</td>
<td align="left">Action[9,*]&#x3D;S7</td>
<td>移进*</td>
</tr>
<tr>
<td>10</td>
<td>0 1 6 9 7</td>
<td># E + T *</td>
<td>i</td>
<td>i#</td>
<td align="left">Action[7,i]&#x3D;S5</td>
<td>移进i</td>
</tr>
<tr>
<td>11</td>
<td>0 1 6 9 7 5</td>
<td># E + T * i</td>
<td>#</td>
<td>#</td>
<td align="left">Action[5,#]&#x3D;r6,GOTO(7,F)&#x3D;10</td>
<td>用F -&gt; i 归约</td>
</tr>
<tr>
<td>12</td>
<td>0 1 6 9 7 10</td>
<td># E + T * F</td>
<td>#</td>
<td>#</td>
<td align="left">Action[10,#]&#x3D;r3,GOTO(6,T)&#x3D;9</td>
<td>用T -&gt; T+F归约</td>
</tr>
<tr>
<td>13</td>
<td>0 1 6 9</td>
<td># E + T</td>
<td>#</td>
<td>#</td>
<td align="left">Action[9,#]&#x3D;r1,GOTO(0,E)&#x3D;1</td>
<td>用E -&gt; E+T归约</td>
</tr>
<tr>
<td>14</td>
<td>0 1</td>
<td># E</td>
<td>#</td>
<td>#</td>
<td align="left">Action[1,#]&#x3D;acc</td>
<td>接受</td>
</tr>
</tbody></table>
<h2 id="LR-1-分析法"><a href="#LR-1-分析法" class="headerlink" title="LR(1)分析法"></a>LR(1)分析法</h2><h3 id="SLR冲突消解存在的问题"><a href="#SLR冲突消解存在的问题" class="headerlink" title="SLR冲突消解存在的问题"></a>SLR冲突消解存在的问题</h3><p>在SLR方法中，如果项目集I<del>i</del>含项目A -&gt;α •而且下一输入符号α∈FOLLOW(A)，则状态i面临α时，可选用“用A -&gt;α归约”动作。</p>
<p>但是在某些情况下，当状态i显现于栈顶时，当前单词是α，栈里的活前缀βα未必允许把α归约为A，因为可能根本不存在一个形如“βAα”的规范句型。在这种情况下，用“A -&gt;α”归约不一定合适</p>
<p>【因为FOLLOW（A）集合提供的信息太泛】</p>
<h3 id="构造LR-1-分析表的方法"><a href="#构造LR-1-分析表的方法" class="headerlink" title="构造LR(1)分析表的方法"></a>构造LR(1)分析表的方法</h3><p>1、把G扩广成G’</p>
<p>2、对G’构造：得到LR(1)项目集规范族C；活前缀识别自动机的状态转换函数GO</p>
<p>3、使用C和GO，构造LR（1）分析表：</p>
<p>LR(K)项目：扩展LR(0)项目，附带有k个终结符[A-&gt;α •β,α<del>1</del>α<del>2</del>····α<del>k</del>]<br>α<del>1</del>α<del>2</del>····α<del>k</del>称为向前搜索符串（或展望串）</p>
<p>归约项目[A-&gt;α •,α<del>1</del>α<del>2</del>····α<del>k</del>]的意义：当它所属的状态呈现现在栈顶且后续的k个输入符号为α<del>1</del>α<del>2</del>····α<del>k</del>时，才可以把栈顶上的α归约为A</p>
<p> 对于任何移进或待约项目[A-&gt;α •β,α<del>1</del>α<del>2</del>····α<del>k</del>]，β不等于α，搜索符串α<del>1</del>α<del>2</del>····α<del>k</del>没有直接作用 </p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">构造项目集规范族的算法：</span><br><span class="line"><span class="function"><span class="keyword">PROCEDURE</span> <span class="title">ITEMSET</span><span class="params">(G<span class="string">&#x27;)；</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">BEGIN</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">C:&#123;CLOSURE&#123;S&#x27;</span>-&gt;.S,#&#125;&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">REPEAT</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">FOR</span> C中的每一个项目集I和G<span class="string">&#x27;的每一个符号X DO</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		IF GO(I,X)非空且不属于C THEN</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		把GO(I,X)放入C族中</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">	UNTIL C不再增大</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">End</span></span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>若项目[A -&gt;α • aβ，b]属于 I<del>k</del> 且 GO (I<del>k</del>, a)&#x3D; I<del>j</del>,期望字符a为终结符，则置ACTION[k, a] &#x3D;s<del>j</del> (j表示新状态I<del>j</del>);</li>
<li>若项目[A -&gt;α •，a]属于I<del>k</del>, 那么对任何终结符a，<strong>当满足a属于follow(A)时</strong>， 置ACTION[k, a]&#x3D;r<del>j</del>；其中，假定A-&gt;α为文法G 的第j个产生式；</li>
<li>若项目[S’ -&gt;S • ，#]属于I<del>k</del>, 则置ACTION[k, #]&#x3D;“acc”;</li>
<li>若GO[I<del>k</del>，A]&#x3D;I<del>j</del>，则置GOTO[K,A]&#x3D;j</li>
<li>分析表中凡不能用上述规则填入信息的空白格均置上“出错标志”</li>
</ul>
<p>$$<br>LR(0)\subset SLR(1)\subset LR(1)\subset 无二义文法<br>$$</p>
<p><strong>（SLR(1)和LR(1)的区别在于LR(1)多使用了一个预判信息，即项目后面的符号如A →·e,c中的c，这个预判信息是用first集而非follow集得出的）</strong></p>
<h1 id="LR-0-、SLR-1-、LL-1-等的区别"><a href="#LR-0-、SLR-1-、LL-1-等的区别" class="headerlink" title="LR(0)、SLR(1)、LL(1)等的区别"></a>LR(0)、SLR(1)、LL(1)等的区别</h1><p>LL(1)定义：一个文法G是LL（1）的，当且仅当对于G的每一个非终结符A的任何两个不同产生式 A→α|β，下面的条件成立：SELECT( A→α)∩SELECT( A→β)&#x3D;,其中，</p>
<p>α|β不能同时ε。</p>
<p>解释：LL(1)的意思是，第一个L,指的是从左往右处理输入，第二个L,指的是它为输入生成一个最左推导。1指的是向前展望1个符号。LL(1)文法是上下文无关文法的一个子集。它用的方法是自顶向下的(递归式的处理)。它要求生成的预测分析表的每一个项目至多只能有一个生成式。上面的定义说的是，任何两个不同的产生式 A→α和 A→β,选择A→α或者 A→β是不能有冲突的，即SELECT( A→α)∩SELECT( A→β)&#x3D;，具体来说，就是，第一:First( A→α) ∩ First( A→β)&#x3D;,首符集不能有交集，否则当交集中的元素出现时，选择哪个产生式进行推导是不确定的，（这其中也包含了α|β不能同时ε，否则交集就是{ε}不为空），第二：若任何一个产生式β，有ε属于First(β),应有First(A)∩Follow( A)为空（当ε属于First(β)，则A有可能被空串代替，那么就要看A的下一个字符，即Follow集，即要求Follow集和First集不能相交，否则可能发生冲突）。</p>
<p>LR文法：定义：如果某一文法能够构造一张分析表，使得表中每一个元素至多只有一种明确动作，则该文法称为LR文法。</p>
<p>拓展：由上面的定义可以看到，LL(1)和LR文法都是无二义性的：LL(1)要求生成的预测分析表的每一个项目至多只能有一个生成式，即对于读头下的每一个字符，都可以明确地选择哪个产生式来推导，LR文法要求每一步都有明确的动作，移进和归约都是可确定的，没有二义性。</p>
<p>比较两大类型（自顶向下　vs 自底向上）的文法的特点：</p>
<p>1.首先LL(1)分析法是自上而下的分析法。LR(0),LR(1),SLR(1),LALR(1)是自下而上的分析法。<br>   2.自上而下:从开始符号出发，根据产生式规则推导给定的句子。用的是推导<br>   3.自下而上:从给定的句子规约到文法的开始符号。用的是归约<br>   4.自上而下就是一种试探过程，怎么试探？需要你写出它的FIRST()集与FOLLOW()集。写出这两个集合后根据LL(1)分析表构造规则画出LL(1)分析表。现在基本完成了大半，当计算机输入句子时，分析程序便会根据输入去和分析表进行匹配，如果每步都能够匹配成功则说明符合该语法规则，分析成功。<br>   FIRST()集：其实是终结符的集合，看该非终结符A能不能产生以它里面的某个符号开头的句子。（这也是自上而下分析法的思想）<br>   5.自下而上就是把句子变成非终结符，在把非终结符变成非终结符，这样不断的进行如果能到根节点则成功。</p>
<p> LL(1)就是向前只搜索1个符号，即与FIRST()匹配，如果FIRST为空则还要考虑Follow。<br>　 LR需要构造一张LR分析表，此表用于当面临输入字符时，将它移进，规约（即自下而上分析思想），接受还是出错。<br>   LR(0)找出句柄前缀，构造分析表，然后根据输入符号进行规约。不考虑先行，只要出现终结符就移进，只要出现归约状态，就无条件归约,这样子可能出现归约－移进，归约－归约冲突。<br>   SLR(1)使用LR(0)时若有归约－归约冲突，归约－移进冲突，所以需要看先行，则只把有问题的地方向前搜索一次。</p>
<p>SLR(1)定义：满足下面两个条件的文法是SLR(1)文法</p>
<p>a.对于在s中的任何项目 A→α.Xβ,当X是一个终结符，且X在Follow(B)中时，s中没有完整的项目B→r.</p>
<p>b.对于在s中的任何两个完整项目A→α.和 B→β.,Follow(A)∩Follow(B)为空。</p>
<p>解释：a.当X是一个终结符且X出现在读头上，对于项目 A→α.Xβ应该采用移进，若有完整的项目B→r.且Follow(B)中有X，当X出现在读头上时，此时应该归约，于是，就产生了移进和归约冲突</p>
<p>b.假设Follow(A)∩Follow(B)为{ X },对于A→α.，若Follow(A)[A后面的元素]出现时，应该归约，同理B也一样，于是，会产生归约－归约冲突，SLR(1)是为了消除LR(0)的两个冲突。<br>   LR(1)1.在每个项目中增加搜索符。2.举个列子如有A-&gt;α.Bβ，则还需将B的规则也加入。<br>   LALR(1)就是假如两个产生式集相同则将它们合并为一个，几合并同心集</p>
<p><strong>总结：</strong></p>
<p><strong>见到First集就移进，见到Follow集就归约。</strong></p>
<p><strong>LR(0):见到First集就移进，见到终态就归约</strong></p>
<p><strong>SLR(1)见到First集就移进，见到终态先看Follow集，与Follow集对应的项目归约，其它报错。</strong></p>
<p><strong>SLR分析法包含的展望信息是体现在利用了Follow(A)信息，可以解决“归约－归约”冲突</strong></p>
<p><strong>SLR分析法没有包含足够的展望信息，不能完成解决“移进－归约”冲突，需要改进。</strong></p>
<p><strong>下面是LR(0),SLR(1),LALR(1),LR(1)文法处理能力的比较，圆圈越大说明能力越强。</strong></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20130703204706828"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/03/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">编译原理-语法分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-27 15:18:13" itemprop="dateCreated datePublished" datetime="2020-03-27T15:18:13Z">2020-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-05 12:14:36" itemprop="dateModified" datetime="2020-07-05T12:14:36Z">2020-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="词法分析程序设计"><a href="#词法分析程序设计" class="headerlink" title="词法分析程序设计"></a>词法分析程序设计</h1><h2 id="词法分析任务"><a href="#词法分析任务" class="headerlink" title="词法分析任务"></a>词法分析任务</h2><p>词法分析阶段是编译的第一阶段，它的主要任务是<strong>从左至右扫描文本格式的源程序，从基于字符理解的源程序中分离出符合源语言词法的单词，最终转换成基于单词理解的源程序。</strong></p>
<blockquote>
<p>  <strong>输出形式为：</strong> <strong>（单词种类，单词）</strong></p>
<p><strong>单词种类类似于自然语言的词性，由构词规则等因素确定的。</strong></p>
<p>计算机高级语言一般都有<strong>关键字、标识符、常数、运算符和定界符</strong>这5类单词。</p>
</blockquote>
<h2 id="词法分析程序和语法分析程序的接口方式"><a href="#词法分析程序和语法分析程序的接口方式" class="headerlink" title="词法分析程序和语法分析程序的接口方式"></a>词法分析程序和语法分析程序的接口方式</h2><p>词法分析程序通常与后阶段语法分析程序接口有下列两种方式。</p>
<p>⑴词法分析程序和语法分析程序各自独立一趟方式。即词法分析程序把字符流的源程序转换成单词流的内部程序形式，供语法分析程序之用。</p>
<p>⑵词法分析程序和语法分析程序合并为一趟方式。即<strong>词法分析程序由反复语法分析程序调用，每调用一次从源程序中一个新单词返回给语法分析程序。</strong></p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200329103603763.png" style="zoom:67%;" />

<p>第一种方式的效率比较低。</p>
<h1 id="单词的描述工具"><a href="#单词的描述工具" class="headerlink" title="单词的描述工具"></a>单词的描述工具</h1><p>基于<strong>生成观点、计算观点和识别观点</strong>，分别形成了<strong>正规文法、正规式和有穷自动机</strong> 3种用于描述计算机高级语言词法的工具。</p>
<h2 id="正规文法"><a href="#正规文法" class="headerlink" title="正规文法"></a>正规文法</h2><p>对应的是生成观点。</p>
<p>左线性&#x2F;右线性正规文法描述。</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200329111144052.png" style="zoom:67%;" />

<h2 id="正规式"><a href="#正规式" class="headerlink" title="正规式"></a>正规式</h2><p>对应的是计算观点。</p>
<p>基于字母表∑上的正规式（也称为<strong>正则表达式</strong>）定义如下,正规式e的计算值称为正规集,记为L(e)。 </p>
<ol>
<li><p>ε是∑上的正规式，L(ε)＝ {ε} 【ε是空串】</p>
</li>
<li><p>Ф是∑上的正规式，L(Ф)＝Ф【Ф和ε不一样，它表示的是空集，对应的是实体的完整性】</p>
</li>
<li><p>任何a∈∑，a是∑上的正规式，L(a)＝ {a}</p>
</li>
<li><p>如果e<del>1</del>和e<del>2</del>是∑上的正规式，则</p>
<p>4.1.  (e<del>1</del>)是∑上的正规式，L((e<del>1</del>))＝L(e<del>1</del>)【直接脱括号】</p>
<p>4.2. e<del>1</del>︱e<del>2</del> 是∑上的正规式，L(e<del>1</del>︱e<del>2</del>)＝L(e<del>1</del>)∪L(e<del>2</del>)</p>
<p>4.3. e<del>1</del> · e<del>2</del> 是∑上的正规式，L(e<del>1</del>· e<del>2</del>)＝L(e<del>1</del>)·L(e<del>2</del>)</p>
<p>4.4. e<del>1</del>* 是∑上的正规式，L(e<del>1</del>*)＝L(e<del>1</del>)* 【闭包运算】</p>
</li>
</ol>
<blockquote>
<p>字母表∑1和∑2的乘积( product)：</p>
<p>　　∑1∑2 &#x3D;{ab|a ∈∑1, b ∈ ∑2}</p>
<p>　　例： {0, 1} {a, b} &#x3D;{0a, 0b, 1a, 1b}</p>
<p><em><strong>字母表∑的n次幂( power)：长度为n的符号串构成的集合</strong></em></p>
<p>　　∑0 &#x3D;{ ε }<br>　　∑n &#x3D;∑n-1 ∑ , n ≥0</p>
<p>　　例： {0, 1}3 &#x3D;{0, 1} {0, 1} {0, 1}&#x3D;{000, 001, 010, 011, 100, 101, 110, 111}</p>
<p>字母表的正闭包（positive closure）：长度正数的符号串构成的集合：</p>
<p>　　∑+ &#x3D; ∑ ∪∑2 ∪∑3 ∪…</p>
<p>　　例：{a, b, c, d }+ &#x3D; {a, b, c, d,aa, ab, ac, ad, ba, bb, bc, bd, …, aaa, aab, aac, aad, aba, abb, abc, …}</p>
<p>字母表的克林闭包（Kleene closure）：任意符号串（长度可以为零）构成的集合：</p>
<p>　　∑* &#x3D; ∑0 ∪∑+ &#x3D; ∑0 ∪∑ ∪∑2 ∪∑3 ∪…</p>
<p>　　例：{a, b, c, d }* &#x3D; {ε, a, b, c, d,aa, ab, ac, ad, ba, bb, bc, bd, …, aaa, aab, aac, aad, aba, abb, abc, …}</p>
</blockquote>
<blockquote>
<p>例 3.1 令∑＝{a,b}，则∑上正规式的例子如下，</p>
<p>​        a、a︱b、ab、(a︱b)* 、(a︱b)*a，</p>
<p>且 L(a)＝{a}</p>
<p>   L(a︱b)＝L(a)∪L(b)＝ {a}∪{b} ＝ {a,b}</p>
<p>   L((a︱b)*)＝L(L(a︱b))*＝({a,b})*＝{a,b}*</p>
<p>   L((a︱b)*a)＝L((a︱b)*)·L(a)＝ {a,b}*{a}【集合运算更有利于计算机的操作】</p>
</blockquote>
<p><strong>两个正规式e<del>1</del>和e<del>2</del>相等，是指正规式e<del>1</del>和e<del>2</del>计算值相等(即L(e<del>1</del>)＝ L(e<del>2</del>))，记为e<del>1</del>＝ e<del>2</del> 。</strong></p>
<p><strong>设r,s,t为正规式，则正规式有如下定律：</strong></p>
<p>​    <strong>1. 交换律：r︱s ＝ s︱r</strong></p>
<p>​    <strong>2. 结合律：（r︱s）︱t ＝ r︱（s︱t）</strong></p>
<p>​     <strong>（r·s）·t ＝ r·（s·t）</strong></p>
<p>​    <strong>3. 分配律：r·（s︱t）＝ r·s︱r·t</strong></p>
<p>​    <strong>（s︱t）·r ＝ s·r︱t·r</strong></p>
<blockquote>
<p>(1) 描述“标识符”单词的正规式</p>
<p>a(a︱b)*</p>
<p>​    其中，∑＝{a,b}，a —— 字母， b —— 数字</p>
<p> 正规集 ： L(a(a︱b)*)&#x3D;{a}{a,b}*</p>
<p>(2) 描述“整数”单词的正规式</p>
<p>dd*︱＋dd*︱－dd</p>
<p>​	其中，∑＝{＋,－,d}， d —— 数字</p>
<p>  正规集： L(dd*︱＋dd*︱－dd*)&#x3D;{+,－, ε}{d}{d}*</p>
</blockquote>
<h3 id="正规式和正规文法之间的转换"><a href="#正规式和正规文法之间的转换" class="headerlink" title="正规式和正规文法之间的转换"></a>正规式和正规文法之间的转换</h3><p>如果正规式r和文法G，有L(r)＝L(G)则称正规式r和文法G是等价的。</p>
<p><strong>转换方法：</strong></p>
<p>设∑上正规式r，则等价文法G＝(V<del>N</del>,V<del>T</del>,P,S)。其中,V<del>T</del>＝∑；从形如产生式 S→r 开始，按下表规则进行转换， 直到全部形如产生式， 符合正规文法之规则形式为止，可得到P和V<del>N</del> 。</p>
<table>
<thead>
<tr>
<th>规则1</th>
<th>A→xy</th>
<th>A→xB,B→y</th>
</tr>
</thead>
<tbody><tr>
<td>规则2</td>
<td>A→x*****y</td>
<td>A→xB,A→y；B→xB,B→y</td>
</tr>
<tr>
<td>规则3</td>
<td>A→x︱y</td>
<td>A→x, A→ y</td>
</tr>
<tr>
<td>注：A，B∈V<del>N</del> ，B为新增非终结符</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>逆过程</p>
<table>
<thead>
<tr>
<th>规则1</th>
<th>A→xB,B→y</th>
<th>A→xy</th>
</tr>
</thead>
<tbody><tr>
<td>规则2</td>
<td>A→xA︱y</td>
<td>A→x*y</td>
</tr>
<tr>
<td>规则3</td>
<td>A→x, A→ y</td>
<td>A→x |y</td>
</tr>
</tbody></table>
<h1 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/AndyEvans/p/10240790.html">参考文章</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/AndyEvans/p/10241031.html">参考文章</a></p>
<p>对应的是识别观点。</p>
<p>有穷自动机首先包含一个有限<strong>状态</strong>的集合，还包含了从一个状态到另外一个状态的<strong>转换</strong>。有穷自动机看上去就像是一个有向图，其中状态是图的节点，而状态转换则是图的边。此外这些状态中还必须有一个<strong>初始状态</strong>和至少一个<strong>接受状态</strong>。</p>
<p>这里提到的自动机特指有限状态自动机，简称为FA，根据状态转移的性质又分为确定的自动机（DFA）和非确定的自动机（NFA）。FA的表达能力等价于正规表达式或者正规文法。<strong>FA可以看做是一个有向带权图，图的顶点集合称为自动机的状态集合，图的权值集合为自动机的字母集合。</strong></p>
<p><strong>DFA、NFA和正则表达式是等价的。</strong></p>
<p>转换图 (Transition Graph)<br>　　结点：FA的状态<br>　　初始状态（开始状态）：只有一个，由start箭头指向<br>　　终止状态（接收状态）：可以有多个，用双圈表示<br>　　带标记的有向边：如果对于输入a，存在一个从状态p到状态q的转换，就在p、q之间画一条有向边，并标记上a</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108151439378-850603381.png" style="zoom:67%;" />

 

<h2 id="确定有穷自动机DFA"><a href="#确定有穷自动机DFA" class="headerlink" title="确定有穷自动机DFA"></a>确定有穷自动机DFA</h2><p>一个确定的有穷自动机DFA M是一个五元组：M&#x3D;(K,Σ,f,S,Z)。 </p>
<p>其中:</p>
<ul>
<li>K是非空有穷集，每个元素称为状态；</li>
<li>Σ是有穷字母表；</li>
<li>f是K×S→K映射，称为状态转换函数；s∈S, a∈Σ, δ(s,a)表示从状态s出发，沿着标记为a的边所能到达的状态。</li>
<li>S∈K，称为开始状态；</li>
<li>Z ⊂K，称为结束状态集，或接受状态集。</li>
</ul>
<p>转换函数<strong>f可以扩充为f’: K×Σ*→K</strong>映射，并以f替代f’使用。</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108152731112-2109218224.png" style="zoom:67%;" />

<p>上图中r&#x3D;(a|b)*abb；状态1：串以a结尾；状态2：串以ab结尾；状态3：串以abb结尾；</p>
<h2 id="DFA识别的语言"><a href="#DFA识别的语言" class="headerlink" title="DFA识别的语言"></a>DFA识别的语言</h2><p>设DFA M＝(K,Σ,f,S,Z)，如果α∈Σ*，f’(S,α)∈Z，则称符号串α是DFA M所接受(或识别)的。DFA M所接受的符号串的集合记为L(M)，即：</p>
<p><strong>L(M)＝{α︱α∈Σ*，f’(S,α)∈Z}。</strong></p>
<blockquote>
<p>一个DFA M＝(K,Σ,f,S,Z)，以带权有向图G&#x3D;(V，E)观点，还可采用图形直观描述：</p>
<ul>
<li>顶点表示状态(即V＝K)</li>
<li>加上粗箭头的顶点表示开始状态</li>
<li>双圈顶点表示接受状态</li>
<li>权为a的弧&lt;A,B&gt;(∈E)表示f(A,a)＝B。</li>
</ul>
<p>f(A，a)＝B也读作“状态A经过a转换到状态B”。</p>
</blockquote>
<h2 id="不确定有穷自动机NFA"><a href="#不确定有穷自动机NFA" class="headerlink" title="不确定有穷自动机NFA"></a>不确定有穷自动机NFA</h2><p>一个不确定的有穷自动机NFA M是一个五元组：M&#x3D;(K,Σ,f,S,Z)。</p>
<p>其中：</p>
<ul>
<li>K是非空有穷集，每个元素称为状态；</li>
<li>Σ是有穷字母表；</li>
<li>f是K×Σ∪{ε}→ρ(K)映射；f称为状态转换函数，ρ(K) 表示K之幂集。</li>
<li>S ⊂K，称为开始状态集；</li>
<li>Z ⊂K，称为结束状态集，或接受状态集。</li>
</ul>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108153217858-287134971.png" style="zoom:67%;" />

<p>上图中r&#x3D;(a|b)*abb；状态1：串以a结尾；状态2：串以ab结尾；状态3：串以abb结尾；</p>
<h3 id="带有“ε-边”的NFA"><a href="#带有“ε-边”的NFA" class="headerlink" title="带有“ε-边”的NFA"></a>带有“ε-边”的NFA</h3><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108160754427-678793579.png"></p>
<h3 id="NFA识别的语言"><a href="#NFA识别的语言" class="headerlink" title="NFA识别的语言"></a>NFA识别的语言</h3><p>设NFA M＝(K,Σ,f,S,Z)，如果α∈Σ*，f’(S,α)∩Z≠Φ，则称符号串α是NFA M所接受(或识别)的。NFA M所接受的符号串的集合亦记为L(M)，即：</p>
<p>​     <strong>L(M)＝{α︱α∈Σ*，f’(S,α)∩Z≠Φ}。</strong></p>
<h2 id="自动机的等价性"><a href="#自动机的等价性" class="headerlink" title="自动机的等价性"></a>自动机的等价性</h2><p>如果FA M<del>1</del>和FA M<del>2</del>接受相同的符号串的集合(即L(M<del>1</del>)＝L(M<del>2</del>))，则称FA M<del>1</del>和FA M<del>2</del>是等价的。</p>
<blockquote>
<p>对任何非确定的有穷自动机N ，存在定义同一语言的确定的有穷自动机D<br>对任何确定的有穷自动机D ，存在定义同一语言的非确定的有穷自动机N</p>
</blockquote>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108154711824-544131721.png"></p>
<h2 id="DFA和NFA的比较"><a href="#DFA和NFA的比较" class="headerlink" title="DFA和NFA的比较"></a>DFA和NFA的比较</h2><p>两类引擎要顺利工作，都必须有一个正则式和一个文本串，一个捏在手里，一个吃下去。DFA捏着文本串去比较正则式，看到一个子正则式，就把可能的匹配串全标注出来，然后再看正则式的下一个部分，根据新的匹配结果更新标注。而NFA是捏着正则式去比文本，吃掉一个字符，就把它跟正则式比较，匹配就记下来：“某年某月某日在某处匹配上了！”，然后接着往下干。一旦不匹配，就把刚吃的这个字符吐出来，一个个的吐，直到回到上一次匹配的地方。</p>
<p>DFA与NFA机制上的不同带来5个影响：</p>
<ol>
<li>DFA对于文本串里的每一个字符只需扫描一次，比较快，但特性较少；NFA要翻来覆去吃字符、吐字符，速度慢，但是特性丰富，所以反而应用广泛，当今主要的正则表达式引擎，如Perl、Ruby、Python的re模块、Java和.NET的regex库，都是NFA的。</li>
<li>只有NFA才支持lazy和backreference等特性；</li>
<li>NFA急于邀功请赏，所以最左子正则式优先匹配成功，因此偶尔会错过最佳匹配结果；DFA则是“最长的左子正则式优先匹配成功”。</li>
<li>NFA缺省采用greedy量词；</li>
<li>NFA可能会陷入递归调用的陷阱而表现得性能极差。</li>
</ol>
<p>e.g.</p>
<blockquote>
<p>例如用正则式&#x2F;perl|perlman&#x2F;来匹配文本 ‘perlman book’。如果是NFA，则以正则式为导向，手里捏着正则式，眼睛看着文本，一个字符一个字符的吃，吃完 ‘perl’ 以后，跟第一个子正则式&#x2F;perl&#x2F;已经匹配上了，于是记录在案，往下再看，吃进一个 ‘m’，这下糟了，跟子式&#x2F;perl&#x2F;不匹配了，于是把m吐出来，向上汇报说成功匹配 ‘perl’，不再关心其他，也不尝试后面那个子正则式&#x2F;perlman&#x2F;，自然也就看不到那个更好的答案了。</p>
<p>如果是DFA，它是以文本为导向，手里捏着文本，眼睛看着正则式，一口一口的吃。吃到&#x2F;p&#x2F;，就在手里的 ‘p’ 上打一个钩，记上一笔，说这个字符已经匹配上了，然后往下吃。当看到 &#x2F;perl&#x2F; 之后，DFA不会停，会尝试再吃一口。这时候，第一个子正则式已经山穷水尽了，没得吃了，于是就甩掉它，去吃第二个子正则式的&#x2F;m&#x2F;。这一吃好了，因为又匹配上了，于是接着往下吃。直到把正则式吃完，心满意足往上报告说成功匹配了 ‘perlman’。</p>
</blockquote>
<h2 id="ε闭包运算"><a href="#ε闭包运算" class="headerlink" title="ε闭包运算"></a>ε闭包运算</h2><p><strong>当处于某个指定状态时，如果该状态有ε边，那么，不需要吸收任何字符，就可以从该状态转换到ε边所指向的状态。</strong></p>
<p>e.g：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/643298-20190520094021908-797811750.png"></p>
<p>一开始，状态机处于起始状态12，</p>
<p>在状态12，通过ε边可直达状态2，6，</p>
<p>在状态2，可以通过ε边，直达状态0，3。也就是说，当处于状态12时，通过ε边的连接，可以同时抵达状态的集合是 {12，2，6，0，3}。</p>
<p><strong>通过一个状态，推算出它能同时抵达的状态集合,这个状态集合称作ε闭包集合，这种运算称之为ε闭包运算</strong>：<br>ε-closure(12) &#x3D; {12, 2, 6, 0, 3}。</p>
<p>接下来读入字符1，我们从闭包集合中看看，哪个状态节点有能够吸收数字的转换边。从上图观察，我们发现，</p>
<p>状态6和0，拥有吸收数字字符的转换边。</p>
<p>状态6吸收一个数字字符后，跳转到状态7，</p>
<p>状态0吸收字符1后，跳转到状态1，</p>
<p>这样我们可以说，状态集合{12， 2， 6， 0， 3} 在吸收字符1后，跳转到集合{1，7}，</p>
<p>后面这个集合{1，7}，<strong>我们称为转移集合(move set)</strong>, 我们把这种跳转运算标记如下：<br>move({12, 2, 6, 0, 3}, D} &#x3D; {1, 7}。</p>
<h2 id="NFA到DFA转换方法（子集法）"><a href="#NFA到DFA转换方法（子集法）" class="headerlink" title="NFA到DFA转换方法（子集法）"></a>NFA到DFA转换方法（子集法）</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012359618/article/details/42456771">参考文章</a></p>
<p>设 NFA M＝(K,Σ,f,S,Z)则与之等价的DFA M¢＝(K’,Σ’,f’,S’,Z’)，其中</p>
<p>⑴ K’＝ρ(K)(ρ(K)是K全部子集之集合称为K之幂集)</p>
<p>⑵ Σ’＝Σ</p>
<p>⑶ f’(q，a)＝ε_closure(M(q，a))【转换闭包ε-closure(s)表示由状态s经由条件ε可以到达的<strong>所有状态</strong>的集合】</p>
<p>⑷ S’＝ε_closure(S)</p>
<p>⑸ Z’＝{q︱q∈K’, q∩Z≠Φ}</p>
<p><strong>注解：</strong></p>
<p><strong>①从FA开始状态不存在路径到达的状态,称为不可达状态。</strong></p>
<p><strong>②考虑舍弃不可达状态的转换状态之计算,子集法可以简化从S’＝ε_closure(S)开始计算。</strong></p>
<p><strong>这些步骤的目的是为了消掉ε。</strong></p>
<p>设 NFA M＝(K,Σ,f,S,Z)，子集法得到与其等价的DFA M¢＝(K’,Σ,f’,S’,Z’之具体计算步骤可以是：</p>
<p>① 置K’为空集；</p>
<p>② 计算M’的开始状态S’＝ε_closure(S)， S’作为K’新增状态；</p>
<p>③ 对于K’每一新增状态q，计算出每个a∈S的转换状态p，即f’(q，a) ＝p＝ε_closure(M(q,a))。如果p∉K’，则p作为K’新增状态；</p>
<p>④ 重复③，直到K’不再出现新增状态为止；</p>
<p>⑤ 计算接受状态集Z’＝{q︱q∈K’,q∩Z≠Φ}。</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108191338570-1952257461.png"></p>
<p>例子：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/66efc2e9856a561252d36fcd.jpg"></p>
<h2 id="DFA的最小化"><a href="#DFA的最小化" class="headerlink" title="DFA的最小化"></a>DFA的最小化</h2><h3 id="消除多余状态"><a href="#消除多余状态" class="headerlink" title="消除多余状态"></a>消除多余状态</h3><ul>
<li>什么是多余状态<ul>
<li><strong>从这个状态出发没有通路到达终态</strong>（也称为死状态）</li>
<li><strong>从开始状态出发，任何输入串也不能到达的那个状态</strong></li>
</ul>
</li>
<li>如何消除多余状态<ul>
<li>删除</li>
</ul>
</li>
</ul>
<p> 例如：</p>
<blockquote>
<p>   如下为正规文法G[S]</p>
<p>​    S→aA|bQ； A→aA|bB|b；B→bD|aQ；Q→aQ|bD|b；D→bB|aA；E→aB|bF；F→bD|aE|b</p>
<p> 构造相应的DFA。 </p>
</blockquote>
<p>此处我们观察到E不出现在任何产生式的右部，所以E是无效符号，（其对应的状态就是多余状态）<br>删除E所在的产生式之后，符号F也不出现在任何产生式的右部，则F是无效符号，<br>删除F及其所在产生式。此时除了文法开始符号S之外，其余非终结符都是从S可达的。</p>
<h3 id="等价状态"><a href="#等价状态" class="headerlink" title="等价状态"></a>等价状态</h3><ul>
<li>何为等价状态，对于两个状态s和t<ul>
<li><strong>一致性条件</strong>：<strong>状态s和t必须同时为终态或非终态</strong></li>
<li><strong>蔓延性条件</strong>：<strong>对于所有输入符号，状态s和状态t必须转化到等价的状态里</strong></li>
</ul>
</li>
</ul>
<h3 id="DFA的化简算法：分割法"><a href="#DFA的化简算法：分割法" class="headerlink" title="DFA的化简算法：分割法"></a>DFA的化简算法：分割法</h3><p>对于DFA M&#x3D;(S,Σ,f,S0,Z)</p>
<ul>
<li><p>首先将DFA的状态集进行初始化，分成Π&#x3D;(Z,S-Z);</p>
</li>
<li><p>用下面的过程对Π构造新的划分Π new<br> for (Π中每个组G) do    &#x2F;&#x2F;每个组都是一个状态集<br> begin<br> 把G划分成小组，G中的任意两个状态Si和Sj在同一组中，当且仅当对于Σ中任意输入符号a ，Si和Sj的a转换是到同一组中，move(Si,a) ∈Gi ，move(Sj,a) ∈Gi。这样，只要Si和Sj的a转换是到不同的组中，则说明Si和Sj是可区别的，可进行划分。在Π new中用刚完成的对G的划分代替原来的G。<br> end ; Π :&#x3D; Π new；</p>
</li>
<li><p>重复执行(2)，直到Π中每个状态集不能再划分(Π new&#x3D; Π)为止;</p>
</li>
<li><p>合并等价状态 ,在每个G中，取任意状态作为代表，删去其它状态;</p>
</li>
<li><p>删去无关状态，从其它状态到无关状态的转换都成为无定义。</p>
</li>
</ul>
<blockquote>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/9251733-245a040972e1ec21.webp" style="zoom:67%;" />

<p>①首次划分: Π0&#x3D;({2,3,4,5},{0,1})<br> ②在G&#x3D;{2,3,4,5}中:f(2,a)&#x3D;1，f(4,a)&#x3D;0(转向终态集{0,1})；f(3,a)&#x3D;3,f(5,a)&#x3D;5(转向非终态集{2,3,4,5})，故{2,4}和{3,5}是可区别的，得Π1&#x3D;({2,4}，{3,5}，{0,1})；<br> ③在G&#x3D;{2,4}中，f(2,a)&#x3D;1，f(4,a)&#x3D;0(转向终态子集),而f(2,b)&#x3D;3,f(4,b)&#x3D;5(转向非终态子集{3,5}),所以不可区别，不再进行划分；<br> ④考察G&#x3D;{3,5}，f(3,a)&#x3D;3,f(5,a)&#x3D;5(转向非终态子集{3,5})，f(3,b)&#x3D;2,f(5,b)&#x3D;4(转向非终态子集{2,4}), 所以不可区别，不再进行划分；<br> ⑤考察G&#x3D;{0,1}，f(0,a)&#x3D;f(1,a)&#x3D;1(转向终态集{0,1}); f(0,b)&#x3D;2,f(1,b)&#x3D;4(转向非终态子集{2,4}),所以不可区别，不再进行划分；<br> ⑦进一步进行考察，可以发现每个子集都不能再划分了；<br> ⑧消去等价状态：{0,1}用0表示，{2,4}用2表示，{3,5}用3表示，如右图所示<br> ⑨去掉无关状态，因DFA M’中没有无关状态，所以下图即为最后结果。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9251733-887727ca13d4c204.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/756/format/webp" alt="img"></p>
</blockquote>
<h1 id="正规式和有穷自动机的等价性"><a href="#正规式和有穷自动机的等价性" class="headerlink" title="正规式和有穷自动机的等价性"></a>正规式和有穷自动机的等价性</h1><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108183412603-1278831634.png"></p>
<h2 id="正则式-到NFA的转换"><a href="#正则式-到NFA的转换" class="headerlink" title="正则式 到NFA的转换"></a>正则式 到NFA的转换</h2><p>□ ε对应的NFA</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108183642258-773357630.png" alt="img"></p>
<p>□ 字母表Σ中符号a对应的NFA</p>
<p><img src="https://img2018.cnblogs.com/blog/1350938/201901/1350938-20190108183656822-1565813934.png" alt="img"></p>
<p>□ r &#x3D; r1r2对应的NFA</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108184004292-217968247.png" alt="img"></p>
<p>□ r &#x3D; r1|r2对应的NFA</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108184016617-1377042977.png" alt="img"></p>
<p>□ r &#x3D; (r1)*对应的NFA</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108184040443-1516153785.png" alt="img"></p>
<p>例:r&#x3D;(a|b)*abb 对应的NFA</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108184348115-1799178457.png" alt="img"></p>
<h2 id="NFA到正规式的转换方法"><a href="#NFA到正规式的转换方法" class="headerlink" title="NFA到正规式的转换方法"></a>NFA到正规式的转换方法</h2><p>设NFA M＝( K,Σ,f,S,Z)，则与之等价的Σ上正规式R，可以由下列方法构造。</p>
<p>⑴ 在NFA M上，新增两个状态X和Y作为开始状态和接受状态，且将X经ε指向M的开始状态(任意q∈K，增加f(X,ε)&#x3D;q）, 将将M的开始状态经ε指向Y(任意q∈Z，增加f(q, ε)&#x3D;Y）。这样，得到一个与NFA M等价的、只有唯一开始状态X和唯一接受状态Y的NFA M’； </p>
<p>⑵ 按下列转换规则，逐步消除NFA M’中的状态，直到只剩下X和Y两个状态为止。弧上符号串，即为等价的S上正规式R。</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200331134705228.png" style="zoom:50%;" />

<h2 id="DFA到右线性正规文法转换"><a href="#DFA到右线性正规文法转换" class="headerlink" title="DFA到右线性正规文法转换"></a>DFA到右线性正规文法转换</h2><p>要把一个 DFA 转化为正则表达式，我们可以通过将它分解为更简单的子问题来迭代求解：</p>
<ul>
<li>将状态按 1、2、…、n 的顺序依次标号</li>
<li>先求任意状态 i 到 j（i 可以等于 j，即自身到自身），不经过其它状态的路径对应的正则表达式</li>
<li>求状态 i 到 j，最高只经过状态 1 的路径对应的正则表达式</li>
<li>求状态 i 到 j，最高只经过状态 2 的路径对应的正则表达式</li>
<li>依此类推……</li>
<li>求状态 i 到 j，最高只经过状态 n 的路径对应的正则表达式，即经过所有状态的路径对应的正则表达式</li>
</ul>
<h1 id="正规文法和有穷自动机间的转换"><a href="#正规文法和有穷自动机间的转换" class="headerlink" title="正规文法和有穷自动机间的转换"></a>正规文法和有穷自动机间的转换</h1><h2 id="正规文法到NFA转换方法"><a href="#正规文法到NFA转换方法" class="headerlink" title="正规文法到NFA转换方法"></a>正规文法到NFA转换方法</h2><p>设右线性正规文法G＝(V<del>N</del>,V<del>T</del>,P,S)，则与之等价的NFA M＝(V<del>N</del>∪{Z},V<del>T</del>,f,{S},{Z})，其中V<del>N</del>∩{Z}＝Φ，转换函数f可以由下列方法构造：</p>
<p>（1）如果A→a∈P ，  则f(A，a)&#x3D;Z；</p>
<p>（2） 如果A→ ε ∈P ，则f(A， ε)&#x3D;Z；</p>
<p>（3）如果A→aB∈P， 则f(A， a)&#x3D;B。</p>
<blockquote>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200331161412369.png" style="zoom:50%;" />

<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200331161358726.png"></p>
</blockquote>
<h2 id="DFA到正规文法转换方法"><a href="#DFA到正规文法转换方法" class="headerlink" title="DFA到正规文法转换方法"></a>DFA到正规文法转换方法</h2><p>设DFA M＝(K,Σ,f,S,Z)，则与之等价的右线性正规文法G＝(K,Σ,P,S)，其中规则集转换P可以由下列方法构造：</p>
<p>(1) 如果 f(B，a)＝C， 则B→aC∈P。</p>
<p>(2) 对接收状态 ∈Z， 增加S→ε</p>
<h2 id="构造词法分析程序的技术线路"><a href="#构造词法分析程序的技术线路" class="headerlink" title="构造词法分析程序的技术线路"></a>构造词法分析程序的技术线路</h2><p>(1)依据给定的源语言之单词集，设计其正规文法或正规式；</p>
<p>(2)之后等价地转换成非确定有穷自动机；</p>
<p>(3)再通过子集法将其确定化，最终将确定有穷自动机最小化；</p>
<p>(4最后依据最小化确定有穷自动机，设计词法分析程序。</p>
<h1 id="自顶向下语法分析方法"><a href="#自顶向下语法分析方法" class="headerlink" title="自顶向下语法分析方法"></a>自顶向下语法分析方法</h1><h2 id="分析思想"><a href="#分析思想" class="headerlink" title="分析思想"></a>分析思想</h2><p>自顶向下语法分析方法(即推导法)是从文法开始符S出发，逐步进行推导，以证实S&#x3D;&gt;α的推导过程是否存在的方法。</p>
<p>问题是每步推导会面临两次多种可能选择：</p>
<p>  ⑴ 选择句型中哪一个非终结符进行推导</p>
<p>  ⑵ 选择非终结符的哪一个规则进行推导</p>
<p>问题⑴可以采用<strong>最左推导</strong>解决。<strong>问题⑵通常需要穷举每一个规则的可能推导，即不确定的自顶向下语法分析</strong>。具体思想是：</p>
<p>一旦寻找到一个符号串α之推导过程，便结束穷举过程，断定符号串α是句子。</p>
<p>只有当穷举全部可能的推导，而没有一个符号串α之推导过程的时候，才可以断定符号串α不是句子。</p>
<h3 id="递归向下分析"><a href="#递归向下分析" class="headerlink" title="递归向下分析"></a>递归向下分析</h3><p>　　递归向下的语法分析可能需要回溯（aka需要重复扫描输入），考虑以下文法： S -&gt; aBc ，B -&gt; bc | b ,当我们用递归向下分析，输入为abc时，语法树如下图：</p>
<p>　　<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/102001293123161.jpg"></p>
<p>　　当我们第一次匹配时识别失败了（a匹配a，bc匹配B，最后一个c未匹配到），输入必须回到b，用B的另外一种方式匹配。</p>
<p>　　递归向下的分析十分直观，实现起来也比较方便，但效率较低，所以一般不采用。递归向下的分析方法实际上是深度优先搜索+回溯。而下面要说的预测分析则是用高效的动态规划来实现语法分析。</p>
<h3 id="递归预测向下分析"><a href="#递归预测向下分析" class="headerlink" title="递归预测向下分析"></a>递归预测向下分析</h3><p>　　　在讨论使用动态规划的预测向下分析之前，我们先来看一种特殊的预测向下分析。它在本质上也是递归的，唯一的区别在于它不需要回溯。考虑以下文法：A -&gt; aBb | bAB，伪代码实现如下：</p>
<p> <em>proc A {</em></p>
<p><em>case 当前标记 {</em></p>
<p>　　<em>‘a’:匹配a, 移动到下个标记;</em></p>
<p>　　　　　<em>调用函数B;<br>　　　　　匹配b, 移动到下个标记；<br>　　‘b’:匹配b，移动到下个标记；<br>　　　　　调用函数A；</em></p>
<p>　　　　　<em>调用函数B；</em></p>
<p>　　　　　　　<em>}<br>　　　　}</em></p>
<p> 　其实这种分析方式与前者的区别就在于它用了case语句来预测A的两种可能性，从而做出不同的判断。但这种方式的效率也是不如动态规划的。</p>
<h3 id="非递归预测向下分析"><a href="#非递归预测向下分析" class="headerlink" title="非递归预测向下分析"></a>非递归预测向下分析</h3><p>　　非递归预测向下分析是表驱动的分析方法，也叫做LL(1)分析。第一个”L”表示从左到右扫描。第二个”L”表示产生最左推导。”1”表示每次只要往前走一步就可以决定语法分析的动作。</p>
<p>所谓表驱动就是通过查表的方式来分析一个输入流是否符合文法。假设我们已经得到了这张语法分析表，现在来具体分析这种方式是如何工作的。</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/102344125308901.jpg">　　</p>
<p>首先我们需要一个栈来存储start symbol，即语法树的根。然后从表中查找当栈顶为S，输入为a时对应的文法，然后将S替换为aBa（注意入栈顺序），然后a与输入的a匹配，非终结标志B对应到了b，此时查找表中相应的文法，将B弹出栈，将bB压入栈（注意顺序）。以此类推直到栈底的终止字符匹配到了输入的终止字符，表示匹配成功。</p>
<p>上面是实例，下面我们给出一个高度的分析行为概括：</p>
<p>　　当栈顶为X,当前输入为a时，有以下四种分析行为：</p>
<p>　　1.如果X和a都为终止符号$，匹配成功，停止匹配。</p>
<p>　　2.如果X和a都是同一种终结标志(terminal symbol)，将X弹出栈，将输入移动到下个标志。（表示该标志成功匹配，准备匹配下个标志）</p>
<p>　　3.如果X是非终结标志(nonterminal symbol)，查询语法分析表，找到[S,a]，如果[S,a]为 X-&gt;Y<del>1</del>Y<del>2</del>Y<del>3</del>…Y<del>k</del>，则将Y<del>1</del>Y<del>2</del>Y<del>3</del>…Y<del>k</del>逆序放入栈中。（即Y<del>1</del>为栈顶）</p>
<p>　　4.不符合以上三种情况，匹配失败，进入错误恢复模式。</p>
<h4 id="FIRST集的定义"><a href="#FIRST集的定义" class="headerlink" title="FIRST集的定义"></a>FIRST集的定义</h4><p>设文法G＝（V<del>N</del>，V<del>T</del>，P，S），则FIRST(α)＝{a︱α&#x3D;&gt;*a β，a∈V<del>T</del>，α，β∈V *}</p>
<p>  特别地，α&#x3D;&gt;*ε，约定ε∈FIRST(α)。</p>
<p><strong>FIRST(α)是由α可以推导以终结符号开头符号串的头符号集合</strong>。如果所有非终结符右部的FIRST集合两两相交为空，可以使用确定的最左推导。</p>
<p>计算规则如下：</p>
<p>　　1.如果X是终结符号，first(X)&#x3D;{X}</p>
<p>　　2.如果X是非终结符号且X-&gt;ε是一个文法规则，那么ε属于first(X)</p>
<p>　　3.如果X是非终结符号且X-&gt;Y<del>1</del>Y<del>2</del>Y<del>3</del>…Y<del>n</del>是一个文法规则，那么：①如果终结符号a在first(Y<del>i</del>)中且ε在所有的first(Y<del>j</del>) (j-1,2,…i-1)中，那么a也属于first(X) ②如果ε在所有的first(Y<del>j</del>) (j&#x3D;1,2…n) 那么ε也属于first(X)</p>
<p>　　4.如果X本身为ε，那么first(X)&#x3D;{ε}</p>
<p>　　以上的规则将一直使用直到没有元素能够加入到任何first()当中。</p>
<blockquote>
<blockquote>
<p>如A-&gt;aB | CD</p>
</blockquote>
<p>这里面包含了组成First（A）的两种情况：<br>以终结符开头，当然要把这个终结符（a）放到A的First里<br>以非终结符开头，先把C的First放到A的First里</p>
</blockquote>
<h4 id="FOLLOW集的定义"><a href="#FOLLOW集的定义" class="headerlink" title="FOLLOW集的定义"></a>FOLLOW集的定义</h4><p>一般形式：</p>
<p>  输 入 串：  a<del>1</del>a<del>2</del>……a<del>i-1</del> a<del>i</del>……a<del>n</del></p>
<p>  句型推导：S&#x3D;&gt;* a<del>1</del>a<del>2</del>……a<del>i-1</del> Aβ</p>
<p>  如果使用空规则，意味着需要：β &#x3D;&gt;* a<del>i</del>……a<del>n</del></p>
<p>  则有句型：  S&#x3D;&gt;* a<del>1</del>a<del>2</del>……a<del>i-1</del> A a<del>i</del>……a<del>n</del></p>
<p>设文法G＝(V<del>N</del>,V<del>T</del>,P,S)，则FOLLOW(A)＝{a︱S&#x3D;&gt;* αAβ,A∈V<del>N</del>, a∈FIRST(β),α,β∈V*}</p>
<p>（或者：FOLLOW(A）＝{a︱S &#x3D;&gt;*  ···Aa···，A∈V<del>N</del>，a∈V<del>T</del> }）</p>
<p>　<strong>follow(A):从A之后可以立即得到（可以理解为与A相邻）的终结符号的集合,其中A是非终结符号。</strong></p>
<p>如果对非终结符A，有一条空规则，则A的FOLLOW集合和A的非空右部的FIRST集合两两相交为空，可以使用确定的最左推导。</p>
<p>计算规则如下：</p>
<p>　　1.如果A-&gt;aBb是一个文法规则，那么所有在first(b)中的元素除了ε都包含在follow(B)中。</p>
<p>　　2.如果A-&gt;aB是一个文法规则或者A-&gt;aBb是一个文法规则且ε包含在first(b)中，那么在follow(A)中的所有元素都在follow(B)中。即follow(A)属于follow(B)</p>
<p>　　以上的规则也将一直使用直到没有元素能够加入到任何follow()当中。</p>
<blockquote>
<blockquote>
<p>如S-&gt;(L) | aL | LC</p>
</blockquote>
<p>找Follow的三种情况：<br>先在候选式（右边）中找到该非终结符，如L（注意例中只有一个定义，但找Follow要看到所有右边出现该非终结符的）</p>
<p>如果L的右边是终结符，    那么这个终结符加入L的Follow</p>
<p>如果L的右边是非终结符， 那么把这个非终结符的First除去空加到L的Follow中</p>
<p>如果L处在末尾，那么，’-&gt;’左边符号的Follow成为L的Follow</p>
<p>另外要注意的是：<br>    开始符号的Follow中要加上‘#’        </p>
</blockquote>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/121008231083082.jpg"></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/20200314210706645.png"></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/121009242658099.jpg"></p>
<h4 id="SELECT集的定义"><a href="#SELECT集的定义" class="headerlink" title="SELECT集的定义"></a>SELECT集的定义</h4><p>$$<br>设文法G&#x3D;（V_N,V_T,P,S）,A\in V_N,A\to{\alpha}\in P,则\<br>SELECT(A\to{\alpha})&#x3D;\begin{cases}<br>FIRST(\alpha),&amp;(\alpha\not\Rightarrow\star\varepsilon)\<br>(FIRST(\alpha)-{(\varepsilon)})\cup(FOLLOW(A))&amp;(\alpha\Rightarrow\star\varepsilon)\<br>\end{cases}<br>$$</p>
<p>SELECT(A→α)称为规则A→α的选择集。它是FIRST(α)和FOLLOW(A)组成，是终结符号集V<del>T</del>的子集。</p>
<h2 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h2><p>文法G是LL(1)的，当且仅当G的任意两个具有相同左部的产生式A→α∣β满足下面的条件：</p>
<ul>
<li><p>不存在终结符a使得α和β都能推导出以a开头的串。</p>
</li>
<li><p>α和β至多有一个能推导出ϵ</p>
</li>
<li><p>如果$\beta \Rightarrow^*{\epsilon}$⇒则$FIRST(α)∩FOLLOW(A)&#x3D;Φ$<br>如果$α\Rightarrow^*{\epsilon}$⇒ 则$FIRST(β)∩FOLLOW(A)&#x3D;Φ$<br>因为如果$\beta \Rightarrow^*{\epsilon}$⇒ 那么$SELECT(β)$就包含了$FOLLOW(A)$，所以$FIRST(\alpha)$就不能包含$FOLLOW(A)$中元素。不然两个的SELECT集将会相交。</p>
</li>
<li><p>同一非终结符的各个产生式的可选集互不相交</p>
</li>
</ul>
<h3 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h3><ol>
<li><p>检查产生式中是否有含有左递归或左公因子：<br><strong>含有左递归或左公因子的文法一定不是LL(1)文法；</strong><br><strong>不含有左递归或左公因子的文法也不能确定是否为LL(1)文法；</strong></p>
</li>
<li><p>计算每个<strong>产生式</strong>的FIRST集：</p>
<p>①如果这个产生式右部第一个字符是终结符，那么这个终结符就属于它的FIRST集。</p>
<p>②如果这个产生式右部第一个字符是非终结符，那么这个非终结符的FIRST集就属于它的FIRST集。</p>
<p>如果这个非终结符的FIRST集中含ε，那么后面的字符如果是终结符……</p>
<p>③如果这个产生式右部可以推出ε，那么ε也属于它的FIRST集。</p>
</li>
<li><p>计算每个<strong>非终结符</strong>的FOLLOW集：</p>
<p>首先向开始符号的FOLLOW集中添加<code>#</code>，然后对于所有非终结符，不断的找含有它的产生式右部：</p>
<p>①该非终结符后面的字符若是终结符，那么这个终结符就属于它的FOLLOW集；</p>
<p>②该非终结符后面的字符若是非终结符，那么这个非终结符的FIRST()集中的所有元素就属于它的FOLLOW集；</p>
<p>如果这个非终结符的FIRST()集中含ε，将ε删去，同时将这个产生式左部FOLLOW集中的所有元素添加至它的FOLLOW集中；</p>
<p>注意：不需要考虑后面的字符了，因为已经包含在FIRST()集中了。</p>
</li>
<li><p>计算每个<strong>产生式</strong>的SELECT集：</p>
<p>①如果这个产生式可以推出ε，那么它的SELECT集是<code>&#123;FIRST(该产生式右部)-ε&#125;∪FOLLOW(该产生式左部的非终结符)</code>。</p>
<p>②如果这个产生式不能推出ε，那么它的SELECT集是<code>&#123;FIRST(该产生式右部)&#125;</code>。</p>
</li>
<li><p>检查相同左部产生式的SELECT集的交集：</p>
<p>检查相同左部产生式的SELECT集的交集，如果全为空集说明该文法是LL(1)文法，反之则不是。</p>
</li>
</ol>
<h2 id="非LL-1-文法到LL-1-文法的等价变换"><a href="#非LL-1-文法到LL-1-文法的等价变换" class="headerlink" title="非LL(1)文法到LL(1)文法的等价变换"></a>非LL(1)文法到LL(1)文法的等价变换</h2><p>但下面讨论的等价变换方法，仅仅确保变换的等价性（即L(G)＝L(G′)），不能保证变换后的文法G′一定是LL(1)文法。因此，对于变换后的文法G′，必须判别它是LL(1)文法后，方可使用确定的自顶向下语法分析方法。</p>
<h3 id="提取左公共因子法"><a href="#提取左公共因子法" class="headerlink" title="提取左公共因子法"></a>提取左公共因子法</h3><p>A→αβ<del>1</del>︱αβ<del>2</del>︱···︱αβ<del>n</del>︱γ<del>1</del>︱γ<del>2</del>︱···︱γ<del>m</del>可以推导出：</p>
<p> A→αB︱γ<del>1</del>︱γ<del>2</del>︱···︱γ<del>m</del>；B→β<del>1</del>︱β<del>2</del> ︱···︱β<del>n</del></p>
<h3 id="消除左递归法"><a href="#消除左递归法" class="headerlink" title="消除左递归法"></a>消除左递归法</h3><p>有直接左递归和间接左递归和一般左递归，对于间接左递归要先化成直接；</p>
<ul>
<li>直接左递归经过一次推导就可以看出文法存在左递归，如P→Pa｜b。</li>
<li>间接左递归侧需多次推导才可以看出文法存在左递归，如文法：S→Qc｜c，Q→Rb｜b，R→Sa｜a有S &#x3D;&gt;Qc &#x3D;&gt;Rbc &#x3D;&gt;Sabc</li>
</ul>
<h4 id="消除直接左递归法"><a href="#消除直接左递归法" class="headerlink" title="消除直接左递归法"></a>消除直接左递归法</h4><p>A→Aα<del>1</del>︱Aα<del>2</del>︱···︱Aα<del>m</del>︱β<del>1</del>︱β<del>2</del>︱···︱β<del>n</del> &#x3D;&gt;</p>
<p>A  →β<del>1</del> A′︱β<del>2</del> A′︱···︱β<del>n</del> A′；A′→α<del>1</del>A′︱α<del>2</del>A′︱···︱α<del>m</del>A′︱ε </p>
<blockquote>
<p>有文法G(E)：</p>
<p>E→E +T |T</p>
<p>T→T*F | F</p>
<p>F→i| (E)</p>
<p>消除该文法的直接左递归。</p>
<p>解：按转换规则,可得:</p>
<p>E→TE’</p>
<p>E’→+TE’|ε</p>
<p>T→FT ‘</p>
<p>T’→*FT’|ε</p>
<p>F→i| (E)</p>
</blockquote>
<h4 id="消除间接左递归法"><a href="#消除间接左递归法" class="headerlink" title="消除间接左递归法"></a>消除间接左递归法</h4><p>设非终结符按某种规则排序为A1，A2，<strong>…</strong>，An。</p>
<p><strong>For i﹕&#x3D;1 to n do</strong></p>
<p><strong>begin</strong></p>
<p><strong>For j﹕&#x3D;1 to i-1 do</strong></p>
<p><strong>begin</strong></p>
<p><strong>若Aj的所有产生式为：</strong></p>
<p><strong>Aj →δ1| δ2 | … | δn</strong></p>
<p><strong>替换形如Ai → Aj γ的产生式为：</strong></p>
<p><strong>Ai →δ1γ |δ2γ | … |δnγ</strong></p>
<p><strong>end</strong></p>
<p><strong>消除Ai中的一切直接左递归</strong></p>
<p><strong>end</strong></p>
<blockquote>
<p>以文法G6为例消除左递归：</p>
<p>(1)A→aB</p>
<p>(2)A→Bb</p>
<p>(3)B→Ac</p>
<p>(4)B→d</p>
<p>解：用产生式(1)，(2)的右部代替产生式(3)中的非终结A得到左部为B的产生式：</p>
<p>(1)B→aBc</p>
<p>(2)B→Bbc</p>
<p>(3)B→d</p>
<p>消除左递归后得到：</p>
<p>B→aBcB’ |dB’</p>
<p>B’→bcB’ |ε</p>
<p>再把原来其余的产生式A→aB,A→Bb加入，最终得到等价文法为:</p>
<p>(1) A→aB</p>
<p>(2) A→Bb</p>
<p>(3) B→(aBc|d)B’</p>
<p>(4) B’→bcB’|ε</p>
<p>c)消除文法中一切左递归的算法</p>
</blockquote>
<h3 id="递归下降分析法"><a href="#递归下降分析法" class="headerlink" title="递归下降分析法"></a>递归下降分析法</h3><p>通过计算的SELECT集判断编写子程序：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200423151629988.png"></p>
<p>递归下降分析法</p>
<p>ParseE’函数表示进入E’的产生式，通过switch函数分离相同左部的产生式，然后依次检查产生式右部字符，如果是终结符，则通过MatchToken函数判断符合，不符合则出错；如果是非终结符，则继续递归跳转至它所对应的Parse函数。</p>
<p>递归下降分析法对应的是最左推导过程<br>优点：程序结构和层次清晰明了，易于手工实现；<br>对于语义加工，这种方法十分灵活；<br>缺点：递归调用可能带来效率问题。</p>
<h3 id="预测分析法"><a href="#预测分析法" class="headerlink" title="预测分析法"></a>预测分析法</h3><p>首先根据计算出的SELECT集绘制出预测分析表</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200423151732414.png"></p>
<p>然后新建一个分析栈，向空栈中依次压入<code>#</code>和文法的开始符号<code>E</code>，然后比较剩余输入串的首字符和分析栈顶元素，如果不同，则先将分析栈顶元素出栈，然后将对应预测分析表中的产生式右部<u>从后向前</u>依次入栈；如果相同，则先将分析栈顶元素出栈，并将剩余输入串的首字符删去；然后重复以上过程直到栈为<code>#</code>，剩余输入串也为<code>#</code>，则表示语法匹配成功。</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200423151751741.png"></p>
<h3 id="LL-1-分析中的一种错误处理办法"><a href="#LL-1-分析中的一种错误处理办法" class="headerlink" title="LL(1)分析中的一种错误处理办法"></a><strong>LL(1)分析中的一种错误处理办法</strong></h3><p>发现错误的情况：<br>(1) 栈顶的终结符与当前输入符不匹配;<br>(2) 非终结符A于栈顶，面临的输入符为a，但分析表M的M[A,a]为空 （FIRST(A)中没有a）;</p>
<p>应急”恢复策略:<br>对于错误(1) 跳过输入串中的一些符号直至遇到和栈顶的终结符相同的字符为止。</p>
<p>对于错误((2) 跳过输入串中的一些符号直至遇到“同步符号”为止 。</p>
<p>同步符号的选择<br>(1) 把FOLLOW(A)中的所有符号作为A的同步符号。跳过输入串中的一些符号直至遇到这些“同步符号”，把A从栈中弹出，可使分析继续。（跳过A）<br>(2) 把FIRST(A)中的符号加到A的同步符号集，当FIRST(A)中的符号在输入中出现时，可根据A恢复分析。 （不跳过A）</p>
<h1 id="自底向上优先分析"><a href="#自底向上优先分析" class="headerlink" title="自底向上优先分析"></a>自底向上优先分析</h1><h2 id="优先分析概述"><a href="#优先分析概述" class="headerlink" title="优先分析概述"></a>优先分析概述</h2><p>优先分析法是利用句型相邻两个符号之间的所谓“优先关系”确定句柄。</p>
<p>优先关系由文法规则确定，其本质含义是在句型相邻两个符号中哪个符号可以优先归约。</p>
<p>采用简单优先分析法或算符优先分析法构造语法分析程序时，语法分析程序的总体框架如图所示。</p>
<h2 id="简单优先分析法"><a href="#简单优先分析法" class="headerlink" title="简单优先分析法"></a>简单优先分析法</h2><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200423160030288.png"></p>
<h3 id="优先关系定义"><a href="#优先关系定义" class="headerlink" title="优先关系定义"></a>优先关系定义</h3><p>1、X和Y优先级相等，表示为 <code>X=·Y</code>，当且仅当G中存在产生式规则A&#x3D;&gt;···XY···。</p>
<p><em>解读：X、Y的优先级相同，当XY存在一个句柄之中，它们将同时被归约。表现在语法树中S&#x3D;·b。</em></p>
<p>2、X优先级小于Y，表示为 <code>X&lt;·Y</code> ，当且仅当G中存在产生式规则A&#x3D;&gt;···XB···，B&#x3D;+&#x3D;&gt;Y···。</p>
<p><em>解读：X优先级小于Y，当XY存在一个句型中时，它们将不可能出现在同一个句柄中，Y一定比X先被规约。表现在语法树中b&lt;·a。</em></p>
<p>3、X优先级大于Y，表示为 <code>X&gt;·Y</code> ，当且仅当G中存在产生式规则A&#x3D;&gt;··BD···，B&#x3D;+&#x3D;&gt;···X，D&#x3D;*&#x3D;&gt;Y···。</p>
<p><em>解读：X优先级大于Y，当XY存在一个句型中时，它们将不可能出现在同一个句柄中，X一定比Y先被规约。表现在语法树中a&gt;·S。</em></p>
<p>X和Y的优先级为空，表示在文法的任何句型中都不会出现该符号对相邻出现的情况。</p>
<h3 id="简单优先文法定义"><a href="#简单优先文法定义" class="headerlink" title="简单优先文法定义"></a>简单优先文法定义</h3><p>一个文法是简单优先文法，需要满足以下两个条件：</p>
<ol>
<li>在文法符号集中V，任意两个符号之间必须之后一种优先关系存在。（显然满足）</li>
<li>在文法中，两个产生式不能有相同的右部。</li>
</ol>
<h3 id="简单优先分析法的操作步骤"><a href="#简单优先分析法的操作步骤" class="headerlink" title="简单优先分析法的操作步骤"></a>简单优先分析法的操作步骤</h3><ol>
<li><p>将输入输入串a<del>1</del>a<del>2</del>···a<del>n</del>#依次压栈，不断比较栈顶符号a<del>i</del>和下一个待输入符号a<del>j</del>的优先级，若a<del>i</del>&gt;·a<del>j</del>则进行下一步，否则重复此步骤。</p>
<p><em>解读：停止条件是a<del>i</del>&gt;·a<del>j</del>表示前面输入串一定比后面先归约，所以只需要在前面找句柄就行了。</em></p>
</li>
<li><p>栈顶符号a<del>i</del>即为句柄尾，从此处向左寻找句柄头a<del>k</del>，满足a<del>k-1</del>&lt;·a<del>k</del>。</p>
<p><em>解读：从后向前找a<del>k-1</del>&lt;·a<del>k</del>表示a<del>k</del>之前的输入串一定比a<del>i</del>···a<del>k</del>后归约，由此确定现在就是要归约a<del>i</del>···a<del>k</del>。</em></p>
</li>
<li><p>由句柄a<del>i</del>···a<del>k</del>在文法中寻找右部为a<del>i</del>···a<del>k</del>的产生式；找到则将句柄替换为相应左部，找不到则说明该输入串不是该文法的句子。</p>
</li>
<li><p>重复以上步骤直到归约完成。</p>
</li>
</ol>
<h2 id="算符优先分析法"><a href="#算符优先分析法" class="headerlink" title="算符优先分析法"></a>算符优先分析法</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li><p>**算符文法(OG)**：文法G中没有形如A&#x3D;&gt;···BC···的产生式，其中B、C为非终结符，则G为算符文法（operator grammar）。</p>
<p>也就是说产生式的<strong>右部不能出现两个非终结符相邻</strong>，就好像算式中两个操作数相连。</p>
<p><strong>算符文法的两个性质：</strong></p>
<p><code>①算符文法中任何句型都不包含两个相邻的非终结符。</code></p>
<p><code>②如果Ab（bA）出现在算符文法的句型y中，则y中含b的短语必含A，含A的短语不一定含b。</code></p>
</li>
<li><p>**算符优先文法(OPG)**：一个不含ε产生式的算符文法G，任意终结符对(a,b)之间最多只有一种优先关系存在，则G为算符优先文法（operator precedence grammar）。</p>
<p>以算式类比，也就是说我们只关心算符之间的优先关系，不关心操作数的优先关系，·利用算符的优先性和结合性来判断哪个部分先计算（归约）。</p>
<p><strong>注意 ：这里的优先关系与简单优先分析法中不一样。</strong></p>
<blockquote>
<p>a、b为终结符，A、B、C为非终结符</p>
<ol>
<li><p>a和b优先级相等，表示为 <code>a=·b</code> ，当且仅当G中存在产生式规则A&#x3D;&gt;···ab···或者A&#x3D;&gt;···aBb···。</p>
<p><em>解读：表示a、b在同一句柄中同时归约。</em></p>
</li>
<li><p>a优先级小于b，表示为<code>a&lt;·b</code>，当且仅当G中存在产生式规则A&#x3D;&gt;···aB···，且B&#x3D;^+^&#x3D;&gt;b···或B&#x3D;^+^&#x3D;&gt;Cb···。</p>
<p><em>解读：表示b、a不在一个句柄中，b比a先归约。</em></p>
</li>
<li><p>a优先级大于b，表示为 <code>a&gt;·b</code> ，当且仅当G中存在产生式规则A&#x3D;&gt;··Bb···，且B&#x3D;^+^&#x3D;&gt;···a或B&#x3D;^+^&#x3D;&gt;···aC。</p>
<p><em>解读：表示b、a不在一个句柄中，a比b先归约。</em></p>
</li>
</ol>
</blockquote>
<ol>
<li><strong>FIRSTVT()：</strong>FIRSTVT(B)&#x3D;{b|B&#x3D;^+^&#x3D;&gt;b···或B&#x3D;^+^&#x3D;&gt;Cb···,B∈V<del>N</del>，C∈V<del>N</del>,b∈V<del>T</del> }【在算符优先中，非终结符只会和一个终结符相邻】</li>
<li><strong>LASTVT()：</strong>LASTVT(B)&#x3D;{b|B&#x3D;^+^&#x3D;&gt;···b或B&#x3D;^+^&#x3D;&gt;···bC，B∈V<del>N</del>，C∈V<del>N</del>,b∈V<del>T</del>}</li>
<li><strong>素短语：</strong>（a）它首先是<strong>一个短语</strong>，（b）它至少含一个终结符号，（c）除自身外，不再包含其他素短语。</li>
</ol>
</li>
</ol>
<h3 id="最左素短语定理"><a href="#最左素短语定理" class="headerlink" title="最左素短语定理"></a>最左素短语定理</h3><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200427113818455.png" style="zoom:67%;" />

<h3 id="FIRSTVT-的构造算法"><a href="#FIRSTVT-的构造算法" class="headerlink" title="FIRSTVT()的构造算法"></a>FIRSTVT()的构造算法</h3><ol>
<li><p><strong>原理:</strong></p>
<p>①如果有这样的表达式：A&#x3D;&gt;a···或者A&#x3D;&gt;Ba···，那么a∈FIRSTVT(A)。</p>
<p>②如果有这样的表达式：B&#x3D;&gt;A···且有a∈FIRSTVT(A)，则a∈FIRSTVT(B)。</p>
</li>
<li><p><strong>算法：</strong></p>
<p>数据结构：</p>
<p> 布尔数组F[m,n]，m为非终结符数量，n为终结符数量，为真时表示对应a∈FIRSTVT(A)。</p>
<p> 栈S：暂存用于进行原理②的元素。</p>
<p>流程图：</p>
</li>
</ol>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200423191044780.png"></p>
<h3 id="算符优先关系矩阵的构造算法"><a href="#算符优先关系矩阵的构造算法" class="headerlink" title="算符优先关系矩阵的构造算法"></a>算符优先关系矩阵的构造算法</h3><ol>
<li><p><strong>原理</strong></p>
<p>&#x3D;·关系</p>
<p>查看所有产生式的右部，寻找A&#x3D;&gt;···ab···或者A&#x3D;&gt;···aBb···的产生式，可得a&#x3D;·b。</p>
<p>&lt;·关系</p>
<p>查看所有产生式的右部，寻找A&#x3D;&gt;···aB···的产生式，对于每一b∈FIRSTVT(B)，可得a&lt;·b。</p>
<p>&gt;·关系</p>
<p>查看所有产生式的右部，寻找A&#x3D;&gt;··Bb···的产生式，对于每一a∈LASTVT(B)，可得a&gt;·b。</p>
</li>
<li><p><strong>算法：</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">for</span> 每条规则U::= x1 x2…xn do</span><br><span class="line">    <span class="attribute">for</span> i:=<span class="number">1</span> to n-<span class="number">1</span> do</span><br><span class="line">    <span class="attribute">begin</span></span><br><span class="line">        <span class="attribute">if</span> xi和xi+<span class="number">1</span>均为终结符, THEN 置 xi=xi+<span class="number">1</span></span><br><span class="line">        <span class="attribute">if</span> i≤n-<span class="number">2</span>，且xi和xi+<span class="number">2</span>都为终结符号但xi+<span class="number">1</span>为非终结符号 then 置 xi=xi+<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">        <span class="attribute">if</span> xi为终结符号xi+<span class="number">1</span>为非终结符号 then</span><br><span class="line">            <span class="attribute">for</span> FIRSTVT(xi+<span class="number">1</span>)中的每个b do 置xi&lt;b</span><br><span class="line">    </span><br><span class="line">        <span class="attribute">if</span> xi为非终结符号xi+<span class="number">1</span>为终结符号 then</span><br><span class="line">            <span class="attribute">for</span> LASTVT(xi)中的每个a do 置a&gt;xi+<span class="number">1</span></span><br><span class="line">    <span class="attribute">end</span></span><br></pre></td></tr></table></figure>

<p>流程图：</p>
</li>
</ol>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200423191122833.png"></p>
<h2 id="算符优先分析法-1"><a href="#算符优先分析法-1" class="headerlink" title="算符优先分析法"></a>算符优先分析法</h2><p>实现算符优先分析法：<strong>找句型的最左子串（最左素短语）【在语法树中，位子在句型最左边的那个素短语】并进行规约</strong>。</p>
<p>具体实现：当栈内终结符的优先级＜或＝栈外终结符的优先级时，移进；当栈内终结符的优先级＞栈外终结符的优先级时，表明找到了素短语的尾，再往前找其头，并进行规约。</p>
<p>读入字符串为X<del>1</del>X<del>2</del>···X<del>n</del>#</p>
<p>数组S[n+2]用于存放压入栈的字符</p>
<p>流程图：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200423191158915.png"></p>
<h2 id="算符优先函数"><a href="#算符优先函数" class="headerlink" title="算符优先函数"></a>算符优先函数</h2><p><strong>迭代法</strong></p>
<p>若已知运算符之间的优先关系，可按如下步骤构造优先函数：</p>
<p>1、对每个运算符a（包括#在内）令f(a)&#x3D;g(a)&#x3D;1</p>
<p>2、如果a⋗b且f(a)&lt;&#x3D;g(b)令f(a)&#x3D;g(b)+1</p>
<p>3、如果a⋖b且f(a)&gt;&#x3D;g(b)令g(b)&#x3D; f(a)+1</p>
<p>4、如果a≐b而f(a) ≠g(b)，令min{f(a),g(b)}&#x3D;max{f(a),g(b)}</p>
<p>5、重复2~4，直到过程收敛。如果重复过程中有一个值大于2n，则表明不存在算符优先函数。</p>
<h2 id="算符优先关系表"><a href="#算符优先关系表" class="headerlink" title="算符优先关系表"></a>算符优先关系表</h2><h2 id="算符优先归约和规范规约"><a href="#算符优先归约和规范规约" class="headerlink" title="算符优先归约和规范规约"></a>算符优先归约和规范规约</h2><p>自下而上的语法分析，其分析过程为<strong>边输入单词符号，边归约，</strong>直至归约到文法的开始符号。（归约是指根据文法的产生式规则，把产生式的右部替换成左部符号）自下而上的分析方法的关键就是<strong>找到可归约串。</strong></p>
<p>对于简单问题（不用考虑优先级等问题）的自下而上语法分析有以下方法：<br>1.<strong>移进归约</strong>，即用一个寄存符号的先进后出栈，把输入符号一个一个地移进到栈里，当栈顶形成某个产生式的候选式时，即把栈顶的这一部分替换成(归约为)该产生式的左部符号；<br>2.<strong>规范规约</strong>，首先了解规范规约的定义，假定α是文法G的一个句子，如果序列α<del>n</del>，α<del>n-1</del>，… ，α<del>0</del>满足：(1)α<del>n</del>&#x3D;α(2)α<del>0</del>为文法的开始符号，即α<del>0</del>&#x3D;S(3)  对任何i，0&lt;i≤n，α<del>i-1</del>是α<del>i</del>把句柄（句型的最左直接短语即最左端的简单子树）替换成为相应产生式左部符号而得到的。我们称该序列是α的一个规范归约，<strong>规范规约即最左归约，可通过修剪最左简单子树实现；</strong><br>3.用符号栈进行自下而上的语法分析，取一个栈作为符号栈，在分析开始时，’#’预先进栈，作为栈底符号，将输入串中的符号依次入栈并规约，’#’作为输入串的结束符。</p>
<p>  在实际问题中往往能够需要考虑优先级，对于优先级问题有以下处理方法:（1）算符优先分析法，即定义算符之间的某种优先关系，借助这种优先关系找到可归约串并规约。这种优先关系往往是单向的，没有自反性。在算符优先分析法中将最左素短语作为可归纳串（算符优先分析一般不等于规范归约）；（2）优先函数法，优先函数是把每个终结符α与两个自然数f(α)与g(α)相对应，使得若α1 &lt;. α2，则f(α1) &lt; g(α2)，若α1 &#x3D;. α2，则f(α1) &#x3D; g(α2)，若α1 &gt;. α2，则f(α1) &gt; g(α2)，f称为入栈优先函数，g称为比较优先函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/03/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">编译原理-文法和语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-27 15:17:55" itemprop="dateCreated datePublished" datetime="2020-03-27T15:17:55Z">2020-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-04 08:07:22" itemprop="dateModified" datetime="2020-07-04T08:07:22Z">2020-07-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文法的直接概念"><a href="#文法的直接概念" class="headerlink" title="文法的直接概念"></a>文法的直接概念</h1><p>文法是阐述语法的一个工具，语句是语法的实例 。</p>
<blockquote>
<p>语言的构成：组成语言的基本形式是句子，句子是由单词序列构成的，单词是由语言基本符号（字母或单字）组成的。</p>
<p>语言既包含单词和句子这样的语言成分，又包含将这些成分组织起来的语言规则，如词法规则、句法规则等。</p>
<ul>
<li>语法：是一组规则，定义符号如何排列，排列与符号含义无关。</li>
<li>语句：是一组规则，定义符号如何排列，排列与符号含义无关。</li>
<li>语义：研究语法的含义</li>
</ul>
</blockquote>
<p><strong>约定（1）:符号”::&#x3D;”表示“···是由···组成的”</strong></p>
<p><strong>约定（2):符号”|”表示“或者”的意义</strong></p>
<p><strong>约定（3):符号”&#x3D;&gt;”表示“推导”</strong></p>
<p>eg：</p>
<blockquote>
<p>&lt;句子&gt; ∷＝&lt;主语&gt; &lt;谓语&gt; &lt;宾语&gt;<br>&lt;主语&gt; ∷＝&lt;名词&gt;<br>&lt;主语&gt; ∷＝&lt;代词&gt;<br>&lt;谓语&gt; ∷＝&lt;动词&gt;<br>&lt;宾语&gt; ∷＝&lt;名词&gt;<br>&lt;宾语&gt; ∷＝&lt;代词&gt;<br>&lt;代词&gt; ∷＝ 我<br>&lt;代词&gt; ∷＝ 你<br>&lt;动词&gt; ∷＝ 吃<br>&lt;动词&gt; ∷＝ 做<br>&lt;名词&gt; ∷＝ 饭<br>&lt;名词&gt; ∷＝ 菜</p>
</blockquote>
<blockquote>
<p>&lt;句子&gt; &#x3D;&gt; &lt;主语&gt; &lt;谓语&gt; &lt;宾语&gt;<br>&#x3D;&gt; &lt;代词&gt; &lt;谓语&gt; &lt;宾语&gt;<br>&#x3D;&gt; 我 &lt;谓语&gt; &lt;宾语&gt;<br>&#x3D;&gt; 我&lt;动词&gt; &lt;宾语&gt;<br>&#x3D;&gt; 我吃&lt;宾语&gt;<br>&#x3D;&gt; 我吃&lt;名词&gt;<br>&#x3D;&gt; 我吃饭</p>
</blockquote>
<blockquote>
<p>1、推导过程不唯一</p>
<p>2、推导起点的不同，导致语法意义上差异的推导结果</p>
</blockquote>
<p>语法形式化方法要点：</p>
<ul>
<li>语法规则的形式化</li>
<li>语法规则含有语法单位符号</li>
<li>语法规则含有构成语句的单词符号</li>
<li>特殊的语法单位符号——开始符号</li>
</ul>
<p><strong>语法形式化的最终目的在于将语法分析的问题将装换成形式化的推导过程。</strong></p>
<h1 id="符号和符号串"><a href="#符号和符号串" class="headerlink" title="符号和符号串"></a>符号和符号串</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><strong>字母表：字母表∑是非空有穷集合，其元素称为符号。</strong> </li>
<li><strong>符号串 由字母表∑中的符号组成的有穷序列称为 (字母表∑上的)符号串。特别地，不含任何符号的有穷序列称为空串，记为ε。单词和源程序都是符号串！</strong></li>
</ul>
<p>eg</p>
<blockquote>
<p>设字母表∑＝｛0，1｝，则</p>
<p>​     101是∑上的符号串，201不是∑上的符号串。</p>
</blockquote>
<ul>
<li><strong>符号串长度：符号串α的长度是指符号串α中含有符号的个数，记为︱α︱。特别约定，空串ε为零，即︱α︱＝0。</strong></li>
<li><strong>符号串集合：如果集合A的元素都是字母表∑上的符号串，则称集合A为∑上的符号串集合，简称串集。</strong></li>
</ul>
<p>eg</p>
<blockquote>
<p>  设字母表∑＝｛a，b，c｝，A＝｛ε，a，ba，cab｝，B＝｛a1，ba，cab｝，则</p>
<p>   A是∑上的符号串集合，B不是∑上的符号串集合。</p>
</blockquote>
<h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><ul>
<li><strong>符号串连接运算：设x和y是字母表∑上的符号串，在符号串x的最后一个符号之后顺序接上符号串y的符号得到的新符号串z，则称符号串z是由符号串x和符号串y经过连接运算的结果，记为z＝x·y，其中，·是连接运算符。</strong></li>
</ul>
<blockquote>
<p>设字母表∑＝｛a，b，c，0，1｝，x＝abc，y＝01cba，则  z＝x·y＝ abc01cba</p>
</blockquote>
<ul>
<li><p><strong>符号串方幂运算 设x是字母表∑上的符号串，z是由n(≥0)个x自身连接得到的符号串，则称符号串z是由符号串x的n次方幂运算的结果，记为z ＝ x^n^ 。特别约定，x^0^ ＝ε, x^1^＝x 。</strong></p>
</li>
<li><p><strong>符号串集连接运算 设A，B是字母表∑上的符号串集，·是符号串集连接运算，则C＝A·B＝｛x·y︱x∈A ，y∈B｝。 笛卡尔积</strong></p>
</li>
<li><p><strong>符号串集方幂运算 设A是字母表∑上的符号串集，则C是由n(≥0)个A自身连接得到的符号串集，则称符号串集C是由符号串A的n次方幂运算的结果，记为C ＝ A^n^ 。特别约定，A^0^ ＝｛ε｝,A^1^＝A 。</strong></p>
</li>
<li><p><strong>符号串集正闭包运算 设A是字母表∑上的符号串集， A+是A的正闭包，则: A+＝A^1^∪A^2^∪A^3^∪···∪A^n^··· 。</strong></p>
</li>
<li><p><strong>符号串集闭包运算 设A是字母表∑上的符号串集， A*是A的闭包，则 : A* ＝A0∪A+ ，</strong></p>
<p>​     <strong>即：A* ＝A^0^∪A^1^∪A^2^∪A^3^∪···∪A^n^··· 。</strong></p>
</li>
</ul>
<h2 id="文法和语言的形式定义"><a href="#文法和语言的形式定义" class="headerlink" title="文法和语言的形式定义"></a>文法和语言的形式定义</h2><p>规则是字母表V上形如 a∷＝b的式子，可以简写成a→b。其中，符号串a∈V^+^称为规则的左部，符号串b∈V*称为规则的右部。<strong>规则也称为重写规则、产生式或生成式。</strong></p>
<p>特别地，a∷＝ε（ε空串）称为a的空规则。</p>
<p>对于相同左部的多个规则，可以使用符号∣简写。如，规则a∷＝b和a∷＝δ，简写成a∷＝b∣δ。 简写为a → b∣δ</p>
<h3 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h3><p>文法G定义为一个四元组（V<del>N</del>，V<del>T</del>，P，S），记为G＝（V<del>N</del>，V<del>T</del>，P，S）。其中，</p>
<p> ① V<del>N</del>是非空有穷集合，称为非终结符集，其元素称为非终结符；</p>
<p> ② V<del>T</del>是有穷集合，称为终结符集，其元素称为终结符；</p>
<p> ③ P是非空有穷集合，称为规则集，其元素是字母表V<del>N</del>∪V<del>T</del>上的规则，<strong>V<del>N</del>∪V<del>T</del>称为文法的字母表V，且V<del>N</del>∩V<del>T</del>＝空集；</strong></p>
<p> ④ S∈V<del>N</del>，称为开始符。</p>
<h3 id="直接推导、直接归约"><a href="#直接推导、直接归约" class="headerlink" title="直接推导、直接归约"></a>直接推导、直接归约</h3><p>设文法G＝（V<del>N</del>，V<del>T</del>，P，S），<strong>如果α→β∈P，则称γ α δ推导出γ β δ，记为γ α δ&#x3D;&gt;γ β δ</strong>，其中,γ,δ∈V。</p>
<p>γ α δ&#x3D;&gt;γ β δ也称为直接推导或一步推导。</p>
<p>如果γ α δ&#x3D;&gt;γ β δ，则也称为γ β δ归约到γ α δ，也称为直接归约或一步归约。</p>
<blockquote>
<p>例如，例3.1 定义的文法G1＝({S}，{a，b}，{S→aSb，S→ab}，S)，推导例子有：</p>
<p>（1）S&#x3D;&gt; aSb (α＝S，β＝aSb，γ＝ε，δ＝ε)【ε是空集】</p>
<p>（2）aSb &#x3D;&gt; aaSbb (α＝S，β＝aSb，γ＝a，δ＝b)</p>
<p>（3）aSb &#x3D;&gt; aabb (α＝S，β＝ab，γ＝a，δ＝b)</p>
<p>（4）aSbSb &#x3D;&gt; aaSbbSb (α＝S，β＝aSb，γ＝a，δ＝bSb )</p>
</blockquote>
<h3 id="多步推导、多步归约"><a href="#多步推导、多步归约" class="headerlink" title="多步推导、多步归约"></a>多步推导、多步归约</h3><p>设文法G＝（V<del>N</del>，V<del>T</del>，P，S），α,β∈（V<del>N</del>∪V<del>T</del>）*， 如果α,β之间存在推导序列：</p>
<p>α＝ W<del>0</del> &#x3D;&gt; W<del>1</del> &#x3D;&gt; W<del>2</del> ··· &#x3D;&gt; W<del>n</del> ＝β（n≥1）,</p>
<p>则称α经过n步推导出β，记为α&#x3D;&gt;^+^β。其中，W<del>i</del>∈(V<del>N</del>∪V<del>T</del>)*</p>
<p>(1≤i≤n)。α&#x3D;&gt;^+^β也称n步推导或多步推导。</p>
<p>如果α&#x3D;&gt;^+^β，也称为β归约到α，也称为n步归约或多步归约。</p>
<blockquote>
<p>例如，例3.1 定义的文法G1＝({S}，{a，b}，{S→aSb，S→ab}，S) ，多步推导(Þ)例子有：</p>
<p>（1）S&#x3D;&gt;^+^ ab (∵S&#x3D;&gt; ab)</p>
<p>（2）S&#x3D;&gt;^+^ aabb (∵ S&#x3D;&gt; aSb&#x3D;&gt; aabb)</p>
<p>（3）S&#x3D;&gt;^+^ aaaSbbb (∵ S&#x3D;&gt; aSb&#x3D;&gt; aaSbb&#x3D;&gt; aaaSbbb)</p>
<p>（4）aSb &#x3D;&gt;^+^ aaabbb (∵ aSb&#x3D;&gt; aaSbb&#x3D;&gt; aaabbb)</p>
</blockquote>
<h3 id="0步或0步以上推导与归约"><a href="#0步或0步以上推导与归约" class="headerlink" title="0步或0步以上推导与归约"></a>0步或0步以上推导与归约</h3><p>设文法G＝（V<del>N</del>，V<del>T</del>，P，S），α,β∈（V<del>N</del>∪V<del>T</del> ) ^*^，如果有α→β或α&#x3D;&gt;^+^β，则称α经过0步或0步以上推导出β，记为α&#x3D;&gt;*β。亦称β经过0步或0步以上归约到α。</p>
<blockquote>
<p>例如，例3.1 定义的文法G1＝({S}，{a，b}，{S→aSb，S→ab}，S) ， 0步或0步以上推导(Þ)例子有：</p>
<p>   （1）S&#x3D;&gt;* ab，因为有S&#x3D;&gt;^+^ ab</p>
<p>   （2）S&#x3D;&gt;* aabb， 因为有S&#x3D;&gt;^+^aabb</p>
<p>   （3）S&#x3D;&gt;* aaabbb，因为有S&#x3D;&gt;^+^aaabbb</p>
<p>   （4）aSb &#x3D;&gt;* aaabbb，因为有aSb&#x3D;&gt;^+^ aaabbb</p>
<p>   （5）aSbSb &#x3D;&gt;*aSbSb，因为有aSbSb &#x3D;&gt;^+^ aSbSb</p>
</blockquote>
<h3 id="句型、句子"><a href="#句型、句子" class="headerlink" title="句型、句子"></a>句型、句子</h3><p>设文法G＝（V<del>N</del>，V<del>T</del>，P，S），如果有S&#x3D;&gt;* β，则称β是文法G的句型。如果有S&#x3D;&gt;* β，且β∈V<del>T</del>*，则称β是文法G的句子。</p>
<blockquote>
<p>例如，例3.1 定义的文法G1＝({S}，{a，b}，{S→aSb，S→ab}，S) ，句型和句子例子有：</p>
<p>（1）ab是G的句子，因为有S&#x3D;&gt;* ab ，ab∈VT*</p>
<p>（2）aabb是G的句子，因为有S&#x3D;&gt;*  aabb，aabb∈VT*</p>
<p>（3）aaaSbbb是G的句型，因为有S&#x3D;&gt;* aaaSbbb(aaaSbbb ∉ VT*)</p>
</blockquote>
<h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><p>文法G＝（V<del>N</del>，V<del>T</del>，P，S）的产生<strong>语言定义为文法G的句子集合</strong>，记为L(G)。即：</p>
<p>L(G)＝｛β︱S&#x3D;&gt;^<em>^β，β∈V<del>T</del>^</em>^｝。</p>
<h3 id="文法等价"><a href="#文法等价" class="headerlink" title="文法等价"></a>文法等价</h3><p>设G1和G2是两个文法，如果L(G1)＝L(G2)，则称文法G1和G2是等价的。</p>
<blockquote>
<p>例如，下列文法G2和G3是等价的。因为它们产生的语言都是以字母a开头、字母a和b构成的符号串的集合。即L(G2)＝L(G2）＝{a}{a，b}*。</p>
<p>G2＝(｛S，C｝，｛a，b｝，P，S），</p>
<p>  其中，P＝｛S→aC，C→aC ，C→bC, C→ε｝。</p>
<p>G3＝(｛S｝，｛a，b｝，P，S），</p>
<p>  其中，P＝｛S→Sa，S→Sb ，S→a｝。</p>
</blockquote>
<h2 id="文法类型"><a href="#文法类型" class="headerlink" title="文法类型"></a>文法类型</h2><h3 id="0型文法"><a href="#0型文法" class="headerlink" title="0型文法"></a>0型文法</h3><p>设文法G＝（V<del>N</del>，V<del>T</del>，P，S），如果任意α→β∈P，α中至少含有一个非终结符，则称文法G属于0型文法。0型文法，也称为短语文法。</p>
<h3 id="1型文法"><a href="#1型文法" class="headerlink" title="1型文法"></a>1型文法</h3><p>设文法G＝（V<del>N</del>，V<del>T</del>，P，S），如果任意α→β∈P，α中至少含有一个非终结符，且除空规则之外，α的长度不大于β的长度，即︱α︱≤︱β︱，则称文法G属于1型文法。1型文法，也称为上下文有关文法。</p>
<blockquote>
<p>文法G5定义如下，显然G5是1型文法。</p>
<p>​      L(G5）＝｛a^n^b^n^c^n^︱n≥1｝。</p>
<p>G5 ＝（V<del>N</del>，V<del>T</del>，P，S），</p>
<p>  其中，V<del>N</del>＝｛S，B，C｝，</p>
<p>   V<del>T</del>＝｛a，b，c｝，</p>
<p>   P ＝｛S→aSBC︱aBC，CB→BC，</p>
<p>​        aB→ab，bB→bb，</p>
<p>​        bC→bc，cC→cc｝</p>
</blockquote>
<h3 id="2型文法"><a href="#2型文法" class="headerlink" title="2型文法"></a>2型文法</h3><p>设文法G＝（V<del>N</del>，V<del>T</del>，P，S），如果任意α→β∈ P，α∈V<del>N</del> ，则称文法G属于2型文法。2型文法，也称为上下文无关文法。</p>
<blockquote>
<p>例3.6 文法G6定义如下，显然G6是2型文法。</p>
<p>  L(G6）＝｛w$w^R^︱n≥0, w^R^ 为w之逆，w∈{0，1}*｝</p>
<p>G6 ＝（V<del>N</del>，V<del>T</del>，P，S），</p>
<p>   其中，V<del>N</del>＝｛S｝，</p>
<p>​      V<del>T</del> ＝｛$，0，1｝，</p>
<p>​      P ＝｛S→0S0︱1S1︱$ ｝</p>
</blockquote>
<h3 id="3型文法"><a href="#3型文法" class="headerlink" title="3型文法"></a>3型文法</h3><p>文法  设文法G＝（V<del>N</del>，V<del>T</del>，P，S），如果任意α→β∈ P，α∈ V<del>N</del> ，且β只能是aB或a（除空规则之外），则称文法G属于右线性3型文法。【B是非终结符】</p>
<p>设文法G＝（V<del>N</del>，V<del>T</del>，P，S），如果任意α→β∈ P，α∈ V<del>N</del> ，且β只能是Ba或a（除空规则之外），则称文法G属于左线性3型文法。</p>
<p>左线性3型文法和右线性3型文法，统称3型文法，也称为正规文法。</p>
<blockquote>
<p>例2.7 文法G7定义如下。显然G7是3型文法。</p>
<p>​      L(G7）＝｛00，01，10，11｝。</p>
<p>G7 ＝（V<del>N</del>，V<del>T</del>，P，S），</p>
<p> 其中，V<del>N</del>＝｛S，A，B｝，</p>
<p> V<del>T</del>＝｛0，1｝，</p>
<p>  P ＝｛S→A0︱B1，A→0︱1，B→0︱1｝</p>
</blockquote>
<p>文法分类是对规则形式逐步加以限制而得。换言之，从0型文法到1型文法、2型文法和3型文法，其规则形式逐步简单。自然，其表达力也随之逐步减弱。</p>
<p>如果L0、L1、L2和L3分别是0型文法、1型文法、2型文法和3型文法能产生的语言之集，则有如下关系：</p>
<p>L0 ⊋ L1 ⊋ L2 ⊋ L3。</p>
<h2 id="上下无关文法及其语法树"><a href="#上下无关文法及其语法树" class="headerlink" title="上下无关文法及其语法树"></a>上下无关文法及其语法树</h2><p>上下无关文法一个显著特征是<strong>规则左部一定有且仅有一个非终结符</strong>。利用这个特征，可以不列出V<del>N</del>和V<del>T</del> ，给出一个上下无关文法的简洁描述方法：①文法名G改写成G[S]，其中，S表示开始符；②规则集P，仅书写其具体规则。</p>
<h3 id="最左推导、最右推导"><a href="#最左推导、最右推导" class="headerlink" title="最左推导、最右推导"></a>最左推导、最右推导</h3><p>如果在推导的每一步<strong>总是选择当前句型的最左（最右）边非终结符进行推导</strong>，则称这种推导过程为最左（最右）推导。最右推导，也叫规范推导。由规范推导所得的句型，叫做规范句型。规范推导的逆过程，叫做规范归约。</p>
<blockquote>
<p>G[S]：S→aAS︱a</p>
<p>   A→SbA︱SS︱ba</p>
<p>最左推导：S &#x3D;&gt; aAS &#x3D;&gt; aSbAS &#x3D;&gt; aabAS &#x3D;&gt; aabbaS &#x3D;&gt; aabbaa</p>
<p>最右推导：S &#x3D;&gt; aAS &#x3D;&gt; aAa &#x3D;&gt; aSbAa &#x3D;&gt; aSbbaa &#x3D;&gt; aabbaa</p>
<p>一般推导：S &#x3D;&gt; aAS &#x3D;&gt; aSbAS &#x3D;&gt; aSbAa &#x3D;&gt; aabAa &#x3D;&gt; aabbaa</p>
</blockquote>
<h3 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h3><p>假设文法G＝（V<del>N</del>，V<del>T</del>，P，S），则文法G的语法树是一个满足下列条件的多叉树：</p>
<p>（1）以文法开始符S做为树根；</p>
<p>（2）以终结符号或非终结符号做为树的其他结点，且子树根和其孩子结点分别是某规则的左部和右部。</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E9%9F%B3/image-20200328134034228.png" style="zoom: 67%;" />

<p><strong>推论： ①非叶子结点一定是非终结符</strong></p>
<pre><code>           **②全部叶子结点组成的符号串是文法的句子**
</code></pre>
<h3 id="语义二义性"><a href="#语义二义性" class="headerlink" title="语义二义性"></a>语义二义性</h3><p>如果一个文法G，某个句子存在对应的至少两棵不同的语法树，则称文法G是二义性的。</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E9%9F%B3/image-20200328134255807.png" alt="image-20200328134255807" style="zoom:67%;" />

<p><strong>推论</strong>： </p>
<p> <strong>① 如果文法是无二义性的，一个句子的语法树反映了该句子的全部推导过程；</strong></p>
<p> <strong>②</strong> <strong>如果文法是无二义性的，一个句子的最左（最右）推导是唯一的。</strong></p>
<h3 id="语义的先天二义性"><a href="#语义的先天二义性" class="headerlink" title="语义的先天二义性"></a>语义的先天二义性</h3><p>文法的二义性，并不等同于语言的二义性，尽管两者之间可能存在非必然的联系。</p>
<p>因为二义性文法G，可能存在与之等价的无二义性的文法G′，即L(G)＝L(G′）。 </p>
<p>如果一个语言不存在无二义性的文法，则称该语言是先天二义性的。</p>
<blockquote>
<p>例如，语言L＝{a^i^b^j^c^k^︱(i＝j 或i＝k)，(i，j，k≥1)}不存在无二义性的文法，是先天二义性的语言。</p>
</blockquote>
<p><strong>已经证明：文法的二义性判定问题是递归不可解的。即不存在这个判定问题的算法。</strong></p>
<h2 id="句型分析"><a href="#句型分析" class="headerlink" title="句型分析"></a>句型分析</h2><p>假设文法G[S]是语言L之文法，即L(G)＝L，则“符号串α是否符合语言L的语法问题”被等价地转化成“推导或归约问题”，即：</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E9%9F%B3/image-20200328134758183.png" style="zoom:50%;" />

<p>【从起始符推导出α，并且α是非终结符组成的串，也就是α不能再细分】</p>
<p>【归约和推导可以视作是一个相反的过程】</p>
<p>这样，自然地形成了推导法和归约法两大类分析方法。推导法和归约法，也分别称为自上而下的分析方法和自下而上的分析方法。</p>
<h3 id="自上而下的分析方法"><a href="#自上而下的分析方法" class="headerlink" title="自上而下的分析方法"></a>自上而下的分析方法</h3><p>从文法开始符号出发，反复使用规则，寻找匹配符号串（推导）的句型，直到推导出句子或规则用遍。<strong>进行每步推导时，存在两个选择问题：</strong></p>
<p>  <strong>⑴ 选择句型中哪一个非终结符进行推导</strong></p>
<p>  <strong>⑵ 选择非终结符的哪一个规则进行推导</strong></p>
<p><strong>问题⑴可以采用最左推导解决。问题⑵通常需要穷举每一个规则的可能推导。</strong></p>
<p><strong>成功：在推到过程中一旦出现个符号串α，便结束穷举过程，断定符号串α是句子。</strong></p>
<p><strong>失败：当穷举全部可能的推导，而不存在一个符号串α之推导过程的时候，才可以断定符号串α不是句子。</strong></p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E9%9F%B3/image-20200328140215540.png" style="zoom:67%;" />

<h3 id="自下而上的分析方法"><a href="#自下而上的分析方法" class="headerlink" title="自下而上的分析方法"></a>自下而上的分析方法</h3><p>从输入符号串α开始，逐步进行“归约”，直至归约出文法的开始符号 S，则输入串α是文法G定义的语言的句子。否则不是。</p>
<p>这种分析方法在进行每步归约时，存在两个如何选择句型α的子串β进行归约的问题(α&#x3D;β δ)。</p>
<p>如果文法规则没有相同的右部，则在语法分析的过程中，一旦出现子串β与某条规则的右部相同，就可以使用这条规则进行归约,简单优先分析法就是采用此方法进行归约。</p>
<p>但这种限制，实际上也限制了文法的表达能力，所以通常是通过在句型中寻找所谓的“句柄”的途径解决的。</p>
<h3 id="短语、直接短语、句柄"><a href="#短语、直接短语、句柄" class="headerlink" title="短语、直接短语、句柄"></a>短语、直接短语、句柄</h3><p>设G[S]是一文法，αβδ是文法G的句型，如果有S&#x3D;&gt;^*^αAδ且A&#x3D;&gt;^+^β，则称β是句型αβδ的、相对于非终结符A的短语。</p>
<p>特别地，当A&#x3D;&gt;^+^β实际是A&#x3D;&gt;β即<strong>一步推导时</strong>，则又称β是句型αβδ的、相对于非终结符A的直接短语（或简单短语）。</p>
<p><strong>句型的最左直接短语，称为该句型的句柄。</strong></p>
<blockquote>
<p>短语的理解：</p>
<p> “αβδ是文法G的句型”，即S &#x3D;&gt;^*^αβδ</p>
<p> “S&#x3D;&gt;^*^αAδ且A&#x3D;&gt;^+^β”，即S&#x3D;&gt; … &#x3D;&gt;αAδ&#x3D;&gt; … &#x3D;&gt;αβδ</p>
<p>  这表明，如果β是句型αβδ的、相对于A的短语，则至少存在一个推导，使得αAδ &#x3D;&gt;^+^ αβδ，或者αβδ&lt;&#x3D;^+^ αAδ。</p>
<p>  特别地，如果β是直接短语，则αAδ &#x3D;&gt; αβδ，或者αβδ&lt;&#x3D;αAδ。</p>
</blockquote>
<p>【直接短语、短语都是某一个句型的子串】</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E9%9F%B3/image-20200328144445764.png"></p>
<p>在语法树中，<strong>短语是子树的叶子的组合</strong>；<strong>直接短语是两层子树的末端</strong>【i3和F1是两层子树】</p>
<h2 id="文法在实用中的一些说明"><a href="#文法在实用中的一些说明" class="headerlink" title="文法在实用中的一些说明"></a>文法在实用中的一些说明</h2><p>在实际应用中，对于文法规则提出了一些限制条件，但这些并没有限制文法的语言描述能力。限制下列 3种规则的使用：</p>
<p><strong>（1）有害规则 形如U→U的规则，称为有害规则。</strong></p>
<p><strong>（2）不可达规则 不在任何规则右部出现的非终结符对应的规则，称为不可达规则。</strong></p>
<p><strong>（3）不可终止规则  如果从某非终结符开始，不可能推导出任意终结串来，则该非终结符对应的规则称为不可终止规则。</strong></p>
<p><strong>不含有多余规则的文法，称为压缩过的文法。在后面讨论的文法时，都假设是压缩过的的文法。</strong></p>
<h3 id="ε规则问题"><a href="#ε规则问题" class="headerlink" title="ε规则问题"></a>ε规则问题</h3><p>在文法设计中，使用ε规则有时会带来方便，但会导致文法讨论和证明的复杂。</p>
<p>一个上下文无关文法G是否必须使用ε规则，完全取决于文法G产生的语言L(G[S])中是否含有ε语句。</p>
<p>可以证明，如果ε不属于L(G[S]),则存在一个等价的文法G’[S’] ，且G’ 不含ε规则。</p>
<p>如果ε∈ L(G[S]),则存在一个等价的文法G’[S’] ，且G’ 仅含S’ →ε的一个空规则。</p>
<p><strong>提示：使用“代入法”，即可得到等价的文法G’(S’)</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/03/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">编译原理-概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-22 19:57:34" itemprop="dateCreated datePublished" datetime="2020-03-22T19:57:34Z">2020-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-04 07:27:04" itemprop="dateModified" datetime="2020-07-04T07:27:04Z">2020-07-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="编译原理概述"><a href="#编译原理概述" class="headerlink" title="编译原理概述"></a>编译原理概述</h1><h2 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a>编译程序</h2><p>编译程序是现代计算机系统的基本组成部分。</p>
<ul>
<li>功能上：一个编译程序就是一个语言翻译程序。把源语言翻译成目标语言。</li>
<li>目的：让程序员不需要考虑机器的细节。</li>
</ul>
<blockquote>
<p>需要处理的源程序—（预处理器）—源程序—（编译程序）—-目标汇编程序—（汇编程序）—可再装配的机器代码—（装配连接编辑）—绝对机器码</p>
</blockquote>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%A6%82%E8%BF%B0/image-20200325150810603.png" style="zoom:67%;" />

<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%A6%82%E8%BF%B0/image-20200325151402593.png" style="zoom:67%;" />

<p>编译过程的阶段是一种逻辑上的划分：</p>
<ul>
<li>划分“前端&#x2F;后端”。 将与仅依赖于源程序而与目标机器（硬件）无关的阶段组合成前端，将与目标机器（硬件）相关的阶段组合成后端。<ul>
<li>前端：语法分析程序、语义分析程序</li>
<li>后端：中间代码生成程序、代码优化程序、目标代码生成程序</li>
</ul>
</li>
<li>划分“遍”。从头到尾扫描一遍输入串称谓遍。每遍可以完成编译的若干阶段的编译任务。</li>
</ul>
<h3 id="词法分析（扫描）"><a href="#词法分析（扫描）" class="headerlink" title="词法分析（扫描）"></a>词法分析（扫描）</h3><p>语法分析器读入组成源程序的字符流，并且将它们组织成为有意义的词素的序列。&lt;token-name,attribute-value&gt;</p>
<p>token-name是一个由语法分析步骤使用的抽象符号；attribute-value指向符号表中关于这个词法单元的条目。符号表条目的信息会被语义分析和代码生成步骤使用。</p>
<p><strong>单词符号：</strong></p>
<ul>
<li>常数</li>
<li>保留字</li>
<li>标识符</li>
<li>运算符</li>
<li>界符等类型（例如：空格、括号···）</li>
</ul>
<h3 id="语法分析（解析）"><a href="#语法分析（解析）" class="headerlink" title="语法分析（解析）"></a>语法分析（解析）</h3><p>语法分析器使用由词法分析器生成的各个词法单元的第一个分量来创建树形的中间表示。该中间表示给出了词法分析产生的词法单元流的语法结构。</p>
<p><strong>功能：</strong>层次分析，依据源程序的语法规则把源程序的单词序列组成语法短语（表示成语法树）</p>
<p>语法树中的每个内部结点表示一个运算，而该结点的子结点表示该运算的分量。</p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>语义分析器使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。同时收集类型信息，并且将这些信息存放在语法树或符号表中，方便在随后的中间代码生成过程中使用。</p>
<p><strong>类型检查：检查每个运算符是否具有匹配的运算分量（例如：要求的数组是一个整数，但是给定的是一个浮点数，编译器就会报错）</strong></p>
<h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><p>在源程序的语法分析和语义分析完成后，很多编译器生成一个明确的低级的或类机器语言的中间表示。可以把这个表示看作是某个抽象机器的程序（应具有两个性质：易于生成、易于翻译成目标机器的语言。）</p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>机器无关的代码优化步骤试图改进中间代码，以便生成更好的目标代码。</p>
<h3 id="符号表管理"><a href="#符号表管理" class="headerlink" title="符号表管理"></a>符号表管理</h3><ul>
<li><p>记录源程序中使用的各种符号名称</p>
</li>
<li><p>收集每个符号的各种名称的属性信息</p>
</li>
<li><p>类型、作用域、分配存储信息</p>
</li>
<li><p>符号表管理(）</p>
<ul>
<li>登录：扫描到说明语句就将标识符登记在符号表中</li>
<li>查找：在执行语句查找标识符的属性，判断语义是否正确</li>
</ul>
</li>
</ul>
<p>错误检查</p>
<ul>
<li><p>报告出错信息</p>
</li>
<li><p>排错</p>
</li>
<li><p>恢复编译工作</p>
</li>
</ul>
<h2 id="编译方式和解释方式"><a href="#编译方式和解释方式" class="headerlink" title="编译方式和解释方式"></a>编译方式和解释方式</h2><p>采用编译方式的编译程序称为编译型的编译程序，简称编译程序；采用解释方式的编译程序称为解释型的编译程序，简称解释程序。</p>
<p>　　编译方式是先翻译后执行，即将整个源程序翻译完毕，再执行目标程序，只需要保存完整的目标程序而无需保存源程序。一次翻译后无需再翻译，可多次执行。</p>
<p>　　解释方式是边翻译边执行，即翻译一句就执行一句，翻译完毕也执行完毕，只保存源程序无需保存完整的目标程序。执行一次需要翻译一次。**</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%A6%82%E8%BF%B0/image-20200325155908423.png" style="zoom:67%;" />

<h3 id="解释程序"><a href="#解释程序" class="headerlink" title="解释程序"></a>解释程序</h3><ul>
<li><strong>不产生目标程序文件</strong></li>
<li><strong>不区别翻译阶段和执行阶段</strong></li>
<li><strong>翻译源程序的每条语句后直接执行</strong></li>
<li><strong>程序执行期间一直有解释程序守候</strong></li>
<li><strong>常用于实现虚拟机</strong></li>
</ul>
<h3 id="存储组织不同"><a href="#存储组织不同" class="headerlink" title="存储组织不同"></a>存储组织不同</h3><p>编译程序处理时,在源语言程序被编译阶段,存储区中要为源程序(中间形式)和目标代码开辟空间,要存放编译用的各种各样表格,比如符号表.在目标代码运行阶段,存储区中主要是目标代码和数据,编译所用的任何信息都不再需要.</p>
<p><strong>解释程序一般是把源程序一条语句一条语句的进行语法分析,转换为一种内部表示形式,存放在源程序区</strong>,比如BASIC解释程序,将LET和GOTO这样的关键字表示为一个字节的操作码,标识符用其在符号表的入口位置表示.因为解释程序允许在执行用户程序时修改用户程序,这就要求<strong>源程序,符号表等内容始终存放在存储区中,并且存放格式要设计的易于使用和修改.</strong></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%A6%82%E8%BF%B0/image-20200325160411573.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">计算机系统结构-指令系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-22 19:57:24" itemprop="dateCreated datePublished" datetime="2020-03-22T19:57:24Z">2020-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-04 15:17:12" itemprop="dateModified" datetime="2020-06-04T15:17:12Z">2020-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机系统结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本概念和分类"><a href="#基本概念和分类" class="headerlink" title="基本概念和分类"></a>基本概念和分类</h1><p>ISA(指令系统)定义了软硬件交互的协约。</p>
<h2 id="指令系统设计原则"><a href="#指令系统设计原则" class="headerlink" title="指令系统设计原则"></a>指令系统设计原则</h2><ul>
<li>可编程性</li>
<li>可实现性</li>
<li>兼容性</li>
</ul>
<h2 id="指令系统设计要素"><a href="#指令系统设计要素" class="headerlink" title="指令系统设计要素"></a>指令系统设计要素</h2><ul>
<li><p><strong>指令格式</strong>：包括了指令长度（定长或者是变长）以及编码方式</p>
</li>
<li><p><strong>操作数存储位置（寄存器、主存、累加器、堆栈）、类型（整型、浮点）、长度（字节、字、双字）和个数（1，2，3，多操作数）</strong></p>
</li>
<li><p><strong>寻址方式</strong></p>
</li>
<li><p><strong>支持的操作类型：加减、比较</strong></p>
</li>
</ul>
<h2 id="指令系统结构分类"><a href="#指令系统结构分类" class="headerlink" title="指令系统结构分类"></a>指令系统结构分类</h2><p>根据操作数的存储位置对指令进行分类：</p>
<ul>
<li>主存型结构：主存</li>
<li>累加器型结构：累加器</li>
<li>堆栈型结构：堆栈</li>
<li>通用寄存器结构：通用寄存器组</li>
</ul>
<p><strong>指令系统中操作数给出方式：</strong></p>
<ul>
<li>显式给出：用指令字中的操作数字段给出</li>
<li>隐式给出：隐式给出则是使用实现约定好的单元</li>
</ul>
<h1 id="指令系统的发展和改进"><a href="#指令系统的发展和改进" class="headerlink" title="指令系统的发展和改进"></a>指令系统的发展和改进</h1><p>由性能公式：CPU时间&#x3D;指令条数IC*CPI *周期时间</p>
<h2 id="复杂指令系统CISC"><a href="#复杂指令系统CISC" class="headerlink" title="复杂指令系统CISC"></a>复杂指令系统CISC</h2><p><strong>改进方法：</strong></p>
<ul>
<li>减少指令条数，使用复杂的指令</li>
<li>对于使用频率高的指令串，用一条新的指令来代替</li>
</ul>
<p><strong>问题：</strong></p>
<ul>
<li>设计周期长，准确性难以保证</li>
<li>需要大量的硬件支持</li>
<li>很多复杂指令使用频率低，造成资源浪费</li>
<li>许多指令由于操作复杂，其CPI值比较大，执行速度慢</li>
<li>规整性不好，不利于采用流水线技术来提高性能</li>
</ul>
<h2 id="精简指令系统RISC"><a href="#精简指令系统RISC" class="headerlink" title="精简指令系统RISC"></a>精简指令系统RISC</h2><p><strong>RISC遵循的原则：</strong></p>
<ul>
<li>指令条数少，功能简单<br>【只选取使用频率很高的指令，再补充一些其他最有用的指令】</li>
<li>指令格式简单、规整、并减少寻址方式</li>
<li>指令的执行在单个周期内完成（采用流水线机制）</li>
<li>只有load和store指令才能访问存储器，其他指令的操作都是在寄存器之间进行（load-store结构）</li>
<li>大多数指令都采用硬连逻辑来实现</li>
<li>强调优化编译器的作用，为高级语言程序生成优化的代码</li>
<li>充分利用流水线技术来提高性能</li>
</ul>
<p><strong>改进方法：</strong></p>
<ul>
<li>减少CPI，使用大量单周期指令</li>
<li>增加指令条数，复杂的指令使用频率很低，实际程序的指令条数并不太多</li>
<li>减少时钟周期时间</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/03/23/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/23/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-22 19:57:09" itemprop="dateCreated datePublished" datetime="2020-03-22T19:57:09Z">2020-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-01 08:28:18" itemprop="dateModified" datetime="2020-06-01T08:28:18Z">2020-06-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>数据模型是数据库系统的核心和基础。它是现实世界的模拟。</p>
<p>三要素：数据结构、数据操作、数据约束</p>
<h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><p>信息模型，按用户的观点来对数据和信息建模。</p>
<ul>
<li>实体：客观存在并可相互区别的事物</li>
<li>属性：实体所具有的某一特性</li>
<li>码：<strong>唯一</strong>标识实体的属性集</li>
<li>实体型：</li>
</ul>
<h3 id="逻辑模型和物理模型"><a href="#逻辑模型和物理模型" class="headerlink" title="逻辑模型和物理模型"></a>逻辑模型和物理模型</h3><ul>
<li>逻辑模型主要包括网状模型、层次模型、关系模型、面向对象模型···</li>
<li>物理模型是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或者是磁带上的存储方式和存取方法。</li>
</ul>
<h3 id="客观对象的抽象过程–两步抽象"><a href="#客观对象的抽象过程–两步抽象" class="headerlink" title="客观对象的抽象过程–两步抽象"></a>客观对象的抽象过程–两步抽象</h3><p>1、客观对象抽象为概念模型</p>
<p>2、把概念模型转换为某一DBMS支持的数据模型</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200323175234167.png" style="zoom:67%;" />

<h2 id="常用的数据模型"><a href="#常用的数据模型" class="headerlink" title="常用的数据模型"></a>常用的数据模型</h2><ul>
<li><strong>非关系模型</strong><ul>
<li>层次模型</li>
<li>网状模型</li>
</ul>
</li>
<li><strong>关系模型</strong><ul>
<li>面向对象模型</li>
<li>对象关系模型</li>
</ul>
</li>
</ul>
<h3 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h3><p>使用<strong>树状结构</strong>来表示各类实体以及实体间的联系。</p>
<p>要求：</p>
<ol>
<li>有且只有一个结点没有双亲结点，这个结点称为根节点</li>
<li><strong>根以外的其他结点有且只有一个双亲结点</strong></li>
</ol>
<p>根据上述的要求，可以确认层次模型其实是<strong>父与子之间一对多的联系</strong>。每个结点表示的是记录类型，记录类型之间的联系用结点之间的连线表示。</p>
<h4 id="层次模型的特点"><a href="#层次模型的特点" class="headerlink" title="层次模型的特点"></a>层次模型的特点</h4><ul>
<li>结点的双亲是唯一的</li>
<li>只能直接处理<strong>一对多</strong>的实体联系<br>【如果一个结点有多个双亲结点的话，只能通过引入冗余数据或者创建非自然的数据结构来解决】</li>
<li>每个记录类型可以定义一个排序字段（码字段）<br>【方便查找，并且查找效率高】</li>
<li>任何记录值只有按其路径查看时，才能显出它的全部意义<br>【可以直观的知道其一脉相承的父子关系，结构严密】</li>
<li>没有一个子女记录值能够脱离双亲记录值而独立存在<br>【例如：插入操作时，要先找到其父结点值；删除操作时，其子结点会一并被删除】</li>
<li>查询子女结点必须通过双亲结点</li>
</ul>
<h4 id="多对多联系在层次模型中的表示"><a href="#多对多联系在层次模型中的表示" class="headerlink" title="多对多联系在层次模型中的表示"></a>多对多联系在层次模型中的表示</h4><p>基本思路是：将多对多联系分解成一对多联系</p>
<p><strong>冗余结点法</strong>：就是将存在多对多联系的结点拆分成一对多联系的模式。会产生多个根节点，同时该多个根结点也表示子结点。</p>
<p><strong>虚拟结点法</strong>：就是将存在多对多联系的结点拆分，产生多个根结点。每个根节点连接一个虚拟结点【该虚拟结点就是上述拆开的子节点】</p>
<h4 id="增删查改与完整性约束"><a href="#增删查改与完整性约束" class="headerlink" title="增删查改与完整性约束"></a>增删查改与完整性约束</h4><ul>
<li>无相应的双亲结点值就不能插入子女结点值</li>
<li>如果删除双亲结点值，则相应的子女结点值也会被删除</li>
<li><strong>更新操作时，应更新所有相应记录，以保证数据的一致性</strong></li>
</ul>
<h4 id="层次数据模型的存储结构"><a href="#层次数据模型的存储结构" class="headerlink" title="层次数据模型的存储结构"></a>层次数据模型的存储结构</h4><p><strong>邻接法</strong></p>
<p>按照层次树前序遍历将所有的记录值一次邻接存储，通过<strong>物理空间的位置相邻</strong>来实现层次顺序</p>
<p><strong>链接法</strong></p>
<p>用指针来反映数据之间的层次联系</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200324103822351.png" style="zoom:67%;" />

<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200324103845301.png" style="zoom:67%;" />



<h3 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h3><p>要求：</p>
<ol>
<li>允许一个以上的结点无双亲结点</li>
<li>一个结点可以有多个双亲结点</li>
</ol>
<p>层次模型可以看成是网状模型的一个特例</p>
<h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p><strong>用二维表来表示实体及其联系：行、列</strong></p>
<blockquote>
<p>用表格表示实体集，用列表示属性，表结构表示实体的型</p>
<p>用表间的特定的冗余信息表示实体间的联系（主键和外键）</p>
<p>行、列是无序的</p>
<p>列不可再分</p>
<p>没有重复行</p>
</blockquote>
<p><strong>关系规范化要求：</strong>关系的每一个分量必须是一个不可分的数据项 <strong>不允许表中还有表</strong></p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200324104653997.png" style="zoom:50%;" />

<h4 id="关系模型的存储结构"><a href="#关系模型的存储结构" class="headerlink" title="关系模型的存储结构"></a>关系模型的存储结构</h4><p>实体及实体间的联系都用表来表示</p>
<p>表以文件形式存储</p>
<h2 id="数据库系统结构"><a href="#数据库系统结构" class="headerlink" title="数据库系统结构"></a>数据库系统结构</h2><p>在数据模型中有“型”和“值”的概念。<strong>型是指对某一类数据的结构和属性的说明。值是型的一个具体赋值</strong></p>
<p>数据库系统内部的体系结构：采取三级模式结构</p>
<p>数据库系统外部的体系结构：</p>
<ul>
<li>单用户结构</li>
<li>主从式结构</li>
<li>分布式结构</li>
<li>客户|服务器</li>
<li>浏览器|应用服务器|数据库服务器多层结构</li>
</ul>
<h3 id="数据库系统的三级模式结构"><a href="#数据库系统的三级模式结构" class="headerlink" title="数据库系统的三级模式结构"></a>数据库系统的三级模式结构</h3><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200324120106956.png"></p>
<h4 id="模式（逻辑模式）"><a href="#模式（逻辑模式）" class="headerlink" title="模式（逻辑模式）"></a>模式（逻辑模式）</h4><p>对数据库中的全部数据的逻辑结构和特征的描述，它仅仅涉及到的是型的描述，不涉及到具体的值。</p>
<p><strong>模式的定义：</strong></p>
<ul>
<li>数据的逻辑结构（包括了数据项的名字、类型、取值范围···）</li>
<li>数据之间的联系</li>
<li>数据有关的安全性、完整性要求</li>
</ul>
<blockquote>
<p><strong>模式（schema）</strong>：反映的是数据的结构及其联系</p>
<p><strong>实例（instance）</strong>：模式的一个具体值，实例会随着数据库中的数据的更新而变动</p>
<p><strong>模式是相对稳定的，而实例是相对变动的</strong></p>
</blockquote>
<p><strong>一个数据库只有一个模式，可以将模式视为是数据库数据在逻辑级上的视图。</strong></p>
<p>&#x3D;&#x3D;<strong>模式是数据库系统模式结构的中间层</strong>&#x3D;&#x3D;</p>
<ul>
<li>与数据的物理存储细节和硬件环境无关</li>
<li>与具体的应用程序、开发工具及高级程序设计语言无关</li>
</ul>
<h4 id="外模式（子模式、用户模式）"><a href="#外模式（子模式、用户模式）" class="headerlink" title="外模式（子模式、用户模式）"></a>外模式（子模式、用户模式）</h4><p><strong>数据库用户的数据视图，是用户使用的局部数据的逻辑结构和特征的描述</strong></p>
<p>&#x3D;&#x3D;<strong>外模式介于模式和应用之间</strong>&#x3D;&#x3D;</p>
<ul>
<li>模式与外模式的关系：一对多<ul>
<li>外模式通常是模式的子集</li>
<li>一个数据库可以拥有多个外模式。</li>
<li>对模式中同一数据，在外模式中的结构、类型、长度、保密级别都不同（这倒是让我想起了在同一个项目下使用不同数据库存储不同的数据）</li>
</ul>
</li>
<li>外模式与应用的关系：一对多<ul>
<li>同一外模式可以为某个用户的多个应用系统所使用</li>
<li>但是一个应用程序只能使用一个外模式</li>
</ul>
</li>
</ul>
<p>外模式的用途</p>
<ul>
<li>保证数据库安全性</li>
<li>每个用户只能看见和访问所对应的外模式中的数据</li>
</ul>
<h3 id="内模式（存储模式）"><a href="#内模式（存储模式）" class="headerlink" title="内模式（存储模式）"></a>内模式（存储模式）</h3><p>是数据物理结构和存储方式的描述（不同数据库的内部实现方式）</p>
<p>是数据在数据库内部的表示方式</p>
<ul>
<li>记录的存储方式（顺序存储、按照B树结构存储、按照hash方式存储）</li>
<li>索引的组织方式</li>
<li>数据是否压缩存储</li>
<li>数据是否加密</li>
<li>数据存储记录结构的规定</li>
</ul>
<p><strong>一个数据库只有一个内模式</strong></p>
<h3 id="数据库的二级映像功能与数据独立性"><a href="#数据库的二级映像功能与数据独立性" class="headerlink" title="数据库的二级映像功能与数据独立性"></a>数据库的二级映像功能与数据独立性</h3><p>二级映像在DBMS内部实现这三个抽象层次的联系和转换</p>
<ul>
<li>外模式|模式映像</li>
<li>模式|内模式映像</li>
</ul>
<h4 id="外模式-模式映象"><a href="#外模式-模式映象" class="headerlink" title="外模式|模式映象"></a>外模式|模式映象</h4><p>定义外模式与模式之间的对应关系。映象定义通常包含在各自外模式的描述中。</p>
<blockquote>
<p>模式描述的是数据的全局逻辑结构；外模式描述的是数据的局部逻辑结构。</p>
<p>同一个模式下可以有任意多个外模式。</p>
</blockquote>
<p><strong>保证数据的逻辑独立性</strong>：应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性。</p>
<h4 id="模式-内模式映象"><a href="#模式-内模式映象" class="headerlink" title="模式|内模式映象"></a>模式|内模式映象</h4><p>定义了数据全局逻辑结构与存储结构之间的对应关系。通常包含在模式描述中。</p>
<p><strong>数据库中模式|内模式映象是唯一的。</strong></p>
<p><strong>保证了数据的物理独立性：</strong>当数据库的存储结构改变了，只要修改模式|内模式映象使得模式保持不变，应用程序就不会受到影响。</p>
<h4 id="数据库模式"><a href="#数据库模式" class="headerlink" title="数据库模式"></a>数据库模式</h4><ul>
<li>全局逻辑结构</li>
<li>设计数据库模式结构时应该首先确定数据库的逻辑模式</li>
</ul>
<h4 id="数据库的内模式"><a href="#数据库的内模式" class="headerlink" title="数据库的内模式"></a>数据库的内模式</h4><ul>
<li>依赖其全局逻辑结构</li>
<li>独立于数据库的用户视图（外模式）</li>
<li>独立于具体的存储设备</li>
<li>将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，提高空间使用率。</li>
</ul>
<h4 id="数据库的外模式"><a href="#数据库的外模式" class="headerlink" title="数据库的外模式"></a>数据库的外模式</h4><ul>
<li>面向的是具体的应用程序</li>
<li>定义在逻辑模式之上</li>
<li>独立于存储模式和存储设备</li>
<li>当应用需求发生较大的变化时，相对应外模式不能满足其视图要求时，该外模式就得做出相应改动。</li>
<li>设计外模式时应充分考虑到应用的扩展性</li>
</ul>
<h4 id="特定的应用程序"><a href="#特定的应用程序" class="headerlink" title="特定的应用程序"></a>特定的应用程序</h4><ul>
<li>是在外模式描述的数据结构上编制的</li>
<li>依赖于特定的外模式</li>
<li>与数据库的模式和存储结构独立</li>
<li>不同的应用程序有时可以共用一个外模式</li>
</ul>
<h2 id="数据库系统的组成"><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h2><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200324155703346.png" style="zoom:67%;" />

<h3 id="硬件平台及数据库"><a href="#硬件平台及数据库" class="headerlink" title="硬件平台及数据库"></a>硬件平台及数据库</h3><ol>
<li><p>足够大的内存</p>
<blockquote>
<p>存放操作系统、数据库管理系统的核心模块、数据缓冲区和应用程序</p>
</blockquote>
</li>
<li><p>足够大的外存</p>
<blockquote>
<p>可以用作数据的备份</p>
</blockquote>
</li>
<li><p>较高的通道能力，提高数据传送率</p>
</li>
</ol>
<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><ol>
<li><p>DBMS</p>
<blockquote>
<p>数据库管理系统是为数据库的建立、使用和维护配置的系统软件</p>
</blockquote>
</li>
<li><p>支持DBMS运行的操作系统</p>
</li>
<li><p>与数据库接口的高级语言和配套的编译系统</p>
</li>
<li><p>以DBMS为核心的应用开发工具</p>
</li>
<li><p>为特定应用环境开发的数据库应用系统</p>
</li>
</ol>
<h3 id="人员"><a href="#人员" class="headerlink" title="人员"></a>人员</h3><ol>
<li><p>数据库管理人员DBA</p>
<blockquote>
</blockquote>
</li>
<li><p>系统分析员和数据库设计人员</p>
</li>
<li><p>应用程序员</p>
</li>
<li><p>用户</p>
</li>
</ol>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200324160326154.png" style="zoom:67%;" />

<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p>文件系统和数据库系统都能管理数据，也都支持通过应用程序访问数据，两种方式在数据独立性上有何不同？</p>
<p>数据管理文件系统阶段和数据库系统阶段“数据独立性”有何不同？</p>
<blockquote>
<p> 在数据管理技术的发展过程中，经历了人工管理阶段、文件系统阶段和数据库系统阶段，其中数据独立性最高的阶段是数据库系统。数据库阶段用数据模型表示复杂的数据，有较高的数据独立性。数据库系统为用户提供了方便的用户接口，用户可使用查询语言或终端命令操作数据库，也可以用程序方式操作数据库。数据库管理系统提供了数据控制功能。</p>
<p> 文件系统和数据库系统之间的区别：</p>
<p> （1） 文件系统用文件将数据长期保存在外存上，数据库系统用数据库统一存储数据；</p>
<p> （2） 文件系统中的程序和数据有一定的联系，数据库系统中的程序和数据分离；</p>
<p> （3） 文件系统用操作系统中的存取方法对数据进行管理，数据库系统用DBMS统一管理和控制数据；</p>
<p> （4） 文件系统实现以文件为单位的数据共享，数据库系统实现以记录和字段为单位的数据共享。</p>
<p> 文件系统和数据库系统之间的联系：</p>
<p> （1） 均为数据组织的管理技术；</p>
<p> （2） 均由数据管理软件管理数据，程序与数据之间用存取方法进行转换；</p>
<p> （3） 数据库系统是在文件系统的基础上发展而来的。</p>
<p> 文件系统是操作系统用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。</p>
<p> 文件系统由三部分组成：文件系统的接口，对对象操纵和管理的软件集合，对象及属性。从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等。</p>
</blockquote>
<p>数据库系统在管理数据时采用的分层管理的思想，也就是三级模式两级映像的架构，这么做起到了什么作用？</p>
<blockquote>
<p>采用三级模式和二级映像的原因：</p>
<p>1）保证了数据的独立性。将模式与内模式、模式与外模式分开保证了数据的物理独立性和逻辑独立性</p>
<p>2）简化了用户接口，按照外模式编写应用程序或敲入命令，不需了解内部结构</p>
<p>3）有利于数据共享，不同应用可共用一个外模式，减少了数据冗余</p>
<p>4）有利于数据的安全保密，在外模式限定下进行操作，不能对限定数据操作，保证了其他数据的安全</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rhb</p>
  <div class="site-description" itemprop="description">纵浪大化中，不喜亦不惧</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">126</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RShawshank" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RShawshank" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rhb</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://lib.baomitu.com/canvas-nest.js/1.0.1/canvas-nest.js"></script>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
