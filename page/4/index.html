<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rshawshank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="纵浪大化中，不喜亦不惧">
<meta property="og:type" content="website">
<meta property="og:title" content="rhb_blog">
<meta property="og:url" content="http://rshawshank.github.io/page/4/index.html">
<meta property="og:site_name" content="rhb_blog">
<meta property="og:description" content="纵浪大化中，不喜亦不惧">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rhb">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rshawshank.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>rhb_blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rhb_blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">rao的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">55</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">22</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">126</span></a>

  </li>
        <li class="menu-item menu-item-photos">

    <a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
        <li class="menu-item menu-item-readnote">

    <a href="/readnote/" rel="section"><i class="fa fa-book fa-fw"></i>阅读笔记</a>

  </li>
        <li class="menu-item menu-item-somethink">

    <a href="/somethink/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>随笔闲谈</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/RShawshank" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/08/17/%E5%8A%9B%E9%87%8F%E8%AE%AD%E7%BB%83%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/17/%E5%8A%9B%E9%87%8F%E8%AE%AD%E7%BB%83%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">力量训练基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-16 16:11:37" itemprop="dateCreated datePublished" datetime="2021-08-16T16:11:37Z">2021-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-10 07:39:10" itemprop="dateModified" datetime="2022-11-10T07:39:10Z">2022-11-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深蹲"><a href="#深蹲" class="headerlink" title="深蹲"></a>深蹲</h1><p>主要要点：</p>
<ul>
<li>重心：杠铃重心应该始终保持在脚中心的正上方位置</li>
<li>站姿：脚跟距离与肩同宽；脚尖外展约30度</li>
<li>握距：越窄越好，越窄越能将杠铃控制在肌肉上。大拇指应该在杠铃上方以确保握杠时手腕和前臂在一条直线上。</li>
<li>肘向上抬</li>
<li>全程保持头向下看</li>
<li>发力方向：髋部发力应该是往上不是往前，往前的话会导致重心往脚尖压</li>
<li>反弹：反弹必须作为发力过程的启动部分而存在</li>
<li>呼吸：深吸一口气并屏住呼吸</li>
</ul>
<h2 id="5X5训练计划"><a href="#5X5训练计划" class="headerlink" title="5X5训练计划"></a>5X5训练计划</h2><p>一周在非连续的日子里健身3次，并把AB部分轮流使用：</p>
<p>周一：</p>
<p>A：深蹲5X5（起始重量）、推举5X5（起始重量）、硬拉1X5（起始重量）</p>
<p>周三：</p>
<p>B：深蹲5X5（+2.5kg）、卧推5X5（起始重量）、划船5X5（起始重量）</p>
<p>周五：</p>
<p>A：深蹲5X5（+2.5kg）、推举5X5（+2.5kg）、硬拉1X5（+5kg）</p>
<p>周一：</p>
<p>B：深蹲5X5（+2.5kg）、卧推5X5（+2.5kg）、划船5X5（+2.5kg）</p>
<p><strong>热身</strong>：</p>
<p>一般会做三个热身组，先用50%今天要做的重量做一组，65%今天要做的重量做一组，80%今天要做的重量做一组。</p>
<p><strong>注意事项</strong>：</p>
<p>1、如不能完成5组任意一个，争取做完全部5组（能做几个做几个），下次继续，如果三次训练不能做完，减重10%继续5*5，只要你还没达到瓶颈，就加重下去。</p>
<p>2、至于推举和划船的重量，你也应该尝试每次增加5磅重量，但是由于这两个锻炼所要求的肌肉力量会少于深蹲、硬拉、和卧推（推举所用的肩部力量远远少于你大腿的伸膝力量），每次增加5磅重量不一定现实。</p>
<blockquote>
<p>比如：我用160磅卧推5X5时第三组时失败了，只做了4下。那么我第四组时会拿155磅的重量企图完成，如果我还是败了就用150磅完成第五组。<br>如果失败的地方是在第五组，那么不要纠结企图多做一组了。下次再说吧。注意如果你出现失败的情况，那么下次不能增加重量。</p>
</blockquote>
<p>3、如果你加重失败，5组没做完出现完成不了的情况，你可以选择多休息（5+分钟）再挑战这个重量，或者在把重量减少到上次的重量后，再把剩下几组做完。</p>
<p>正常的话，组间休息在90秒左右；训练初期重量较轻，组间休息时间可以适当减少，到后期快到达极限时需要酌情延长。一般休息3分钟可以让ATP恢复到80%左右，5分钟可以恢复到95%。</p>
<p><strong>deload:</strong></p>
<p>全体deload的方法很简单。花一周时间，啥运动都不做，就休息。每健身的第九周，全体deload一周。当然如果你没有健身疲劳也没必要什么运动都不做。你可以照样跟平时一样健身，组数次数啥的都一样，但就把重量减轻40%或更多，然后专门注意纠正改善你的姿势。<br>有的人会问deload完之后怎么办。之后就当啥事没发生，之前该干啥还干啥。该做什么计划就继续做什么计划。</p>
<p>半deload一般只适合在用线性计划、长时间某项锻炼无法提高的朋友。<br>如果你在做5X5，并且已经有两周你的卧推停滞在80KG上涨不了，那么你可以半deload。方法很简单，别的锻炼照样做，卧推重量减少15磅（或者更多），设这个为你的新的RM。然后从这里开始再慢慢把重量加回去。<br>一般来说，在开始一项新的计划之前，你应该把你的所有锻炼都半deload，以较轻的新的RM开始这个计划（像5&#x2F;3&#x2F;1会专门求你设原来的1RM的90%为1RM）。原因很简单：你从来不想让自己用一个新的计划的第一天就拼尽全力。用一个新的计划的前两周你应该处于一种适应的状态，如果你连这个计划的频率、训练量都没适应，就直接push你自己，只会导致自己肌肉恢复跟不上、然后各种失败。</p>
<p><strong>辅助训练（最好不加</strong>）：</p>
<p>引体向上 （最多3组）或 绳索下拉（最多3组）<br>孤立三头锻炼 （最多3组）或 双杠臂屈伸（最多3组）<br>孤立二头肌锻炼（最多3组）<br>后侧肌肉群锻炼 如山羊挺身、罗马尼亚硬拉、直腿硬拉（最多3组）</p>
<h3 id="ICF冰淇淋5X5："><a href="#ICF冰淇淋5X5：" class="headerlink" title="ICF冰淇淋5X5："></a>ICF冰淇淋5X5：</h3><p>A部分<br>深蹲 5X5<br>卧推 5X5<br>划船 5X5<br>杠铃或哑铃耸肩 3X8-12<br>三头肌下压 3X8-12<br>二头肌弯举 3X8-12<br>逆向曲腿3X8-12<br>腹肌锻炼自己加</p>
<p>B部分<br>深蹲5X5<br>推举5X5<br>硬拉1X5<br>划船（用比A部分少10%的重量做） 5X5<br>窄距卧推 或 双杠臂屈伸 3X8-12<br>二头肌弯举 3X8-12<br>腹肌锻炼自己加</p>
<p>这个计划在5X5的基础上添加了很多辅助增肌的锻炼，因此如果你并不是特别对力量有兴趣，更追求增肌的话，这个计划在5X5的计划里算是最适合健美增肌的了（而5X5本身就比99%的其他计划更适合健美增肌。。。）。<br>如果你在减脂，却还想使用这个计划的话，也不是不可以，把所有5组的锻炼做3组，所有3组的锻炼做2组就可以了。你如果减脂期间坚持做完整个计划的话，你会发现你的肌肉恢复会可能跟不上。</p>
<h2 id="拉伸"><a href="#拉伸" class="headerlink" title="拉伸"></a>拉伸</h2><p>每次拉伸至少要拉30秒以上</p>
<p>1、髖屈肌群拉伸</p>
<p>2、</p>
<h2 id="madcow5X5"><a href="#madcow5X5" class="headerlink" title="madcow5X5"></a>madcow5X5</h2><p>当你可以深蹲体重1.5到2倍左右、硬拉体重2到2.5倍左右、卧推体重1.25倍到1.5倍左右的时候</p>
<p>每周第一天<br>深蹲 5X5 (除了最后1组之外，前面4组分别用最后一组的60%，70%，80%，90%完成）<br>卧推 5X5 （除了最后1组之外，前面4组从60%开始增加重量）<br>俯身划船 5X5 （除了最后1组之外，前面4组从60%开始增加重量）<br>可选辅助锻炼： 腹肌锻炼、3组二头肌弯举、三组三头肌下压</p>
<p>第二天 休息</p>
<p>第三天<br>深蹲 4X5 （和第一天一样，只不过你不做最后一组正式组）<br>推举 或 上斜卧推 4X5 （前3组从60%开始增加重量，第四组为正式组）<br>硬拉 4X5 （前3组从60%开始增加重量，第四组为正式组）<br>可选辅助锻炼：3组哑铃飞鸟、2组窄握双杠臂屈伸、3组二头肌弯举、腹肌锻炼</p>
<p>第四天 休息</p>
<p>第五天<br>深蹲 4X5 1X3 1X8 （前4组和第一天第三天一样，第五组1X3用周一的重量提高2.5%完成，第六组1X8用前四组中的第三组完成）<br>卧推 4X5 1X3 1X8（前4组和第一天第三天一样，第五组1X3用周一的重量提高2.5%完成，第六组1X8用前四组中的第三组完成）<br>俯身划船 4X5 1X3 1X8（前4组和第一天第三天一样，第五组1X3用周一的重量提高2.5%完成，第六组1X8用前四组中的第三组完成）<br>可选辅助锻炼：3组窄握双杠臂屈伸、3组脸拉、3组二头肌弯举、腹肌锻炼</p>
<p>第六天第七天休息，然后下周第一天时，正式组都用上一周的1X3来做。<br>也就是说：这周周一我第五组正式组是1X5 200磅卧推，这周周五的我的第五组正式组是1X3 205磅卧推，那么下周周一我的第五组正式组是1X5 205磅卧推。<br>至于第三天的推举和硬拉，你只需要跟着每周正式组增加2.5%的重量走就可以了。</p>
<h3 id="Canditto-LP坎底托直线提高计划介绍"><a href="#Canditto-LP坎底托直线提高计划介绍" class="headerlink" title="Canditto LP坎底托直线提高计划介绍"></a>Canditto LP坎底托直线提高计划介绍</h3><p>本周第一天 上身力量<br>杠铃卧推 3X6<br>背部主要锻炼 3X6<br>肩部主要锻炼 1X6<br>背部次要锻炼 1X6<br>可选上身锻炼1 3X8-15<br>可选上身锻炼2 3X8-15</p>
<p>本周第二天 下身力量<br>后端深蹲（高杠或低杠）3X6<br>硬拉 2X5<br>可选下身锻炼1 3X8-15<br>可选下身锻炼2 3X8-15<br>可选下身锻炼3 3X8-15<br>本周第三天 休息</p>
<p>本周第四天 上身增肌<br>杠铃或哑铃卧推 3X8-12<br>背部主要锻炼 4X8-12<br>肩部主要锻炼 3X8-12<br>背部次要锻炼 4X8-12<br>上斜杠铃或哑铃卧推 3X8-12<br>二头肌弯举 3X8-12<br>可选上身锻炼 3X8-12</p>
<p>本周第五天 下身增肌<br>深蹲（前端或后端） 5X8<br>可选花式硬拉 2X6<br>腘绳肌锻炼 3X8-12<br>小腿提锺 3X8-12<br>可选下身锻炼1 3X8-12<br>可选下身锻炼2 3X8-12</p>
<p>本周第六天 第七天 休息</p>
<p>这个模板可以说是相当地灵活，你可以自己随便加锻炼进去。当然，我个人推荐加如下的锻炼：<br>背部主要锻炼 - 俯身划船 或 负重引体向上 或 背部下拉<br>背部次要锻炼 - 俯身划船 或 负重引体向上 或 背部下拉<br>肩部主要锻炼 - 直立杠铃推举 或 坐姿哑铃推举<br>可选上身锻炼 - 二头肌弯举 三头肌下压 俯身哑铃飞鸟 杠铃或哑铃耸肩<br>可选花式硬拉 - 罗马尼亚硬拉 直腿硬拉<br>可选下身锻炼 - 跳箱 前端深蹲 前屈弓步 （这个选择面比较广）<br>腘绳肌锻炼 - 双腿伸屈（机器）</p>
<p>增重原则<br>所有锻炼，每周尝试增加0-10磅的重量。<br>因为真正的力量日上身下身一周各只有一天，所以增重的尝试只有一次。很多人因此觉得这个计划的增重规律实在太慢，但我个人认为0-10磅的增重设计反而非常不错，因此不会硬逼着你加重，你如何加重完全是看感觉。新手，特别是动作姿势还有问题的新手，被逼着加重时很可能出现姿势不正确、不完全完成动作的行为（比如深蹲时就做个半蹲），因此这种灵活的增重设计我是赞成的。</p>
<h2 id="GZCL训练理念"><a href="#GZCL训练理念" class="headerlink" title="GZCL训练理念"></a>GZCL训练理念</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25446245">【最良心的干货】手把手教你周期力量计划的设计 - 知乎 (zhihu.com)</a></p>
<p>每次训练你把你的锻炼要分为三个不同的区域之内，分别是：</p>
<p><strong>一级主项，二级副项，三级辅助</strong>。</p>
<p>ZCL理念即是：每天的训练应该安排成一个金字塔。金字塔的厚度为训练量，高为训练强度。最高的位置，训练强度最高、训练量越低，这也是对于你发展力量最重要的训练部分（一级主项）；稍微往下，训练强度、训练量都为中等，这是你<a target="_blank" rel="noopener" href="http://music.163.com/#/program?id=900702866">攻克自己的弱点</a>、直接性辅助你力量提高的训练部分（二级副项）；最下方，训练强度最低，训练量最高，这是你做大量的次数和组数好得到增肌效果、以助于你以后力量的提高（三级辅助）。</p>
<p>一级主项的锻炼安排：一般来说这是你最重要的大三项，深蹲硬拉卧推。根据你目标的不同，也可以包括别的主项锻炼，比如实力推。你每次训练的目的是把最多的精力和力量安排到一级主项上面。一般而言，你每次训练只会安排一个主项，训练强度一般都高于80%1RM。</p>
<p>二级副项的锻炼安排：一般来说这是你的三大项的<strong>专项性辅助。</strong>深蹲的包括：暂停深蹲、其他深蹲方式（主蹲低杠的，可以安排高杠或者前蹲）；硬拉的包括：超程硬拉、架上拉、其他硬拉方式（主拉相扑拉的，可以安排传统拉）；卧推的包括：暂停卧推、窄距卧推。这都只是一些例子。要注意的是你也可以把主项放入副项里练。副项的目标，除了攻克弱点、直接性辅助你的主项之外，也可以发展其他的主项；但是重要性会低于当天的一级主项。具体这是什么意思，我会在底下说明白。一般而言，你每次训练只会安排一个或者两个副项，训练强度一般在65%-85%1RM之间。</p>
<p>三级辅助的锻炼安排：一般来说这是任何其它的辅助锻炼，包括（不限制于）：背部锻炼（划船、引体向上）、哑铃锻炼（哑铃卧推）、增肌性质的三大项辅助（硬拉：罗马尼亚硬拉、直腿硬拉；卧推：哑铃卧推、俯卧撑、甚至胸推机器；深蹲：哑铃弓箭步、箱跳、腿弯举）、肩部锻炼（推举这边也可以练）。你要通过三级辅助，把一级和二级锻炼里还没有压榨完的精力给全部花出去。一般而言，每次训练会安排两个以上的三级辅助，每个的组数锻炼至少3组以上、每组10-20次（Cody喜欢做每组20下的三级辅助，走他的黑又壮计划的朋友们应该都明白，哭死人）。三级辅助的目标是：提高训练容量（高组数高次数）、达到增肌效果、提高综合耐力。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/08/13/oracle%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/13/oracle%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">oracle数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-13 10:45:54" itemprop="dateCreated datePublished" datetime="2021-08-13T10:45:54Z">2021-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-13 02:50:44" itemprop="dateModified" datetime="2021-09-13T02:50:44Z">2021-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/oracle%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">oracle数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h1><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013537329">参考文章</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013540871">参考文章</a></p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Oracle数据库服务器由两部分组成：</p>
<ul>
<li><strong>实例：理解为对象,看不见的</strong></li>
<li><strong>数据库：理解为类，看得见的</strong></li>
</ul>
<p>Oracle数据库把表、视图等都看成是对象。</p>
<h2 id="null值"><a href="#null值" class="headerlink" title="null值"></a>null值</h2><p>Oracle中如果存在字段是null值的话，那么在sqlplus中它是不会显示出来的….<strong>如果我们使用null值的数据与其他数据进行运算…那么最终得出的结果都是null值</strong></p>
<p>因此，Oracle提供了NVL(表达式1，表达式2)函数供我们使用，如果表达式1的值为null值，那么就取表达式2的值…当然了，如果表达式1不是null，取的就是表达式1的值</p>
<p>还有值得注意的是：<strong>null值不能参数&#x3D;号运算，null能参数number&#x2F;date&#x2F;varchar2类型运算</strong></p>
<p><strong>Oracle提供了 is null关键字来代替&#x3D;号运算的问题</strong></p>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>Mysql中如果要用别名的话，需要使用as关键字 ，后面跟着别名就行了….Oracle可以省略as关键字…</p>
<p>并且，一般地，我们使用别名都是用双引号””把别名括起来，Oracle也支持我们直接写别名，但是呢<strong>，如果我们不写双引号，那么我们的别名是不能有空格的</strong></p>
<p>还有一点的是：<strong>Oracle的别名是不能使用单引号来括起来的，Oracle默认认为单引号是字符串类型和日期类型的。</strong></p>
<h2 id="操作表细节"><a href="#操作表细节" class="headerlink" title="操作表细节"></a>操作表细节</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">进入回收站</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> users;</span><br><span class="line"></span><br><span class="line">查询回收站中的对象</span><br><span class="line"><span class="keyword">show</span> recyclebin;</span><br><span class="line"></span><br><span class="line">闪回，即将回收站还原</span><br><span class="line">flashback <span class="keyword">table</span> 表名 <span class="keyword">to</span> before <span class="keyword">drop</span>;</span><br><span class="line">flashback <span class="keyword">table</span> 表名 <span class="keyword">to</span> before <span class="keyword">drop</span> rename <span class="keyword">to</span>  新表名;</span><br><span class="line"></span><br><span class="line">彻底删除users表</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> users purge;</span><br><span class="line"></span><br><span class="line">清空回收站</span><br><span class="line">purge recyclebin;</span><br><span class="line"></span><br><span class="line">为emp表增加image列，<span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 类型(宽度) </span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp</span><br><span class="line"><span class="keyword">add</span> image <span class="type">blob</span>;</span><br><span class="line"></span><br><span class="line">修改ename列的长度为<span class="number">20</span>个字节，<span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify 列名 类型(宽度) </span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp</span><br><span class="line">modify ename varchar2(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">删除image列，<span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">column</span> 列名</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">column</span> image;</span><br><span class="line"></span><br><span class="line">重名列名ename为username，<span class="keyword">alter</span> <span class="keyword">table</span> 表名 rename <span class="keyword">column</span> 原列名 <span class="keyword">to</span> 新列名</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp</span><br><span class="line">rename <span class="keyword">column</span> ename <span class="keyword">to</span> username;</span><br><span class="line"></span><br><span class="line">将emp表重命名emps，rename 原表名 <span class="keyword">to</span> 新表名</span><br><span class="line">rename emp <span class="keyword">to</span> emps;</span><br></pre></td></tr></table></figure>

<p>值得注意的是：<strong>修改表的时候，是不能回滚的！</strong></p>
<p>Oracle中的级联操作：</p>
<ul>
<li><strong>【on delete cascade】级联删除</strong></li>
<li><strong>【on delete set null】将外键一方设置为null</strong></li>
</ul>
<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p>Oracle中的分页是依靠着rownum这个伪列来实现的，由于rownum只能使用的是&lt;&#x3D;或者&lt;来获取数据。。。因为rownum的值可能会经常变【加入一条数据，那么rownum就+1，讲道理rownum可以是无穷大的，因此不能使用&gt;来进行操作】….</p>
<p>那么Oracle分页的思路是这样子的：</p>
<ul>
<li>先在子查询中获取前n条记录</li>
<li><strong>由于返回的是多行多列，因此我们可以看做成一张表</strong></li>
<li>那么将查询出来的数据放在from字句的后边</li>
<li>外套的查询可以<strong>通过where字句来对子查询出来的数据进行过滤</strong></li>
<li>那么我们就可以查询出想要的数据了…</li>
</ul>
<p>公式：</p>
<ul>
<li><strong>Mysql从(currentPage-1)*lineSize开始取数据，取lineSize条数据</strong></li>
<li><strong>Oracle先获取currentPage*lineSize条数据，从(currentPage-1)*lineSize开始取数据</strong></li>
</ul>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h2><p><strong>我们查询出来的数据可看成是一张表，那么我们在插入数据的时候，可以根据查询出来的数据进行插入</strong>…这就可以看成是批量操作…</p>
<p>值得注意的是，<strong>如果没有指定插入哪些字段的话，那么查询出来的全部字段均会插入表中</strong>..</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将xxx_emp表中所有<span class="number">20</span>号部门的员工，复制到emp表中，批量插入，<span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">select</span> ...语法</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> xxx_emp</span><br><span class="line"><span class="keyword">where</span> deptno<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<h3 id="删除操作对比"><a href="#删除操作对比" class="headerlink" title="删除操作对比"></a>删除操作对比</h3><p>我们的删除语法有三种：</p>
<ul>
<li><strong>delete from</strong></li>
<li><strong>truncate from</strong></li>
<li><strong>drop from</strong></li>
</ul>
<p>我们来对比一下他们的区别：</p>
<p>drop table</p>
<ul>
<li>1)属于DDL</li>
<li>2)不可回滚</li>
<li>3)不可带where</li>
<li>4)表内容和结构删除</li>
<li>5)删除速度快</li>
</ul>
<p>truncate table</p>
<ul>
<li>1)属于DDL</li>
<li>2)不可回滚</li>
<li>3)不可带where</li>
<li>4)表内容删除</li>
<li>5)删除速度快</li>
</ul>
<p>delete from</p>
<ul>
<li>1)属于DML</li>
<li>2)可回滚</li>
<li>3)可带where</li>
<li>4)表结构在，表内容要看where执行的情况</li>
<li>5)删除速度慢,需要逐行删除</li>
</ul>
<h2 id="访问其他用户的对象"><a href="#访问其他用户的对象" class="headerlink" title="访问其他用户的对象"></a>访问其他用户的对象</h2><p><strong>我们只要在访问表的时候，指定具体的用户.数据库表就行了，但是呢，还要看看该用户有没有权限查询别的用户的数据表，于是就需要赋予权限了</strong>…</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">声明：scott或hr叫用户名<span class="operator">/</span>方案名<span class="operator">/</span>空间名</span><br><span class="line">      scott<span class="comment">--tiger</span></span><br><span class="line">      hr<span class="comment">-----lion</span></span><br><span class="line">      </span><br><span class="line">查询当前用户是谁</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line">查询scott自己表空间下的所有对象时，可加，或不加用户名<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> scott.emp;</span><br><span class="line"></span><br><span class="line">以sysdba身份解锁hr普通帐户</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> hr account unlock;</span><br><span class="line"></span><br><span class="line">以sysdba身份设置hr普通帐户的密码</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> hr identified <span class="keyword">by</span> lion;</span><br><span class="line"></span><br><span class="line">当scott查询hr表空间下的所有表时，必须得加用户名</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> hr.jobs;</span><br><span class="line"></span><br><span class="line">在默认情况下，每个用户只能查询自已空间下的对象的权限，不能查询其它用户空间下的对象</span><br><span class="line"></span><br><span class="line">以sysdba身份角色，授予scott用户查询所有用户空间下的对象权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">any</span> <span class="keyword">table</span> <span class="keyword">to</span> scott;</span><br><span class="line"></span><br><span class="line">以sysdba身份，撤销scott用户查询所有用户空间下的对象权限</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">any</span> <span class="keyword">table</span> <span class="keyword">from</span> scott;</span><br><span class="line"></span><br><span class="line">scott自已查看自己所拥有的权限</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_sys_privs;</span><br><span class="line"></span><br><span class="line">从scott用户空间导航到sysdba用户空间</span><br><span class="line">conn <span class="operator">/</span> <span class="keyword">as</span> sysdba;</span><br><span class="line"></span><br><span class="line">从sysdba用户空间导航到scott用户空间</span><br><span class="line">conn scott<span class="operator">/</span>tiger;</span><br><span class="line"></span><br><span class="line">从scott用户空间导航到hr用户空间</span><br><span class="line">conn hr<span class="operator">/</span>lion;</span><br><span class="line"></span><br><span class="line">查询hr用户空间中的所有对象</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tab;</span><br><span class="line"></span><br><span class="line">从hr用户空间导航到scott用户空间</span><br><span class="line">conn scott<span class="operator">/</span>tiger;</span><br><span class="line"></span><br><span class="line">在scott用户空间下，查询hr用户空间下的jobs表，必须加上hr用户空间名</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> hr.jobs;</span><br></pre></td></tr></table></figure>

<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">基于emp表所有列，创建视图emp_view_1，<span class="keyword">create</span> <span class="keyword">view</span> 视图名 <span class="keyword">as</span> <span class="keyword">select</span>对一张或多张基表的查询</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> emp_view_1</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line">默认情况下，普通用户无权创建视图，得让sysdba为你分配creare <span class="keyword">view</span>的权限 </span><br><span class="line"></span><br><span class="line">以sysdba身份，授权scott用户<span class="keyword">create</span> <span class="keyword">view</span>权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">view</span> <span class="keyword">to</span> scott;</span><br><span class="line"></span><br><span class="line">以sysdba身份，撤销scott用户<span class="keyword">create</span> <span class="keyword">view</span>权限</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">create</span> <span class="keyword">view</span> <span class="keyword">from</span> scott;</span><br><span class="line"></span><br><span class="line">基于emp表指定列，创建视图emp_view_2，该视图包含编号<span class="operator">/</span>姓名<span class="operator">/</span>工资<span class="operator">/</span>年薪<span class="operator">/</span>年收入（查询中使用列别名）</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> emp_view_2</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> empno &quot;编号&quot;,ename &quot;姓名&quot;,sal &quot;工资&quot;,sal<span class="operator">*</span><span class="number">12</span> &quot;年薪&quot;,sal<span class="operator">*</span><span class="number">12</span><span class="operator">+</span>NVL(comm,<span class="number">0</span>) &quot;年收入&quot;</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line">基于emp表指定列，创建视图emp_view_3(a,b,c,d,e)，包含编号<span class="operator">/</span>姓名<span class="operator">/</span>工资<span class="operator">/</span>年薪<span class="operator">/</span>年收入（视图中使用列名）</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> emp_view_3(a,b,c,d,e)</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> empno &quot;编号&quot;,ename &quot;姓名&quot;,sal &quot;工资&quot;,sal<span class="operator">*</span><span class="number">12</span> &quot;年薪&quot;,sal<span class="operator">*</span><span class="number">12</span><span class="operator">+</span>NVL(comm,<span class="number">0</span>) &quot;年收入&quot;</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line">查询emp_view_3创建视图的结构</span><br><span class="line"><span class="keyword">desc</span> emp_view_3;</span><br><span class="line"></span><br><span class="line">修改emp_view_3(id,name,salary,annual,income)视图，<span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> 视图名 <span class="keyword">as</span> 子查询</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> emp_view_3(id,name,salary,annual,income)</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> empno &quot;编号&quot;,ename &quot;姓名&quot;,sal &quot;工资&quot;,sal<span class="operator">*</span><span class="number">12</span> &quot;年薪&quot;,sal<span class="operator">*</span><span class="number">12</span><span class="operator">+</span>NVL(comm,<span class="number">0</span>) &quot;年收入&quot;</span><br><span class="line"><span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line">查询emp表，求出各部门的最低工资，最高工资，平均工资</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(sal),<span class="built_in">max</span>(sal),round(<span class="built_in">avg</span>(sal),<span class="number">0</span>),deptno</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> deptno;</span><br><span class="line"></span><br><span class="line">创建视图emp_view_4，视图中包含各部门的最低工资，最高工资，平均工资</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> emp_view_4</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> deptno &quot;部门号&quot;,<span class="built_in">min</span>(sal) &quot;最低工资&quot;,<span class="built_in">max</span>(sal) &quot;最高工资&quot;,round(<span class="built_in">avg</span>(sal),<span class="number">0</span>) &quot;平均工资&quot;</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> deptno;</span><br><span class="line"></span><br><span class="line">创建视图emp_view_5，视图中包含员工编号，姓名，工资，部门名，工资等级</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> emp_view_5</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> e.empno &quot;编号&quot;,e.ename &quot;姓名&quot;,e.sal &quot;工资&quot;,d.dname &quot;部门名&quot;,s.grade &quot;工资等级&quot;</span><br><span class="line"><span class="keyword">from</span> emp e,dept d,salgrade s</span><br><span class="line"><span class="keyword">where</span> (e.deptno<span class="operator">=</span>d.deptno) <span class="keyword">and</span> (e.sal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal);</span><br><span class="line"></span><br><span class="line">删除视图emp_view_1中的<span class="number">7788</span>号员工的记录，使用<span class="keyword">delete</span>操作，会影响基表吗</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp_view_1 <span class="keyword">where</span> empno<span class="operator">=</span><span class="number">7788</span>;写法正确，会影响基表</span><br><span class="line"></span><br><span class="line">修改emp_view_1为只读视图【<span class="keyword">with</span> read <span class="keyword">only</span>】，再执行上述<span class="keyword">delete</span>操作，还行吗？</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> emp_view_1</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">with</span> read <span class="keyword">only</span>;</span><br><span class="line">不能进行<span class="keyword">delete</span>操作了</span><br><span class="line"></span><br><span class="line">删除视图中的【某条】记录会影响基表吗？</span><br><span class="line">会影响基表</span><br><span class="line"></span><br><span class="line">将【整个】视图删除，会影响表吗？</span><br><span class="line">不会影响基表</span><br><span class="line"></span><br><span class="line">删除视图，会进入回收站吗？</span><br><span class="line">不会进入回收站</span><br><span class="line"></span><br><span class="line">删除基表会影响视图吗？</span><br><span class="line">会影响视图</span><br><span class="line"></span><br><span class="line">闪回基表后,视图有影响吗？</span><br><span class="line">视图又可以正常工作了</span><br></pre></td></tr></table></figure>

<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">为emp表的empno字段，创建序列emp_empno_seq，<span class="keyword">create</span> sequence 序列名</span><br><span class="line"><span class="keyword">create</span> sequence emp_empno_seq;</span><br><span class="line"></span><br><span class="line">删除序列emp_empno_seq，<span class="keyword">drop</span> sequence 序列名</span><br><span class="line"><span class="keyword">drop</span> sequence emp_empno_seq;</span><br><span class="line"></span><br><span class="line">查询emp_empno_seq序列的当前值currval和下一个值nextval，第一次使用序列时，必须选用：序列名.nextval</span><br><span class="line"><span class="keyword">select</span> emp_empno_seq.nextval <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> emp_empno_seq.currval <span class="keyword">from</span> dual;</span><br><span class="line"></span><br><span class="line">使用序列，向emp表插入记录，empno字段使用序列值</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(empno) <span class="keyword">values</span>(emp_empno_seq.nextval);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(empno) <span class="keyword">values</span>(emp_empno_seq.nextval);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(empno) <span class="keyword">values</span>(emp_empno_seq.nextval);</span><br><span class="line"></span><br><span class="line">修改emp_empno_seq序列的increment <span class="keyword">by</span>属性为<span class="number">20</span>，默认<span class="keyword">start</span> <span class="keyword">with</span>是<span class="number">1</span>，<span class="keyword">alter</span> sequence 序列名</span><br><span class="line"><span class="keyword">alter</span> sequence emp_empno_seq</span><br><span class="line">increment <span class="keyword">by</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">修改修改emp_empno_seq序列的的increment <span class="keyword">by</span>属性为<span class="number">5</span></span><br><span class="line"><span class="keyword">alter</span> sequence emp_empno_seq</span><br><span class="line">increment <span class="keyword">by</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">修改emp_empno_seq序列的<span class="keyword">start</span> <span class="keyword">with</span>属性，行吗</span><br><span class="line"><span class="keyword">alter</span> sequence emp_empno_seq</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">有了序列后，还能为主健手工设置值吗？</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(empno) <span class="keyword">values</span>(<span class="number">9999</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(empno) <span class="keyword">values</span>(<span class="number">7900</span>);</span><br><span class="line"></span><br><span class="line">删除表，会影响序列吗？</span><br><span class="line">你无法做<span class="keyword">insert</span>操作,表真正亡，序列亡</span><br><span class="line"></span><br><span class="line">删除序列，会影响表吗？</span><br><span class="line"></span><br><span class="line">不会</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在hibernate中，如果是访问oracle数据库服务器，那么User.hbm.xml映射文件中关于<span class="operator">&lt;</span>id<span class="operator">&gt;</span>标签如何配置呢？</span><br><span class="line"><span class="operator">&lt;</span>id name<span class="operator">=</span>&quot;id&quot; <span class="keyword">column</span><span class="operator">=</span>&quot;id&quot;<span class="operator">&gt;</span></span><br><span class="line">   <span class="operator">&lt;</span>generator class<span class="operator">=</span>&quot;increment/identity/uuid/【sequence】/【native】&quot;<span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span>id<span class="operator">&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>（1）是一种<strong>快速查询表中内容的机制</strong>，类似于新华字典的目录<br>（2）运用在表中某个&#x2F;些字段上，但<strong>存储时，独立于表之外</strong></p>
<p>为什么要用索引</p>
<ul>
<li>（1）<strong>通过指针加速Oracle服务器的查询速度</strong></li>
<li>（2）<strong>通过rowid快速定位数据的方法，减少磁盘I&#x2F;O</strong><ul>
<li>rowid是oracle中唯一确定每张表不同记录的唯一身份证</li>
</ul>
</li>
</ul>
<h3 id="rowid特点"><a href="#rowid特点" class="headerlink" title="rowid特点"></a>rowid特点</h3><ol>
<li>位于每个表中，但表面上看不见，例如：desc emp是看不见的</li>
<li>只有在select中，显示写出rowid，方可看见</li>
<li>它与每个表绑定在一起，表亡，该表的rowid亡，二张表rownum可以相同，但rowid必须是唯一的</li>
<li>rowid是18位大小写加数字混杂体，唯一表代该条记录在DBF文件中的位置</li>
<li>rowid可以参与&#x3D;&#x2F;like比较时，用’’单引号将rowid的值包起来，且区分大小写</li>
<li>rowid是联系表与DBF文件的桥梁</li>
</ol>
<h3 id="索引特点"><a href="#索引特点" class="headerlink" title="索引特点"></a>索引特点</h3><ol>
<li>索引一旦建立, <strong>Oracle管理系统会对其进行自动维护</strong>, 而且由Oracle管理系统决定何时使用索引</li>
<li>用户不用在查询语句中指定使用哪个索引</li>
<li><strong>在定义primary key或unique约束后系统自动在相应的列上创建索引</strong></li>
<li>用户也能按自己的需求，对指定单个字段或多个字段，添加索引</li>
</ol>
<p>需要注意的是：<strong>Oracle是自动帮我们管理索引的，并且如果我们指定了primary key或者unique约束，系统会自动在对应的列上创建索引</strong>..</p>
<p>什么时候【要】创建索引</p>
<p>（1）表经常进行 SELECT 操作</p>
<p>（2）表很大(记录超多)，记录内容分布范围很广</p>
<p>（3）列名经常在 WHERE 子句或连接条件中出现</p>
<p>什么时候【不要】创建索引</p>
<p>（1）表经常进行 INSERT&#x2F;UPDATE&#x2F;DELETE 操作</p>
<p>（2）表很小(记录超少)</p>
<p>（3）列名不经常作为连接条件或出现在 WHERE 子句中</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">为emp表的empno单个字段，创建索引emp_empno_idx，叫单列索引，<span class="keyword">create</span> index 索引名 <span class="keyword">on</span> 表名(字段,...)</span><br><span class="line"><span class="keyword">create</span> index emp_empno_idx</span><br><span class="line"><span class="keyword">on</span> emp(empno);</span><br><span class="line"></span><br><span class="line">为emp表的ename,job多个字段，创建索引emp_ename_job_idx，多列索引<span class="operator">/</span>联合索引</span><br><span class="line"><span class="keyword">create</span> index emp_ename_job_idx </span><br><span class="line"><span class="keyword">on</span> emp(ename,job);</span><br><span class="line">如果在<span class="keyword">where</span>中只出现job不使用索引</span><br><span class="line">如果在<span class="keyword">where</span>中只出现ename使用索引</span><br><span class="line">我们提倡同时出现ename和job</span><br><span class="line"></span><br><span class="line">注意：索引创建后，只有查询表有关，和其它（<span class="keyword">insert</span><span class="operator">/</span><span class="keyword">update</span><span class="operator">/</span><span class="keyword">delete</span>）无关,解决速度问题</span><br><span class="line"></span><br><span class="line">删除emp_empno_idx和emp_ename_job_idx索引，<span class="keyword">drop</span> index 索引名</span><br><span class="line"><span class="keyword">drop</span> index emp_empno_idx;</span><br><span class="line"><span class="keyword">drop</span> index emp_ename_job_idx;</span><br></pre></td></tr></table></figure>

<h1 id="权限和用户"><a href="#权限和用户" class="headerlink" title="权限和用户"></a>权限和用户</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">一）用户</span><br><span class="line">Oracle中的用户分为二大类</span><br><span class="line"><span class="number">1</span>）Oracle数据库服务器创建时，由系统自动创建的用户，叫系统用户，如sys。</span><br><span class="line"><span class="number">2</span>）利用系统用户创建的用户，叫普通用户，如scott,hr，c##tiger,zhaojun,...</span><br><span class="line"></span><br><span class="line">》用sys登录，查询当前Oracle数据库服务器中已有用户的名字和状态</span><br><span class="line">  username表示登录名</span><br><span class="line">  expired<span class="operator">&amp;</span>locked表示帐号过期和锁定</span><br><span class="line">  <span class="keyword">open</span>表示帐号现在可用</span><br><span class="line">  sqlplus <span class="operator">/</span> <span class="keyword">as</span> sysdba;</span><br><span class="line">  col username <span class="keyword">for</span> a30;</span><br><span class="line">  col account_status <span class="keyword">for</span> a30;</span><br><span class="line">  <span class="keyword">set</span> pagesize <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">select</span> username,account_status <span class="keyword">from</span> dba_users;</span><br><span class="line">  </span><br><span class="line">  查询Oracle中有哪些用户</span><br><span class="line">  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> all_users;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二）创建与删除普通用户</span><br><span class="line">可以在Oracle中创建新的普通用户，创建普通用户命令是：<span class="keyword">create</span> <span class="keyword">user</span>，在创建普通用户的同时，应该为其分配一个具体的表空间，通常叫users。</span><br><span class="line"></span><br><span class="line">》用sys登录，查询Oracle中有哪些可用存储空间，所有普通用户默认为users存储空间</span><br><span class="line">  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$tablespace;</span><br><span class="line"></span><br><span class="line">》用sys登录，创建普通用户c##tiger，密码为abc，默认使用users存储空间，即对应硬盘上的一个DBF二进制文件</span><br><span class="line">  sqlplus <span class="operator">/</span> <span class="keyword">as</span> sysdba;</span><br><span class="line">  <span class="keyword">create</span> <span class="keyword">user</span> c##tiger identified <span class="keyword">by</span> abc <span class="keyword">default</span> tablespace users;</span><br><span class="line"></span><br><span class="line">》用sys登录，为c##tiger分配users空间无限制使用，即数据库中DBF文件可以无限增加，一个DBF文件不够，会创建第二个DBF文件</span><br><span class="line">  sqlplus <span class="operator">/</span> <span class="keyword">as</span> sysdba;</span><br><span class="line">  <span class="keyword">alter</span> <span class="keyword">user</span> c##tiger quota unlimited <span class="keyword">on</span> users;</span><br><span class="line"></span><br><span class="line">》用c##tiger登录，能进orcl数据库吗？</span><br><span class="line">  sqlplus c##tiger<span class="operator">/</span>abc</span><br><span class="line">  进不去orcl数据库</span><br><span class="line"></span><br><span class="line">》用sys登录，删除普通用户c##tiger</span><br><span class="line">  sqlplus <span class="operator">/</span> <span class="keyword">as</span> sysdba;</span><br><span class="line">  <span class="keyword">drop</span> <span class="keyword">user</span> c##tiger cascade;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">三）了解系统用户</span><br><span class="line">sys是Oracle中一个重要的系统用户，sys是Oracle中最高权限用户，其角色为SYSDBA（系统管理员）</span><br><span class="line">sqlplus <span class="operator">/</span> <span class="keyword">as</span> sysdba</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">四）权限</span><br><span class="line">权限的最终作用于用户。即所有用户在数据库内的操作对象和可执行的动作都是受到限制的。</span><br><span class="line">Oracle中权限分为二大类：</span><br><span class="line"><span class="number">1</span>）系统权限</span><br><span class="line"><span class="number">2</span>）对象权限</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">五）系统权限</span><br><span class="line">针对数据库中特定操作的许可，例如：让c##tiger能登录到orcl数据库，能在orcl数据库中创建表</span><br><span class="line"></span><br><span class="line">》用sys登录，获取系统权限的相关信息，例如：<span class="keyword">select</span> <span class="keyword">any</span> <span class="keyword">table</span>表示针对所有表的<span class="keyword">select</span>权限</span><br><span class="line">  sqlplus <span class="operator">/</span> <span class="keyword">as</span> sysdba;</span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">distinct</span> privilege <span class="keyword">from</span> dba_sys_privs;</span><br><span class="line"></span><br><span class="line">》用sys登录，为c##tiger分配<span class="keyword">create</span> session与数据库建立会话的权限，即允许该用户登录</span><br><span class="line">  sqlplus <span class="operator">/</span> <span class="keyword">as</span> sysdba;</span><br><span class="line">  <span class="keyword">grant</span> <span class="keyword">create</span> session <span class="keyword">to</span> c##tiger;</span><br><span class="line"></span><br><span class="line">》用c##tiger登录，能进orcl数据库吗？</span><br><span class="line">  sqlplus c##tiger<span class="operator">/</span>abc</span><br><span class="line">  能进去orcl数据库</span><br><span class="line"></span><br><span class="line">》用c##tiger登录，创建一张tiger的表，能创建吗？</span><br><span class="line">  sqlplus c##tiger<span class="operator">/</span>abc</span><br><span class="line">  <span class="keyword">create</span> <span class="keyword">table</span> tiger(</span><br><span class="line">    name varchar2(<span class="number">20</span>)</span><br><span class="line">  );</span><br><span class="line">  这时c##tiger没有权限创建表</span><br><span class="line"></span><br><span class="line">》用sys登录，为c##tiger分配<span class="keyword">create</span> <span class="keyword">table</span>权限，即允许创建表</span><br><span class="line">  sqlplus <span class="operator">/</span> <span class="keyword">as</span> sysdba;</span><br><span class="line">  <span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">to</span> c##tiger;</span><br><span class="line"></span><br><span class="line">》用c##tiger登录，创建一张tiger的表，能创建吗？</span><br><span class="line">  sqlplus c##tiger<span class="operator">/</span>abc</span><br><span class="line">  <span class="keyword">create</span> <span class="keyword">table</span> tiger(</span><br><span class="line">    name varchar2(<span class="number">20</span>)</span><br><span class="line">  );</span><br><span class="line">  可以创建c##tiger表</span><br><span class="line"></span><br><span class="line">》用sys登录，查询c##tiger所拥有的系统权限</span><br><span class="line">  sqlplus <span class="operator">/</span> <span class="keyword">as</span> sysdba;</span><br><span class="line">  <span class="keyword">select</span> grantee,privilege <span class="keyword">from</span> dba_sys_privs <span class="keyword">where</span> <span class="built_in">lower</span>(grantee) <span class="operator">=</span> <span class="string">&#x27;c##tiger&#x27;</span>;</span><br><span class="line">  grantee表示普通用户名</span><br><span class="line">  privilege权限名  </span><br><span class="line"></span><br><span class="line">》用sys登录，撤销c##tiger的<span class="keyword">create</span> <span class="keyword">table</span>权限</span><br><span class="line">  sqlplus <span class="operator">/</span> <span class="keyword">as</span> sysdba;</span><br><span class="line">  <span class="keyword">revoke</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">from</span> c##tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">六）对象权限</span><br><span class="line">用户对已有对象的操作权限，包括：</span><br><span class="line"><span class="number">1</span>）<span class="keyword">select</span>可用于表，视图和序列</span><br><span class="line"><span class="number">2</span>）<span class="keyword">insert</span>向表或视图中插入新的记录</span><br><span class="line"><span class="number">3</span>）<span class="keyword">update</span>更新表中数据</span><br><span class="line"><span class="number">4</span>）<span class="keyword">delete</span>删除表中数据</span><br><span class="line"><span class="number">5</span>）<span class="keyword">execute</span>函数，过程的执行</span><br><span class="line"><span class="number">6</span>）index为表创建索引</span><br><span class="line"><span class="number">7</span>）<span class="keyword">references</span>为表创建外健</span><br><span class="line"><span class="number">8</span>）<span class="keyword">alter</span>修改表或者序列的属性</span><br><span class="line"></span><br><span class="line">》用sys登录，查询c##tiger所拥有的对象权限</span><br><span class="line">  sqlplus <span class="operator">/</span> <span class="keyword">as</span> sysdba;</span><br><span class="line">  col grantee <span class="keyword">for</span> a10;</span><br><span class="line">  col table_name <span class="keyword">for</span> a10;</span><br><span class="line">  col privilege <span class="keyword">for</span> a20;</span><br><span class="line">  <span class="keyword">select</span> grantee,table_name,privilege <span class="keyword">from</span> dba_tab_privs <span class="keyword">where</span> <span class="built_in">lower</span>(grantee) <span class="operator">=</span> <span class="string">&#x27;c##tiger&#x27;</span>;</span><br><span class="line"></span><br><span class="line">》用sys登录，为c##tiger分配对tiger表的所有权限，即增删改查操作</span><br><span class="line">  sqlplus <span class="operator">/</span> <span class="keyword">as</span> sysdba;</span><br><span class="line">  <span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> c##tiger.tiger <span class="keyword">to</span> c##tiger;</span><br><span class="line">  注意：c##tiger表示空间名</span><br><span class="line">        tiger表示该空间下的表名</span><br><span class="line">  C##TIGER   TIGER      FLASHBACK</span><br><span class="line">  C##TIGER   TIGER      DEBUG</span><br><span class="line">  C##TIGER   TIGER      QUERY REWRITE</span><br><span class="line">  C##TIGER   TIGER      <span class="keyword">ON</span> <span class="keyword">COMMIT</span> REFRESH</span><br><span class="line">  C##TIGER   TIGER      <span class="keyword">REFERENCES</span></span><br><span class="line">  C##TIGER   TIGER      <span class="keyword">UPDATE</span></span><br><span class="line">  C##TIGER   TIGER      <span class="keyword">SELECT</span></span><br><span class="line">  C##TIGER   TIGER      <span class="keyword">INSERT</span></span><br><span class="line">  C##TIGER   TIGER      INDEX</span><br><span class="line">  C##TIGER   TIGER      <span class="keyword">DELETE</span></span><br><span class="line">  C##TIGER   TIGER      <span class="keyword">ALTER</span></span><br><span class="line"></span><br><span class="line">》用c##tiger登录，对tiger表进行增删改查操作</span><br><span class="line">  sqlplus c##tiger<span class="operator">/</span>abc;</span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> tiger(name) <span class="keyword">values</span>(<span class="string">&#x27;AA&#x27;</span>);</span><br><span class="line">  <span class="keyword">update</span> tiger <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;BB&#x27;</span>;</span><br><span class="line">  <span class="keyword">delete</span> <span class="keyword">from</span> tiger <span class="keyword">where</span> rownum <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tiger;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="PLSQL学习"><a href="#PLSQL学习" class="headerlink" title="PLSQL学习"></a>PLSQL学习</h1><p><strong>PLSQL是Oracle对SQL99的一种扩展</strong></p>
<ul>
<li>是专用于Oracle服务器，在SQL基础之上，<strong>添加了一些过程化控制语句，叫PLSQL</strong></li>
<li>过程化包括有：类型定义，判断，循环，游标，异常或例外处理。。。</li>
<li><strong>PLSQL强调过程</strong></li>
</ul>
<p>为什么要用PLSQL</p>
<ul>
<li>因为SQL是第四代命令式语言，<strong>无法显示处理过程化的业务，所以得用一个过程化程序设计语言来弥补SQL的不足之处</strong>，</li>
<li>SQL和PLSQL不是替代关系，是弥补关系</li>
</ul>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013560860">参考文章</a></p>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013517914">参考文章</a></p>
<h1 id="有关mysql命令"><a href="#有关mysql命令" class="headerlink" title="有关mysql命令"></a>有关mysql命令</h1><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000017278335">面试前必须知道的MySQL命令【explain】 - SegmentFault 思否</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/08/12/%E9%BB%91%E4%B9%A6%E7%B3%BB%E5%88%97-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/12/%E9%BB%91%E4%B9%A6%E7%B3%BB%E5%88%97-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">黑书系列-深入理解计算机系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-12 09:32:19 / 修改时间：02:08:48" itemprop="dateCreated datePublished" datetime="2021-08-12T09:32:19Z">2021-08-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%BB%91%E4%B9%A6/" itemprop="url" rel="index"><span itemprop="name">黑书</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1、文件是对I&#x2F;O设备的抽象表示；虚拟内存是对主存和磁盘I&#x2F;O的抽象表示；进程是对处理器、主存和I&#x2F;O设备的抽象表示。</p>
<p>2、shell进程：shell做为一种和Linux系统的特殊交互式工具，为用户提供了启动程序、管理文件系统中的文件及运行在Linux上的进程的途径。shell通过解析输入的文本命令，在内核中执行来达到与系统交互的功能。shell包含了一组内部命令，通过这些命令可以进行文件管理、程序管理及运行等操作。</p>
<blockquote>
<p>【什么是shell】</p>
<p>简单点理解，就是系统跟<a target="_blank" rel="noopener" href="https://m.baidu.com/s?word=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6&from=1011904q&sa=gh_pl_wisezm">计算机硬件</a>交互时使用的中间介质，它只是系统的一个工具。实际上，在shell和<a target="_blank" rel="noopener" href="https://m.baidu.com/s?word=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6&from=1011904q&sa=gh_pl_wisezm">计算机硬件</a>之间还有一层东西那就是系统内核了。打个比方，如果把<a target="_blank" rel="noopener" href="https://m.baidu.com/s?word=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6&from=1011904q&sa=gh_pl_wisezm">计算机硬件</a>比作一个人的躯体，而系统内核则是人的大脑，至于shell，把它比作人的五官似乎更加贴切些。回到计算机上来，用户直接面对的不是<a target="_blank" rel="noopener" href="https://m.baidu.com/s?word=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6&from=1011904q&sa=gh_pl_wisezm">计算机硬件</a>而是shell，用户把指令告诉shell，然后shell再传输给系统内核，接着内核再去支配计算机硬件去执行各种操作。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">数据库-面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-13 15:22:51" itemprop="dateCreated datePublished" datetime="2021-03-13T15:22:51Z">2021-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-18 05:13:18" itemprop="dateModified" datetime="2021-03-18T05:13:18Z">2021-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1、事务的四大特性是什么？"><a href="#1、事务的四大特性是什么？" class="headerlink" title="1、事务的四大特性是什么？"></a>1、事务的四大特性是什么？</h1><ul>
<li>原子性，要么执行，要么不执行  </li>
<li>隔离性，所有操作全部执行完以前其它会话不能看到过程 </li>
<li>一致性，事务前后，数据总额一致 </li>
<li>持久性，一旦事务提交，对数据的改变就是永久的</li>
</ul>
<h1 id="PS-sql语句"><a href="#PS-sql语句" class="headerlink" title="PS:sql语句"></a>PS:sql语句</h1><p><strong>sql对大小写不敏感。</strong></p>
<h2 id="1-SQL-DML-和-DDL"><a href="#1-SQL-DML-和-DDL" class="headerlink" title="1.SQL DML 和 DDL"></a>1.SQL DML 和 DDL</h2><p>可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。</p>
<p>SQL (结构化查询语言)是用于执行查询的语法。但是 SQL 语言也包含用于更新、插入和删除记录的语法。</p>
<p>查询和更新指令构成了 SQL 的 DML 部分：</p>
<ul>
<li><em>SELECT</em> - 从数据库表中获取数据</li>
<li><em>UPDATE</em> - 更新数据库表中的数据</li>
<li><em>DELETE</em> - 从数据库表中删除数据</li>
<li><em>INSERT INTO</em> - 向数据库表中插入数据</li>
</ul>
<p>SQL 的数据定义语言 (DDL) 部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。</p>
<p>SQL 中最重要的 DDL 语句:</p>
<ul>
<li><em>CREATE DATABASE</em> - 创建新数据库</li>
<li><em>ALTER DATABASE</em> - 修改数据库</li>
<li><em>CREATE TABLE</em> - 创建新表</li>
<li><em>ALTER TABLE</em> - 变更（改变）数据库表</li>
<li><em>DROP TABLE</em> - 删除表</li>
<li><em>CREATE INDEX</em> - 创建索引（搜索键）</li>
<li><em>DROP INDEX</em> - 删除索引</li>
</ul>
<h3 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h3><p>从表中选取数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名称，列名称 <span class="keyword">FROM</span> 表名称</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名称<span class="operator">/</span><span class="operator">/</span>星号（<span class="operator">*</span>）是选取所有列的快捷方式。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>distinct语句</p>
<p>关键词 DISTINCT 用于返回唯一不同的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 列名称 <span class="keyword">FROM</span> 表名称</span><br></pre></td></tr></table></figure>

<h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p><strong>WHERE 子句用于规定选择的标准</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名称 <span class="keyword">FROM</span> 表名称 <span class="keyword">WHERE</span> 列 运算符 值</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;</td>
<td align="left">等于</td>
</tr>
<tr>
<td align="left">&lt;&gt;</td>
<td align="left">不等于</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">大于</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">小于</td>
</tr>
<tr>
<td align="left">&gt;&#x3D;</td>
<td align="left">大于等于</td>
</tr>
<tr>
<td align="left">&lt;&#x3D;</td>
<td align="left">小于等于</td>
</tr>
<tr>
<td align="left">BETWEEN</td>
<td align="left">在某个范围内</td>
</tr>
<tr>
<td align="left">LIKE</td>
<td align="left">搜索某种模式</td>
</tr>
</tbody></table>
<h4 id="and和or运算符"><a href="#and和or运算符" class="headerlink" title="and和or运算符"></a>and和or运算符</h4><p>AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。</p>
<p>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</p>
<p>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Persons <span class="keyword">WHERE</span> (FirstName<span class="operator">=</span><span class="string">&#x27;Thomas&#x27;</span> <span class="keyword">OR</span> FirstName<span class="operator">=</span><span class="string">&#x27;William&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> LastName<span class="operator">=</span><span class="string">&#x27;Carter&#x27;</span><span class="comment">/*使用圆括号来组成复杂的表达式*/</span></span><br></pre></td></tr></table></figure>

<h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3><p>ORDER BY 语句用于对结果集进行排序。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*按照company名字进行升序排序*/</span></span><br><span class="line"><span class="keyword">SELECT</span> Company, OrderNumber <span class="keyword">FROM</span> Orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> Company</span><br><span class="line"><span class="comment">/*以字母顺序显示公司名称（Company），并以数字顺序显示顺序号（OrderNumber*/</span></span><br><span class="line"><span class="keyword">SELECT</span> Company, OrderNumber <span class="keyword">FROM</span> Orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> Company, OrderNumber</span><br><span class="line"><span class="comment">/*desc是降序*/</span></span><br><span class="line"><span class="keyword">SELECT</span> Company, OrderNumber <span class="keyword">FROM</span> Orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> Company <span class="keyword">DESC</span>, OrderNumber <span class="keyword">ASC</span></span><br></pre></td></tr></table></figure>

<h3 id="insert-into"><a href="#insert-into" class="headerlink" title="insert into"></a>insert into</h3><p>INSERT INTO 语句用于向表格中插入<strong>新的行。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*(值1, 值2,....)构成新的一行*/</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名称 <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>,....)</span><br><span class="line"><span class="comment">/*指定所要插入数据的列*/</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (列<span class="number">1</span>, 列<span class="number">2</span>,...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>,....)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p><strong>修改列值</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名称 <span class="keyword">SET</span> 列名称 <span class="operator">=</span> 新值 <span class="keyword">WHERE</span> 列名称 <span class="operator">=</span> 某值</span><br></pre></td></tr></table></figure>

<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>删除表中的<strong>行</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名称 <span class="keyword">WHERE</span> 列名称 <span class="operator">=</span> 值</span><br><span class="line"><span class="comment">/*删除所有行*/</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>

<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*选取头两条记录*/</span></span><br><span class="line"><span class="keyword">SELECT</span> TOP <span class="number">2</span> <span class="operator">*</span> <span class="keyword">FROM</span> Persons</span><br><span class="line"><span class="comment">/*选取50%记录*/</span></span><br><span class="line"><span class="keyword">SELECT</span> TOP <span class="number">50</span> <span class="keyword">PERCENT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Persons</span><br></pre></td></tr></table></figure>

<h3 id="like"><a href="#like" class="headerlink" title="like"></a>like</h3><p>用在where子句中搜索列中的指定模式</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*从 &quot;Persons&quot; 表中选取居住在以 &quot;N&quot; 开始的城市里的人*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Persons</span><br><span class="line"><span class="keyword">WHERE</span> City <span class="keyword">LIKE</span> <span class="string">&#x27;N%&#x27;</span></span><br></pre></td></tr></table></figure>

<p>“%” 可用于定义通配符（模式中缺少的字母）。</p>
<p>SQL 通配符必须与 LIKE 运算符一起使用。</p>
<table>
<thead>
<tr>
<th align="left">通配符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%</td>
<td align="left">替代一个或多个字符</td>
</tr>
<tr>
<td align="left">_</td>
<td align="left">仅替代一个字符</td>
</tr>
<tr>
<td align="left">[charlist]</td>
<td align="left">字符列中的任何单一字符</td>
</tr>
<tr>
<td align="left">[^charlist]或者[!charlist]</td>
<td align="left">不在字符列中的任何单一字符</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*从 &quot;Persons&quot; 表中选取居住的城市以 &quot;A&quot; 或 &quot;L&quot; 或 &quot;N&quot; 开头的人*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Persons</span><br><span class="line"><span class="keyword">WHERE</span> City <span class="keyword">LIKE</span> <span class="string">&#x27;[ALN]%&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><p>IN 操作符允许我们在 WHERE 子句中规定多个值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*选取姓氏为 Adams 和 Carter 的人*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Persons</span><br><span class="line"><span class="keyword">WHERE</span> LastName <span class="keyword">IN</span> (<span class="string">&#x27;Adams&#x27;</span>,<span class="string">&#x27;Carter&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="alias（别名-AS）"><a href="#alias（别名-AS）" class="headerlink" title="alias（别名-AS）"></a>alias（别名-AS）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>

<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p><strong>SQL join 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。</strong></p>
<ul>
<li>JOIN: 如果表中有至少一个匹配，则返回行</li>
<li>LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行</li>
<li>RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行</li>
<li>FULL JOIN: 只要其中一个表中存在匹配，就返回行</li>
</ul>
<p><img src="https://i.loli.net/2021/03/18/ZUSLomsxJlOvFhP.jpg"></p>
<h4 id="inner-join（内连接）"><a href="#inner-join（内连接）" class="headerlink" title="inner join（内连接）"></a>inner join（内连接）</h4><p>INNER JOIN 与 JOIN 是相同的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table_name2 </span><br><span class="line"><span class="keyword">ON</span> table_name1.column_name<span class="operator">=</span>table_name2.column_name</span><br></pre></td></tr></table></figure>

<p>没有匹配的话，就不会返回行了</p>
<p>同理：left join…</p>
<h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*列出所有在中国和美国的不同的雇员名*/</span></span><br><span class="line"><span class="keyword">SELECT</span> E_Name <span class="keyword">FROM</span> Employees_China</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> E_Name <span class="keyword">FROM</span> Employees_USA</span><br></pre></td></tr></table></figure>

<p>union只会选择出不同值，union all会选择出所有值（包括了两个表之间的共同值）</p>
<p><strong>union合并需要UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型</strong></p>
<h3 id="select-into"><a href="#select-into" class="headerlink" title="select into"></a>select into</h3><p>SELECT INTO 语句从一个表中选取数据，然后把数据插入另一个表中。</p>
<p>SELECT INTO 语句常用于创建表的备份复件或者用于对记录进行存档。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">INTO</span> new_table_name [<span class="keyword">IN</span> externaldatabase] </span><br><span class="line"><span class="keyword">FROM</span> old_tablename</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*从 &quot;Persons&quot; 表中提取居住在 &quot;Beijing&quot; 的人的信息，创建了一个带有两个列的名为 &quot;Persons_backup&quot; 的表*/</span></span><br><span class="line"><span class="keyword">SELECT</span> LastName,Firstname</span><br><span class="line"><span class="keyword">INTO</span> Persons_backup</span><br><span class="line"><span class="keyword">FROM</span> Persons</span><br><span class="line"><span class="keyword">WHERE</span> City<span class="operator">=</span><span class="string">&#x27;Beijing&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE database_name</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名称</span><br><span class="line">(</span><br><span class="line">列名称<span class="number">1</span> 数据类型,</span><br><span class="line">列名称<span class="number">2</span> 数据类型,</span><br><span class="line">列名称<span class="number">3</span> 数据类型,</span><br><span class="line">....</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> train(</span><br><span class="line">TID <span class="type">int</span>,</span><br><span class="line">SDate <span class="type">date</span>,</span><br><span class="line">TName <span class="type">char</span>(<span class="number">20</span>), </span><br><span class="line">SStationID <span class="type">int</span>,</span><br><span class="line">AStationID <span class="type">int</span>, </span><br><span class="line">STime datetime, </span><br><span class="line">ATime datetime,</span><br><span class="line"><span class="keyword">constraint</span> PK_train <span class="keyword">primary</span> key (TID),</span><br><span class="line"><span class="keyword">constraint</span> UK_date_tname <span class="keyword">unique</span>(SDate,TName),</span><br><span class="line"><span class="keyword">constraint</span> FK_train_SStationId <span class="keyword">foreign</span> key(SStationID) <span class="keyword">REFERENCES</span> station(SID),</span><br><span class="line"><span class="keyword">constraint</span> FK_train_AStationId <span class="keyword">foreign</span> key(AStationID) <span class="keyword">REFERENCES</span> station(SID)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="constraints"><a href="#constraints" class="headerlink" title="constraints"></a>constraints</h3><p>约束用于限制加入表的数据的类型。</p>
<p>可以在<strong>创建表时</strong>规定约束（通过 CREATE TABLE 语句），或者在表创建之后也可以（通过 ALTER TABLE 语句）。</p>
<ul>
<li><p>NOT NULL</p>
</li>
<li><p>UNIQUE</p>
<ul>
<li>&#96;&#96;&#96;sql<br>&#x2F;<em>当表已经被创建时添加约束</em>&#x2F;<br>ALTER TABLE Persons<br>ADD UNIQUE (Id_P)<br>&#x2F;<em>添加多个约束</em>&#x2F;<br>ALTER TABLE Persons<br>ADD CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName)<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span></span><br><span class="line"></span><br><span class="line">  - <span class="keyword">UNIQUE</span> 和 <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> 约束均为列或列集合提供了唯一性的保证。</span><br><span class="line"></span><br><span class="line">  - 每个表可以有多个 <span class="keyword">UNIQUE</span> 约束，但是每个表只能有一个 <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> 约束。</span><br><span class="line"></span><br><span class="line">  - ```sql</span><br><span class="line">    <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Persons</span><br><span class="line">    <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (Id_P)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>FOREIGN KEY</p>
<ul>
<li><pre><code class="sql">CREATE TABLE Orders
(
Id_O int NOT NULL,
OrderNo int NOT NULL,
Id_P int,
PRIMARY KEY (Id_O),
FOREIGN KEY (Id_P) REFERENCES Persons(Id_P)
)
/*在已存在的情况下创建约束*/
ALTER TABLE Orders
ADD FOREIGN KEY (Id_P)
REFERENCES Persons(Id_P)
/*撤销相关的约束*/
ALTER TABLE Orders
DROP FOREIGN KEY fk_PerOrders
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="operator">-</span> <span class="keyword">CHECK</span></span><br><span class="line"></span><br><span class="line">  <span class="operator">-</span> <span class="keyword">CHECK</span> 约束用于限制列中的值的范围。</span><br><span class="line"></span><br><span class="line">    如果对单个列定义 <span class="keyword">CHECK</span> 约束，那么该列只允许特定的值。</span><br><span class="line"></span><br><span class="line">    如果对一个表定义 <span class="keyword">CHECK</span> 约束，那么此约束会在特定的列中对值进行限制。</span><br><span class="line"></span><br><span class="line">    ```<span class="keyword">sql</span></span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons</span><br><span class="line">    (</span><br><span class="line">    Id_P <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    LastName <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    FirstName <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    Address <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    City <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> chk_Person <span class="keyword">CHECK</span> (Id_P<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">AND</span> City<span class="operator">=</span><span class="string">&#x27;Sandnes&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">/*撤销check约束*/</span></span><br><span class="line">    <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Persons</span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">CHECK</span> chk_Person</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li></li>
</ul>
</li>
<li><p>DEFAULT</p>
<ul>
<li><p>DEFAULT 约束用于向列中插入默认值。</p>
</li>
<li><p>&#96;&#96;&#96;sql<br>CREATE TABLE Persons<br>(<br>Id_P int NOT NULL,<br>LastName varchar(255) NOT NULL,<br>FirstName varchar(255),<br>Address varchar(255),<br>City varchar(255) DEFAULT ‘Sandnes’<br>)</p>
<p>SQL View<br>SQL Date<br>SQL Nulls<br>SQL isnull()<br>SQL 数据类型<br>SQL 服务器<br>SQL 函数<br>SQL functions<br>SQL avg()<br>SQL count()<br>SQL first()<br>SQL last()<br>SQL max()<br>SQL min()<br>SQL sum()<br>SQL Group By<br>SQL Having<br>SQL ucase()<br>SQL lcase()<br>SQL mid()<br>SQL len()<br>SQL round()<br>SQL now()<br>SQL format()<br>SQL 总结<br>SQL 快速参考<br>SQL 教程总结<br>SQL 测验<br>SQL 测验<br>建站手册<br>网站构建<br>万维网联盟 (W3C)<br>浏览器信息<br>网站品质<br>语义网<br>职业规划<br>网站主机<br>编程<br>Python 教程<br>关于 W3School<br>帮助 W3School<br>SQL DEFAULT 约束<br>SQL Check<br>SQL Create Index<br>SQL DEFAULT 约束<br>DEFAULT 约束用于向列中插入默认值。</p>
<p>如果没有规定其他的值，那么会将默认值添加到所有的新记录。</p>
<p>SQL DEFAULT Constraint on CREATE TABLE<br>下面的 SQL 在 “Persons” 表创建时为 “City” 列创建 DEFAULT 约束：</p>
<p>My SQL &#x2F; SQL Server &#x2F; Oracle &#x2F; MS Access:<br>CREATE TABLE Persons<br>(<br>Id_P int NOT NULL,<br>LastName varchar(255) NOT NULL,<br>FirstName varchar(255),<br>Address varchar(255),<br>City varchar(255) DEFAULT ‘Sandnes’<br>)<br>通过使用类似 GETDATE() 这样的函数，DEFAULT 约束也可以用于插入系统值：</p>
<p>CREATE TABLE Orders<br>(<br>Id_O int NOT NULL,<br>OrderNo int NOT NULL,<br>Id_P int,<br>OrderDate date DEFAULT GETDATE()<br>)<br>SQL DEFAULT Constraint on ALTER TABLE<br>&#x2F;<em>在表已存在的情况下为 “City” 列创建 DEFAULT 约束</em>&#x2F;<br>ALTER TABLE Persons<br>ALTER City SET DEFAULT ‘SANDNES’<br>&#x2F;<em>需撤销 DEFAULT 约束</em>&#x2F;<br>ALTER TABLE Persons<br>ALTER City DROP DEFAULT</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### <span class="keyword">index</span></span><br><span class="line"></span><br><span class="line">在表中创建索引</span><br><span class="line"></span><br><span class="line">```<span class="keyword">sql</span></span><br><span class="line"><span class="comment">/*允许使用重复的值*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name</span><br><span class="line"><span class="keyword">ON</span> <span class="built_in">table_name</span> (<span class="built_in">column_name</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>视图是基于 SQL 语句的结果集的可视化的表。</p>
<p>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。</p>
<p>视图的作用：</p>
<ol>
<li>简化了操作，把<strong>经常使用</strong>的数据定义为视图，可以将复杂的SQL查询语句进行封装。</li>
<li>安全性，用户只能查询和修改能看到的数据。<ul>
<li>使用视图，基表中的数据就有了一定的安全性。因为视图是虚拟的，物理上是不存在的，只是存储了数据的集合，我们可以不通过视图将基表中重要的字段信息给用户。视图是动态的数据的集合，数据是随着基表的更新而更新的。同时，用户对视图，不可以随意的更改和删除，可以保证数据的安全性。</li>
</ul>
</li>
<li>逻辑上的独立性，屏蔽了真实表的结构带来的影响。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/03/06/java-IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/06/java-IO/" class="post-title-link" itemprop="url">java-IO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-06 12:57:51 / 修改时间：08:28:18" itemprop="dateCreated datePublished" datetime="2021-03-06T12:57:51Z">2021-03-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h1><p>Java 的 I&#x2F;O 大概可以分成以下几类：</p>
<ul>
<li>磁盘操作：File</li>
<li>字节操作：InputStream 和 OutputStream</li>
<li>字符操作：Reader 和 Writer</li>
<li>对象操作：Serializable</li>
<li>网络操作：Socket</li>
<li>新的输入&#x2F;输出：NIO</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/03/06/java-JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/06/java-JVM/" class="post-title-link" itemprop="url">java-JVM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-06 12:57:07" itemprop="dateCreated datePublished" datetime="2021-03-06T12:57:07Z">2021-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-21 01:39:54" itemprop="dateModified" datetime="2022-04-21T01:39:54Z">2022-04-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、JVM的基本介绍"><a href="#一、JVM的基本介绍" class="headerlink" title="一、JVM的基本介绍"></a>一、JVM的基本介绍</h1><p>原文地址：<a target="_blank" rel="noopener" href="https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28">https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28</a></p>
<p>JVM其实就类似于一台小电脑运行在windows或者linux这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互，可操作系统可以帮我们完成和硬件进行交互的工作。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5778d113-8e13-4c53-b5bf-801e58080b97.png" width="400px"> </div><br>

<h2 id="1-1-Java文件是如何运行的？"><a href="#1-1-Java文件是如何运行的？" class="headerlink" title="1.1 Java文件是如何运行的？"></a>1.1 Java文件是如何运行的？</h2><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>如果 <strong>JVM</strong> 想要执行这个 <strong>.class</strong> 文件，我们需要将其装进一个 <strong>类加载器</strong> 中，它就像一个搬运工一样，会把所有的 <strong>.class</strong> 文件全部搬进JVM里面来。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/1/9/16f8a9d3cd16cc5f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><strong>方法区</strong> 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等</p>
<p>类加载器将 .class 文件搬过来就是先丢到这一块上</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><strong>堆</strong> 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 <strong>线程共享区域</strong> 。也就是说它们都是 <strong>线程不安全</strong> 的</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong>栈</strong> 这是我们的代码运行空间。我们编写的每一个方法都会放到 <strong>栈</strong> 里面运行。</p>
<p>我们会听说过 本地方法栈 或者 本地方法接口 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用C来进行工作的，和Java没有太大的关系。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是<strong>本地方法栈为本地方法服务。</strong></p>
<p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66a6899d-c6b0-4a47-8569-9d08f0baf86c.png" width="300px"> </div><br>

<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码。和栈一样，都是 <strong>线程独享</strong> 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/1/9/16f8ab42da5a81cd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ol>
<li>Java文件经过编译后变成 .class 字节码文件</li>
<li>字节码文件通过类加载器被搬运到 JVM 虚拟机中</li>
<li>虚拟机主要的5大块：方法区，堆都为线程共享区域，有线程安全问题，栈和本地方法栈和计数器都是独享区域，不存在线程安全问题，而 JVM 的调优主要就是围绕堆，栈两大块进行</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayName</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;student is name is &quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;tellUrDream&quot;</span>);</span><br><span class="line">        student.sayName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行main方法的步骤如下:</p>
<ol>
<li><strong>编译</strong>好 App.java 后得到 App.class 后，执行 App.class，系统会<strong>启动一个 JVM 进程</strong>，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 <strong>App 类的加载</strong></li>
<li>JVM 找到 App 的主程序入口，执行main方法</li>
<li>这个main中的第一条语句为 Student student &#x3D; new Student(“tellUrDream”) ，就是让 JVM 创建一个Student对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中</li>
<li>加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有<strong>指向方法区中的 Student 类的类型信息</strong> 的引用</li>
<li>执行student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。</li>
<li>执行sayName()</li>
</ol>
<p>其实也不用管太多，只需要知道<strong>对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法</strong>。找方法就在方法表中找。</p>
<h1 id="二、类加载器的介绍"><a href="#二、类加载器的介绍" class="headerlink" title="二、类加载器的介绍"></a>二、类加载器的介绍</h1><p>之前也提到了它是负责加载.class文件的，它们在文件开头会有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且ClassLoader只负责class文件的加载，而是否能够运行则由 Execution Engine 来决定</p>
<p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。</p>
<h2 id="2-1-类加载器的流程"><a href="#2-1-类加载器的流程" class="headerlink" title="2.1 类加载器的流程"></a>2.1 类加载器的流程</h2><p>从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中<strong>验证，准备，解析三个部分统称为连接</strong></p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/335fe19c-4a76-45ab-9320-88c90d6a0d7e.png" width="600px"> </div><br>

<h3 id="2-1-1-加载"><a href="#2-1-1-加载" class="headerlink" title="2.1.1 加载"></a>2.1.1 加载</h3><ol>
<li><p>加载是类加载的一个阶段，注意不要混淆。</p>
<p>加载过程完成以下三件事：</p>
<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流。</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li>
<li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li>
</ul>
<p>其中二进制字节流可以从以下方式中获取：</p>
<ul>
<li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，最典型的应用是 Applet。</li>
<li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li>
<li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li>
</ul>
</li>
</ol>
<h3 id="2-1-2-链接"><a href="#2-1-2-链接" class="headerlink" title="2.1.2 链接"></a>2.1.2 链接</h3><ol>
<li>验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查</li>
<li>准备：为<strong>static变量</strong>在<strong>方法区</strong>中分配内存空间，设置变量的初始值，例如 static int a &#x3D; 3 （注意：准备阶段只设置类中的&#x3D;&#x3D;静态变量（方法区中）&#x3D;&#x3D;，不包括实&#x3D;&#x3D;例变量（堆内存中）&#x3D;&#x3D;，实例变量是对象初始化时赋值的）</li>
<li>解析：虚拟机<strong>将常量池内的符号引用替换为直接引用的过程</strong>（符号引用比如我现在import java.util.ArrayList这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）</li>
</ol>
<h3 id="2-1-3-初始化"><a href="#2-1-3-初始化" class="headerlink" title="2.1.3 初始化"></a>2.1.3 初始化</h3><p>初始化其实就是执行类构造器方法的<code>&lt;clinit&gt;()</code>的过程，而且要保证执行前父类的<code>&lt;clinit&gt;()</code>方法执行完毕。这个方法由编译器收集，顺序执行所有类变量（static修饰的成员变量）显式初始化和静态代码块中语句。此时准备阶段时的那个 <code>static int a</code> 由默认初始化的0变成了显式初始化的3. 由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。</p>
<blockquote>
<p>注意：字节码文件中初始化方法有两种，非静态资源初始化的<code>&lt;init&gt;</code>和静态资源初始化的<code>&lt;clinit&gt;</code>，类构造器方法<code>&lt;clinit&gt;()</code>不同于类的构造器，这些方法都是字节码文件中只能给JVM识别的特殊方法。</p>
</blockquote>
<h3 id="2-1-4-卸载"><a href="#2-1-4-卸载" class="headerlink" title="2.1.4 卸载"></a>2.1.4 卸载</h3><p>GC将无用对象从内存中卸载</p>
<h2 id="2-2-类加载器分类和加载顺序"><a href="#2-2-类加载器分类和加载顺序" class="headerlink" title="2.2 类加载器分类和加载顺序"></a>2.2 类加载器分类和加载顺序</h2><p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p>
<ul>
<li><p>启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；</p>
</li>
<li><p>所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。</p>
</li>
</ul>
<p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p>
<ul>
<li><p>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 &lt;JRE_HOME&gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</p>
</li>
<li><p>扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &lt;JAVA_HOME&gt;&#x2F;lib&#x2F;ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</p>
</li>
<li><p>应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ul>
<p>加载一个Class类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的</p>
<ol>
<li>BootStrap ClassLoader：rt.jar</li>
<li>Extension ClassLoader: 加载扩展的jar包</li>
<li>App ClassLoader：指定的classpath下面的jar包</li>
<li>Custom ClassLoader：自定义的类加载器</li>
</ol>
<h2 id="2-3-双亲委派机制（重点）"><a href="#2-3-双亲委派机制（重点）" class="headerlink" title="2.3 双亲委派机制（重点）"></a>2.3 双亲委派机制（重点）</h2><p>双亲委派模式要求<strong>除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器</strong>，请注意双亲委派模式中的父子关系并非通常所说的类继承关系，而是<strong>采用组合关系来复用父类加载器的相关代码</strong>，类加载器间的关系如下：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0dd2d40a-5b2b-4d45-b176-e75a4cd4bdbf.png" width="500px"> </div><br>

<p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是<strong>委派给父类去完成</strong>，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就<strong>成功返回</strong>，倘若父类加载器无法完成此加载任务，<strong>子加载器才会尝试自己去加载</strong>，这就是双亲委派模式。</p>
<p>比如我现在要new一个Person，这个Person是我们自定义的类，如果我们要加载它，就会先委派App ClassLoader，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的Class）时，子类加载器才会自行尝试加载</p>
<p>双亲委派模式优势</p>
<ul>
<li>采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种<strong>带有优先级的层次关系</strong>，通过这种层级关可以<strong>避免类的重复加载</strong>，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</li>
<li>其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以<strong>防止核心API库被随意篡改</strong>。</li>
</ul>
<h1 id="三、运行时数据区"><a href="#三、运行时数据区" class="headerlink" title="三、运行时数据区"></a>三、运行时数据区</h1><h2 id="3-1-本地方法栈和程序计数器"><a href="#3-1-本地方法栈和程序计数器" class="headerlink" title="3.1 本地方法栈和程序计数器"></a>3.1 本地方法栈和程序计数器</h2><p>比如说我们现在点开Thread类的源码，会看到它的start0方法带有一个native关键字修饰，而且不存在方法体，这种用native修饰的方法就是本地方法，这是使用C来实现的，然后一般这些方法都会放到一个叫做本地方法栈的区域。</p>
<p>程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现OutOfMemoryError的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。</p>
<p>如果执行的是native方法，那这个指针就不工作了。</p>
<h2 id="3-2-方法区"><a href="#3-2-方法区" class="headerlink" title="3.2 方法区"></a>3.2 方法区</h2><p>用于存放<strong>已被加载</strong>的类信息、常量、静态变量、即时编译器编译后的代码等数据。当它存储的信息过大时，会在无法满足内存分配时报错。</p>
<p><strong>和堆一样不需要连续的内存</strong>，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p>
<p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p>
<p>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p>
<p>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。</p>
<h3 id="3-2-1-运行时常量池"><a href="#3-2-1-运行时常量池" class="headerlink" title="3.2.1 运行时常量池"></a>3.2.1 运行时常量池</h3><p>运行时常量池是方法区的一部分。</p>
<p>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。</p>
<p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p>
<h3 id="3-2-2-直接内存"><a href="#3-2-2-直接内存" class="headerlink" title="3.2.2 直接内存"></a>3.2.2 直接内存</h3><p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p>
<h2 id="3-3-虚拟机栈和虚拟机堆"><a href="#3-3-虚拟机栈和虚拟机堆" class="headerlink" title="3.3 虚拟机栈和虚拟机堆"></a>3.3 虚拟机栈和虚拟机堆</h2><p>一句话便是：<strong>栈管运行，堆管存储</strong>。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。</p>
<h3 id="3-3-1-虚拟机栈的概念"><a href="#3-3-1-虚拟机栈的概念" class="headerlink" title="3.3.1 虚拟机栈的概念"></a>3.3.1 虚拟机栈的概念</h3><p>它是Java方法执行的<strong>内存模型</strong>。里面会对局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享。同时如果我们听到<strong>局部变量表</strong>，那也是在说虚拟机栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-2-虚拟机栈存在的异常"><a href="#3-3-2-虚拟机栈存在的异常" class="headerlink" title="3.3.2 虚拟机栈存在的异常"></a>3.3.2 虚拟机栈存在的异常</h3><p>如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 <strong>StackOverflowError</strong> （这种错误经常出现在递归中）。Java虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 <strong>OutOfMemoryError</strong>。</p>
<h3 id="3-3-3-虚拟机栈的生命周期"><a href="#3-3-3-虚拟机栈的生命周期" class="headerlink" title="3.3.3 虚拟机栈的生命周期"></a>3.3.3 虚拟机栈的生命周期</h3><p><strong>对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。</strong></p>
<p>这里补充一句：<strong>8种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。</strong></p>
<h3 id="3-3-4-虚拟机栈的执行"><a href="#3-3-4-虚拟机栈的执行" class="headerlink" title="3.3.4 虚拟机栈的执行"></a>3.3.4 虚拟机栈的执行</h3><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8442519f-0b4d-48f4-8229-56f984363c69.png" width="400px"> </div><br>

<h3 id="3-3-5-局部变量的复用"><a href="#3-3-5-局部变量的复用" class="headerlink" title="3.3.5 局部变量的复用"></a>3.3.5 局部变量的复用</h3><p><strong>局部变量表用于存放方法参数和方法内部所定义的局部变量。</strong>它的容量是以Slot为最小单位，一个slot可以存放32位以内的数据类型。</p>
<p>虚拟机通过<strong>索引定位</strong>的方式使用局部变量表，范围为[0,局部变量表的slot的数量]。方法中的参数就会按一定顺序排列在这个局部变量表中，至于怎么排的我们可以先不关心。而为了节省栈帧空间，这些slot是可以复用的，当方法执行位置超过了某个变量，那么这个变量的slot可以被其它变量复用。当然如果需要复用，那我们的垃圾回收自然就不会去动这些内存。</p>
<h3 id="3-3-6-虚拟机堆的概念"><a href="#3-3-6-虚拟机堆的概念" class="headerlink" title="3.3.6 虚拟机堆的概念"></a>3.3.6 虚拟机堆的概念</h3><p>JVM内存会划分为堆内存和非堆内存，堆内存中也会划分为<strong>年轻代</strong>和<strong>老年代</strong>，而非堆内存则为<strong>永久代</strong>。年轻代又会分为<strong>Eden</strong>和<strong>Survivor</strong>区。Survivor也会分为<strong>FromPlace</strong>和<strong>ToPlace</strong>，toPlace的survivor区域是空的。Eden，FromPlace和ToPlace的默认占比为 <strong>8:1:1</strong>。该比例可以通过一个 -XX:+UsePSAdaptiveSurvivorSizePolicy 参数来根据生成对象的速率动态调整</p>
<p><img src="https://i.loli.net/2021/03/06/Nv3FTUBGKMARo7S.png" alt="image-20200324095521916"></p>
<p><strong>堆内存中存放的是对象</strong>，**垃圾收集就是收集这些对象然后交给GC算法进行回收。 **<br><strong>非堆内存&#x3D;&#x3D;方法区。</strong><br>在1.8中已经移除永久代，替代品是一个元空间(MetaSpace)，最大区别是metaSpace是不存在于JVM中的，它使用的是本地内存。并有两个参数</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MetaspaceSize：初始化元空间大小，控制发生<span class="built_in">GC</span></span><br><span class="line">MaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。</span><br></pre></td></tr></table></figure>

<p>移除的原因可以大致了解一下：融合HotSpot JVM和JRockit VM而做出的改变，因为JRockit是没有永久代的，不过这也间接性地解决了永久代的OOM问题。</p>
<h3 id="3-3-7-Eden年轻代的介绍"><a href="#3-3-7-Eden年轻代的介绍" class="headerlink" title="3.3.7 Eden年轻代的介绍"></a>3.3.7 Eden年轻代的介绍</h3><p>当我们<strong>new一个对象后，会先放到Eden划分出来的一块作为存储空间的内存</strong>，但是我们知道对堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况。这里JVM的处理是每个线程都会预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作TLAB。</p>
<p>当Eden空间满了之后，会触发一个叫做Minor GC（就是一个发生在年轻代的GC）的操作，存活下来的对象移动到Survivor0区。Survivor0区满后触发 Minor GC，就会将存活对象移动到Survivor1区，此时还会把from和to两个指针交换，这样保证了一段时间内总有一个survivor区为空且to所指向的survivor区为空。经过多次的 Minor GC后仍然存活的对象（<strong>这里的存活判断是15次，对应到虚拟机参数为 -XX:MaxTenuringThreshold 。为什么是15，因为HotSpot会在对象投中的标记字段里记录年龄，分配到的空间仅有4位，所以最多只能记录到15</strong>）会移动到老年代。<strong>老年代是存储长期存活的对象的，占满时就会触发我们最常听说的Full GC，期间会停止所有线程等待GC的完成。</strong>所以对于响应要求高的应用应该尽量去减少发生Full GC从而避免响应超时的问题。</p>
<p>而且<strong>当老年区执行了full gc之后仍然无法进行对象保存的操作，就会产生OOM</strong>，这时候就是虚拟机中的堆内存不足，原因可能会是堆内存设置的大小过小，这个可以通过参数-Xms、-Xmx来调整。也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/1/14/16fa201c39ac86ad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h1 id="四、垃圾收集"><a href="#四、垃圾收集" class="headerlink" title="四、垃圾收集"></a>四、垃圾收集</h1><h2 id="4-1-如何判断一个对象需要被干掉"><a href="#4-1-如何判断一个对象需要被干掉" class="headerlink" title="4.1 如何判断一个对象需要被干掉"></a>4.1 如何判断一个对象需要被干掉</h2><p><img src="https://user-gold-cdn.xitu.io/2020/1/14/16fa2057cf851442?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>图中程序计数器、虚拟机栈、本地方法栈，3个区域随着线程的生存而生存的。内存分配和回收都是确定的。随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题。而Java堆和方法区则不一样，各线程共享，内存的分配和回收都是动态的。因此<strong>垃圾收集器所关注的都是堆和方法这部分内存。</strong></p>
<p>判断方法:</p>
<p>1.引用计数器计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于0时就是不会再次使用的。不过这个方法有一种情况就是<strong>出现对象的循环引用时，引用计数器永远不为0，GC没法回收。</strong></p>
<p>2.可达性分析计算：以 GC Roots 为起始点进行搜索，<strong>可达的对象都是存活的，不可达的对象可被回收。</strong></p>
<p>（了解一下即可）在Java语言汇总能作为GC Roots的对象分为以下几种：</p>
<ol>
<li>虚拟机栈（栈帧中的本地方法表）中引用的对象（局部变量）</li>
<li>方法区中静态变量所引用的对象（静态变量）</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈（即native修饰的方法）中JNI引用的对象（JNI是Java虚拟机调用对应的C函数的方式，通过JNI函数也可以创建新的Java对象。且JNI对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收）</li>
<li>已启动的且未终止的Java线程</li>
</ol>
<p>这种方法的优点是能够解决循环引用的问题，可它的实现需要耗费大量资源和时间，也需要GC（它的分析过程引用关系不能发生变化，所以需要停止所有进程）</p>
<h2 id="4-2-如何宣告一个对象的真正死亡"><a href="#4-2-如何宣告一个对象的真正死亡" class="headerlink" title="4.2 如何宣告一个对象的真正死亡"></a>4.2 如何宣告一个对象的真正死亡</h2><p>首先必须要提到的是一个名叫 <strong>finalize()</strong> 的方法</p>
<p>finalize()是Object类的一个方法、一个对象的finalize()方法只会被系统自动调用一次，经过finalize()方法逃脱死亡的对象，第二次不会再调用。</p>
<p>【不建议使用finalize方法】</p>
<p>判断一个对象的死亡至少需要两次标记</p>
<ol>
<li>如果对象进行可达性分析之后没发现与GC Roots相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行finalize()方法。如果对象有必要执行finalize()方法，则被放入F-Queue队列中。</li>
<li>GC对F-Queue队列中的对象进行二次标记。如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</li>
</ol>
<p>如果确定对象已经死亡，我们又该如何回收这些垃圾呢</p>
<h2 id="4-3-引用类型"><a href="#4-3-引用类型" class="headerlink" title="4.3 引用类型"></a>4.3 引用类型</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p>
<p>Java 提供了四种强度不同的引用类型。</p>
<h4 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1. 强引用"></a>1. 强引用</h4><p>被强引用关联的对象不会被回收。</p>
<p>使用 new 一个新对象的方式来创建强引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<h4 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2. 软引用"></a>2. 软引用</h4><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p>
<p>使用 SoftReference 类来创建软引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>

<h4 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3. 弱引用"></a>3. 弱引用</h4><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p>
<p>使用 WeakReference 类来创建弱引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4. 虚引用"></a>4. 虚引用</h4><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p>
<p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p>
<p>使用 PhantomReference 来创建虚引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj, <span class="literal">null</span>);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-垃圾回收算法"><a href="#4-4-垃圾回收算法" class="headerlink" title="4.4 垃圾回收算法"></a>4.4 垃圾回收算法</h2><h3 id="4-4-1-标记清除算法"><a href="#4-4-1-标记清除算法" class="headerlink" title="4.4.1 标记清除算法"></a>4.4.1 标记清除算法</h3><p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</p>
<p>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</p>
<p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。</p>
<p>不足：</p>
<ul>
<li>标记和清除过程效率都不高；</li>
<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/1/15/16fa593b220bd65b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>此时可使用的内存块都是零零散散的，导致了刚刚提到的大内存对象问题</p>
<h3 id="4-4-2-复制算法"><a href="#4-4-2-复制算法" class="headerlink" title="4.4.2 复制算法"></a>4.4.2 复制算法</h3><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p>主要不足是只使用了内存的一半。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/1/15/16fa599ea6f4ce56?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p>
<p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p>
<h3 id="4-4-3-标记整理算法"><a href="#4-4-3-标记整理算法" class="headerlink" title="4.4.3 标记整理算法"></a>4.4.3 标记整理算法</h3><p>复制算法在对象存活率高的时候会有一定的效率问题，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是<strong>让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存</strong></p>
<p>优点:</p>
<ul>
<li>不会产生内存碎片</li>
</ul>
<p>不足:</p>
<ul>
<li>需要移动大量对象，处理效率比较低。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/1/15/16fa59da25a1629e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="4-4-4-分代收集算法"><a href="#4-4-4-分代收集算法" class="headerlink" title="4.4.4 分代收集算法"></a>4.4.4 分代收集算法</h3><p>根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>一般将堆分为新生代和老年代。</p>
<ul>
<li>新生代使用：复制算法<ul>
<li>每次垃圾收集时都发现有大批对象死去，只有少量存活</li>
</ul>
</li>
<li>老年代使用：标记 - 清除 或者 标记 - 整理 算法<ul>
<li>因为对象存活率高、没有额外空间对它进行分配担保</li>
</ul>
</li>
</ul>
<h2 id="4-5-方法区的回收"><a href="#4-5-方法区的回收" class="headerlink" title="4.5 方法区的回收"></a>4.5 方法区的回收</h2><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p>
<p>主要是<strong>对常量池的回收和对类的卸载</strong>。</p>
<p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p>
<p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p>
<ul>
<li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li>
</ul>
<h1 id="五、内存分配和回收策略"><a href="#五、内存分配和回收策略" class="headerlink" title="五、内存分配和回收策略"></a>五、内存分配和回收策略</h1><h2 id="5-1-Minor-GC-和-Full-GC"><a href="#5-1-Minor-GC-和-Full-GC" class="headerlink" title="5.1 Minor GC 和 Full GC"></a>5.1 Minor GC 和 Full GC</h2><ul>
<li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li>
<li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li>
</ul>
<h2 id="5-2-内存分配策略"><a href="#5-2-内存分配策略" class="headerlink" title="5.2 内存分配策略"></a>5.2 内存分配策略</h2><h3 id="5-2-1-对象优先在-Eden-分配"><a href="#5-2-1-对象优先在-Eden-分配" class="headerlink" title="5.2.1 对象优先在 Eden 分配"></a>5.2.1 对象优先在 Eden 分配</h3><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p>
<h3 id="5-2-2-大对象直接进入老年代"><a href="#5-2-2-大对象直接进入老年代" class="headerlink" title="5.2.2 大对象直接进入老年代"></a>5.2.2 大对象直接进入老年代</h3><p>大对象是指<strong>需要连续内存空间的对象</strong>，最典型的大对象是那种很长的字符串以及数组。</p>
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
<p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p>
<h3 id="5-2-3-长期存活的对象进入老年代"><a href="#5-2-3-长期存活的对象进入老年代" class="headerlink" title="5.2.3 长期存活的对象进入老年代"></a>5.2.3 长期存活的对象进入老年代</h3><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p>
<h3 id="5-2-4-动态对象年龄判定"><a href="#5-2-4-动态对象年龄判定" class="headerlink" title="5.2.4 动态对象年龄判定"></a>5.2.4 动态对象年龄判定</h3><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<h3 id="5-2-5-空间分配担保"><a href="#5-2-5-空间分配担保" class="headerlink" title="5.2.5 空间分配担保"></a>5.2.5 空间分配担保</h3><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p>
<p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p>
<h2 id="5-3-Full-GC-的触发条件"><a href="#5-3-Full-GC-的触发条件" class="headerlink" title="5.3 Full GC 的触发条件"></a>5.3 Full GC 的触发条件</h2><p>对于 Minor GC，其触发条件非常简单，<strong>当 Eden 空间满时，就将触发一次 Minor GC。</strong>而 Full GC 则相对复杂，有以下条件：</p>
<h4 id="1-调用-System-gc"><a href="#1-调用-System-gc" class="headerlink" title="1. 调用 System.gc()"></a>1. 调用 System.gc()</h4><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<h4 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2. 老年代空间不足"></a>2. 老年代空间不足</h4><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
<h4 id="3-空间分配担保失败"><a href="#3-空间分配担保失败" class="headerlink" title="3. 空间分配担保失败"></a>3. 空间分配担保失败</h4><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。</p>
<h4 id="4-JDK-1-7-及以前的永久代空间不足"><a href="#4-JDK-1-7-及以前的永久代空间不足" class="headerlink" title="4. JDK 1.7 及以前的永久代空间不足"></a>4. JDK 1.7 及以前的永久代空间不足</h4><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
<h4 id="5-Concurrent-Mode-Failure"><a href="#5-Concurrent-Mode-Failure" class="headerlink" title="5. Concurrent Mode Failure"></a>5. Concurrent Mode Failure</h4><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">数据库-数据库系统原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-04 15:31:18 / 修改时间：08:34:50" itemprop="dateCreated datePublished" datetime="2021-03-04T15:31:18Z">2021-03-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-1-相关概念"><a href="#1-1-相关概念" class="headerlink" title="1.1 相关概念"></a>1.1 相关概念</h2><ol>
<li><p>DBMS：数据库管理系统，是位于用户与操作系统之间的一层数据管理软件，用于科学地组织、存储和管理数据、高效地获取和维护数据。</p>
</li>
<li><p>DBS：数据库系统，指在计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、应用系统、数据库管理员（DBA）构成。</p>
</li>
<li><p>数据模型：是用来抽象、表示和处理现实世界中的数据和信息的工具，是对现实世界的模拟，是数据库系统的核心和基础；其组成元素有数<strong>据结构、数据操作和完整性约束</strong>。</p>
</li>
<li><p>概念模型：也称信息模型，是按用户的观点来对数据和信息建模，主要用于数据库设计。</p>
</li>
<li><p>逻辑模型：是按计算机系统的观点对数据建模，用于DBMS实现。</p>
</li>
<li><p>物理模型：是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的。</p>
</li>
<li><p>实体和属性：客观存在并可相互区别的事物称为实体。实体所具有的某一特性称为属性。</p>
</li>
<li><p>E-R图：即实体-关系图，用于描述现实世界的事物及其相互关系，是数据库概念模型设计的主要工具。</p>
</li>
<li><p>关系模式：从用户观点看，关系模式是由一组关系组成，每个关系的数据结构是一张规范化的二维表。</p>
</li>
<li><p>型&#x2F;值：型是对某一类数据的结构和属性的说明；值是型的一个具体赋值，是型的实例。</p>
</li>
<li><p>数据库模式：是对数据库中全体数据的逻辑结构（数据项的名字、类型、取值范围等）和特征（数据之间的联系以及数据有关的安全性、完整性要求）的描述。</p>
</li>
<li><p>数据库的三级系统结构：外模式、模式和内模式。</p>
</li>
<li><p>数据库内模式：又称为存储模式，是对数据库物理结构和存储方式的描述，是数据在数据库内部的表示方式。一个数据库<strong>只有一个</strong>内模式。</p>
</li>
<li><p>数据库外模式：又称为子模式或用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图。通常是模式的子集。一个数据库<strong>可有多个外模式</strong>。</p>
</li>
<li><p>数据库的二级映像：外模式&#x2F;模式映像、模式&#x2F;内模式映像。</p>
<ul>
<li>外模式&#x2F;模式映像：同一个模式下可以有任意多个外模式。【逻辑独立性】</li>
<li>模式&#x2F;内模式映像：唯一的【储存结构】</li>
</ul>
</li>
<li><p>候选码（Candidate Key）：关系中的一个属性组，其值能唯一标识一个元组</p>
</li>
<li><p>主键： 能够唯一地标识一个元组的属性或属性组称为关系的键或候选键。 若一个关系有多个候选键则可选其一作为主键(Primary key)。</p>
</li>
<li><p>外键：如果一个关系的一个或一组属性引用(参照)了另一个关系的主键，则称这个或这组属性为外码或外键(Foreign key)。</p>
</li>
<li><p>关系数据库：依照关系模型建立的数据库称为关系数据库。 它是在某个应用领域的所有关系的集合。</p>
</li>
<li><p>关系模式： 简单地说，关系模式就是对关系的型的定义， 包括关系的属性构成、各属性的数据类型、 属性间的依赖、 元组语义及完整性约束等。 记作R(A<del>1</del> , A<del>2</del> ,…, A<del>n</del> ) 。<br>关系是关系模式在某一时刻的状态或内容， 关系模型是型， 关系是值， 关系模型是静态的、 稳定的， 而关系是动态的、随时间不断变化的，因为关系操作在不断地更新着数据库中的数据。</p>
<ul>
<li><p>五元组形式化表示为：R（U，D，DOM，F），其中</p>
<p>​      R —— 关系名</p>
<p>​      U —— 组成该关系的属性名集合</p>
<p>​      D —— 属性组 U 中属性所来自的域</p>
<p>​      DOM —— 属性向域的映象集合</p>
<p>​      F —— 属性间的数据依赖关系集合</p>
</li>
</ul>
</li>
<li><p>实体完整性：用于标识实体的<strong>唯一性</strong>。它要求基本关系必须要有一个能够标识元组唯一性的主键，<strong>主键不能为空，也不可取重复值</strong>。</p>
</li>
<li><p>参照完整性： 用于维护实体之间的引用关系。 它要求一个关系的外键要么为空， 要么取与被参照关系对应的主键值，即外键值必须是主键中已存在的值。<br>意义：如果关系R<del>2</del>的某个元组t<del>2</del>参照了关系R<del>1</del>的某个元组t<del>1</del>，则t<del>1</del>必须存在</p>
</li>
<li><p>用户定义的完整性：就是针对某一具体应用的数据必须满足的语义约束。包括非空、 唯一和布尔条件约束三种情况。</p>
</li>
</ol>
<h2 id="1-2-笛卡尔积"><a href="#1-2-笛卡尔积" class="headerlink" title="1.2 笛卡尔积"></a>1.2 笛卡尔积</h2><h1 id="二、事务"><a href="#二、事务" class="headerlink" title="二、事务"></a>二、事务</h1><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<h2 id="2-1-四大特性——ACID"><a href="#2-1-四大特性——ACID" class="headerlink" title="2.1 四大特性——ACID"></a>2.1 四大特性——ACID</h2><h4 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1. 原子性（Atomicity）"></a>1. 原子性（Atomicity）</h4><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>
<p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
<h4 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2. 一致性（Consistency）"></a>2. 一致性（Consistency）</h4><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p>
<h4 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3. 隔离性（Isolation）"></a>3. 隔离性（Isolation）</h4><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>
<h4 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4. 持久性（Durability）"></a>4. 持久性（Durability）</h4><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>
<p>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p>
<p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对系统崩溃的情况。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207210437023.png"/> </div><br>

<h3 id="AUTOCOMMIT"><a href="#AUTOCOMMIT" class="headerlink" title="AUTOCOMMIT"></a>AUTOCOMMIT</h3><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/03/02/java-%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/02/java-%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">java-容器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-02 14:30:19" itemprop="dateCreated datePublished" datetime="2021-03-02T14:30:19Z">2021-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-06 11:55:44" itemprop="dateModified" datetime="2021-03-06T11:55:44Z">2021-03-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、集合介绍"><a href="#一、集合介绍" class="headerlink" title="一、集合介绍"></a>一、集合介绍</h1><p>Java的集合类</p>
<p>　　集合类主要负责保存、盛装和管理对象，因此集合类也被称为容器类。</p>
<p>　　集合类分为Set、List、Map和Queue四大体系。</p>
<ul>
<li>Set 代表无序、不可重复集合；</li>
<li>List 代表有序、可重复集合；</li>
<li>Map 代表具有映射关系元素的集合；</li>
<li>Queue 代表队列，实现元素的先进先出管理。</li>
</ul>
<p>　　数组也是一种集合类，它是能随机存储和访问引用序列的诸多方法中最高效的一种，当追求高效的数据访问时，数组是很不错的选择。</p>
<p>所有集合类都位于java.util包中，集合中只能保存对象的引用。<strong>集合类把它所含有的元素看成是Object的实例</strong>，这样方便但是也有隐患，即多个类型不同的元素被放入一个集合中，会增加集合访问时类型转换的困难，甚至会产生错误。</p>
<p>　　泛型的引入改善了这种情况，使用泛型来限制集合里元素的类型，并让集合记住元素的类型。这样可以允许编译器检查加入集合的元素类型，避免值类型不一致的错误。</p>
<h1 id="二、集合概述"><a href="#二、集合概述" class="headerlink" title="二、集合概述"></a>二、集合概述</h1><p>Java的集合类主要由两个接口派生而出——Collection和Map，它们是Java集合框架的根接口。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208220948084.png"/> </div><br>

<p>Collection接口存储一组不唯一（可以重复），无序的对象</p>
<p><img src="https://i.loli.net/2021/03/05/ojb6kgSeCnhmw1F.png" alt="img"></p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20201101234335837.png"/> </div><br>

<p>　标准集合类实现了Collection接口，其中一些是抽象类，实现部分接口，其它是具体类，可以直接在代码中使用。</p>
<h2 id="2-1-Set"><a href="#2-1-Set" class="headerlink" title="2.1 Set"></a>2.1 Set</h2><ul>
<li><p>TreeSet：（有序，唯一）： 红黑树(自平衡的排序二叉树)。HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</p>
</li>
<li><p>HashSet：无序，唯一）: 基于 <code>HashMap</code> 实现的，底层采用<code>HashMap</code> 来保存元素。</p>
</li>
<li><p>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。</p>
</li>
</ul>
<h2 id="2-2-List"><a href="#2-2-List" class="headerlink" title="2.2 List"></a>2.2 List</h2><ul>
<li><p>ArrayList：基于动态数组实现，支持随机访问。</p>
</li>
<li><p>Vector：和 ArrayList 类似，但它是线程安全的。</p>
<ul>
<li><p>1.<strong>Stack栈是继承了Vector类，所以底层还是数组</strong>。</p>
<p>2.Stack栈是将底层的数组的最后一个元素当做栈顶。第一个元素当做栈底。</p>
</li>
</ul>
</li>
<li><p>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p>
</li>
</ul>
<h2 id="2-3-Queue"><a href="#2-3-Queue" class="headerlink" title="2.3 Queue"></a>2.3 Queue</h2><ul>
<li>LinkedList：可以用它来实现双向队列。</li>
<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li>
</ul>
<h2 id="2-4-Map"><a href="#2-4-Map" class="headerlink" title="2.4 Map"></a>2.4 Map</h2><ul>
<li>TreeMap：基于红黑树实现。</li>
<li>HashMap：DK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li>key不可重复</li>
<li>HashTable： 数组+链表组成的，数组是HashTable的主体，链表则是主要为了解决哈希冲突而存在的。<br>线程安全，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li>
<li>LinkedHashMap：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。详细可以查看：<a target="_blank" rel="noopener" href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li>
</ul>
<h2 id="2-5-如何选用集合"><a href="#2-5-如何选用集合" class="headerlink" title="2.5 如何选用集合"></a>2.5 如何选用集合</h2><p>需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合：</p>
<ul>
<li>需要排序时选择 <code>TreeMap</code></li>
<li>不需要排序时就选择 <code>HashMap</code></li>
<li>需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</li>
</ul>
<p>只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合：</p>
<ul>
<li>需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code></li>
<li>不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code></li>
</ul>
<h2 id="2-6-为什么需要使用集合？"><a href="#2-6-为什么需要使用集合？" class="headerlink" title="2.6 为什么需要使用集合？"></a>2.6 为什么需要使用集合？</h2><p>数组存储的数据是有序的、可重复的，特点单一。 但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。</p>
<h1 id="三、Collection的子接口——List"><a href="#三、Collection的子接口——List" class="headerlink" title="三、Collection的子接口——List"></a>三、Collection的子接口——List</h1><h2 id="3-1-ArrayList和Vector的区别"><a href="#3-1-ArrayList和Vector的区别" class="headerlink" title="3.1 ArrayList和Vector的区别"></a>3.1 ArrayList和Vector的区别</h2><ul>
<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li>
<li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code> Object[ ]</code> 存储，线程安全的。</li>
</ul>
<h2 id="3-2-ArrayList和LinkedList的区别"><a href="#3-2-ArrayList和LinkedList的区别" class="headerlink" title="3.2 ArrayList和LinkedList的区别"></a>3.2 ArrayList和LinkedList的区别</h2><ol>
<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>
<li><strong>插入和删除是否受元素位置的影响：</strong><ol>
<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</li>
<li><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</li>
</ol>
</li>
<li><strong>是否支持快速随机访问：</strong> <ol>
<li><code>LinkedList</code> 不支持高效的随机元素访问</li>
<li><code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
</ol>
</li>
<li><strong>内存空间占用：</strong> ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ol>
<h2 id="3-3-ArrayList的扩容机制（重点）"><a href="#3-3-ArrayList的扩容机制（重点）" class="headerlink" title="3.3 ArrayList的扩容机制（重点）"></a>3.3 ArrayList的扩容机制（重点）</h2><ol>
<li>初始化的默认容量是10；</li>
<li>当添加元素的时候，add（）方法会调用ensureCapacityInternal（size+1）方法，用来进行容量检查，决定扩容的想要的最小容量。</li>
<li>当需要扩容的时候，会调用grow（）方法。<br><strong>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> </li>
<li><strong>真正的实现扩容其实是Arrays.copy方法，就是复制数组实现扩容</strong></li>
</ol>
<h1 id="四、Collection的子接口Set"><a href="#四、Collection的子接口Set" class="headerlink" title="四、Collection的子接口Set"></a>四、Collection的子接口Set</h1><h2 id="4-1-comparable-和-Comparator-的区别"><a href="#4-1-comparable-和-Comparator-的区别" class="headerlink" title="4.1 comparable 和 Comparator 的区别"></a>4.1 comparable 和 Comparator 的区别</h2><ul>
<li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>comparator</code>接口实际上是出自 java.util包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<h2 id="4-2-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#4-2-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="4.2 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>4.2 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><p><code>HashSet</code> 是 <code>Set</code> 接口的主要实现类 ，<code>HashSet</code> 的底层是 <code>HashMap</code>，线程不安全的，可以存储 null 值；</p>
<p><code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，能够按照添加的顺序遍历；</p>
<p><code>TreeSet</code> 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</p>
<h1 id="五、Map接口"><a href="#五、Map接口" class="headerlink" title="五、Map接口"></a>五、Map接口</h1><h2 id="5-1-HashMap-和-Hashtable-的区别"><a href="#5-1-HashMap-和-Hashtable-的区别" class="headerlink" title="5.1 HashMap 和 Hashtable 的区别"></a>5.1 HashMap 和 Hashtable 的区别</h2><ol>
<li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>HashTable</code> 是线程安全的,因为 <code>HashTable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>HashTable</code> 效率高一点。另外，<code>HashTable</code> 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
<h2 id="5-2-HashMap-和-HashSet-区别"><a href="#5-2-HashMap-和-HashSet-区别" class="headerlink" title="5.2 HashMap 和 HashSet 区别"></a>5.2 HashMap 和 HashSet 区别</h2><p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。</p>
<table>
<thead>
<tr>
<th align="center"><code>HashMap</code></th>
<th align="center"><code>HashSet</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现了 <code>Map</code> 接口</td>
<td align="center">实现 <code>Set</code> 接口</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储对象</td>
</tr>
<tr>
<td align="center">调用 <code>put()</code>向 map 中添加元素</td>
<td align="center">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td>
</tr>
<tr>
<td align="center"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td>
<td align="center"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code> equals()</code>方法用来判断对象的相等性</td>
</tr>
</tbody></table>
<h2 id="5-3-HashMap-和-TreeMap-区别"><a href="#5-3-HashMap-和-TreeMap-区别" class="headerlink" title="5.3 HashMap 和 TreeMap 区别"></a>5.3 HashMap 和 TreeMap 区别</h2><p>相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</p>
<h2 id="5-4-HashSet-如何检查重复"><a href="#5-4-HashSet-如何检查重复" class="headerlink" title="5.4 HashSet 如何检查重复"></a>5.4 HashSet 如何检查重复</h2><p>先看hashcode；再用equals（）</p>
<p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
<p><strong><code>hashCode()</code>与 <code>equals()</code> 的相关规定：</strong></p>
<ol>
<li>如果两个对象相等，则 <code>hashcode</code> 一定也是相同的</li>
<li>两个对象相等,对两个 <code>equals()</code> 方法返回 true</li>
<li>两个对象有相同的 <code>hashcode</code> 值，它们也不一定是相等的</li>
<li>综上，<code>equals()</code> 方法被覆盖过，则 <code>hashCode()</code> 方法也必须被覆盖</li>
<li><code>hashCode() </code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>
</ol>
<h2 id="5-5-HashMap-多线程操作导致死循环问题"><a href="#5-5-HashMap-多线程操作导致死循环问题" class="headerlink" title="5.5 HashMap 多线程操作导致死循环问题"></a>5.5 HashMap 多线程操作导致死循环问题</h2><p>主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p>
<h2 id="5-6-HashMap-有哪几种常见的遍历方式"><a href="#5-6-HashMap-有哪几种常见的遍历方式" class="headerlink" title="5.6 HashMap 有哪几种常见的遍历方式?"></a>5.6 HashMap 有哪几种常见的遍历方式?</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow">HashMap 的 7 种遍历方式与性能分析！</a></p>
<p>HashMap <strong>遍历从大的方向来说，可分为以下 4 类</strong>：</p>
<ol>
<li>迭代器（Iterator）方式遍历；</li>
<li>For Each 方式遍历；</li>
<li>Lambda 表达式遍历（JDK 1.8+）;</li>
<li>Streams API 遍历（JDK 1.8+）。</li>
</ol>
<h2 id="5-7-ConcurrentHashMap-和-Hashtable-的区别"><a href="#5-7-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="5.7 ConcurrentHashMap 和 Hashtable 的区别"></a>5.7 ConcurrentHashMap 和 Hashtable 的区别</h2><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表&#x2F;红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
<p><strong>两者的对比图：</strong></p>
<p><strong>HashTable:</strong></p>
<p><img src="https://i.loli.net/2021/03/05/aEFBtdkMfr6m5Aw.png" alt="HashTable全表锁"></p>
<p style="text-align:right;font-size:13px;color:gray">http://www.cnblogs.com/chengxiao/p/6842045.html></p>

<p><strong>JDK1.7 的 ConcurrentHashMap：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ConcurrentHashMap%E5%88%86%E6%AE%B5%E9%94%81.jpg" alt="JDK1.7的ConcurrentHashMap"></p>
<p style="text-align:right;font-size:13px;color:gray">http://www.cnblogs.com/chengxiao/p/6842045.html></p>

<p><strong>JDK1.8 的 ConcurrentHashMap：</strong></p>
<p><img src="https://i.loli.net/2021/03/05/bEcBXCiyvxn9Qw4.png" alt="Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）"></p>
<p>JDK1.8 的 <code>ConcurrentHashMap</code> 不在是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 &#x2F; 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 **<code>TreeNode</code>**。当冲突链表达到一定长度时，链表会转换成红黑树。</p>
<h2 id="5-8-ConcurrentHashMap-线程安全的具体实现方式-x2F-底层具体实现"><a href="#5-8-ConcurrentHashMap-线程安全的具体实现方式-x2F-底层具体实现" class="headerlink" title="5.8 ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现"></a>5.8 ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</h2><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p>
<p>Segment 实现了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。</p>
<h3 id="JDK1-8-（上面有示意图）"><a href="#JDK1-8-（上面有示意图）" class="headerlink" title="JDK1.8 （上面有示意图）"></a>JDK1.8 （上面有示意图）</h3><p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 CAS 和 <code>synchronized</code> 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表&#x2F;红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）</p>
<p><code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>
<h1 id="六、Collections-工具类"><a href="#六、Collections-工具类" class="headerlink" title="六、Collections 工具类"></a>六、Collections 工具类</h1><p>Collections 工具类常用方法:</p>
<ol>
<li>排序</li>
<li>查找,替换操作</li>
<li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li>
</ol>
<h2 id="6-1-排序"><a href="#6-1-排序" class="headerlink" title="6.1 排序"></a>6.1 排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(List list, <span class="type">int</span> i , <span class="type">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(List list, <span class="type">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span></span><br></pre></td></tr></table></figure>

<h2 id="6-2-查找-替换操作"><a href="#6-2-查找-替换操作" class="headerlink" title="6.2 查找,替换操作"></a>6.2 查找,替换操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span>, 用新元素替换旧元素</span><br></pre></td></tr></table></figure>

<h2 id="6-3-同步控制"><a href="#6-3-同步控制" class="headerlink" title="6.3 同步控制"></a>6.3 同步控制</h2><p><code>Collections</code> 提供了多个<code>synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p>
<p>我们知道 <code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>,<code>LinkedList</code>,<code>HashMap</code>,<code>TreeMap</code> 都是线程不安全的。<code>Collections</code> 提供了多个静态方法可以把他们包装成线程同步的集合。</p>
<p><strong>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。</strong></p>
<p>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt;  c) <span class="comment">//返回指定 collection 支持的同步（线程安全的）collection。</span></span><br><span class="line">synchronizedList(List&lt;T&gt; list)<span class="comment">//返回指定列表支持的同步（线程安全的）List。</span></span><br><span class="line">synchronizedMap(Map&lt;K,V&gt; m) <span class="comment">//返回由指定映射支持的同步（线程安全的）Map。</span></span><br><span class="line">synchronizedSet(Set&lt;T&gt; s) <span class="comment">//返回指定 set 支持的同步（线程安全的）set。</span></span><br></pre></td></tr></table></figure>

<h1 id="七、容器中的设计模式"><a href="#七、容器中的设计模式" class="headerlink" title="七、容器中的设计模式"></a>七、容器中的设计模式</h1><h2 id="7-1-迭代器模式"><a href="#7-1-迭代器模式" class="headerlink" title="7.1 迭代器模式"></a>7.1 迭代器模式</h2><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208225301973.png"/> </div><br>

<p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p>
<p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-适配器模式"><a href="#7-2-适配器模式" class="headerlink" title="7.2 适配器模式"></a>7.2 适配器模式</h2><p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span></span><br></pre></td></tr></table></figure>

<p>应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(arr);</span><br></pre></td></tr></table></figure>

<p>也可以使用以下方式调用 asList()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/02/11/Algorithm-%E5%89%8D%E7%BC%80%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/11/Algorithm-%E5%89%8D%E7%BC%80%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/" class="post-title-link" itemprop="url">Algorithm__前缀和哈希表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-10 22:23:19 / 修改时间：14:23:20" itemprop="dateCreated datePublished" datetime="2021-02-10T22:23:19Z">2021-02-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/02/11/Algorithm-%E5%B9%B6%E6%9F%A5%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/11/Algorithm-%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="post-title-link" itemprop="url">Algorithm__并查集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-10 21:56:17 / 修改时间：13:56:18" itemprop="dateCreated datePublished" datetime="2021-02-10T21:56:17Z">2021-02-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rhb</p>
  <div class="site-description" itemprop="description">纵浪大化中，不喜亦不惧</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">126</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RShawshank" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RShawshank" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rhb</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://lib.baomitu.com/canvas-nest.js/1.0.1/canvas-nest.js"></script>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
