<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rshawshank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="纵浪大化中，不喜亦不惧">
<meta property="og:type" content="website">
<meta property="og:title" content="rhb_blog">
<meta property="og:url" content="http://rshawshank.github.io/page/13/index.html">
<meta property="og:site_name" content="rhb_blog">
<meta property="og:description" content="纵浪大化中，不喜亦不惧">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rhb">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rshawshank.github.io/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>rhb_blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rhb_blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">rao的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">63</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">27</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">154</span></a>

  </li>
        <li class="menu-item menu-item-photos">

    <a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
        <li class="menu-item menu-item-readnote">

    <a href="/readnote" rel="section"><i class="fa fa-book fa-fw"></i>阅读笔记</a>

  </li>
        <li class="menu-item menu-item-somethink">

    <a href="/somethink/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>随笔闲谈</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/RShawshank" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/01/13/android_Activity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/13/android_Activity/" class="post-title-link" itemprop="url">Activity</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-13 11:15:15" itemprop="dateCreated datePublished" datetime="2020-01-13T11:15:15Z">2020-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Activity概述"><a href="#Activity概述" class="headerlink" title="Activity概述"></a>Activity概述</h1><p>活动代表了一个具有用户界面的单一屏幕，如 Java 的窗口或者帧。Android 的活动是 ContextThemeWrapper 类的子类。<br>它是一种可以包含用户界面组件，主要用于和用户进行交互。</p>
<h2 id="AndroidManifest文件"><a href="#AndroidManifest文件" class="headerlink" title="AndroidManifest文件"></a>AndroidManifest文件</h2><p>AndroidManifest.xml 是每个android程序中必须的文件。它位于整个项目的根目录，描述了package中暴露的组件（activities, services, 等等），他们各自的实现类，各种能被处理的数据和启动位置。 除了能声明程序中的Activities, ContentProviders, Services, 和Intent Receivers,还能指定permissions和instrumentation（安全控制和测试）</p>
<h2 id="活动与任务"><a href="#活动与任务" class="headerlink" title="活动与任务"></a>活动与任务</h2><p>Android将这些活动保持在同一个任务（task）中以维持用户的体验。简单地讲，任务是用户体验上的一个“应用程序”，是排成堆栈的一组相关活动。栈底的活动（根活动）是起始活动——一般来讲，它是用户在应用程序启动器（也称应用程序列表，下同）中选择的一个活动。栈顶的活动是正在运行的活动——它关注用户的行为（操作）。当一个活动启动另一个，新的活动被压入栈顶，变为正在运行的活动。前面那个活动保存在栈中。当用户点击返回按钮时，当前活动从栈顶中弹出，且前面那个活动恢复成为正在运行的活动。</p>
<p>一个任务的所有活动作为一个整体运行。整个任务（整个活动栈）可置于前台或发送到后台。例如，假设当前任务有四个活动在栈中——三个活动在当前活动下面。用户按下HOME键，切换到程序启动器，并选择一个新的应用程序（实际上是一个新的任务）。当前任务进入后台，新任务的根活动将显示。接着，过了一会，用户回到主屏幕并再次选择之前的应用程序（之前的任务）。那个任务栈中的所有四个活动都变为前台运行。当用户按下返回键时，不是离开当前任务回到之前任务的根活动。相反，栈顶的活动被移除且栈中的下一个活动将显示。</p>
<p>上面所描述的是活动和任务的默认行为，但是有方法来改变所有这些行为。活动与任务之间的联系及任务中活动的行为，是由启动活动的Intent对象的标志（flags）和清单文件中活动<activity>元素的属性共同决定的。</p>
<h2 id="菜单menu"><a href="#菜单menu" class="headerlink" title="菜单menu"></a>菜单menu</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/HDK2016/p/8038908.html">https://www.cnblogs.com/HDK2016/p/8038908.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/aiynmimi/article/details/54964945">https://blog.csdn.net/aiynmimi/article/details/54964945</a></p>
<h3 id="菜单的分类"><a href="#菜单的分类" class="headerlink" title="菜单的分类"></a>菜单的分类</h3><p>菜单是Android应用中非常重要且常见的组成部分，主要可以分为三类：选项菜单、上下文菜单&#x2F;上下文操作模式以及弹出菜单。它们的主要区别如下：</p>
<ul>
<li><p>选项菜单是一个应用的主菜单项，用于放置对应用产生全局影响的操作，如搜索&#x2F;设置。</p>
</li>
<li><p>上下文菜单是用户长按某一元素时出现的浮动菜单。它提供的操作将影响所选内容，主要应用于列表中的每一项元素（如长按列表项弹出删除对话框）。上下文操作模式将在屏幕顶部栏（菜单栏）显示影响所选内容的操作选项，并允许用户选择多项，一般用于对列表类型的数据进行批量操作。</p>
</li>
<li><p>弹出菜单以垂直列表形式显示一系列操作选项，一般由某一控件触发，弹出菜单将显示在对应控件的上方或下方。它适用于提供与特定内容相关的大量操作。</p>
</li>
</ul>
<h3 id="选项菜单"><a href="#选项菜单" class="headerlink" title="选项菜单"></a>选项菜单</h3><p>当用户单击设备上的菜单按钮（Menu），触发事件弹出的菜单就是选项菜单。</p>
<h4 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h4><p><img src="/images/Activity/1070689-20171214171311342-1238515765.png"></p>
<p><img src="/images/Activity/1070689-20171214171318951-320255124.png"></p>
<h4 id="实现过程讲解："><a href="#实现过程讲解：" class="headerlink" title="实现过程讲解："></a>实现过程讲解：</h4><p>在Activity中重写<code>onCreateOptionsMenu()</code>来创建选项菜单，在中包含了<code>getMenuInflater().inflate(R.menu.main,menu)</code>，R.menu.main是res的menu文件夹下的xml文件是放菜单的文件夹；</p>
<h4 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h4><p>设置菜单项可以通过两种方法</p>
<p><strong>1.通过在XML文件中添加控件来实现</strong></p>
<p>在R.menu.main的xml文件中，添加item控件来添加设置菜单项;</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;com.jiapeng.munedemo.MainActivity&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/mune_enter&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orderInCategory</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;登录&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">&quot;never&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/mune_setting&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orderInCategory</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;设置&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">&quot;never&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/mune_out&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orderInCategory</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;退出&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">&quot;never&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中：<code>showAsAction</code>主要是针对这个菜单的显示起作用的，它有三个可选项<br>always：总是显示在界面上<br>never：不显示在界面上，只让出现在右边的三个点中<br>ifRoom：如果有位置才显示，不然就出现在右边的三个点中</p>
<p><strong>java代码和设置监听：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> &#123;</span><br><span class="line">    <span class="comment">//导入菜单布局</span></span><br><span class="line">    getMenuInflater().inflate(R.menu.main, menu);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> &#123;</span><br><span class="line">    <span class="comment">//创建菜单项的点击事件</span></span><br><span class="line">    <span class="keyword">switch</span> (item.getItemId()) &#123;</span><br><span class="line">    <span class="keyword">case</span> R.id.mune_enter:</span><br><span class="line">        Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;点击了登陆&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R.id.mune_setting:</span><br><span class="line">        Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;点击了设置&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R.id.mune_out:</span><br><span class="line">        Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;点击了退出&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.onOptionsItemSelected(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<strong>通过动态代码实现</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">menu</span><span class="selector-class">.add</span>(groupId,itemId,<span class="attribute">order</span>,title),</span><br><span class="line"></span><br><span class="line">groupId--<span class="number">1</span>:分组的id;</span><br><span class="line">itemId--<span class="number">100</span>:菜单项的id;</span><br><span class="line"><span class="attribute">order</span>--<span class="number">1</span>:菜单项排序用的;</span><br><span class="line">title--&quot;菜单<span class="number">1</span>&quot;:菜单名称;</span><br></pre></td></tr></table></figure>

<p>menu的用法类似于ArrayList,可以调用add方法来加载如<br>&#x2F;&#x2F;API大于等于11 时 Item图标不显示<br>menu.add(1,100,1,”菜单一”);<br>menu.add(1,101,1,”菜单二”);<br>menu.add(1,102,1,”菜单三”);<br>add方法返回的是item，可以赋值给item，再调用item的setTitle与setIcon（在API&gt;&#x3D;11时，是不显示图标的）来设置item。</p>
<p><strong>代码如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> &#123;</span><br><span class="line">        <span class="comment">// groupId--1:分组的id;itemId--100:菜单项的id;order--1:菜单项排序用的;title--&quot;菜单1&quot;:菜单名称;</span></span><br><span class="line">        <span class="type">MenuItem</span> <span class="variable">item</span> <span class="operator">=</span> menu.add(<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="string">&quot;菜单项&quot;</span>);</span><br><span class="line">        item.setTitle(<span class="string">&quot;我是一个菜单&quot;</span>);</span><br><span class="line">        <span class="comment">// 在API&gt;=11时，是不显示图标的</span></span><br><span class="line">        item.setIcon(R.drawable.ic_launcher);</span><br><span class="line">        menu.add(<span class="number">1</span>, <span class="number">101</span>, <span class="number">1</span>, <span class="string">&quot;登录&quot;</span>);</span><br><span class="line">        menu.add(<span class="number">1</span>, <span class="number">102</span>, <span class="number">1</span>, <span class="string">&quot;设置&quot;</span>);</span><br><span class="line">        menu.add(<span class="number">1</span>, <span class="number">103</span>, <span class="number">1</span>, <span class="string">&quot;退出&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建菜单项的点击事件</span></span><br><span class="line">        <span class="keyword">switch</span> (item.getItemId()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">101</span>:</span><br><span class="line">            Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;你点击了登录&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">102</span>:</span><br><span class="line">            Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;你点击了设置&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">103</span>:</span><br><span class="line">            Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;你点击了退出&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onOptionsItemSelected(item);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="上下文菜单（context-menu）"><a href="#上下文菜单（context-menu）" class="headerlink" title="上下文菜单（context menu）"></a>上下文菜单（context menu）</h3><p>当用户长按Activity页面时，弹出的菜单我们称为上下文菜单。我们经常在Windows中用鼠标右键单击弹出的菜单就是上下文菜单。</p>
<p>ContextMenu与OptionMenu的区别：<br>1、<code>OptionMenu</code>对应的是<code>activity</code>，一个activity只能拥有一个选项菜单；<br>2、<code>ContextMenu</code>对应的是<code>view</code>，每个view都可以设置上下文菜单；<br>3、一般情况下ContextMenu常用语ListView或者GridView</p>
<h4 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h4><p>（1）首先给View注册上下文菜单<code>registerForContextMenu()</code><br><code>this.registerForContextMenu(contextView);</code><br>（2）添加上下文菜单的内容<code>onCreateContextMenu()</code></p>
<p><strong>效果图：</strong></p>
<p><img src="/images/Activity/1070689-20171214172243263-372940928.png" alt="img"></p>
<p><img src="/images/Activity/1070689-20171214172250357-1874018666.png" alt="img"></p>
<p><img src="/images/Activity/1070689-20171214172256295-322673058.png" alt="img"></p>
<p><strong>代码</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/container&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;com.jiapeng.munedemo.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:ignore</span>=<span class="string">&quot;MergeRootFrame&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ListView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/mune_list&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ListView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      setContentView(R.layout.activity_main);</span><br><span class="line">      showListView();</span><br><span class="line">      <span class="comment">// 注册上下文菜单</span></span><br><span class="line">      <span class="built_in">this</span>.registerForContextMenu(listview);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 加载数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showListView</span><span class="params">()</span> &#123;</span><br><span class="line">      listview = (ListView) findViewById(R.id.mune_list);</span><br><span class="line">      ArrayAdapter&lt;String&gt; adapter = <span class="keyword">new</span> <span class="title class_">ArrayAdapter</span>&lt;String&gt;(<span class="built_in">this</span>,</span><br><span class="line">              android.R.layout.simple_list_item_1, getDate());</span><br><span class="line">      listview.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建数据源</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> list</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;String&gt; <span class="title function_">getDate</span><span class="params">()</span> &#123;</span><br><span class="line">      ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">          list.add(<span class="string">&quot;菜单&quot;</span> + i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加上下文菜单的菜单项</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreateContextMenu</span><span class="params">(ContextMenu menu, View v,</span></span><br><span class="line"><span class="params">          ContextMenuInfo menuInfo)</span> &#123;</span><br><span class="line">      menu.setHeaderTitle(<span class="string">&quot;上下文菜单&quot;</span>);</span><br><span class="line">      menu.setHeaderIcon(R.drawable.ic_launcher);</span><br><span class="line">      <span class="comment">//加载上下文菜单内容</span></span><br><span class="line">      menu.add(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;保存&quot;</span>);</span><br><span class="line">      menu.add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;更改&quot;</span>);</span><br><span class="line">      menu.add(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;删除&quot;</span>);</span><br><span class="line">      <span class="built_in">super</span>.onCreateContextMenu(menu, v, menuInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建单击事件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onContextItemSelected</span><span class="params">(MenuItem item)</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> (item.getItemId()) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">          Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;点击了保存&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">          Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;点击了更改&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">          Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;点击了删除&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.onContextItemSelected(item);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>注：何为上下文菜单：Windows操作系统中任何地方右击鼠标会出现俗称的“右键菜单”，其实就是指上下文菜单。因为上下文菜单根据鼠标位置来判断弹出什么的菜单（如桌面右击显示个性化菜单，文件右击则显示针对文件操作删除等的菜单）也就是根据上下文来判断如何弹出和弹出哪种菜单，所以称为上下文菜单。手机上就是长按会弹出选项</p>
<h3 id="子菜单（Sub-Menu）"><a href="#子菜单（Sub-Menu）" class="headerlink" title="子菜单（Sub Menu）"></a>子菜单（Sub Menu）</h3><p>就是将功能相同的操作分组显示，他作用在OptionsMenu上，是OptionsMenu的二级菜单</p>
<h4 id="实现步骤：-1"><a href="#实现步骤：-1" class="headerlink" title="实现步骤："></a>实现步骤：</h4><p>（1）重写<code>onCreateOptionsMenu()</code>方法<br>（2）点击事件，重写<code>onOptionsItemSelected()</code>方法</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>（1）<code>SubMenu.add(groupId, itemId, order, title);</code><br>因为每个SubMenu有一个groupId，所以需要使用这个groupId区别是点击了那个子菜单<br>（2）APP的样式会影响子菜单的显示风格</p>
<p><strong>效果图</strong>：</p>
<p><img src="/images/Activity/1070689-20171214172703092-915673361.png" alt="img"></p>
<p><img src="/images/Activity/1070689-20171214172717857-532792389.png" alt="img"></p>
<p><img src="/images/Activity/1070689-20171214172726326-2106934821.png" alt="img"></p>
<p><strong>代码</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/container&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;com.jiapeng.munedemo.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:ignore</span>=<span class="string">&quot;MergeRootFrame&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;SubMenu&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;30sp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> &#123;</span><br><span class="line">        <span class="type">SubMenu</span> <span class="variable">fileMenu</span> <span class="operator">=</span> menu.addSubMenu(<span class="string">&quot;查看文件&quot;</span>);</span><br><span class="line">        <span class="type">SubMenu</span> <span class="variable">editMenu</span> <span class="operator">=</span> menu.addSubMenu(<span class="string">&quot;输入文件&quot;</span>);</span><br><span class="line">        <span class="comment">//添加菜单项</span></span><br><span class="line">        fileMenu.add(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;文件1&quot;</span>);</span><br><span class="line">        fileMenu.add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;文件2&quot;</span>);</span><br><span class="line">        fileMenu.add(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;文件3&quot;</span>);</span><br><span class="line">        editMenu.add(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;输入1&quot;</span>);</span><br><span class="line">        editMenu.add(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;输入2&quot;</span>);</span><br><span class="line">        editMenu.add(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;输入3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onCreateOptionsMenu(menu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建点击事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.getGroupId() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (item.getItemId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;点击了文件1&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;点击了文件2&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;点击了文件3&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.getGroupId() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (item.getItemId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;点击了输入1&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;点击了输入2&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;点击了输入3&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onOptionsItemSelected(item);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="menu的属性解释"><a href="#menu的属性解释" class="headerlink" title="menu的属性解释"></a>menu的属性解释</h3><ul>
<li><p><code>android:id</code><br>定义资源ID，它是个唯一值，使用“@+id&#x2F;name”格式可以给这个菜单项创建一个新的资源ID，“+”号指示要创建一个新的ID。</p>
</li>
<li><p><code>android:title</code><br>字符串资源，它用字符串资源或原始的字符串来定义菜单的标题。</p>
</li>
<li><p><code>android:titleCondensed</code><br>字符串资源。它用字符串资源或原始的字符串来定义一个简要的标题，以便在普通的标题太长时来使用。</p>
</li>
<li><p><code>android:icon</code><br>可绘制资源，它定义了一个菜单项所要使用的图标。</p>
</li>
<li><p><code>android:onClick</code><br>方法名。在这个菜单项被点击时，会调用这个方法。在Activity中，这个方法必须用public关键字来声明，并且只接受一个MenuItem对象，这个对象指明了被点击的菜单项。这个方法会优先标准的回调方法：onOptionsItemSelected()。<br>警告：如果要使用ProGuard（或类似的工具）来混淆代码，就要确保不要重名这个属性所指定的方法，因为这样能够破坏功能。<br>这个属性在API级别11中被引入。</p>
</li>
<li><p><code>android:showAsAction</code><br>关键词。它定义这个项目作为操作栏中的操作项的显示时机和方式。只用Activity包含了一个ActionBar对象时，菜单项才能够作为操作项来显示。这个属性在API级别11中被引入，有效值如下：<br>值 说明<br><strong>ifRoom</strong> 如果有针对这个项目的空间，则只会把它放到操作栏中<br><strong>withText</strong> 操作项也要包含文本（通过android:title属性来定义的）。可以把这个值与其他的Flag设置放到一起，通过管道符“|”来分离它们。<br><strong>never</strong> 这个项目不会放到操作栏中<br><strong>always</strong><br>始终包这个项目放到操作栏中。要避免使用这个设置，除非在操作栏中始终显示这个项目是非常关键的。设置多个项目作为始终显示的操作项会导<br>致操作栏中其他的UI溢出。<br>icollapseActiionView 它定义了跟这个操作项关联的可折叠的操作View对象（用android:actionViewLayout来声明）。这个关键词在API级别14中被引入。</p>
</li>
<li><p><code>android:actionViewLayout</code><br>它引用一个布局资源，这个布局要用于操作窗口。更多的信息请参照“操作栏”开发指南。这个属性在API级别11中被引入。</p>
</li>
<li><p><code>android:actionViewClass</code><br>类名。它定义了操作窗口要使用的View对象的完整的类名。例如，“android.widget.SearchView”说明操作窗口要使用的SearchView类。<br>警告：如果要使用ProGuard（或类似的工具）来混淆代码，就要确保不要重名这个属性所指定的方法，因为这样能够破坏功能。<br>这个属性在API级别11中被引入。</p>
</li>
<li><p><code>android:actionProviderClass</code></p>
<p>类名，它是操作项目所使用的ActionProvider类的完整的类名。例如，“android.widget.ShareActionProvider”说明要使用<br>ShareActionProvider类。<br>警告：如果要使用ProGuard（或类似的工具）来混淆代码，就要确保不要重名这个属性所指定的方法，因为这样能够破坏功能。<br>这个属性在API级别14中被引入。</p>
</li>
<li><p><code>android:alphabeticShortcut</code><br>字符，定义一个字符快捷键</p>
</li>
<li><p><code>android:numericShortcut</code><br>数字值，定义一个数字快捷键</p>
</li>
<li><p><code>android:checkable</code><br>布尔值，如果菜单项是可以复选的，那么就设置为true。</p>
</li>
<li><p><code>android:checked</code><br>布尔值，如果复选菜单项默认是被选择的，那么就设置为true。</p>
</li>
<li><p><code>android:visible</code><br>布尔值，如果菜单项默认是可见的，那么就设置为true。</p>
</li>
<li><p><code>android:enabled</code><br>布尔值，如果菜单项目默认是可用的，那么就设置为true。</p>
</li>
<li><p><code>android:menuCategory</code><br>关键词。它的值对应了定义菜单项优先级的CATEGORE_*常量，有效值如下：<br>值 说明<br>Container 菜单项是容器的一部分<br>system 菜单项是由系统提供的。<br>secondary 提供给用户的辅助选择的菜单项（很少使用）<br>alternative 基于当前显示的数据来选择操作的菜单项。</p>
</li>
<li><p><code>android:orderInCategory</code><br>整数值，它定义菜单项在菜单组中的重要性的顺序。</p>
</li>
</ul>
<h4 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h4><p><code>&lt;group&gt;</code><br>它定义了一个菜单组（它是一个具有共同特征的菜单项的组合，如菜单项的可见性、可用性或可复选性）。它要包含多个<code>&lt;item&gt;</code>元素，而且必须是<code>&lt;menu&gt;</code>元素的子元素。</p>
<h4 id="属性（ATTRIBUTES）："><a href="#属性（ATTRIBUTES）：" class="headerlink" title="属性（ATTRIBUTES）："></a>属性（ATTRIBUTES）：</h4><ul>
<li><p><code>android:id</code><br>资源ID。它是资源的唯一标识。使用“@+id&#x2F;name”格式给菜单项创建一个新的资源ID。“+”号指示应该给这个元素创建一个新的资源ID。</p>
</li>
<li><p><code>android:checkableBeharior</code><br>关键词。针对菜单组的可复选行为的类型。有效值如下：<br>值 说明<br>none 没有可复选性<br>all 组内的所有的项目都被复选（使用复选框）<br>single 仅有一个项目能够被复选（使用单选按钮）</p>
</li>
<li><p><code>android:visible</code></p>
<p>布尔值，如果菜单组是可见的，就设置为true。</p>
</li>
<li><p><code>android:enabled</code><br>布尔值，如果菜单组是可用的，就设置为true。</p>
</li>
<li><p><code>android:menuCategory</code><br>关键词。它的值对应了Menu类的CATEGORY_*常量，定义了菜单组的优先级。有效值如下：<br>值 说明<br>container 菜单组是容器的一部分<br>system 菜单组是由系统提供的。<br>secondary 提供给用户的辅助选择的菜单组（很少使用）<br>alternative 基于当前显示的数据来选择操作的菜单组。</p>
</li>
<li><p><code>android:orderInCategory</code><br>整数值，它定义了分类中菜单项目的默认顺序。</p>
</li>
</ul>
<h3 id="使用XML定义menu"><a href="#使用XML定义menu" class="headerlink" title="使用XML定义menu"></a>使用XML定义menu</h3><p>理论上而言，使用XML和Java代码都可以创建Menu。但是在实际开发中，往往通过XML文件定义Menu，这样做有以下几个好处：</p>
<ol>
<li>使用XML可以获得更清晰的菜单结构</li>
<li>将菜单内容与应用的逻辑代码分离</li>
<li>可以使用应用资源框架，为不同的平台版本、屏幕尺寸创建最合适的菜单（如对drawable、string等系统资源的使用）</li>
</ol>
<p>要定义Menu，我们首先需要在res文件夹下新建menu文件夹，它将用于存储与Menu相关的所有XML文件。<br>我们可以使用<menu>、<item>、<group>三种XML元素定义Menu，下面简单介绍一下它们：</p>
<ol>
<li>“<menu>”是菜单项的容器。<menu>元素必须是该文件的根节点，并且能够包含一个或多个<item>和<group>元素。</li>
<li><item>是菜单项，用于定义MenuItem，可以嵌套<menu>元素，以便创建子菜单。</li>
<li><group>是<item>元素的不可见容器（可选）。可以使用它对菜单项进行分组，使一组菜单项共享可用性和可见性等属性。</li>
</ol>
<p>其中，<item>是我们主要需要关注的元素，它的常见属性如下：</p>
<ul>
<li>android:id：菜单项(MenuItem)的唯一标识</li>
<li>android:icon：菜单项的图标（可选）</li>
<li>android:title：菜单项的标题（必选）</li>
<li>android:showAsAction：指定菜单项的显示方式。常用的有ifRoom、never、always、withText，多个属性值之间可以使用|隔开。</li>
</ul>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/option_normal_1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_vpn_key_white_24dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;普通菜单1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">&quot;ifRoom&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/option_normal_2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_email_white_24dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;普通菜单2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">&quot;always&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/option_normal_3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_vpn_key_white_24dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;普通菜单3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">&quot;withText|always&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/option_normal_4&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;普通菜单4&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">&quot;never&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>菜单栏中的菜单项会分为两个部分。一部分可以直接在菜单栏中看见，我们可以称之为常驻菜单；另一部分会被集中收纳到溢出菜单中（就是菜单栏右侧的小点状图标）。一般情况下，常驻菜单项以图标形式显示（需要定义icon属性），而溢出菜单项则以文字形式显示（通过title属性定义）。showAsAction的差异如下所示：</p>
<ol>
<li>always：菜单项永远不会被收纳到溢出菜单中，因此在菜单项过多的情况下可能超出菜单栏的显示范围。</li>
<li>ifRoom：在空间足够时，菜单项会显示在菜单栏中，否则收纳入溢出菜单中。</li>
<li>withText：无论菜单项是否定义了icon属性，都只会显示它的标题，而不会显示图标。使用这种方式的菜单项默认会被收纳入溢出菜单中。</li>
<li>never：菜单项永远只会出现在溢出菜单中。</li>
</ol>
<p>java加载代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> &#123;</span><br><span class="line">    MenuInflater inflater=getMenuInflater();</span><br><span class="line">    inflater.inflate(R.menu.option_menu_normal,menu);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (item.getItemId())&#123;</span><br><span class="line">        <span class="keyword">case</span> R.id.option_normal_1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.option_normal_2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.option_normal_3:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.option_normal_4:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.onOptionsItemSelected(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见，我们在Activity中重写了onCreateOptionsMenu方法，在这个方法中完成加载Menu资源的操作，关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取MenuInflater</span></span><br><span class="line">MenuInflater inflater=getMenuInflater();</span><br><span class="line"><span class="comment">//加载Menu资源</span></span><br><span class="line">inflater.inflate(R.menu.option_menu_normal,menu);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，这个方法必须返回true，否则Menu将不会显示。</p>
<h4 id="获取MenuInflater"><a href="#获取MenuInflater" class="headerlink" title="获取MenuInflater"></a>获取MenuInflater</h4><p><strong>LayoutInflater是用来实例化整个布局文件，而 MenuInflater是用来实例化Menu目录下的Menu布局文件的。</strong><br>传统意义上的菜单定义需要Override Activity的onCreateOptionsMenu，然后在里面调用Menu.add把Menu的一个个item加进来，比较复杂。而通过使用MenuInflater可以把Menu的构造直接放在Menu布局文件中，真现模型（Model）与视图（View）的分离，程序也看着清爽多了。</p>
<p>几点说明：</p>
<p>与LayoutInflater相比，MenuInflater的用法简单多了。首先，MenuInflater获取方法只有一种：Activity.getMenuInflater()；其次，MenuInflater.inflater(int menuRes,Menu menu)(这里不代表inflater就是static方法，可以这样调用，只是为了描述方便)的返回值是void型，这就决定了MenuInflater.inflater后就没有后续操作了。这说明通过这种方式把Menu布局文件写好后就不能在程序中动态修改了，而不像LayoutInflater.inflater那样，返回值是View型，可以进行后续的进一步操作。另外，MenuInflater只有一个void inflater(int menuRes,Menu menu)非构造方法。</p>
<h3 id="包含多级子菜单的选项菜单"><a href="#包含多级子菜单的选项菜单" class="headerlink" title="包含多级子菜单的选项菜单"></a>包含多级子菜单的选项菜单</h3><p><item>是可以嵌套<menu>的，而<menu>又是<item>的容器。因此，我们可以在应用中实现具有层级结构的子菜单。下面给出一个实际的例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/option_sub_file&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;文件&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">&quot;ifRoom&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">menu</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/file_new&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">&quot;新建&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/file_save&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">&quot;保存&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/file_more&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">&quot;更多&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">menu</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/file_more_1&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:title</span>=<span class="string">&quot;更多1&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/file_more_2&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:title</span>=<span class="string">&quot;更多2&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/file_more_more&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:title</span>=<span class="string">&quot;更多更多&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">menu</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/file_more_more_1&quot;</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">android:title</span>=<span class="string">&quot;更多更多1&quot;</span>/&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/file_more_more_2&quot;</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">android:title</span>=<span class="string">&quot;更多更多2&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="intent"><a href="#intent" class="headerlink" title="intent"></a>intent</h2><p>Intent中文意思指”意图”,按照Android的设计理念,A<strong>ndroid使用Intent来封装程序的”调用意图”,不管启动Activity、Service、BroadcastReceiver,Android都使用统一的Intent对象来封装这一”启动意图”。此外,Intent也是应用程序组件之间通信的重要媒介。</strong>在Android中指定的了具体是某个组件，那么就是显性意图；如果只是提出要求没有指定具体的某个人，在Android中即没有指定某个具体的组件，那么就是隐式意图；所有Intent页面跳转的方式又分为显示跳转和隐式跳转。</p>
<h2 id="Intent和三大组件"><a href="#Intent和三大组件" class="headerlink" title="Intent和三大组件"></a>Intent和三大组件</h2><p>Android应用程序包含三种重要组件:Activity、Service、BroadcastReceiver,应用程序采用一致的方式启动它们，都是依靠Intent来进行启动的,Intent中封装了程序要启动的意图。</p>
<blockquote>
<p>下面是Intent启动不同组件的部分方法:<br>　Activity组件:<br>　startActivity(Intent intent);startActivityForResult(Intent intent,int requestCode);<br>　Service组件:<br>　startService(Intent intent);bindService(Intent intent,ServiceConnection conn,int flags);<br>　BroadcastReceiver组件:<br>　sendBroadcast(Intent intent);sendOrderedBroadcast(Intent intent,String receiverPermission);</p>
</blockquote>
<h3 id="显式-Explicit-intent-和隐式-Implicit-intent-。"><a href="#显式-Explicit-intent-和隐式-Implicit-intent-。" class="headerlink" title="显式(Explicit intent)和隐式(Implicit intent)。"></a>显式(Explicit intent)和隐式(Implicit intent)。</h3><h4 id="一、显式（设置Component（组件））"><a href="#一、显式（设置Component（组件））" class="headerlink" title="一、显式（设置Component（组件））"></a>一、显式（设置Component（组件））</h4><p>显式，即直接指定需要打开的activity对应的类。<br>以下多种方式都是一样的，实际上都是设置Component直接指定Activity类的显式Intent，由MainActivity跳转到SecondActivity：<br>1、构造方法传入Component，最常用的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, SecondActivity.class);  </span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>2、setComponent方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ComponentName</span> <span class="variable">componentName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComponentName</span>(<span class="built_in">this</span>, SecondActivity.class);  </span><br><span class="line"><span class="comment">// 或者ComponentName componentName = new ComponentName(this, &quot;com.example.app016.SecondActivity&quot;);  </span></span><br><span class="line"><span class="comment">// 或者ComponentName componentName = new ComponentName(this.getPackageName(), &quot;com.example.app016.SecondActivity&quot;);  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();  </span><br><span class="line">intent.setComponent(componentName);  </span><br><span class="line">startActivity(intent); </span><br></pre></td></tr></table></figure>

<p>3、setClass&#x2F;setClassName方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();  </span><br><span class="line">  </span><br><span class="line">intent.setClass(<span class="built_in">this</span>, SecondActivity.class);  </span><br><span class="line"><span class="comment">// 或者intent.setClassName(this, &quot;com.example.app016.SecondActivity&quot;);  </span></span><br><span class="line"><span class="comment">// 或者intent.setClassName(this.getPackageName(), &quot;com.example.app016.SecondActivity&quot;);  </span></span><br><span class="line">startActivity(intent);  </span><br></pre></td></tr></table></figure>

<p>显式Intent通过Component可以直接设置需要调用的Activity类，可以唯一确定一个Activity，意图特别明确，所以是显式的。设置这个类的方式可以是Class对象（如SecondActivity.class），<br>也可以是包名加类名的字符串（如”com.example.app016.SecondActivity”）。这个很好理解，在应用程序内部跳转界面常用这种方式。  </p>
<h4 id="二、隐式"><a href="#二、隐式" class="headerlink" title="二、隐式"></a>二、隐式</h4><p>隐式，即不是像显式的那样直接指定需要调用的Activity，隐式不明确指定启动哪个Activity，而是设置Action、Data、Category，让系统来筛选出合适的Activity。<br>筛选是根据所有的<intent-filter>来筛选。<br>下面以Action为例：<br>AndroidManifest.xml文件中，首先被调用的Activity要有一个带有<intent-filter>并且包含<action>的Activity，设定它能处理的Intent，并且category设为”android.intent.category.DEFAULT”。<br>action的name是一个字符串，可以自定义，例如我在这里设成”abcdefg”：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;com.example.app016.SecondActivity&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;abcdefg&quot;</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p>然后，在MainActivity，才可以通过这个action name找到上面的Activity。<br>下面两种方式分别通过setAction和构造方法方法设置Action，两种方式效果相同。<br>1、setAction方法  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();  </span><br><span class="line">intent.setAction(<span class="string">&quot;abcdefg&quot;</span>);  </span><br><span class="line">startActivity(intent);  </span><br></pre></td></tr></table></figure>

<p>2、构造方法直接设置Action  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;abcdefg&quot;</span>);  </span><br><span class="line">startActivity(intent); </span><br></pre></td></tr></table></figure>

<p>通过设置Action字符串，表明自己的意图，即我想干嘛，需要由系统解析，找到能够处理这个Intent的Activity并启动。<br>比如我想打电话，则可以设置Action为”android.intent.action.DIAL”字符串，表示打电话的意图，系统会找到能处理这个意图的Activity，例如调出拨号面板。</p>
<p>有几点需要注意：<br>1、 这个Activity其他应用程序也可以调用，<strong>只要使用这个Action字符串。这样应用程序之间交互就很容易了</strong>，例如手机QQ可以调用QQ空间，可以调用腾讯微博等。<br>因为如此，为了防止应用程序之间互相影响，一般命名方式是包名+Action名，例如这里命名”abcdefg”就很不合理了，就应该改成”com.example.app016.MyTest”。<br>2、 当然，你可以在自己的程序中调用其他程序的Action。<br>例如可以在自己的应用程序中调用拨号面板：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_DIAL);  </span><br><span class="line"><span class="comment">// 或者Intent intent = new Intent(&quot;android.intent.action.DIAL&quot;);  </span></span><br><span class="line"><span class="comment">// Intent.ACTION_DIAL是内置常量，值为&quot;android.intent.action.DIAL&quot;  </span></span><br><span class="line">startActivity(intent);  </span><br></pre></td></tr></table></figure>

<p>3、一个Activity可以处理多种Action 只要你的应用程序够牛逼，一个Activity可以看网页，打电话，发短信，发邮件。。。当然可以。 Intent的Action只要是其中之一，就可以打开这个Activity。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">activity  </span><br><span class="line">    android:name=&quot;com.example.app016.SecondActivity&quot;&gt;  </span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 可以处理下面三种Intent --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.app016.SEND_EMAIL&quot;</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.app016.SEND_MESSAGE&quot;</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.app016.DAIL&quot;</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p>对于一个Action字符串，系统有可能会找到一个Activity能处理这个Action，也有可能找到多个Activity，也可能一个都找不到。<br>1、找到一个Activity<br>很简单，直接打开这个Activity。这个不需要解释。<br>2、找到多个Acyivity<br>系统会提示从多个activity中选择一个打开。<br>例如我们自己开发一个拨号面板应用程序，可以设置activity的<intent-filter>中Action name为”android.intent.action.DIAL”，这样别的程序调用拨号器时，<br>用户可以从Android自带的拨号器和我们自己开发的拨号器中选择。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;com.example.app016.SecondActivity&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.DIAL&quot;</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>这也就是当Android手机装上UC浏览器后，打开网页时会弹出选择Android自带浏览器还是UC浏览器，可能都会遇到过。<br>3、一个Activity都没找到<br>一个都没找到的话，程序就会出错，会抛出ActivityNotFoundException。比如随便写一个action字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;asasasas&quot;</span>);  </span><br><span class="line">startActivity(intent);  </span><br></pre></td></tr></table></figure>

<p>所以应该注意try catch异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;asasasas&quot;</span>);  </span><br><span class="line"><span class="keyword">try</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    startActivity(intent);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">catch</span>(ActivityNotFoundException e)  </span><br><span class="line">&#123;  </span><br><span class="line">    Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;找不到对应的Activity&quot;</span>, Toast.LENGTH_SHORT).show();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>或者也可以使用Intent的resolveActivity方法判断这个Intent是否能找到合适的Activity，如果没有，则不再startActivity，或者可以直接禁用用户操作的控件。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_DIAL);  </span><br><span class="line"><span class="keyword">if</span>(intent.resolveActivity(getPackageManager()) == <span class="literal">null</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// 设置控件不可用  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>注意resolveActivity方法返回值就是显式Intent上面讲到的ComponentName对象，一般情况下也就是系统找到的那个Activity。<br>但是如果有多个Activity可供选择的话，则返回的Component是com.android.internal.app.ResolverActivity，也就是用户选择Activity的那个界面对应的Activity，这里不再深究。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> <span class="constructor">Intent(Intent.ACTION_DIAL)</span>;  </span><br><span class="line">ComponentName componentName = intent.resolve<span class="constructor">Activity(<span class="params">getPackageManager</span>()</span>);  </span><br><span class="line"><span class="keyword">if</span>(componentName != null)  </span><br><span class="line">&#123;  </span><br><span class="line">    String className = componentName.get<span class="constructor">ClassName()</span>;  </span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Toast</span>.</span></span>make<span class="constructor">Text(<span class="params">this</span>, <span class="params">className</span>, Toast.LENGTH_SHORT)</span>.show<span class="literal">()</span>;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="四大属性"><a href="#四大属性" class="headerlink" title="四大属性"></a>四大属性</h3><p>Intent在Android中的核心作用就是“跳转”（Android中的跳转机制），同时可以携带必要的信息，将Intent作为一个信息桥梁。最熟悉的莫过于从一个活动跳转到另一个活动，然后返回到上一个活动。不过Intent的“跳转”作用不仅于此，Intent还可以在其他地方使用，比如在碎片中跳转，接受到一个广播后自动跳转。<br>　Intent主要有以下四个重要属性，它们分别为：</p>
<ul>
<li>Action：Action属性的值为一个字符串，它代表了系统中已经定义了一系列常用的动作。通过setAction()方法或在清单文件AndroidManifest.xml中设置。默认为：DEFAULT。</li>
<li>Data：Data通常是URI格式定义的操作数据。例如：tel:&#x2F;&#x2F; 。通过setData()方法设置。</li>
<li>Category：Category属性用于指定当前动作（Action）被执行的环境。通过addCategory()方法或在清单文件AndroidManifest.xml中设置。默认为：CATEGORY_DEFAULT。</li>
<li>Extras：Extras属性主要<strong>用于传递目标组件所需要的额外的数据</strong>。通过<code>putExtras()</code>方法设置。</li>
</ul>
<h4 id="Action：action表示该activity可以执行的动作。"><a href="#Action：action表示该activity可以执行的动作。" class="headerlink" title="Action：action表示该activity可以执行的动作。"></a>Action：action表示该activity可以执行的动作。</h4><ol>
<li>自定义action，匹配Activity的功能：<br>a.menifest中注册的Activity</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:name</span>=<span class="string">&quot;.StudyActivity&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.czh.study&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>b.启动activity</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(&quot;com.czh.study&quot;);</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure>

<p>当intent启动Activity的时候会拿着action到menifest中查找是否有activity的acitoin和我相同，如果匹配成功（即intent中的action和中的action相同）就跳转到该actvitiy.</p>
<p>（如果匹配的2个activity的话，系统会给你一个选择框让你选择启动那么activity）</p>
<ol start="2">
<li>利用系统action，调用UI</li>
</ol>
<p>Action常用的值如下：</p>
<ul>
<li>ACTION_MAIN：Android Application的入口，每个Android应用必须且只能包含一个此类型的Action声明。　　</li>
<li>ACTION_VIEW：系统根据不同的Data类型，通过已注册的对应Application显示数据。</li>
<li>ACTION_EDIT：系统根据不同的Data类型，通过已注册的对应Application编辑示数据。　</li>
<li>ACTION_DIAL：打开系统默认的拨号程序，如果Data中设置了电话号码，则自动在拨号程序中输入此号码。　</li>
<li>ACTION_CALL：直接呼叫Data中所带的号码。　</li>
<li>ACTION_ANSWER：接听来电。　</li>
<li>ACTION_SEND：由用户指定发送方式进行数据发送操作。</li>
<li>ACTION_SENDTO：系统根据不同的Data类型，通过已注册的对应Application进行数据发送操作。　</li>
<li>ACTION_BOOT_COMPLETED：Android系统在启动完毕后发出带有此Action的广播（Broadcast）。　</li>
<li>ACTION_TIME_CHANGED：Android系统的时间发生改变后发出带有此Action的广播（Broadcast）。　</li>
<li>ACTION_PACKAGE_ADDED：Android系统安装了新的Application之后发出带有此Action的广播（Broadcast）。　</li>
<li>ACTION_PACKAGE_CHANGED：Android系统中已存在的Application发生改变之后（如应用更新操作）发出带有此Action的广播</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 从google搜索内容 </span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(); </span><br><span class="line">intent.setAction(Intent.ACTION_WEB_SEARCH); </span><br><span class="line">intent.putExtra(SearchManager.QUERY,<span class="string">&quot;searchString&quot;</span>) </span><br><span class="line">startActivity(intent); </span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 浏览网页 </span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;http://www.google.com&quot;</span>); </span><br><span class="line"><span class="type">Intent</span> <span class="variable">it</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_VIEW,uri); </span><br><span class="line">startActivity(it); </span><br><span class="line"></span><br><span class="line"><span class="number">3</span> 显示地图 </span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;geo:38.899533,-77.036476&quot;</span>); </span><br><span class="line"><span class="type">Intent</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.Action_VIEW,uri); </span><br><span class="line">startActivity(it); </span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 路径规划 </span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;http://maps.google.com/maps?f=dsaddr=startLat%20startLng&amp;daddr=endLat%20endLng&amp;hl=en&quot;</span>); </span><br><span class="line"><span class="type">Intent</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_VIEW,URI); </span><br><span class="line">startActivity(it); </span><br><span class="line"></span><br><span class="line"><span class="number">5</span> 拨打电话 </span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;tel:xxxxxx&quot;</span>); </span><br><span class="line"><span class="type">Intent</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_DIAL, uri);   </span><br><span class="line">startActivity(it); </span><br><span class="line"></span><br><span class="line"><span class="number">6</span> 调用发短信的程序 </span><br><span class="line"><span class="type">Intent</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_VIEW);    </span><br><span class="line">it.putExtra(<span class="string">&quot;sms_body&quot;</span>, <span class="string">&quot;The SMS text&quot;</span>);    </span><br><span class="line">it.setType(<span class="string">&quot;vnd.android-dir/mms-sms&quot;</span>);    </span><br><span class="line">startActivity(it); </span><br><span class="line"></span><br><span class="line"><span class="number">7</span> 发送短信 </span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;smsto:0800000123&quot;</span>);    </span><br><span class="line"><span class="type">Intent</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_SENDTO, uri);    </span><br><span class="line">it.putExtra(<span class="string">&quot;sms_body&quot;</span>, <span class="string">&quot;The SMS text&quot;</span>);    </span><br><span class="line">startActivity(it); </span><br><span class="line">String body=<span class="string">&quot;this is sms demo&quot;</span>; </span><br><span class="line"><span class="type">Intent</span> <span class="variable">mmsintent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_SENDTO, Uri.fromParts(<span class="string">&quot;smsto&quot;</span>, number, <span class="literal">null</span>)); </span><br><span class="line">mmsintent.putExtra(Messaging.KEY_ACTION_SENDTO_MESSAGE_BODY, body); </span><br><span class="line">mmsintent.putExtra(Messaging.KEY_ACTION_SENDTO_COMPOSE_MODE, <span class="literal">true</span>); </span><br><span class="line">mmsintent.putExtra(Messaging.KEY_ACTION_SENDTO_EXIT_ON_SENT, <span class="literal">true</span>); </span><br><span class="line">startActivity(mmsintent); </span><br><span class="line"></span><br><span class="line"><span class="number">8</span> 播放多媒体   </span><br><span class="line"><span class="type">Intent</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_VIEW); </span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;file:///sdcard/song.mp3&quot;</span>); </span><br><span class="line">it.setDataAndType(uri, <span class="string">&quot;audio/mp3&quot;</span>); </span><br><span class="line">startActivity(it); </span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.withAppendedPath(MediaStore.Audio.Media.INTERNAL_CONTENT_URI, <span class="string">&quot;1&quot;</span>);    </span><br><span class="line"><span class="type">Intent</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_VIEW, uri);    </span><br><span class="line">startActivity(it); </span><br><span class="line"></span><br><span class="line"><span class="number">9</span> uninstall apk </span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.fromParts(<span class="string">&quot;package&quot;</span>, strPackageName, <span class="literal">null</span>);    </span><br><span class="line"><span class="type">Intent</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_DELETE, uri);    </span><br><span class="line">startActivity(it); </span><br><span class="line"></span><br><span class="line"><span class="number">10</span> install apk </span><br><span class="line"><span class="type">Uri</span> <span class="variable">installUri</span> <span class="operator">=</span> Uri.fromParts(<span class="string">&quot;package&quot;</span>, <span class="string">&quot;xxx&quot;</span>, <span class="literal">null</span>); </span><br><span class="line">returnIt = <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_PACKAGE_ADDED, installUri); </span><br><span class="line"></span><br><span class="line"><span class="number">11</span> 打开照相机 </span><br><span class="line">    &lt;<span class="number">1</span>&gt;<span class="type">Intent</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_CAMERA_BUTTON, <span class="literal">null</span>); </span><br><span class="line">           <span class="built_in">this</span>.sendBroadcast(i); </span><br><span class="line">     &lt;<span class="number">2</span>&gt;<span class="type">long</span> <span class="variable">dateTaken</span> <span class="operator">=</span> System.currentTimeMillis(); </span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> createName(dateTaken) + <span class="string">&quot;.jpg&quot;</span>; </span><br><span class="line">            fileName = folder + name; </span><br><span class="line">            <span class="type">ContentValues</span> <span class="variable">values</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentValues</span>(); </span><br><span class="line">            values.put(Images.Media.TITLE, fileName); </span><br><span class="line">            values.put(<span class="string">&quot;_data&quot;</span>, fileName); </span><br><span class="line">            values.put(Images.Media.PICASA_ID, fileName); </span><br><span class="line">            values.put(Images.Media.DISPLAY_NAME, fileName); </span><br><span class="line">            values.put(Images.Media.DESCRIPTION, fileName); </span><br><span class="line">            values.put(Images.ImageColumns.BUCKET_DISPLAY_NAME, fileName); </span><br><span class="line">            <span class="type">Uri</span> <span class="variable">photoUri</span> <span class="operator">=</span> getContentResolver().insert( </span><br><span class="line">                    MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values); </span><br><span class="line"></span><br><span class="line">            <span class="type">Intent</span> <span class="variable">inttPhoto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MediaStore.ACTION_IMAGE_CAPTURE); </span><br><span class="line">            inttPhoto.putExtra(MediaStore.EXTRA_OUTPUT, photoUri); </span><br><span class="line">            startActivityForResult(inttPhoto, <span class="number">10</span>); </span><br><span class="line"></span><br><span class="line"><span class="number">12</span> 从gallery选取图片 </span><br><span class="line">  <span class="type">Intent</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(); </span><br><span class="line">            i.setType(<span class="string">&quot;image/*&quot;</span>); </span><br><span class="line">            i.setAction(Intent.ACTION_GET_CONTENT); </span><br><span class="line">            startActivityForResult(i, <span class="number">11</span>); </span><br><span class="line"></span><br><span class="line"><span class="number">13</span> 打开录音机 </span><br><span class="line">   <span class="type">Intent</span> <span class="variable">mi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Media.RECORD_SOUND_ACTION); </span><br><span class="line">            startActivity(mi); </span><br><span class="line"></span><br><span class="line"><span class="number">14</span> 显示应用详细列表       </span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;market://details?id=app_id&quot;</span>);         </span><br><span class="line"><span class="type">Intent</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_VIEW, uri);         </span><br><span class="line">startActivity(it);         </span><br><span class="line"><span class="comment">//where app_id is the application ID, find the ID          </span></span><br><span class="line"><span class="comment">//by clicking on your application on Market home          </span></span><br><span class="line"><span class="comment">//page, and notice the ID from the address bar      </span></span><br><span class="line"></span><br><span class="line">刚才找app id未果，结果发现用<span class="keyword">package</span> name也可以 </span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;market://details?id=&lt;packagename&gt;&quot;</span>); </span><br><span class="line">这个简单多了 </span><br><span class="line"></span><br><span class="line"><span class="number">15</span> 寻找应用       </span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;market://search?q=pname:pkg_name&quot;</span>);         </span><br><span class="line"><span class="type">Intent</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_VIEW, uri);         </span><br><span class="line">startActivity(it); </span><br><span class="line"><span class="comment">//where pkg_name is the full package path for an application       </span></span><br><span class="line"></span><br><span class="line"><span class="number">16</span> 打开联系人列表 </span><br><span class="line">            &lt;<span class="number">1</span>&gt;            </span><br><span class="line">           <span class="type">Intent</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(); </span><br><span class="line">           i.setAction(Intent.ACTION_GET_CONTENT); </span><br><span class="line">           i.setType(<span class="string">&quot;vnd.android.cursor.item/phone&quot;</span>); </span><br><span class="line">           startActivityForResult(i, REQUEST_TEXT); </span><br><span class="line"></span><br><span class="line">            &lt;<span class="number">2</span>&gt; </span><br><span class="line">            <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://contacts/people&quot;</span>); </span><br><span class="line">            <span class="type">Intent</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_PICK, uri); </span><br><span class="line">            startActivityForResult(it, REQUEST_TEXT); </span><br><span class="line"></span><br><span class="line"><span class="number">17</span> 打开另一程序 </span><br><span class="line"><span class="type">Intent</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(); </span><br><span class="line">            <span class="type">ComponentName</span> <span class="variable">cn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComponentName</span>(<span class="string">&quot;com.yellowbook.android2&quot;</span>, </span><br><span class="line">                    <span class="string">&quot;com.yellowbook.android2.AndroidSearch&quot;</span>); </span><br><span class="line">            i.setComponent(cn); </span><br><span class="line">            i.setAction(<span class="string">&quot;android.intent.action.MAIN&quot;</span>); </span><br><span class="line">            startActivityForResult(i, RESULT_OK); </span><br><span class="line"></span><br><span class="line"><span class="number">18</span> 调用系统编辑添加联系人（高版本SDK有效）：</span><br><span class="line"><span class="type">Intent</span> <span class="variable">it</span> <span class="operator">=</span> newIntent(Intent.ACTION_INSERT_OR_EDIT);</span><br><span class="line">               it.setType(<span class="string">&quot;vnd.android.cursor.item/contact&quot;</span>);</span><br><span class="line">                <span class="comment">//it.setType(Contacts.CONTENT_ITEM_TYPE);</span></span><br><span class="line">                it.putExtra(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;myName&quot;</span>);</span><br><span class="line">               it.putExtra(android.provider.Contacts.Intents.Insert.COMPANY,  <span class="string">&quot;organization&quot;</span>);</span><br><span class="line">               it.putExtra(android.provider.Contacts.Intents.Insert.EMAIL,<span class="string">&quot;email&quot;</span>);</span><br><span class="line">                it.putExtra(android.provider.Contacts.Intents.Insert.PHONE,<span class="string">&quot;homePhone&quot;</span>);</span><br><span class="line">                it.putExtra(android.provider.Contacts.Intents.Insert.SECONDARY_PHONE,</span><br><span class="line">                               <span class="string">&quot;mobilePhone&quot;</span>);</span><br><span class="line">                it.putExtra(  android.provider.Contacts.Intents.Insert.TERTIARY_PHONE,</span><br><span class="line">                               <span class="string">&quot;workPhone&quot;</span>);</span><br><span class="line">               it.putExtra(android.provider.Contacts.Intents.Insert.JOB_TITLE,<span class="string">&quot;title&quot;</span>);</span><br><span class="line">                startActivity(it);</span><br><span class="line"></span><br><span class="line"><span class="number">19</span> 调用系统编辑添加联系人（全有效）：</span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> newIntent(Intent.ACTION_INSERT_OR_EDIT);</span><br><span class="line">           intent.setType(People.CONTENT_ITEM_TYPE);</span><br><span class="line">           intent.putExtra(Contacts.Intents.Insert.NAME, <span class="string">&quot;My Name&quot;</span>);</span><br><span class="line">           intent.putExtra(Contacts.Intents.Insert.PHONE, <span class="string">&quot;+1234567890&quot;</span>);</span><br><span class="line">           intent.putExtra(Contacts.Intents.Insert.PHONE_TYPE,Contacts.PhonesColumns.TYPE_MOBILE);</span><br><span class="line">           intent.putExtra(Contacts.Intents.Insert.EMAIL, <span class="string">&quot;com@com.com&quot;</span>);</span><br><span class="line">           intent.putExtra(Contacts.Intents.Insert.EMAIL_TYPE,                    Contacts.ContactMethodsColumns.TYPE_WORK);</span><br><span class="line">           startActivity(intent);</span><br></pre></td></tr></table></figure>

<h4 id="category"><a href="#category" class="headerlink" title="category"></a>category</h4><p>Category属性用于指定当前动作（Action）被执行的环境。</p>
<ol>
<li>自定义category ，匹配Activity的功能：<br>如果2个activity有相同的action，那么我们可以用不同的category来区分。<br>a.menifest中注册的Activity</li>
</ol>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span>  <span class="attr">android:name</span>=<span class="string">&quot;.StudyActivity&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.czh.study&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;com.czh.category.study&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>b.启动activity</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(&quot;com.czh.study&quot;);</span><br><span class="line">intent.addCategory(&quot;com.czh.category.study&quot;)</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释：<br>1.这里的category起到了匹配的作用，系统先匹配action，如果action，再匹配cagegory，如果有相同就跳转。<br>2.有一点大家需要注意：<br><category android:name="android.intent.category.DEFAULT" /><br>隐式启动中你必须要加上这一条。<br>但是也有例外：<br><intent-filter><br><action android:name="android.intent.action.MAIN" /><br><category android:name="android.intent.category.LAUNCHER" /><br></intent-filter><br>这一个就不需要要。</p>
</blockquote>
<ol start="2">
<li>利用系统category</li>
</ol>
<p>cagegory常用的值如下：</p>
<ul>
<li>CATEGORY_DEFAULT：Android系统中默认的执行方式，按照普通Activity的执行方式执行。　</li>
<li>CATEGORY_BROWSABLE：设置该组件可以使用浏览器启动。</li>
<li>CATEGORY_TAB：指定该Activity作为TabActivity的Tab页　</li>
<li>CATEGORY_LAUNCHER：设置该组件为在当前应用程序启动器中优先级最高的Activity，通常为入口ACTION_MAIN配合使用。　</li>
<li>CATEGORY_HOME：设置该组件为Home Activity。</li>
<li>CATEGORY_PREFERENCE：设置该组件为Preference。　</li>
<li>CATEGORY_GADGET：设置该组件可以内嵌到另外的Activity中。</li>
<li>CATEGORY_TEST：该Activity是一个测试</li>
<li>CATEGORY_CAR_MODE：设置该Activity可在车载环境下使用  </li>
<li>CATEGORY_CAR_DOCK：指定手机被插入汽车底座（硬件）时运行该Activity</li>
<li>CATEGORY_DESK_DOCK：指定手机被插入桌面底座（硬件）时运行该Activity</li>
</ul>
<h4 id="extras"><a href="#extras" class="headerlink" title="extras"></a>extras</h4><p>**extras属性主要用于传递目标组件所需要的额外的数据。通过putExtras()方法设置。 **<br>常用的系统extras</p>
<ul>
<li>EXTRA_BCC：存放邮件密送人地址的字符串数组。</li>
<li>EXTRA_CC：存放邮件抄送人地址的字符串数组。</li>
<li>EXTRA_EMAIL：存放邮件地址的字符串数组。</li>
<li>EXTRA_SUBJECT：存放邮件主题字符串。</li>
<li>EXTRA_TEXT：存放邮件内容。</li>
<li>EXTRA_KEY_EVENT：以KeyEvent对象方式存放触发Intent的按键。</li>
<li>EXTRA_PHONE_NUMBER：存放调用ACTION_CALL时的电话号码。<br>例如：</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent  = <span class="keyword">new</span> <span class="constructor">Intent(<span class="string">&quot;com.czh.study&quot;</span>)</span>;</span><br><span class="line">                intent.put<span class="constructor">Extra(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>)</span>;</span><br><span class="line">                start<span class="constructor">Activity(<span class="params">intent</span>)</span>;</span><br><span class="line"></span><br><span class="line">String value = get<span class="constructor">Intent()</span>.get<span class="constructor">StringExtra(<span class="string">&quot;key&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="data"><a href="#data" class="headerlink" title="data"></a>data</h4><ol>
<li>什么是uri：</li>
</ol>
<p>我们先得弄明白uri是什么，才能向下讲。<br>通用资源标志符（Universal Resource Identifier, 简称”URI”）。<br>Uri代表要操作的数据，Android上可用的每种资源 - 图像、视频片段等都可以用Uri来表示。换句话说：android系统中任何可用的资源（图像、视频、文件）都可以用uri表示。</p>
<ol start="2">
<li>uri讲解：</li>
</ol>
<ul>
<li>uri属性有以下4部分组成：android:scheme、android:host、android:port、android:path<br>其中host和port2个统称为authority。</li>
<li>要使authority（host和port）有意义，必须指定scheme；要使path有意义，必须使scheme和authority（host和port）有意义<br>举例说明：<br>URI为： file:&#x2F;&#x2F;com.android.jony.test:520&#x2F;mnt&#x2F;sdcard，我们拆分如下：<br>scheme–&gt;file:<br>host–&gt;com.android.jony.test<br>port–&gt;520<br>path–&gt;mnt&#x2F;sdcard<br>authority–&gt;com.android.jony.test:520<br>图片uri:<br>content:&#x2F;&#x2F;media&#x2F;external&#x2F;images&#x2F;media&#x2F;62026<br>tel:&#x2F;&#x2F;：号码数据格式，后跟电话号码。<br>mailto:&#x2F;&#x2F;：邮件数据格式，后跟邮件收件人地址。<br>smsto:&#x2F;&#x2F;：短息数据格式，后跟短信接收号码。<br>content:&#x2F;&#x2F;：内容数据格式，后跟需要读取的内容。<br>file:&#x2F;&#x2F;：文件数据格式，后跟文件路径。<br>market:&#x2F;&#x2F;search?q&#x3D;pname:pkgname：市场数据格式，在Google Market里搜索包名为pkgname的应用。<br>geo:&#x2F;&#x2F;latitude,longitude:经纬数据格式，在地图上显示经纬度指定的位置。</li>
</ul>
<p><strong>在intentfilter中指定data属性的实际目的是：要求接收的Intent中的data必须符合intent-filter中指定的data属性，这样达到反向限定Intent的作用。</strong></p>
<p>在AndroidManifest.xml 中进行如下设置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.TestActivity&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.jony.test&quot;</span>/&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">&quot;file&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p>启动该Activity的Intent必须进行如下设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();  </span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;file://com.android.test:520/mnt/sdcard&quot;</span>);  </span><br><span class="line">intent.setData(uri)</span><br></pre></td></tr></table></figure>

<h4 id="data讲解："><a href="#data讲解：" class="headerlink" title="data讲解："></a>data讲解：</h4><p>1.data属性有以下5部分组成：android:scheme、android:host、android:port、android:path、android:mimeType<br>data的前四个属性构成了URI的组成部分，<br>mimeType设置了数据的类型<br>2.data元素组成的URI模型如下：<br>scheme:&#x2F;&#x2F;host:port&#x2F;path</p>
<h4 id="URI和intent-filter匹配："><a href="#URI和intent-filter匹配：" class="headerlink" title="URI和intent-filter匹配："></a>URI和intent-filter匹配：</h4><p>Intent中URI和intent-filter进行比较的时候只会进行部分的比较：<br>（1）当intent-filter中只设置了scheme，只会比较URI的scheme部分；<br>（2）当intent-filter中只设置了scheme和authority，那么只会匹配URI中的scheme和authority；<br>（3）当intent-filter中设置了scheme、authority和path，那么只会匹配URI中的scheme、authority、path；（path可以使用通配符进行匹配）<br>（4）当intent-filter中设置了mimeType，还会进行数据类型的匹配。</p>
<h2 id="intent和intentfilter"><a href="#intent和intentfilter" class="headerlink" title="intent和intentfilter"></a>intent和intentfilter</h2><p>如果一个 Intent 请求在一片数据上执行一个动作， Android 如何知道哪个应用程序（和组件）能用来响应这个请求呢？ </p>
<p><strong>Intent Filter就是 用来注册 Activity 、 Service 和 Broadcast Receiver 具有能在某种数据上执行一个动作的能力。</strong><br>使用 Intent Filter ，应用程序组件告诉 Android ，它们能为其它程序的组件的动作请求提供服务，包括同一个程序的组件、本地的或第三方的应用程序。</p>
<p>(1)IntentFilter的解释：</p>
<p>IntentFilter就是用于描述intent的各种属性， 比如action, category等</p>
<p>一些属性设置的例子：</p>
<action android:name="com.example.project.SHOW_CURRENT" />

<category android:name="android.intent.category.DEFAULT" />

<p>&lt;data android:mimeType&#x3D;”video&#x2F;mpeg” android:scheme&#x3D;”http” . . . &#x2F;&gt;</p>
<data android:mimeType="image/*" />

<data android:scheme="http" android:type="video/*" />

<p>(2)使用场景</p>
<p>activity的隐式启动和广播的匹配</p>
<p>(3)IntentFilter的匹配规则</p>
<p>IntentFilter的过滤信息有action,category,data.一个组件可以包含多个intent-filter,一个intent只要能完全匹配一组intent-filter即可成功的启动对应的组件。</p>
<p>1.action的匹配规则</p>
<p>intent-filter中必须包含一个action，intent信息中也必须指定一个action。intent-filter中可以有一个或者多个action，只要intent匹配其中的一个action即可。</p>
<p>2.category的匹配规则</p>
<p>intent中可以不指定category,在receiver的intent-filter中也可以不指定category,但是当要隐式启动一个activity是就必须指定android.intent.category.DEFAULT的category。否则系统也会报找不到指定的activity.当intent中指定了一个category时，就会在具有category的intent-filter中去找匹配组件。</p>
<p>3.data的匹配规则</p>
<p>data由两部分组成mimeType和URI.mimeType指媒体类型，比如image&#x2F;jpeg、audio&#x2F;*等。</p>
<p>URI的结构为</p>
<p><scheme>&#x2F;&#x2F;<host>:<port>&#x2F;[<path> | <pathPrefix>|<pathPattern>]</p>
<p>scheme :URI的模式，比如http、file、content等，如果URI中没有指定scheme,那么整个URI的其他参数无效。<br>host:URI的主机名，比如<a target="_blank" rel="noopener" href="http://www.baidu.com,如果host么有指定那么真个uri的其他参数无效./">www.baidu.com,如果host么有指定那么真个URI的其他参数无效。</a></p>
<p>port：URI的端口号。</p>
<p>path,pathPattern,pathPrefix:这三个参数指定路径信息</p>
<p>data的规则是如果inent-filter中描述了data,那么必须要在intent中描述匹配的data信息，如果intent-filter中没有描述data信息，那么intent中可以不指定data信息。data的规则中如果intent-filter只指定了mimeType,那么其默认的URI的scheme是file或者content。在intent中就必须同时设置mimeType和URI。如果intent-filter中有多组data,那么intent中只需要匹配一组即可。</p>
<h2 id="启动活动"><a href="#启动活动" class="headerlink" title="启动活动"></a>启动活动</h2><h3 id="Intent启动Activity"><a href="#Intent启动Activity" class="headerlink" title="Intent启动Activity"></a>Intent启动Activity</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;com.example.android.myapplication.ACTION_START&quot;</span>);       intent.addCategory(<span class="string">&quot;com.example.android.myapplication.MY_CATEGORY&quot;</span>;</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>如果没有在manifest文件中添加</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.android.myapplication.MY_CATEGORY&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">category</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>就会出现如下异常信息</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android<span class="selector-class">.content</span><span class="selector-class">.ActivityNotFoundException</span>: No Activity found to handle Intent &#123; act=com<span class="selector-class">.example</span><span class="selector-class">.android</span><span class="selector-class">.myapplication</span><span class="selector-class">.ACTION_START</span> cat=<span class="selector-attr">[com.example.android.myapplication.MY_CATEGORY]</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如果不添加默认的</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">category</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一样会遇到上面这个Error</p>
<blockquote>
<pre><code>     *Intent.ACTION_VIEW 系统内置的动作
         * Uri.parse()将一个网址字符串解析成一个 Uri 对象
         * setData()方法将这个 Uri 对象传递进去,指定当前 Intent正在操作的数据
         * */
         Intent intent = new Intent(Intent.ACTION_VIEW);
         intent.setData(Uri.parse(&quot;http://www.baidu.com&quot;));
         startActivity(intent);
</code></pre>
</blockquote>
<h3 id="Activity使用Intent传递数据"><a href="#Activity使用Intent传递数据" class="headerlink" title="Activity使用Intent传递数据"></a>Activity使用Intent传递数据</h3><p>向SecondActivity传递数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;This data come from FirstActivity&quot;</span>;</span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(FirstActivity.<span class="built_in">this</span>,SecondActivity.class);</span><br><span class="line">intent.putExtra(<span class="string">&quot;howy&quot;</span>,data);</span><br><span class="line">startActivity(intent);</span><br><span class="line"><span class="comment">//  取出FirstActivity的数据</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line"><span class="type">String</span> <span class="variable">dataFromFirstActivity</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;howy&quot;</span>);</span><br><span class="line">Log.d(TAG, dataFromFirstActivity);</span><br></pre></td></tr></table></figure>

<h3 id="数据往返传递"><a href="#数据往返传递" class="headerlink" title="数据往返传递"></a>数据往返传递</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> <span class="constructor">Intent(FirstActivity.<span class="params">this</span>,SecondActivity.<span class="params">class</span>)</span>;</span><br><span class="line">start<span class="constructor">ActivityForResult(<span class="params">intent</span>, 1)</span>;</span><br><span class="line"><span class="comment">//在SecondActivity设置数据回传</span></span><br><span class="line"> Intent intent = <span class="keyword">new</span> <span class="constructor">Intent()</span>;</span><br><span class="line">String data = <span class="string">&quot;This data from SecondActivity come to FirstActivity&quot;</span>;</span><br><span class="line">intent.put<span class="constructor">Extra(<span class="string">&quot;howy&quot;</span>, <span class="params">data</span>)</span>;</span><br><span class="line">set<span class="constructor">Result(RESULT_OK,<span class="params">intent</span>)</span>;</span><br><span class="line">finish<span class="literal">()</span>;</span><br><span class="line"><span class="comment">//在FirstActivity重写onActivityResult方法</span></span><br><span class="line"> protected void on<span class="constructor">ActivityResult(<span class="params">int</span> <span class="params">requestCode</span>, <span class="params">int</span> <span class="params">resultCode</span>, Intent <span class="params">data</span>)</span> &#123;</span><br><span class="line">        switch (requestCode) &#123;</span><br><span class="line">            case <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> (resultCode<span class="operator"> == </span>RESULT_OK) &#123;</span><br><span class="line">                    String dataComeFromSecondActivity = data.get<span class="constructor">StringExtra(<span class="string">&quot;howy&quot;</span>)</span>;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(TAG, dataComeFromSecondActivity);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (resultCode<span class="operator"> == </span>RESULT_CANCELED) &#123;</span><br><span class="line">                    String content = <span class="string">&quot;Data come form SecondActivity had been CANCELED&quot;</span>;</span><br><span class="line">                    String dataComeFromSecondActivity = data.get<span class="constructor">StringExtra(<span class="string">&quot;howy&quot;</span>)</span>;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(TAG, <span class="string">&quot; &quot;</span> + dataComeFromSecondActivity);</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(TAG, content);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                String content = <span class="string">&quot;No data come form SecondActivity&quot;</span>;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(TAG, content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>把startActivityForResult方法中的requestCode设置为2<br>就会打印No data come form SecondActivity，<br>在onActivityResult方法会先判断requestCode，再判断resultCode。<br>即使把resultCode设为RESULT_CANCELED也是可以回传数据的。</p>
<p>onBackPressed()方法按返回键回传数据。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void on<span class="constructor">BackPressed()</span> &#123;</span><br><span class="line">Intent intent = <span class="keyword">new</span> <span class="constructor">Intent()</span>;</span><br><span class="line">intent.put<span class="constructor">Extra(<span class="string">&quot;data_return&quot;</span>, <span class="string">&quot;Hello FirstActivity&quot;</span>)</span>;</span><br><span class="line">set<span class="constructor">Result(RESULT_OK, <span class="params">intent</span>)</span>;</span><br><span class="line">finish<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h1><p>Android 使用任务（Task）来管理活动，一个任务就是一组存放在栈里的活动的集合，后进先出。<br><img src="/images/Activity/1930046-a086f191437566f4.webp"></p>
<h2 id="活动状态"><a href="#活动状态" class="headerlink" title="活动状态"></a>活动状态</h2><p>每个活动在其生命周期中最多可能会有四种状态。</p>
<ol>
<li>运行状态</li>
</ol>
<p>当一个活动位于返回栈的栈顶时，这时活动就处于运行状态。系统最不愿意回收的就是处于运行状态的活动，因为这会带来非常差的用户体验。</p>
<ol start="2">
<li>暂停状态</li>
</ol>
<p>当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态，比如对话框形式的活动只会占用屏幕中间的部分区域，处于暂停状态的活动仍然是完全存活着的，系统也不愿意去回收这种活动（因为它还是可见的，回收可见的东西都会在用户体验方面有不好的影响），只有在内存极低的情况下，系统才会去考虑回收这种活动。</p>
<ol start="3">
<li>停止状态</li>
</ol>
<p>当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可能会被系统回收。</p>
<ol start="4">
<li>销毁状态</li>
</ol>
<p>当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证手机的内存充足。</p>
<h2 id="活动的生存期"><a href="#活动的生存期" class="headerlink" title="活动的生存期"></a>活动的生存期</h2><p>Activity 类定义了下面的回调。你可以不用实现所有的回调方法。当了解其中的每一个非常的重要，实现这些可以保证你的应用行为如用户所期望的那样。</p>
<ol>
<li>onCreate()</li>
</ol>
<p>它会在活动第一次被创建的时候调用。应该在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等。</p>
<ol start="2">
<li>onStart()</li>
</ol>
<p>这个方法在活动由不可见变为可见的时候调用。</p>
<ol start="3">
<li>onResume()</li>
</ol>
<p>这个方法在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的栈顶，并且处于运行状态。</p>
<ol start="4">
<li>onPause()</li>
</ol>
<p>这个方法在系统准备去启动或者恢复另一个活动的时候调用。我们通常会在这个方法中将一些消耗 CPU 的资源释放掉，以及保存一些关键数据，但这个方法的执行速度一定要快，不然会影响到新的栈顶活动的使用。</p>
<ol start="5">
<li>onStop()</li>
</ol>
<p>这个方法在活动完全不可见的时候调用。它和 onPause() 方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么 onPause() 方法会得到执行，而 onStop() 方法并不会执行。</p>
<ol start="6">
<li>onDestroy()</li>
</ol>
<p>这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。</p>
<ol start="7">
<li>onRestart()</li>
</ol>
<p>这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。</p>
<hr>
<p>以上七个方法中除了onRestart()方法，其他都是两两相对的，从而又可以将活动分为三种生存期。</p>
<ol>
<li>完整生存期</li>
</ol>
<p>活动在 onCreate() 方法和 onDestroy() 方法之间所经历的，就是完整生存期。一般情况下，一个活动会在 onCreate() 方法中完成各种初始化操作，而在 onDestroy() 方法中完成释放内存的操作。</p>
<ol start="2">
<li>可见生存期</li>
</ol>
<p>活动在 onStart() 方法和 onStop() 方法之间所经历的，就是可见生存期。在可见生存期内，活动对于用户总是可见的，即便有可能无法和用户进行交互。我们可以通过这两个方法，合理地管理那些对用户可见的资源。比如在 onStart() 方法中对资源进行加载，而在 onStop() 方法中对资源进行释放，从而保证处于停止状态的活动不会占用过多内存。</p>
<ol start="3">
<li>前台生存期</li>
</ol>
<p>活动在 onResume() 方法和 onPause() 方法之间所经历的，就是前台生存期。在前台生存期内，活动总是处于运行状态的，此时的活动是可以和用户进行相互的，我们平时看到和接触最多的也这个状态下的活动。</p>
<h2 id="保存临时数据"><a href="#保存临时数据" class="headerlink" title="保存临时数据"></a>保存临时数据</h2><p>当一个活动进入到了停止状态，是有可能被系统回收的。Activity 中还提供了一个 onSaveInstanceState() 回调方法，这个方法会保证一定在活动被回收之前调用，因此我们可以通过这个方法来解决活动被回收时临时数据得不到保存的问题。</p>
<ol>
<li>保存临时数据</li>
</ol>
<p>onSaveInstanceState() 方法会携带一个Bundle 类型的参数，Bundle 提供了一系列的方法用于保存数据，键值对方式。如 putString()、putInt() 等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onSaveInstanceState</span><span class="params">(Bundle outState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onSaveInstanceState(outState);</span><br><span class="line">    <span class="type">String</span> <span class="variable">tempData</span> <span class="operator">=</span> <span class="string">&quot;Something you just typed&quot;</span>;</span><br><span class="line">    outState.putString(<span class="string">&quot;data_key&quot;</span>, tempData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>恢复临时数据</li>
</ol>
<p>onCreate()方法其实也有一个 Bundle 类型的参数。这个参数在一般情况下都是 null，但是当活动被系统回收之前有通过 onSaveInstanceState() 方法来保存数据的话，这个参数就会带有之前所保存的全部数据，只需要再通过相应的取值方法将数据取出即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (savedInstanceState != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tempData</span> <span class="operator">=</span> savedInstanceState.getString(<span class="string">&quot;data_key&quot;</span>);</span><br><span class="line">        Log.d(TAG, tempData);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Intent 还可以结合 Bundle 一起用于传递数据的，首先可以把需要传递的数据都保存在 Bundle 对象中，然后再将 Bundle 对象存放在 Intent 里。到了目标活动之后先从 Intent 中取出 Bundle，再从Bundle中一一取出数据。</p>
<h1 id="活动的四种启动模式"><a href="#活动的四种启动模式" class="headerlink" title="活动的四种启动模式"></a>活动的四种启动模式</h1><p>安卓中的活动（Activity）有四种不同的启动模式，这四种模式分别是：standard，SingleTop，SingleTask，SingleInstance。这四种模式中，standard模式是默认的模式，其他三个想要使用的话，要在AndroidMainFest中进行修改。(例如：<android launchMode ="singleTop">)</p>
<h2 id="standard模式："><a href="#standard模式：" class="headerlink" title="standard模式："></a>standard模式：</h2><p>系统默认的启动模式。<br>Android是使用返回栈来管理活动的，在standard模式下，每当启动一个新的活动，它就会在返回栈中入栈，并处于栈顶的位置。<br>对于使用standard模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，而是每次启动活动都会创建该活动的一个新的实例。 </p>
<h3 id="standard模式原理示意图："><a href="#standard模式原理示意图：" class="headerlink" title="standard模式原理示意图："></a>standard模式原理示意图：</h3><p><img src="https://images2015.cnblogs.com/blog/892430/201605/892430-20160525234337819-1224164299.png">  </p>
<blockquote>
<p>这是最基础的模式，在这种模式中，当你进入一个活动，这个活动就会创造一个实例，出现在返回栈的最顶层，上一个你离开的活动就会被压在下面，（注：返回栈是Android管理活动的地方，出现在界面上的活动就在最上面，再出现新的就一层层往下压。）当你无限的点击进入下一个界面，你的每一个活动都会在返回栈中往下压。如果你点击返回上一个的活动，最顶层的活动就会消失，第二层的就会上来，如果你要退出这个应用，要把返回栈中的所有活动都取消掉，才能退出。如果你用一个极端的例子，不停地从这个活动进入同一个活动，你点击了十次，就要返回十次才能退出程序，因为你在返回栈中创造了十个相同的实例，尽管活动是一样的。</p>
</blockquote>
<h2 id="SingleTop模式："><a href="#SingleTop模式：" class="headerlink" title="SingleTop模式："></a>SingleTop模式：</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">android:</span>launchMode=<span class="string">&quot;singleTop&quot;</span></span><br></pre></td></tr></table></figure>

<p>在SingleTop模式中， 会检查在返回栈栈顶是不是你要启动的活动，如果是的话，他就不会启动，直接使用。<br>所以SingleTop不会出现standard中的情况需要点击多次才能退出程序，它只需要点击一次就可以了。  </p>
<h3 id="singleTop模式原理示意图："><a href="#singleTop模式原理示意图：" class="headerlink" title="singleTop模式原理示意图："></a>singleTop模式原理示意图：</h3><p><img src="/images/Activity/892430-20160525234453803-474351507.png"></p>
<h2 id="SingleTask模式："><a href="#SingleTask模式：" class="headerlink" title="SingleTask模式："></a>SingleTask模式：</h2><p>当活动的启动模式指定为singleTask，每次启动该活动时，首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在就直接使用该实例，并把这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。  </p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">android:</span>launchMode=<span class="string">&quot;singleTask&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="singleTask原理示意图："><a href="#singleTask原理示意图：" class="headerlink" title="singleTask原理示意图："></a>singleTask原理示意图：</h3><p><img src="/images/Activity/892430-20160525234548225-112784357.png"></p>
<h2 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h2><p>这种模式是最特殊的模式，这种模式是为了让不同的app之间可以共享同一个活动，如果你的app想让别的app调用你的某一个界面，就可以用这种模式，这种模式会为你想共享的界面单独创造出一个单独使用的返回栈，不会与别的返回栈共同使用。  </p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">android:</span>launchMode=<span class="string">&quot;singleInstance&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="singleInstance模式示意图"><a href="#singleInstance模式示意图" class="headerlink" title="singleInstance模式示意图:"></a>singleInstance模式示意图:</h3><p><img src="/images/Activity/892430-20160526091149569-982478014.png"></p>
<h1 id="数据适配器"><a href="#数据适配器" class="headerlink" title="数据适配器"></a>数据适配器</h1><h2 id="什么是数据适配器？"><a href="#什么是数据适配器？" class="headerlink" title="什么是数据适配器？"></a>什么是数据适配器？</h2><p>下图展示了数据源、适配器、ListView等数据展示控件之间的关系。我们知道，数据源是各种各样的，而ListView所展示数据的格式则是有一定的要求的。数据适配器正是建立了数据源与ListView之间的适配关系，将数据源转换为ListView能够显示的数据格式，从而将数据的来源与数据的显示进行解耦，降低程序的耦合性。这也体现了Android的适配器模式的使用。对于ListView、GridView等数据展示控件有多种数据适配器，本文讲解最通用的数据适配器——BaseAdapter。<br><img src="/images/Activity/834105-20151220133119758-1793380210.jpg">  </p>
<h2 id="ListView的显示与缓存机制"><a href="#ListView的显示与缓存机制" class="headerlink" title="ListView的显示与缓存机制"></a>ListView的显示与缓存机制</h2><p>我们知道，ListView、GridView等控件可以展示大量的数据信息。假如下图中的ListView可以展示100条信息，但是屏幕的尺寸是有限的，一屏幕只能显示下图中的7条。当向上滑动ListView的时候，item1被滑出了屏幕区域，那么系统就会将item1回收到Recycler中，即View缓冲池中，而将要显示的item8则会从缓存池中取出布局文件，并重新设置好item8需要显示的数据，并放入需要显示的位置。这就是ListView的缓冲机制，总结起来就是一句话：需要时才显示，显示完就被会收到缓存。ListView，GridView等数据显示控件通过这种缓存机制可以极大的节省系统资源。<br><img src="/images/Activity/834105-20151220141452867-684265253.png">  </p>
<h2 id="BaseAdapter"><a href="#BaseAdapter" class="headerlink" title="BaseAdapter"></a>BaseAdapter</h2><p>使用BaseAdapter比较简单，主要是通过继承此类来实现BaseAdapter的四个方法：</p>
<p>public int getCount(): 适配器中数据集的数据个数；</p>
<p>public Object getItem(int position): 获取数据集中与索引对应的数据项；</p>
<p>public long getItemId(int position): 获取指定行对应的ID；</p>
<p>public View getView(int position,View convertView,ViewGroup parent): 获取没一行Item的显示内容。  </p>
<p>下面通过一个简单示例演示如何使用BaseAdapter。</p>
<p>1.创建布局文件</p>
<p>activity_main.xml  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;com.cbt.learnbaseadapter.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ListView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/lv_main&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>item.xml （ListView中每条信息的显示布局）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/iv_image&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;60dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;60dp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_title&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;30dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toEndOf</span>=<span class="string">&quot;@id/iv_image&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Title&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;25sp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toEndOf</span>=<span class="string">&quot;@id/iv_image&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">&quot;@id/tv_title&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.创建数据源</p>
<p>ItemBean.java   </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.cbt.learnbaseadapter;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by caobotao on 15/12/20.</span><br><span class="line"> */</span><br><span class="line">public class ItemBean &#123;</span><br><span class="line">    public int itemImageResId;//图像资源ID</span><br><span class="line">    public String itemTitle;//标题</span><br><span class="line">    public String itemContent;//内容</span><br><span class="line"></span><br><span class="line">    public ItemBean(int itemImageResId, String itemTitle, String itemContent) &#123;</span><br><span class="line">        this.itemImageResId = itemImageResId;</span><br><span class="line">        this.itemTitle = itemTitle;</span><br><span class="line">        this.itemContent = itemContent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>通过此Bean类，我们就将要显示的数据与ListView的布局内容一一对应了，每个Bean对象对应ListView的一条数据。这种方法在ListView中使用的非常广泛。</p>
<p>MainActivity.java  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cbt.learnbaseadapter;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.widget.ListView;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    ListView mListView ;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        List&lt;ItemBean&gt; itemBeanList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">20</span>; i ++)&#123;</span><br><span class="line">            itemBeanList.add(<span class="keyword">new</span> <span class="title class_">ItemBean</span>(R.mipmap.ic_launcher, <span class="string">&quot;标题&quot;</span> + i, <span class="string">&quot;内容&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        mListView = (ListView) findViewById(R.id.lv_main);</span><br><span class="line">        <span class="comment">//设置ListView的数据适配器</span></span><br><span class="line">        mListView.setAdapter(<span class="keyword">new</span> <span class="title class_">MyAdapter</span>(<span class="built_in">this</span>,itemBeanList));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.创建BaseAdapter</p>
<p>通过上面的讲解，我们知道继承BaseAdapter需要重新四个方法：getCount、getItem、getItemId、getView。其中前三个都比较简单，而getView稍微比较复杂。通常重写getView有三种方式，这三种方法性能方面有很大的不同。接下来我们使用此三种方式分别实现MyAdapter。<br>第一种：逗比式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cbt.learnbaseadapter;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.view.*;</span><br><span class="line"><span class="keyword">import</span> android.widget.BaseAdapter;</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by caobotao on 15/12/20.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdapter</span> <span class="keyword">extends</span> <span class="title class_">BaseAdapter</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ItemBean&gt; mList;<span class="comment">//数据源</span></span><br><span class="line">    <span class="keyword">private</span> LayoutInflater mInflater;<span class="comment">//布局装载器对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造方法将数据源与数据适配器关联起来</span></span><br><span class="line">    <span class="comment">// context:要使用当前的Adapter的界面对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAdapter</span><span class="params">(Context context, List&lt;ItemBean&gt; list)</span> &#123;</span><br><span class="line">        mList = list;</span><br><span class="line">        mInflater = LayoutInflater.from(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//ListView需要显示的数据数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//指定的索引对应的数据项</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getItem</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mList.get(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//指定的索引对应的数据项ID</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getItemId</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//返回每一项的显示内容</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">getView</span><span class="params">(<span class="type">int</span> position, View convertView, ViewGroup parent)</span> &#123;</span><br><span class="line">        <span class="comment">//将布局文件转化为View对象</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> mInflater.inflate(R.layout.item,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 找到item布局文件中对应的控件 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ImageView</span> <span class="variable">imageView</span> <span class="operator">=</span> (ImageView) view.findViewById(R.id.iv_image);</span><br><span class="line">        <span class="type">TextView</span> <span class="variable">titleTextView</span> <span class="operator">=</span> (TextView) view.findViewById(R.id.tv_title);</span><br><span class="line">        <span class="type">TextView</span> <span class="variable">contentTextView</span> <span class="operator">=</span> (TextView) view.findViewById(R.id.tv_content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取相应索引的ItemBean对象</span></span><br><span class="line">        <span class="type">ItemBean</span> <span class="variable">bean</span> <span class="operator">=</span> mList.get(position);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置控件的对应属性值 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        imageView.setImageResource(bean.itemImageResId);</span><br><span class="line">        titleTextView.setText(bean.itemTitle);</span><br><span class="line">        contentTextView.setText(bean.itemContent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么称这种getView的方式是逗比式呢？</p>
<p>通过上面讲解，我们知道ListView、GridView等数据展示控件有缓存机制，而这种方式每次调用getView时都是通过inflate创建一个新的View对象，然后在此view中通过findViewById找到对应的控件，完全没有利用到ListView的缓存机制。这种方式没有经过优化处理，对资源造成了极大的浪费，效率是很低的。<br>第二种：普通式  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> View <span class="title function_">getView</span><span class="params">(<span class="type">int</span> position, View convertView, ViewGroup parent)</span> &#123;<span class="comment">//如果view未被实例化过，缓存池中没有对应的缓存</span></span><br><span class="line">        <span class="keyword">if</span> (convertView == <span class="literal">null</span>) &#123;</span><br><span class="line">            convertView = mInflater.inflate(R.layout.item,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 找到item布局文件中对应的控件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ImageView</span> <span class="variable">imageView</span> <span class="operator">=</span> (ImageView) convertView.findViewById(R.id.iv_image);</span><br><span class="line">        <span class="type">TextView</span> <span class="variable">titleTextView</span> <span class="operator">=</span> (TextView) convertView.findViewById(R.id.tv_title);</span><br><span class="line">        <span class="type">TextView</span> <span class="variable">contentTextView</span> <span class="operator">=</span> (TextView) convertView.findViewById(R.id.tv_content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取相应索引的ItemBean对象</span></span><br><span class="line">        <span class="type">ItemBean</span> <span class="variable">bean</span> <span class="operator">=</span> mList.get(position);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置控件的对应属性值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        imageView.setImageResource(bean.itemImageResId);</span><br><span class="line">        titleTextView.setText(bean.itemTitle);</span><br><span class="line">        contentTextView.setText(bean.itemContent);</span><br><span class="line">        <span class="keyword">return</span> convertView;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此方式充分使用了ListView的缓存机制，如果view没有缓存才创建新的view，效率相比于逗比式提升了很多。但是，当ListView很复杂时，每次调用findViewById都会去遍历视图树，所以findViewById是很消耗时间的，我们应该尽量避免使用findViewById来达到进一步优化的目的。<br>第三种：文艺式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> View <span class="title function_">getView</span><span class="params">(<span class="type">int</span> position, View convertView, ViewGroup parent)</span> &#123;</span><br><span class="line">    ViewHolder viewHolder;</span><br><span class="line">    <span class="comment">//如果view未被实例化过，缓存池中没有对应的缓存</span></span><br><span class="line">    <span class="keyword">if</span> (convertView == <span class="literal">null</span>) &#123;</span><br><span class="line">        viewHolder = <span class="keyword">new</span> <span class="title class_">ViewHolder</span>();</span><br><span class="line">        <span class="comment">// 由于我们只需要将XML转化为View，并不涉及到具体的布局，所以第二个参数通常设置为null</span></span><br><span class="line">        convertView = mInflater.inflate(R.layout.item, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对viewHolder的属性进行赋值</span></span><br><span class="line">        viewHolder.imageView = (ImageView) convertView.findViewById(R.id.iv_image);</span><br><span class="line">        viewHolder.title = (TextView) convertView.findViewById(R.id.tv_title);</span><br><span class="line">        viewHolder.content = (TextView) convertView.findViewById(R.id.tv_content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过setTag将convertView与viewHolder关联</span></span><br><span class="line">        convertView.setTag(viewHolder);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果缓存池中有对应的view缓存，则直接通过getTag取出viewHolder</span></span><br><span class="line">        viewHolder = (ViewHolder) convertView.getTag();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取出bean对象</span></span><br><span class="line">    <span class="type">ItemBean</span> <span class="variable">bean</span> <span class="operator">=</span> mList.get(position);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置控件的数据</span></span><br><span class="line">    viewHolder.imageView.setImageResource(bean.itemImageResId);</span><br><span class="line">    viewHolder.title.setText(bean.itemTitle);</span><br><span class="line">    viewHolder.content.setText(bean.itemContent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> convertView;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ViewHolder用于缓存控件，三个属性分别对应item布局文件的三个控件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ViewHolder</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ImageView imageView;</span><br><span class="line">    <span class="keyword">public</span> TextView title;</span><br><span class="line">    <span class="keyword">public</span> TextView content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方式不仅利用了ListView的缓存机制，而且使用ViewHolder类来实现显示数据视图的缓存，避免多次调用findViewById来寻找控件，以达到优化程序的目的。所以，大家在平时的开发中应当尽量使用这种方式进行getView的实现。</p>
<p>总结一下用ViewHolder优化BaseAdapter的整体步骤：</p>
<blockquote>
<p>1 创建bean对象，用于封装数据；</p>
</blockquote>
<blockquote>
<p>2 在构造方法中初始化的数据List；</p>
</blockquote>
<blockquote>
<p>3 创建ViewHolder类，创建布局映射关系；</p>
</blockquote>
<blockquote>
<p>4 判断convertView，为空则创建，并设置tag，不为空则通过tag取出ViewHolder；</p>
</blockquote>
<blockquote>
<p>5 给ViewHolder的控件设置数据。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/01/02/Algorithm_%E6%9C%80%E5%A4%A7%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/02/Algorithm_%E6%9C%80%E5%A4%A7%E6%B5%81/" class="post-title-link" itemprop="url">最大流</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-02 15:49:10" itemprop="dateCreated datePublished" datetime="2020-01-02T15:49:10Z">2020-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1><p>有一个源结点和一个汇点，从源结点向汇点“运输”货物。在不违反任何路径容量限制的条件下，从源结点到汇点运送货物的最大速率是多少——这一问题的抽象称为最大流问题</p>
<p>流具有三个需要注意的点！！</p>
<p>1、对于图中非s和t的普通结点，流进量等于流出量</p>
<p>2、我们非常关心总运输流量，比如这个下水道系统，究竟从s点到t点最多能运输多少立方米的水？我们把它记成|f|，这个|f|极其重要，是我们研究的目的所在。</p>
<p>3、当然，每条边是有运输上限的，就像某条公路车流是有上限的一样，若运输量无穷无尽，我们的研究也就没有意义了。我们将从u点到v点的运输上限，或者说是运载能力记为c(u,v)。对于从u点到v点的流量，记作f(u,v)。显然对所有边(u,v)我们有f(u,v)&lt;&#x3D;c(u,v)。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_41613352/article/details/84481115">参考文章</a></p>
<h2 id="流网络"><a href="#流网络" class="headerlink" title="流网络"></a>流网络</h2><p>流网络G&#x3D;(V,E)是一个有向图，其中每条边(u,v)∈E均有一个非负能量c(u,v)≥0。如果(u,v)∉E，则假定c(u,v)&#x3D;0。流网络中有两个特点的顶点，源点s和汇点t，假定每个顶点均处于从源点到汇点的某条路径上，就是说，对每个顶点v∈V，存在一条路径s-&gt;v-&gt;t，因此图G是连通图，且|E|≥|V|-1。</p>
<blockquote>
<p>带权有向图：网络</p>
<p>结点：表示城市</p>
<p>有向边：表示运输路径和物流的方向</p>
<p>权重：表示运量限制</p>
<p>流：一条从源点到汇点的路径即路径上的流量——这种用来表示”流（flow）”的图称为“流网络”</p>
</blockquote>
<p>流网络遵循以下基本性质：</p>
<p>（1）流量守恒：除源结点和汇点外，其它结点上物料只是“流过”，即物料进入的速率等于离开的速率；</p>
<p>（2）物料的生成速率和接收速率恒定且足够快、足够多，满足需要（包括源结点的输出和所有结点的输入）；</p>
<p>（3）每条边上的容量是物料通过该边的最大速率，不能突破</p>
<p>流网络是一个有向图，边上定义有容量函数c：</p>
<p>(1) 有一个源结点s和汇点t；</p>
<p>(2) 有向边表示流向；</p>
<p>(3) 每条边上有一个非负的容量值；如果(u,v)∉E，则假定c(u,v)&#x3D;0；</p>
<p>(4) <strong>如果边集合E中包含（u，v）边，则图中不包含其反向边（u，v）</strong>；</p>
<p>(5) <strong>图中不允许有自循环</strong>；</p>
<p>(6) <strong>流网络是连通图</strong>，每个结点都在从s到t的某条路径上；</p>
<p>(7) 除源结点外，每个结点至少有一条流入的边；</p>
<p>(8) 除汇点外，每个结点至少有一条流出的边；</p>
<p>(9)  |E|&gt;&#x3D;|V|-1</p>
<p><strong>标准流网络</strong>：</p>
<p>(1)无反向边：也称为反向平行边。一个有向图中，（v，u）、（u，v）互为反向平行边</p>
<p>(2)只有单一的源结点和汇点。</p>
<p><strong>非标准流网络</strong>：</p>
<p>不满足上述要求的流网络是非标准的流网络。对于非标准的流网络可转化为标准流网络。</p>
<p>方法：</p>
<p>1）添加反向平行边</p>
<p><img src="https://i.loli.net/2021/01/17/s4Bl8YnIGwTZqb6.png"></p>
<p>2）多个源结点和多个汇点。加入一个超级源结点s。加入一个超级汇点t。</p>
<p><img src="https://i.loli.net/2021/01/17/bCp7QITLk52jDuq.png"></p>
<h2 id="Ford-Fulkerson方法"><a href="#Ford-Fulkerson方法" class="headerlink" title="Ford-Fulkerson方法"></a>Ford-Fulkerson方法</h2><p>通过不断增加可行流值的方式找到最大流：</p>
<p>（1）从流值为0的初始流开始；</p>
<p>（2）通过某种方法，对流值进行增加；</p>
<p>（3）当确认无法再增加流值时，就得到最大流；</p>
<p>首先这个算法有个重要的工具：残存网络。残存网络其实就是具有残存容量的图。算法导论上有个普遍公式来定义残存容量：<img src="https://i.loli.net/2021/01/17/JB9SVNoyeTqkrWs.png"></p>
<p>翻译一下公式，说明的就是对于两点间的残存容量定义为：<br>1.如果这两点连线原来就是原图的边，那么它的残存容量等于运载上限-运输流量。（<strong>就是目前你还能增加的流量的量</strong>）<br>2.如果这两点的反向连线是原图的边，那么它的残存容量等于那条边的运输流量。（<strong>表示目前用的运输流量，一旦该运输流量等于运载上限，运算结束</strong>）<br>3.其他情况是0，当做没连通。</p>
<p>接下来我们看看残存网络对我们的<strong>帮助</strong>：<br>1.残存网络中没有从s到t的路径时，最大流等于最小割容量。（<strong>没有路径就说明s到t的连线有一段已经达到了最大运载上限了，就是残存容量为0</strong>）<br>2.残存网络中有从s到t的路径时，最大流不等于最小割容量。</p>
<h2 id="最大流算法应用：寻找最大二分匹配"><a href="#最大流算法应用：寻找最大二分匹配" class="headerlink" title="最大流算法应用：寻找最大二分匹配"></a>最大流算法应用：寻找最大二分匹配</h2><p><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/242142">https://yq.aliyun.com/articles/242142</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/01/02/Algorithm_%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E5%AF%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/02/Algorithm_%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E5%AF%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" class="post-title-link" itemprop="url">所有结点对的最短路径</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-02 15:49:00" itemprop="dateCreated datePublished" datetime="2020-01-02T15:49:00Z">2020-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="所有结点对的最短路径"><a href="#所有结点对的最短路径" class="headerlink" title="所有结点对的最短路径"></a>所有结点对的最短路径</h1><p><strong>问题</strong>：有一个带权有向图 G &#x3D; (V, E)，V 为图的顶点集合，E 为边的集合，权重函数为 w：E → R，该函数将边映射到实数值上。我们希望找到，对于所有结点对 u，v∈V，一条从结点 u 到结点 v 的最短路径，使得结点 u 到结点 v 的路径所有边的权重之和最小。</p>
<p>简单来说，我们考虑的问题是<strong>如何找到一个图中所有结点之间的最短路径</strong>。</p>
<p>用单源最短路径算法求解：<br>执行|V|次单源最短路径算法，每次使用一个不同的结点作为源点，从而可以求出每个结点到其他所有结点的最短路径。</p>
<ul>
<li>如果所有的边的权重为非负值，用Dijkstra算法：<ul>
<li>用线性数组实现最小优先队列：O(V^3^+VE)&#x3D;O(V^3^);</li>
<li>用二叉堆实现最小优先队列：O(VElgV)；（对稀疏图较好）</li>
<li>用斐波那契堆实现最小优先队列：O(V^2^lgV+VE)；</li>
</ul>
</li>
<li>如果有权重为负值边，用Bellman-Ford算法：<ul>
<li>一般的运行时间：O(V^2^E);</li>
<li>对稠密图，运行时间为O(V^4^)。</li>
</ul>
</li>
</ul>
<p><strong>允许存在权重为负值的边，但不能包含权重为负值的环路</strong></p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵是表示一个图的常用存储表示。它用两个数组分别存储数据元素（顶点）的信息和数据元素之间的关系（边或弧）的信息。<br>$$<br>W_{ij}&#x3D;\begin{cases}0 &amp;&amp;&amp;&amp;&amp;&amp;if&amp;i&#x3D;j\有向边（i，j）的权重 &amp;&amp;&amp;&amp;&amp;&amp;if&amp;i\not&#x3D;j&amp;and(i,j)\in E\NIL &amp;&amp;&amp;&amp;&amp;&amp;if&amp;i\not&#x3D;j&amp;and(i,j)\notin E\\end{cases}<br>$$</p>
<h3 id="最短路径和矩阵乘法"><a href="#最短路径和矩阵乘法" class="headerlink" title="最短路径和矩阵乘法"></a>最短路径和矩阵乘法</h3><h4 id="步骤一：分析最优解结构"><a href="#步骤一：分析最优解结构" class="headerlink" title="步骤一：分析最优解结构"></a>步骤一：分析最优解结构</h4><p>一条最短路径的所有子路径都是最短路径</p>
<p><strong>每条路径都是最短路径</strong></p>
<h4 id="步骤二：所有结点对最短路径的递归解"><a href="#步骤二：所有结点对最短路径的递归解" class="headerlink" title="步骤二：所有结点对最短路径的递归解"></a>步骤二：所有结点对最短路径的递归解</h4><p>设<img src="/images/%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E5%AF%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/20180611225358746" style="zoom: 33%;" />为从i到j的一条最短路径，且这条路径最多包含m条边。我们可以得到以下的递推公式：</p>
<img src="/images/%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E5%AF%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/2018061122580795-1578384535707" style="zoom: 50%;" />

<p>如果图G不包含权重为负值的环路，则对于每一对结点i和j，如果δ(i,j)&lt;∞，则从i到j之间存在一条最短路径。并且，由于最短路径是简单路径，其中至多包含n-1条边，因此有：</p>
<img src="/images/%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E5%AF%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/image-20200107161153382.png" style="zoom: 67%;" />

<h4 id="步骤三：自底向上计算最短路径权重"><a href="#步骤三：自底向上计算最短路径权重" class="headerlink" title="步骤三：自底向上计算最短路径权重"></a>步骤三：自底向上计算最短路径权重</h4><h4 id="步骤三改进：重复平方"><a href="#步骤三改进：重复平方" class="headerlink" title="步骤三改进：重复平方"></a>步骤三改进：重复平方</h4><h4 id="步骤四：构建最优解"><a href="#步骤四：构建最优解" class="headerlink" title="步骤四：构建最优解"></a>步骤四：构建最优解</h4><h2 id="计算最短路径权重-Floyd-Warshall-算法"><a href="#计算最短路径权重-Floyd-Warshall-算法" class="headerlink" title="计算最短路径权重 - Floyd-Warshall 算法"></a>计算最短路径权重 - Floyd-Warshall 算法</h2><p><strong>采取的是动态规划策略</strong></p>
<p><strong>算法的时间复杂度Θ(V^3^)。</strong></p>
<p><strong>算法允许图中存在负权重的边，但不能存在权重为负值的环路</strong></p>
<p>Floyd 算法考虑的是<em>一条路径上的中间结点</em>。对于任意结点对 i，j∈V，考虑从结点 i 到结点 j 的所有中间结点均取自集合 {1, 2, …, k} 的路径（该集合是 V &#x3D;{1,2,3·····,n}的一个子集），并且设 p 为最短路径。</p>
<p>含义：</p>
<ul>
<li><p>p是简单路径，且p的中间结点都不大于k。</p>
</li>
<li><p>p从i到j，仅经过集合{1,2,…,k}中的结点，但，</p>
<ul>
<li>不一定经过其中的每一个结点，且与顺序无关；</li>
<li>也可能不存在这样的路径，此时p的权重等于∞</li>
</ul>
</li>
</ul>
<blockquote>
<p>从任意节点i到任意节点j的最短路径不外乎2种可能，1是直接从i到j，2是从i经过若干个节点k到j。所以，算法假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，算法检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j)是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，便设置Dis(i,j) &#x3D; Dis(i,k) + Dis(k,j)，这样一来，当遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。</p>
</blockquote>
<p>有两种情况：</p>
<ul>
<li>如果结点 k 不是路径 p 上的中间结点，则路径 p 上的所有中间结点都属于集合 {1, 2, …, k - 1}。</li>
<li>如果结点 k 是路径 p 上的中间结点，则可将路径 p 分解为两条路径，分别是结点 i 到结点 k 和结点 k 到结点 j 的路径。</li>
</ul>
<p>简单来说，就是中间结点选自集合 {1，2，…，k - 1} 的时候的所有结点对的最短路径权重已经知道了，接下来的考虑的中间结点从集合 1，2，…，k - 1，k} 选的时候最短路径权重是多少，只需要考虑路径经过结点 k 的时候权重变化就行了，k 可将 i 到 j 的路径分为两条路径，分别是结点 i 到结点 k 和结点 k 到结点 j 的路径，而这两个的最短路径权重已经知道的（i 到 k 的最短路径的中间结点只能从集合 {1，2，…，k - 1} 选），同理 k 到 j），所以最新的权重选择经过 k 与不经过 k 时的权重较小的那个就行。</p>
<h3 id="递归解"><a href="#递归解" class="headerlink" title="递归解"></a>递归解</h3><p>设$$d^{(k)}_{ij}$$表示从结点 i 到结点 j 的所有中间结点全部取自集合 {1，2，…，k} 的一条最短路径的权重。</p>
<p>k &#x3D; 0 时，表示结点 i 到结点 j 的路径没有任何中间结点，因此$$d^{(0)}<em>{ij} &#x3D; w</em>{ij} $$。</p>
<p>状态转移方程：<br>$$<br>d^{(k)}<em>{ij} &#x3D; \begin{cases} w</em>{ij} &amp;  \text {if $k &#x3D; 0$} \min(d^{(k-1)}<em>{ij}, d^{(k-1)}</em>{ik}+ d^{(k-1)}_{kj}) &amp;  \text {if $k\geq1$  }\end{cases}<br>$$</p>
<p>而因为任何路径的中间结点都属于集合{1,2,…,n}，所以k&#x3D;n时，$$d^{(n)}_{ij}$$给出所有可能的从结点i到结点j的中间结点均取自集合{1,2,…,n}的一条最短路径的权重，也就是从结点i到结点j的最短路径的权重。</p>
<p>所以对所有的$$i,j\in V$$,有：<br>$$<br>d^{(n)}_{ij}&#x3D;δ(i,j)<br>$$</p>
<h3 id="自底向上计算最短路径权重"><a href="#自底向上计算最短路径权重" class="headerlink" title="自底向上计算最短路径权重"></a>自底向上计算最短路径权重</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">floyd</span><span class="params">(Graph G, <span class="type">int</span> dist)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//vexnum表示图G的顶点数</span></span><br><span class="line">    <span class="comment">// 计算最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; G.vexnum; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果经过下标为k顶点路径比原两点间路径更短，则更新dist[i][j]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> (dist[i][k] + dist[k][j]);</span><br><span class="line">                <span class="keyword">if</span> (dist[i][j] &gt; tmp)</span><br><span class="line">                &#123;</span><br><span class="line">                    dist[i][j] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="构建最短路径"><a href="#构建最短路径" class="headerlink" title="构建最短路径"></a>构建最短路径</h3><p>思路：给定一个前驱矩阵 $$\prod$$，再利用递归的思想即可输出结点 i 到结点 j 的最短路径。</p>
<p><strong>前驱矩阵</strong></p>
<blockquote>
<p>定义：给出的是从结点 i 到结点 j 的最短路径上结点 j 的前驱结点，i&#x3D;j 或者从 i 到 j 不存在路径时为 NIL。</p>
</blockquote>
<p>$$\pi^{(k)}_{ij}$$为从结点i到结点j的一条所有中间结点都取自集合{1,2, …, k}的最短路径上j的前驱结点。</p>
<p><strong>怎么得到前驱矩阵？</strong>一种方法是计算权重矩阵 dist 的同时计算前驱矩阵 ∏。具体来说，与 floyd 算法思路类似，分为两种情况：<br>当 k &#x3D; 0 时，从 i 到 j 的最短路径没有中间结点，所以，<br>$$<br>\pi^{(0)}<em>{ij} &#x3D; \begin{cases} NIL &amp;  \text {if $i &#x3D; j\ or\ w</em>{ij} &#x3D; NIL$ } \i &amp;  \text {if $i \ne j\ or\ w_{ij} &lt; NIL$ }\end{cases}<br>$$<br>当 k≥1时<br>$$<br>\pi^{(k)}<em>{ij} &#x3D; \begin{cases}\pi^{(k-1)}<em>{ij}  &amp;  \text {if $d^{(k-1)}</em>{ij} \leq d^{(k-1)}<em>{ik} + d^{(k-1)}</em>{kj}$ } \ \pi^{(k-1)}<em>{kj} &amp;  \text {if $d^{(k-1)}</em>{ij} &gt; d^{(k-1)}</em>{ik} + d^{(k-1)}_{kj}$ }\end{cases}<br>$$</p>
<blockquote>
<p>若不经过k：</p>
<p>此时求从结点i到结点j的所有中间结点都取自集合{1,2,…,k}的最短路径上的j的前驱等价于求从结点i到结点j的所有中间结点都取自集合{1,2,…,k-1}的最短路径上的j的前驱。</p>
<p>若经过k：</p>
<p>此时求从结点i到结点j的所有中间结点都取自集合{1,2,…,k}的最短路径上的j的前驱等价于求从结点k到结点j的所有中间结点都取自集合{1,2,…,k-1}的最短路径上的j的前驱。</p>
</blockquote>
<p><img src="/images/%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E5%AF%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/image-20200107170608073.png"></p>
<p><img src="/images/%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E5%AF%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/image-20200107170623559.png"></p>
<h2 id="用于稀疏图的Johnson算法"><a href="#用于稀疏图的Johnson算法" class="headerlink" title="用于稀疏图的Johnson算法"></a>用于稀疏图的Johnson算法</h2><p>在稀疏图中求每对结点之间的最短路径权重。</p>
<p>对稀疏图，Johnson算法优于Floyd-Warshall算法，时间复杂度可达O(V^2^lgV+VE)。</p>
<ol>
<li>Johnson算法使用的方式相当于给每个边都加了一个权重，使得所有边都为非负数，这样就能对每个边使用较为高效的Dijkstra算法。</li>
<li>注意的是不能简单的给每个边加相同的值然后使得所有边都变成非负数，原因为假设从a-&gt;b有两条路径，一条权重为1+1，一条为2，本应权重和相等；如果都加1，则变成了2+2和3，不一致了，就会导致更新了不该更新的边。</li>
<li>Johnson比较巧妙的引入了h函数来解决这个问题，通过这个函数进行每个边的重新赋值权重</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/36bbe0e86765">参考文章</a></p>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ol>
<li>给定图 G &#x3D; (V, E)，增加一个新的顶点 s，使 s 指向图 G 中的所有顶点都建立连接，设新的图为 G’；</li>
<li>对图 G’ 中顶点 s 使用 Bellman-Ford 算法计算单源最短路径，得到结果 h[] &#x3D; {h[0], h[1], .. h[V-1]}；</li>
<li>对原图 G 中的所有边进行 “re-weight”，即对于每个边 (u, v)，其新的权值为 w(u, v) + (h[u] - h[v])；</li>
<li>移除新增的顶点 s，对每个顶点运行 Dijkstra 算法求得最短路径；</li>
</ol>
<h3 id="算法证明"><a href="#算法证明" class="headerlink" title="算法证明"></a>算法证明</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/01/02/Algorithm_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/02/Algorithm_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" class="post-title-link" itemprop="url">最小生成树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-02 15:48:32" itemprop="dateCreated datePublished" datetime="2020-01-02T15:48:32Z">2020-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>关于图的几个概念定义：</p>
<ul>
<li><strong>连通图</strong>：在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。</li>
<li><strong>强连通图</strong>：在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。</li>
<li><strong>连通网</strong>：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。</li>
<li><strong>生成树</strong>：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。</li>
<li><strong>最小生成树</strong>：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。</li>
</ul>
<p><strong>最小生成树并不一定唯一</strong></p>
<h2 id="最小生成树的形成"><a href="#最小生成树的形成" class="headerlink" title="最小生成树的形成"></a>最小生成树的形成</h2><h3 id="MST性质"><a href="#MST性质" class="headerlink" title="MST性质"></a>MST性质</h3><p>假设N &#x3D; （V，{ E }）是一个连通网，U 是顶点集V的一个非空子集。若（u , v ）是一条具有最小权值（代价）的边，其中u∈U， v∈V - U，则必存在一棵包含边（u，v）的最小生成树。</p>
<p><strong>证明：</strong></p>
<p>剪枝-粘贴法</p>
<p>假设网N的任何一棵最小生成树都不包含（u，v）。设T是连通网上的一棵最小生成树，当将边（u，v）加入到T中时，由生成树的定义，T中必存在一条包含（u，v)的回路。另一方面，由于T是生成树，则在T上必存在另一条边（u’，v’），其中u’∈U，v’∈V - U，且u和u’之间，v和v’之间均有路径相通。删去边（u’，v’），便可消除上述回路，同时得到另一棵生成树T’。因为（u，v）的代价不高于（u’，v’），则T’的代价亦不高于T，T’是包含（u，v）的一棵最小生成树，和假设矛盾。</p>
<h3 id="贪心策略设计（MST性质）"><a href="#贪心策略设计（MST性质）" class="headerlink" title="贪心策略设计（MST性质）"></a>贪心策略设计（MST性质）</h3><p>每个时刻，该方法生长最小生成树的一条边，并在整个策略的实施过程中，管理一个遵守下述循环不变式的边的集合A：<strong>在每遍循环之前，A是某棵最小生成树的一个子集。</strong></p>
<p>循环不变式：在每遍循环之前，A是某棵最小生成树的一个子集。</p>
<p>处理策略：每一步，我们选择一条边不违反循环不变式的边(u,v)加入集合A，即A∪{(u,v)}仍是某棵最小生成树的子集。</p>
<p>这样的边称为“安全边”，因为在集合A中加入它不会破坏A的循环不变式。</p>
<h2 id="Kruskal算法（贪心算法）"><a href="#Kruskal算法（贪心算法）" class="headerlink" title="Kruskal算法（贪心算法）"></a>Kruskal算法（贪心算法）</h2><p>初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。 </p>
<ol>
<li>把图中的所有边按代价从小到大排序； </li>
<li>把图中的n个顶点看成独立的n棵树组成的森林； </li>
<li>按权值从小到大选择边，所选的边连接的两个顶点u<del>i</del>,v<del>i</del>（u<del>i</del>,v<del>i</del>,应属于两颗不同的树），则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 </li>
<li>重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。</li>
<li><strong>注意：不能生成环</strong></li>
</ol>
<p> <img src="/images/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/20160714144315409"></p>
<p>Kruskal算法的时间为：O(E lgE)。</p>
<p>如果再注意到|E|&lt;|V|2，则有lg|E|&#x3D;O(lgV)，所以Kruskal算法的时间可表示为O(E lgV)。</p>
<h2 id="Prim算法（贪心算法）"><a href="#Prim算法（贪心算法）" class="headerlink" title="Prim算法（贪心算法）"></a>Prim算法（贪心算法）</h2><p>此算法可以称为“加点法”，每次迭代选择代价最小的边（已经加到最小生成树的点可以连接的边中选择）对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。</p>
<ol>
<li>图的所有顶点集合为V；初始令集合u&#x3D;{s},v&#x3D;V−u;</li>
<li>在两个集合u,v能够组成的边中，选择一条代价最小的边(u<del>0</del>,v<del>0</del>)，加入到最小生成树中，并把v<del>0</del>并入到集合u中。</li>
<li>重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。</li>
<li><strong>注意不能生成环</strong></li>
</ol>
<p>由于不断向集合u中加点，所以最小代价边必须同步更新；需要建立一个辅助数组closedge,用来维护集合v中每个顶点与集合u中最小代价边信息，</p>
<p><img src="/images/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/20160714161107576"></p>
<p>Prim算法的运行时间依赖于最小优先队列Q的具体实现。</p>
<p>可用二叉最小优先队列的方式实现。</p>
<p>每次EXTRACT-MIN的时间是O(lgV)。</p>
<p>EXTRACT-MIN的总时间是O(V lgV)。</p>
<p>其它时间：第11行的赋值操作共需O(E lgV)。</p>
<p>Prim算法的时间为：O(V lgV+E lgV)&#x3D;O(E lgV)。</p>
<p>从渐进意义上看，Kruskal和Prim算法具有相同的运行时间</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/01/02/Algorithm_%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%9B%BE%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/02/Algorithm_%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%9B%BE%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">基本的图算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-02 15:48:19" itemprop="dateCreated datePublished" datetime="2020-01-02T15:48:19Z">2020-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="图检索算法"><a href="#图检索算法" class="headerlink" title="图检索算法"></a>图检索算法</h1><h2 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h2><p><a href="cnblogs.com/xiaoyh/p/10411762.html">原文链接</a></p>
<p>对于图G&#x3D;（V，E）借助数组存储的方法有邻接矩阵表示法和邻接表表示法，边集表示法。</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>图的邻接矩阵（adjacent matrix）表示法是使用数组来存储图结构的方法，也被称为数组表示法。 它采用两个数组来表示图：一个是用于存储所有顶点信息的一维数组，另一个是用于存储图中顶点之间关联关系的二维数组，这个关联关系数组也被称为邻接矩阵。</p>
<p><img src="https://i.loli.net/2021/08/12/CNJ7UDyAsajngEo.png"></p>
<p><img src="https://i.loli.net/2021/08/12/xBY1f62s5nIUjuh.png"></p>
<p>邻接矩阵有如下特性：</p>
<ul>
<li>图中各顶点序号确定后，图的邻接矩阵是唯一确定的。</li>
<li>无向图和无向网的邻接矩阵是一个对称矩阵。</li>
<li>无向图邻接矩阵中第i行或第i列的非0元素个数即为第i个顶点的度。</li>
<li>有向图邻接矩阵第i行非0元素个数为第i个顶点的出度，第i列非0元素个数为第i个顶点的入度，第i个顶点的度为第i行与第i列非0元素个数之和。</li>
<li>无向图的边数等于邻接矩阵中非0元素个数之和的一半，有向图的弧数等于邻接矩阵中非0元素个数之和。</li>
<li>除完全图外，其他图的邻接矩阵有许多零元素，特别是当n值较大，而边数相对完全图的边n-1又少的多时，则此矩阵称为稀疏矩阵，非常浪费存储空间。</li>
</ul>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表（adjacency list）是图的一种链式存储方法，邻接表表示法类似于树的孩子链表表示法。</p>
<p>　　在邻接表中对于图G中的每个顶点v<del>i</del>建立一个单链表，将所有邻接于v<del>i</del>的顶点v<del>j</del>链成一个单链表，并在表头附设一个表头结点，这个单链表就称为顶点v<del>i</del>的邻接表。</p>
<p>邻接表中共有两种结点结构，分别是边表结点和表头结点。</p>
<p>　　<img src="https://i.loli.net/2021/08/12/qA9kpoL3TJOjVim.png"></p>
<p>邻接表中的每一个结点均包含有两个域：邻接点域和指针域。</p>
<ul>
<li>邻接点域用于存放与定点vi相邻接的一个顶点的序号。</li>
<li>指针域用于指向下一个边表结点。</li>
</ul>
<p>边表结点由3个域组成：</p>
<ul>
<li>邻接点域（adjvex）指示与定点v<del>i</del>邻接的顶点在图中的位置。</li>
<li>链域（nextdge）指向下一条边所在的结点。</li>
<li>数据域（info）存储和边有关的信息。</li>
</ul>
<p>头结点由2个域组成：</p>
<ul>
<li>链域（firstedge）指向链表中的第一个结点之外。</li>
<li>数据域（data）存储顶点相关信息。</li>
</ul>
<p>如下图为邻接表的存储示例：</p>
<p>　　<img src="https://i.loli.net/2021/08/12/PkLCSdMaGp4TtlQ.png"></p>
<p>在无向图的邻接表中，顶点的每一个边表结点对应于与顶点相关联的一条边。</p>
<p>在有向图的邻接表中，顶点的每一个边表结点对应于<strong>以顶点为始点的一条弧</strong>，因此也称有向图的邻接表的边表为出边表。</p>
<p>在有向图的邻接表中，将顶点的每个边表结点对应于以顶点为重点的一条弧，即用便捷点的邻接点域存储邻接到顶点的序号，由此构成的邻接表称为有向图的逆邻接表，逆邻接表有边表称为入边表。</p>
<p>邻接表的性质如下：</p>
<ul>
<li>图的邻接表表示不是惟一的，它与表结点的链入次序有关。</li>
<li>无向图的邻接表中第i个边表的结点个数即为第i个顶点的度。</li>
<li>有向图的邻接表中第i个出边表的结点个数即为第i个结点的出度，有向图的逆邻接表中第i个入边表的结点个数即为第i个结点的入度。</li>
<li>无向图的边数等于邻接表中边表结点数的一半，有向图的弧数等于邻接表（逆邻接表）中出边表结点（入边表结点）的数目。</li>
</ul>
<p>需要说明的是：</p>
<ul>
<li>在邻接表的每个线性链接表中各结点的顺序是任意的。</li>
<li>邻接表中的各个线性链接表不说明他们顶点之间的邻接关系。</li>
<li>对于无向图，某顶点的度数&#x3D;该顶点对应的线性链表的结点数。</li>
<li>对于有向图，某顶点的“出度”数&#x3D;该顶点对应的线性链表的结点数；求某顶点的“入度”需要对整个邻接表的各链接扫描一遍，看有多少与该顶点相同的结点，相同结点数之和即为“入度”值。</li>
</ul>
<p>邻接表与邻接矩阵的关系如下：</p>
<ul>
<li>对应于邻接矩阵的每一行有一个线形连接表；</li>
<li>链接表的表头对应着邻接矩阵该行的顶点；</li>
<li>链接表中的每个结点对应着邻接矩阵中该行的一个非零元素；</li>
<li>对于无向图，一个非零元素表示与该行顶点相邻接的另一个顶点；</li>
<li>对于有向图，非零元素则表示以该行顶点为起点的一条边的终点。</li>
</ul>
<h2 id="宽度（广度）优先检索BFS"><a href="#宽度（广度）优先检索BFS" class="headerlink" title="宽度（广度）优先检索BFS"></a>宽度（广度）优先检索BFS</h2><p>广度优先搜索类似于树的<strong>层次遍历</strong>。从图中的某一顶点出发，遍历每一个顶点时，依次遍历其所有的邻接点，然后再从这些邻接点出发，同样依次访问它们的邻接点。按照此过程，直到图中所有被访问过的顶点的邻接点都被访问到。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p><strong>广度优先遍历背后基于队列</strong>，下面介绍一下具体实现的方法：</p>
<ol>
<li><p>访问起始顶点，并将插入队列；</p>
</li>
<li><p>从队列中删除队头顶点，将与其相邻的未被访问的顶点插入队列中；</p>
</li>
<li><p>重复第二步，直至队列为空。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">breadFirstSearch</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= numOfVexs)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>();</span><br><span class="line">		visit = <span class="keyword">new</span> <span class="title class_">boolean</span>[numOfVexs];</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">   		 queue.offer(v);</span><br><span class="line">		visit[v] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            v = queue.poll();</span><br><span class="line">			sb.append(vexs[v] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numOfVexs; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((edges[v][i] != <span class="number">0</span> &amp;&amp; edges[v][i] != Integer.MAX_VALUE)&amp;&amp; !visited[i]) &#123;</span><br><span class="line">					queue.offer(i);<span class="comment">//因为使用的是队列，所以每次poll出去的都是同一层的。这个和深度优先算法使用栈，每次pop出的都是一层中的一个元素不同</span></span><br><span class="line">					visit[i] = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">           <span class="keyword">return</span> sb.length() &gt; <span class="number">0</span> ? sb.substring(<span class="number">0</span>, sb.length() - <span class="number">1</span>) : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">breadFirstSearch</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= numOfVexs)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>();</span><br><span class="line">		visit = <span class="keyword">new</span> <span class="title class_">boolean</span>[numOfVexs];</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">		queue.offer(v);</span><br><span class="line">		visit[v] = <span class="literal">true</span>;</span><br><span class="line">		ENode current;</span><br><span class="line">		<span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">			v = queue.poll();</span><br><span class="line">			sb.append(vexs[v].data + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">			current = vexs[v].firstadj;</span><br><span class="line">			<span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!visited[current.adjvex]) &#123;</span><br><span class="line">					queue.offer(current.adjvex);</span><br><span class="line">					visit[current.adjvex] = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				current = current.nextadj;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sb.length() &gt; <span class="number">0</span> ? sb.substring(<span class="number">0</span>, sb.length() - <span class="number">1</span>) : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="深度优先检索DFS"><a href="#深度优先检索DFS" class="headerlink" title="深度优先检索DFS"></a>深度优先检索DFS</h2><p><strong>从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底</strong></p>
<p><strong>从图中的某一个顶点x出发，访问x，然后遍历任何一个与x相邻的未被访问的顶点y，再遍历任何一个与y相邻的未被访问的顶点z……依次类推，直到到达一个所有邻接点都被访问的顶点为止；然后，依次回退到尚有邻接点未被访问过的顶点，重复上述过程，直到图中的全部顶点都被访问过为止。</strong></p>
<p><img src="https://i.loli.net/2021/08/12/gGuw5ejA7aSIPpL.png"></p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><p><strong>深度优先遍历背后基于堆栈，有两种方式：第一种是在程序中显示构造堆栈，利用压栈出栈操作实现；第二种是利用递归函数调用，基于递归程序栈实现。</strong></p>
<h4 id="堆栈法"><a href="#堆栈法" class="headerlink" title="堆栈法"></a>堆栈法</h4><ol>
<li>访问起始顶点，并将其压入栈中；</li>
<li>从栈中弹出最上面的顶点，将与其相邻的未被访问的顶点压入栈中；</li>
<li>重复第二步，直至栈为空栈。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采用邻接矩阵</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depthFirstSearch</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(v&lt;<span class="number">0</span>||v&gt;=numOfVexs) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundException</span>();</span><br><span class="line">    <span class="type">boolean</span> []visit = <span class="keyword">new</span> <span class="title class_">boolean</span>[numOfVexs];<span class="comment">//用来标记节点是否被访问</span></span><br><span class="line">    Stack&lt;Integer&gt; stack  = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    stack.push(v);</span><br><span class="line">    visit[v]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        v=stack.pop();<span class="comment">//每层依次出一个没有标记的节点</span></span><br><span class="line">        sb.append(vexs[v] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=numOfVexs-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((edges[v][i]!=<span class="number">0</span>&amp;&amp;edges[v][i]!=Integer.MAX_VALUE)&amp;&amp;!visit[i])</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">                visit[i]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基于邻接表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depthFirstSearch</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(v&lt;<span class="number">0</span>||v&gt;=numOfVexs) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundException</span>();</span><br><span class="line">   <span class="type">boolean</span> []visit = <span class="keyword">new</span> <span class="title class_">boolean</span>[numOfVexs];<span class="comment">//用来标记节点是否被访问</span></span><br><span class="line">   Stack&lt;Integer&gt; stack  = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">   <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">   stack.push(v);</span><br><span class="line">   visit[v]=<span class="literal">true</span>;</span><br><span class="line">	Node current;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        v=stack.pop();<span class="comment">//每次一层选一个出栈</span></span><br><span class="line">        sb.append(vexs[v].data + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">       	current = vexs[v].firstadj;</span><br><span class="line">        <span class="keyword">while</span>(current!=<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit[current.adjvex])</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(current.adjvex);<span class="comment">//这里也是把邻接点全部入栈</span></span><br><span class="line">                visit[current.abjvex]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current=current.nextabj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depthFirstSearch</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(v&lt;<span class="number">0</span>||v&gt;=numOfVexs) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundException</span>();</span><br><span class="line">	<span class="type">boolean</span> []visit = <span class="keyword">new</span> <span class="title class_">boolean</span>[numOfVexs];<span class="comment">//用来标记节点是否被访问</span></span><br><span class="line">	visit[v]=<span class="literal">true</span>;</span><br><span class="line">	printf(<span class="string">&quot;%d &quot;</span>,v);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numOfVexs;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(visit[i]!=<span class="number">0</span>&amp;&amp;(edges[v][i]!=<span class="number">0</span>&amp;&amp;edges[v][i]!=Integer.MAX_VALUE))</span><br><span class="line">    	depthFirstSearch(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depthFirstSearch</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(v&lt;<span class="number">0</span>||v&gt;=numOfVexs) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundException</span>();</span><br><span class="line">	<span class="type">boolean</span> []visit = <span class="keyword">new</span> <span class="title class_">boolean</span>[numOfVexs];<span class="comment">//用来标记节点是否被访问</span></span><br><span class="line">	visit[v]=<span class="literal">true</span>;</span><br><span class="line">	printf(<span class="string">&quot;%d &quot;</span>,v);</span><br><span class="line">    Node current;</span><br><span class="line">	<span class="keyword">while</span>(current!=<span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[current.abjvex]!=<span class="literal">true</span>)</span><br><span class="line">            depthFirstSearch(current.abjvex);</span><br><span class="line">                    current=current.nextabj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/01/02/Algorithm_%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/02/Algorithm_%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">贪心算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-02 15:47:35" itemprop="dateCreated datePublished" datetime="2020-01-02T15:47:35Z">2020-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>贪心算法是这样一种方法：分步骤实施，它<strong>在每一步仅作出当时看起来最佳的选择</strong>，即<strong>局部最优的选择</strong>，并希望通过这样的选择最终能找到<strong>全局最优解</strong>。</p>
<p>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。）</p>
<p><strong>所以，对所采用的贪心策略一定要仔细分析其是否满足无后效性。</strong></p>
<blockquote>
<p>最优解问题大部分都可以拆分成一个个的子问题，把解空间的遍历视作对子问题树的遍历，则以某种形式对树整个的遍历一遍就可以求出最优解，大部分情况下这是不可行的。<strong>贪心算法和动态规划本质上是对子问题树的一种修剪，两种算法要求问题都具有的一个性质就是子问题最优性</strong>(组成最优解的每一个子问题的解，对于这个子问题本身肯定也是最优的)。动态规划方法代表了这一类问题的一般解法，我们自底向上构造子问题的解，对每一个子树的根，求出下面每一个叶子的值，并且以其中的最优值作为自身的值，其它的值舍弃。而贪心算法是动态规划方法的一个特例，可以证明每一个子树的根的值不取决于下面叶子的值，而只取决于当前问题的状况。换句话说，不需要知道一个节点所有子树的情况，就可以求出这个节点的值。由于贪心算法的这个特性，它对解空间树的遍历不需要自底向上，而只需要自根开始，选择最优的路，一直走到底就可以了。</p>
</blockquote>
<p>对比动态规划方法：</p>
<p>在动态规划方法中，每个步骤也都要进行一次选择，但这种选择通常依赖于子问题的解，这导致我们要先求解较小的子问题，然后才能计算较大的子问题。</p>
<p>在贪心方法中，我们总是做出当前看来最佳的选择，然后求解剩下的唯一一个子问题。尽管贪心算法进行选择时可能依赖之前做出的选择，但不依赖任何将来的选择或子问题的解。</p>
<p>动态规划要先求解子问题才能进行选择，贪心算法在进行第一次选择之前不需要求解任何子问题。</p>
<p>动态规划算法通常采用自底向上的方式完成计算，而贪心算法通常是自顶向下的，每一次选择，将给定的问题转换成一个更小的问题，然后继续求解小问题</p>
<h2 id="贪心算法的步骤"><a href="#贪心算法的步骤" class="headerlink" title="贪心算法的步骤"></a>贪心算法的步骤</h2><p>贪心算法通常采用自顶向下的设计，做出一个选择，然后求解剩下的子问题。每次选择将问题转化成一个更小规模的问题。</p>
<ul>
<li><p>确定问题的最优子结构</p>
</li>
<li><p>将最优化问题转化为这样的形式：每次对其作出选择后，只剩下一个子问题需要求解；</p>
</li>
<li><p>证明作出贪心选择后，剩余的子问题满足：其最优子解与前面的贪心选择组合即可得到原问题的最优解(具有最优子结构)。</p>
</li>
</ul>
<p>注：对应每个贪心算法，都有一个动态规划算法，但动态规划算法要繁琐的多。</p>
<h2 id="贪心算法存在的问题"><a href="#贪心算法存在的问题" class="headerlink" title="贪心算法存在的问题"></a>贪心算法存在的问题</h2><ul>
<li>不能保证求得的最后解是最佳的</li>
<li>不能用来求最大值或最小值的问题</li>
<li>只能求满足某些约束条件的可行解的范围</li>
</ul>
<h2 id="贪心算法适用的问题"><a href="#贪心算法适用的问题" class="headerlink" title="贪心算法适用的问题"></a>贪心算法适用的问题</h2><p><strong>贪心策略适用的前提是：局部最优策略能导致产生全局最优解。</strong><br>实际上，贪心算法适用的情况很少。一般对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可以做出判断。</p>
<h2 id="活动选择问题"><a href="#活动选择问题" class="headerlink" title="活动选择问题"></a>活动选择问题</h2><p>有n个需要在同一天使用同一个教室的活动a1,a2,…,an，教室同一时刻只能由一个活动使用。每个活动ai都有一个开始时间si和结束时间fi 。一旦被选择后，活动ai就占据半开时间区间[si,fi)。如果[si,fi]和[sj,fj]互不重叠，ai和aj两个活动就可以被安排在这一天。</p>
<p>活动选择问题：就是对给定的包含n个活动的集合S，在已知每个活动开始时间和结束时间的条件下，从中选出最多可兼容活动的子集合，称为最大兼容活动集合。不失一般性，设活动已经按照结束时间单调递增排序：</p>
<p>$$<br>f1&lt;&#x3D;f2&lt;&#x3D;f3&lt;&#x3D;f4&lt;&#x3D;…&lt;&#x3D;fn-1&lt;&#x3D;fn<br>$$</p>
<h3 id="活动选择问题的最优子结构"><a href="#活动选择问题的最优子结构" class="headerlink" title="活动选择问题的最优子结构"></a>活动选择问题的最优子结构</h3><p>令S<del>ij</del>表示在ai结束之后开始且在a<del>j</del>开始之前结束的那些活动的集合。</p>
<p>问题和子问题的形式定义如下：设A<del>ij</del>是S<del>ij</del>的一个最大兼容活动集，并设A<del>ij</del>包含活动a<del>k</del>，则有：<strong>A<del>ik</del>表示A<del>ij</del>中a<del>k</del>开始之前的活动子集，A<del>kj</del>表示A<del>ij</del>中a<del>k</del>结束之后的活动子集</strong>。并得到两个子问题：寻找S<del>ik</del>的最大兼容活动集合和寻找S<del>kj</del>的最大兼容活动集合。</p>
<p>活动选择问题具有最优子结构性，即：必有：A<del>ik</del>是S<del>ik</del>一个最大兼容活动子集，A<del>kj</del>是S<del>kj</del>一个最大兼容活动子集。而A<del>ij</del>&#x3D; A<del>ik</del>∪{a<del>k</del>}∪A<del>kj</del>。——最优子结构性成立。</p>
<h3 id="活动选择问题的动态规划方法"><a href="#活动选择问题的动态规划方法" class="headerlink" title="活动选择问题的动态规划方法"></a>活动选择问题的动态规划方法</h3><p>$$<br>c[i,j]表示集合s_{ij}的最优解大小，递归式如下：\<br>c[i,j]&#x3D;c[i,k]+c[k,j]+1\<br>c[i,j]&#x3D;\begin{cases}<br>0,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\quad S_{ij}&#x3D;\Phi\<br>\max\limits_{a_k\in S_{ij}}(c[i,k]+c[k,j]+1)\ \ if\quad S_{ij}\not&#x3D;\Phi<br>\end{cases}<br>$$</p>
<h3 id="活动选择问题的贪心算法"><a href="#活动选择问题的贪心算法" class="headerlink" title="活动选择问题的贪心算法"></a>活动选择问题的贪心算法</h3><p>活动选择问题的贪心选择：每次总选择具有最早结束时间的兼容活动加入到集合A中。</p>
<p>直观上，按这种方法选择兼容活动可以为未安排的活动留下尽可能多的时间。也就是说，该算法的贪心选择的意义是使剩余的可安排时间段最大化，以便安排尽可能多的兼容活动。</p>
<h4 id="贪心算法的正确性"><a href="#贪心算法的正确性" class="headerlink" title="贪心算法的正确性"></a>贪心算法的正确性</h4><p>假设A<del>ij</del>是S<del>ij</del>的某个最大兼容活动集，假设A<del>ij</del>中，最早结束的活动是a<del>n</del>，分两种情况：</p>
<p>1、如果a<del>n</del>&#x3D;a<del>i</del> ,得证</p>
<p>2、如果a<del>n</del>！&#x3D; a<del>i</del> ，则a<del>n</del>的结束时间一定会晚于a<del>1</del>的结束时间，我们用a<del>i</del>去替换A<del>ij</del>中的a<del>n</del>，于是得到A^1^，由于a<del>i</del>比a<del>n</del>结束的早，而A<del>ij</del>中的其他活动都比a<del>n</del>的结束时间开始 的要晚，所以A^1^中的其他活动 都与a<del>i</del>不想交，所以A^1^中的所有活动是兼容的，所以A^1^也是S<del>ij</del>的一个最大兼容活动集。</p>
<h4 id="贪心算法的递归实现"><a href="#贪心算法的递归实现" class="headerlink" title="贪心算法的递归实现"></a>贪心算法的递归实现</h4><p>自顶向下的设计</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s、f数组分别表示n个活动的开始时间和结束时间，假设n个活动已经按照结束时间单调递增排列好了</span></span><br><span class="line"><span class="comment">//list用来保存已选的活动</span></span><br><span class="line"><span class="comment">//对于当前的k，返回Sk的一个最大兼容活动集</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; RECURSIVE_ACTIVITY+SELECTOR(List&lt;Integer&gt; list,<span class="type">int</span>[] s ,<span class="type">int</span>[] f,<span class="type">int</span> k,<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> k+<span class="number">1</span>;<span class="comment">//表示是当前剩下没有添加到list的第一个活动</span></span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">        list.add(m);</span><br><span class="line">    <span class="comment">//往后找f[k]&lt;=s[m]的活动</span></span><br><span class="line">    <span class="keyword">while</span>(m&lt;=s.length&amp;&amp;s[m]&lt;f[k])</span><br><span class="line">    &#123;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        list.add[m+<span class="number">1</span>];<span class="comment">//m+1对应活动编号。k=0时的第一个加入的活动编号为1</span></span><br><span class="line">        RECURSIVE_ACTIVITY+SELECTOR(s,f,m,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="贪心算法的迭代实现"><a href="#贪心算法的迭代实现" class="headerlink" title="贪心算法的迭代实现"></a>贪心算法的迭代实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; GREEDY_ACTIVITY+SELECTOR(List&lt;Integer&gt; list,<span class="type">int</span>[] s ,<span class="type">int</span>[] f,<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">   	list.add(k);<span class="comment">//添加第一个活动。</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">2</span>;m&lt;=n;m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[m]&gt;=f[k])<span class="comment">//依次添加符合条件的活动，反正f都是排好序的</span></span><br><span class="line">        &#123;</span><br><span class="line">            list.add(m);</span><br><span class="line">            k=m</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="分数背包问题"><a href="#分数背包问题" class="headerlink" title="分数背包问题"></a>分数背包问题</h2><p>已知n种物品，各具有重量(w<del>1</del>,w<del>2</del>,…,w<del>n</del>)和效益值(p<del>1</del>,p<del>2</del>,…,p<del>n</del>)，及一个可容纳M重量的背包。</p>
<p>问：怎样装包才能使在不超过背包容量的前提下，装入背包的物品的总效益最大？</p>
<p>​	这里：</p>
<p>​				1）所有的w<del>i</del>&gt;0, p<del>i</del>&gt;0，1≤i≤n；</p>
<p>​				2）问题的解用向量(x<del>1</del>,x<del>2</del>,…,x<del>n</del>)表示，每个x<del>i</del>表示物品i被放入背包的比例，0≤x<del>i</del>≤1。当物品i的一部分x<del>i</del>放入背包，可得到p<del>i</del>x<del>i</del>的效益，同时会占用x<del>i</del>w<del>i</del>的重量。</p>
<p>问题分析：</p>
<ul>
<li><p>装入背包的总重量小于等于M，即：<br>$$<br>\sum_{1&lt;&#x3D;i&lt;&#x3D;n}W_iX_i&lt;&#x3D;M<br>$$</p>
</li>
<li><p>$$<br>求\sum_{1&lt;&#x3D;i&lt;&#x3D;n}P_iX_i的最大值<br>$$</p>
</li>
<li><p>可行解：满足上述约束条件的任一(x<del>1</del>,x<del>2</del>,…,x<del>n</del>) 都是问题的一个可行解。可行解可能有多个（甚至是无穷多个）。</p>
</li>
<li><p>最优解：能够使目标函数取最大值的可行解是问题的最优解。最优解也可能有多个。</p>
</li>
</ul>
<h3 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h3><p>这里我们需要思考：</p>
<p>1、策略一：以每装入一件物品，就使背包获得最大可能的效益增量作为策略</p>
<p>2、策略二：让背包容量尽可能慢地被消耗，从而可以尽可能多地装入一些物品。</p>
<p>3、如下的贪心策略</p>
<p>我们要设计一个贪心策略来使得装入背包物品的价值最大。我们的第一直觉肯定是要选择单位重量价格最高的。</p>
<p>然后再选择物品里面第二高的，一次类推直到装满背包为止！</p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>可以利用反证法求证策略一和策略二都不是最优解。</p>
<p>策略三：</p>
<p><strong>需要注意的是X<del>i</del> 的值是小于等于1的</strong></p>
<p>我们首先假设我们有一个最优解A<del>1</del>,那么我们首先找到A<del>1</del>里面单位价值最高的物品a<del>m</del></p>
<ul>
<li>情况一：a<del>m</del>&#x3D;商品里面单位价值最高的物品a<del>1</del>。那么问题得证（因为只要不断拿掉单位价值最高的即可）</li>
<li>情况二：a<del>m</del>&lt;a<del>1</del>。运用剪枝技巧，讲a<del>m</del> 剪掉，补上a<del>1</del> （a<del>1</del>将a<del>m</del>进行全部替换或者部分替换）<ul>
<li>如果a<del>m</del> 的重量比a<del>1</del> 的重量小，a<del>1</del> 全部替换a<del>m</del>，</li>
<li>如果a<del>m</del> 的重量比a<del>1</del> 的重量大，a<del>1</del> 部分替换a<del>m</del>，其余部分保留</li>
</ul>
</li>
</ul>
<h2 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h2><p>其中变长编码表是通过一种评估来源符号出现机率的方法得到的，<strong>出现机率高的字母使用较短的编码，反之出现机率低的则使用较长的编码</strong>，这便使编码之后的字符串的平均长度、期望值降低，从而达到无损压缩数据的目的。</p>
<p>前缀码(Prefix code)：任何码字都不是其它码字的前缀。</p>
<p>问题是：如何设计前缀码？</p>
<h3 id="编码树"><a href="#编码树" class="headerlink" title="编码树"></a>编码树</h3><p>一种为表示字符二进制编码而构造的二叉树。</p>
<p>叶子结点：对应给定的字符，每个字符对应一个叶子结点。</p>
<p>编码构造：字符的二进制码字由根结点到该字符叶子结点的简单路径表示：0代表转向左孩子，1代表转向右孩子。</p>
<p><img src="/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-20200102212604104.png"></p>
<p>一个文件的最优字符编码方案总对应一棵满(full)二叉树，即每个非叶子结点都有两个孩子结点。</p>
<h3 id="最优编码方案"><a href="#最优编码方案" class="headerlink" title="最优编码方案"></a>最优编码方案</h3><p>文件的最优编码方案对应一棵满二叉树。</p>
<ul>
<li><p>设C为字母表</p>
<ul>
<li>对字母表C中的任意字符c，令属性c.freq表示字符c在文件中出现的频率（设所有字符的出现频率均为正数）。</li>
<li>最优前缀码对应的树中恰好有|C|个叶子结点，每个叶子结点对应字母表中的一个字符，且恰有|C|-1个内部结点。</li>
</ul>
</li>
<li><p>令T表示一棵前缀编码树；</p>
</li>
<li><p>令d<del>T</del>(c)表示c的叶子结点在树T中的深度（根到叶子结点的路径长度）。</p>
<ul>
<li>d<del>T</del>(c)也是字符c对应的码字的长度。</li>
</ul>
</li>
</ul>
<p>令B(T)表示采用编码方案T时文件的编码长度，则：<br>$$<br>B(T)&#x3D;\sum_{c\in C}c.freq*d_T(c)<br>$$<br>即文件要用B(T)个二进制位表示.</p>
<ul>
<li>称B(T)为T的代价。</li>
<li>最优编码：对给定的字符集和文件，使文件的编码长度最小的编码称为最优编码。<ul>
<li>Huffman编码是一种最优编码。</li>
</ul>
</li>
</ul>
<h3 id="Huffman编码的贪心算法"><a href="#Huffman编码的贪心算法" class="headerlink" title="Huffman编码的贪心算法"></a>Huffman编码的贪心算法</h3><p>自底向上法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HUFFMAN(C)<span class="comment">//C表示字母表</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n=C.size();</span><br><span class="line">    <span class="type">queue</span> <span class="variable">Q</span> <span class="operator">=</span>C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">node</span> z;</span><br><span class="line">        z.left = x = EXTRACT_MIN(Q);<span class="comment">//取队列中频率最小的</span></span><br><span class="line">        z.right=y=EXTRACT_MIN(Q);</span><br><span class="line">        z.freq=x.freq+y.freq;</span><br><span class="line">        INSERT(Q,Z);<span class="comment">//频率低的拼好后，一步步往上累加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-20200102213951216.png"></p>
<h4 id="时间分析"><a href="#时间分析" class="headerlink" title="时间分析"></a>时间分析</h4><p>Q是使用最小二叉堆实现的。</p>
<ul>
<li><p>首先，Q的初始化花费O(n)的时间。</p>
</li>
<li><p>其次，循环的总代价是O(nlgn)。</p>
<ul>
<li>for循环共执行了n-1次，每次从堆中找出当前频率最小的两个结点及把合并得到的新结点插入到堆中均花费O(lgn)，所以循环的总代价是O(nlgn).</li>
</ul>
</li>
</ul>
<p><strong>所以，HUFFMAN的总运行时间O(nlgn)</strong></p>
<h4 id="HUFFMAN算法的正确性"><a href="#HUFFMAN算法的正确性" class="headerlink" title="HUFFMAN算法的正确性"></a>HUFFMAN算法的正确性</h4><p>1、第一点：令C为一个字母表，其中每个字符c∈C都有一个频率c.freq。令x和y是C中频率最低的两个字符。那么存在C的一个最优前缀码，x和y的码字长度相同，且只有最后一个二进制位不同。</p>
<p>二叉树T表示字符集C的一个最优前缀码，证明可以对T作适当修改后得到一棵新的二叉树T”，在T”中x和y是最深叶子且为兄弟，同时T”表示的前缀码也是C的最优前缀码。设b和c是二叉树T的最深叶子，且为兄弟。设f(b)&lt;&#x3D;f(c)，f(x)&lt;&#x3D;f(y)。由于x和y是C中具有最小频率的两个字符，有f(x)&lt;&#x3D;f(b)，f(y)&lt;&#x3D;f(c)。首先，在树T中交换叶子b和x的位置得到T’，然后再树T’中交换叶子c和y的位置，得到树T’’。如图所示：<br><img src="/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/1364295841_4708.jpg"></p>
<p>由此可知，树T和T’的前缀码的平均码长之差为：</p>
<p><img src="/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/1364296506_7690.jpg"></p>
<p> 因此，<em>T’’表示的前缀码也是最优前缀码</em>，且x,y具有相同的码长，同时，仅最优一位编码不同。</p>
<p>2、第二点：令C为一个给定的字母表，其中每个字符c∈C都有一个频率c.freq。</p>
<p>令x和y是C中频率最低的两个字符。<br>令C’为C去掉字符x和y，并加入一个新字符z后得到的字母表，即C’&#x3D; C -{x, y}∪{z}。</p>
<p>类似C，也为C’定义freq，且z.freq&#x3D; x.freq+ y.freq。<br>令T’为字母表C’的任意一个最优前缀码对应的编码树。则有：可以将T’中叶子结点z替换为一个以x和y为孩子的内部结点，得到树T，而T表示字母表C的一个最优前缀码。</p>
<h4 id="最优子结构性质"><a href="#最优子结构性质" class="headerlink" title="最优子结构性质"></a>最优子结构性质</h4><p>贪心选择性：</p>
<ul>
<li>1、第一点说明首次选择频率最低的两个字符和选择其它可能的字符一样，都可以构造相应的最优编码树。</li>
<li>2、第二点说明首次贪心选择，选择出频率最低的两个字符x和y，合并后将z加入元素集合，可以构造包含z的最优编码树，而还原x和y，一样还是最优编码树。</li>
<li>所以贪心选择性成立。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/01/02/OS_%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%B8%8E%E8%B0%83%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/02/OS_%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%B8%8E%E8%B0%83%E5%BA%A6/" class="post-title-link" itemprop="url">资源分配与调度</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-02 13:02:12" itemprop="dateCreated datePublished" datetime="2020-01-02T13:02:12Z">2020-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D/" itemprop="url" rel="index"><span itemprop="name">资源分配</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="资源分配与调度"><a href="#资源分配与调度" class="headerlink" title="资源分配与调度"></a>资源分配与调度</h1><h2 id="资源管理概述"><a href="#资源管理概述" class="headerlink" title="资源管理概述"></a>资源管理概述</h2><p>资源：应用程序执行时所需要的<strong>全部硬件、软件和数据</strong>。</p>
<p>资源管理的目标：</p>
<ul>
<li>保证资源的高利用率。</li>
<li>在“合理”时间内使所有顾客有获得所需资源的机会。</li>
<li>对不可共享的资源实施互斥使用。</li>
<li>防止由资源分配不当而引起的死锁。</li>
</ul>
<h3 id="资源管理的任务"><a href="#资源管理的任务" class="headerlink" title="资源管理的任务"></a>资源管理的任务</h3><p>(1) 资源数据结构的描述<br>        包含资源的物理名、逻辑名、类型、地址、分配状态等信息。</p>
<p>(2) 确定资源的分配原则(调度原则)<br>        决定资源应分给谁，何时分配，分配多少等问题。</p>
<p>(3) 实施资源分配<br>        执行资源分配；资源收回工作。</p>
<p>(4) 存取控制和安全保护<br>        对资源的存取进行控制并对资源实施安全保护措施。</p>
<h3 id="资源的静态分配和动态分配"><a href="#资源的静态分配和动态分配" class="headerlink" title="资源的静态分配和动态分配"></a>资源的静态分配和动态分配</h3><h4 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h4><p>系统对<strong>作业一级</strong>采用资源静态分配方法。系统在调度作业时，根据作业所需资源进行分配；并在作业运行完毕时，收回所分配的全部资源。这种分配通常称为资源的静态分配。</p>
<h4 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h4><p>系统对<strong>进程一级</strong>采用资源动态分配方法。系统在进程运行中，根据进程提出的资源需求，进行资源的动态分配和回收。这种分配通常称为资源的动态分配。</p>
<blockquote>
<p>  （1）作业是用户向计算机提交任务的任务实体。在用户向计算机提交作业后，系统将它放入外存中的作业等待队列中等待执行。而进程则是完成用户任务的执行实体，是向系统申请分配资源的基本单位。任一进程，只要它被创建，总有相应的部分存在于内存中。</p>
<p>  （2）一个作业可由多个进程组成，且必须至少由一个进程组成，反过来则不成立。</p>
<p>  （3）作业的概念主要用在批处理系统中，像UNIX这样的分时系统中就没有作业的概念。而进程的概念则用在几乎所有的多道程序系统中。</p>
</blockquote>
<h3 id="虚拟资源"><a href="#虚拟资源" class="headerlink" title="虚拟资源"></a>虚拟资源</h3><ul>
<li><p>物理资源(实资源)</p>
</li>
<li><p>虚拟资源(逻辑资源)：<strong>用户使用的逻辑资源</strong>，这是经过操作系统改造的、使用方便的虚资源，而不是物理的、实际的资源。</p>
</li>
</ul>
<p>可以理解为操作系统将资源进行了封装，用户无需关心具体的资源在哪里，只要关心操作系统向用户提供的虚资源的描述。</p>
<p><img src="/images/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%B8%8E%E8%B0%83%E5%BA%A6/image-20200102132245004.png"></p>
<h1 id="资源分配结构和策略"><a href="#资源分配结构和策略" class="headerlink" title="资源分配结构和策略"></a>资源分配结构和策略</h1><p>资源管理的实质是<strong>资源管理的机制和资源管理的策略</strong>。</p>
<ul>
<li><p>机制：进行资源分配所必须的基本设施和部件，包括描述资源状态的数据结构、保证不可共享资源互斥使用的同步机构以及对不能立即得到满足的资源请求进行排队的各种资源队列的结构。</p>
</li>
<li><p>策略：资源分配的原则。</p>
</li>
</ul>
<h2 id="资源分配的机构"><a href="#资源分配的机构" class="headerlink" title="资源分配的机构"></a>资源分配的机构</h2><h3 id="资源描述器"><a href="#资源描述器" class="headerlink" title="资源描述器"></a>资源描述器</h3><p>描述各类资源的最小分配单位的数据结构称为资源描述器rd（resource descriptor）。如：主存分区分配方法中，最小分配单位为主存分区。资源描述器描述了<strong>资源的特性和该资源的管理方式</strong>。</p>
<p><strong>用于资源分配的最重要的信息是这一资源分配单位是可用的还是已分配的。</strong></p>
<ul>
<li>若它具有N个资源分配器，则有N个资源描述器。这些描述器的组织是个重要问题。</li>
<li>描述器的组织方式取决于资源分配单位的数量和数量是否可变这一特征。<ul>
<li>如果数量不可变，使用表结构。</li>
<li>如果数量可变，使用队列结构。</li>
<li>如果数目变化范围可知且不大，使用数组。</li>
</ul>
</li>
</ul>
<p><strong>资源描述器的内容：</strong></p>
<p>资源名、资源类型、最小分配单位的大小、地址、分配标志、描述器链接信息、存取权限、密级、存取时间</p>
<h3 id="资源信息块"><a href="#资源信息块" class="headerlink" title="资源信息块"></a>资源信息块</h3><p>描述某类资源的请求者、可用资源和该类资源分配程序等必要信息的数据结构。</p>
<p><img src="/images/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%B8%8E%E8%B0%83%E5%BA%A6/image-20200102133508777.png"></p>
<p>资源分配程序包括了资源分配程序和资源回收程序。当有进程请求资源的时候，先去资源分配程序中看看有没有资源，没有的话，将进程加入到等待资源队列中；当进程执行释放资源命令时，使用资源回收程序，将释放的资源加入到可利用资源的队列中。</p>
<h2 id="资源分配策略"><a href="#资源分配策略" class="headerlink" title="资源分配策略"></a>资源分配策略</h2><p>对某类资源而言，在多个资源有多个请求者申请的情况下，资源分配的策略包括<strong>选择请求者的策略和选择资源的策略两种。</strong></p>
<p>选择请求者的策略：即资源分配策略，即在众多请求者中选一个满足条件的请求者的原则。</p>
<p>选择资源的策略：是在同等资源间选择一个满足条件的资源的原则。</p>
<p>具体实现：体现在队列的排队原则上。</p>
<p><strong>资源分配的时机</strong></p>
<ul>
<li>当请求者发出一个明确的资源请求命令时；</li>
<li>当处理机空闲时；</li>
<li>当一个存储区被释放变为空闲时；</li>
<li>当一个外存设备发生完成中断时。</li>
</ul>
<h3 id="先请求先服务策略"><a href="#先请求先服务策略" class="headerlink" title="先请求先服务策略"></a>先请求先服务策略</h3><p>每一个新产生的请求均排在队尾；当资源可用时，取队首元素，并满足其需要。</p>
<p>排序原则：按请求的先后次序排序。（<strong>有饿死现象！</strong>）</p>
<h3 id="优先调度策略"><a href="#优先调度策略" class="headerlink" title="优先调度策略"></a>优先调度策略</h3><p>对每一个进程指定一个优先级，优先级反映了进程要求处理的紧迫程度；</p>
<p>每一个新产生的请求，按其优先级的高低插到相应的位置；</p>
<p>当资源可用时，取队首元素，并满足其需要。</p>
<p>排序原则：按优先级的高低排序。</p>
<p>缺点：<strong>因为优先级不同，会存在插队的状况。所以会消耗时间，导致效率下降</strong></p>
<h3 id="针对设备特性的调度策略"><a href="#针对设备特性的调度策略" class="headerlink" title="针对设备特性的调度策略"></a>针对设备特性的调度策略</h3><p>目的是为了当有大量I&#x2F;O请求时，降低完成这些I&#x2F;O服务的总时间。</p>
<h4 id="移臂调度"><a href="#移臂调度" class="headerlink" title="移臂调度"></a>移臂调度</h4><p>总是选取与当前移动臂前进方向上最近的那个I&#x2F;O请求，使移臂距离最短。</p>
<p><strong>移臂的方向是由外向里，即柱面号由小到大</strong></p>
<h4 id="旋转调度"><a href="#旋转调度" class="headerlink" title="旋转调度"></a>旋转调度</h4><p>总是选取与当前读写头最近的那个I&#x2F;O请求，使旋转圈数最少。</p>
<h3 id="几种移臂调度算法"><a href="#几种移臂调度算法" class="headerlink" title="几种移臂调度算法"></a>几种移臂调度算法</h3><h4 id="最短寻道时间优先算法（SSTF）"><a href="#最短寻道时间优先算法（SSTF）" class="headerlink" title="最短寻道时间优先算法（SSTF）"></a>最短寻道时间优先算法（SSTF）</h4><p>从等待访问者中挑选寻找时间最短的（也就是离得最近的）那个请求先执行</p>
<p>缺点：可能会引起读写头在盘面上的大范围移动，可能会推迟请求的服务导致无限拖延</p>
<h4 id="扫描算法（SCAN，即电梯调度算法）"><a href="#扫描算法（SCAN，即电梯调度算法）" class="headerlink" title="扫描算法（SCAN，即电梯调度算法）"></a>扫描算法（SCAN，即电梯调度算法）</h4><p>磁头前进方向上的最短查找时间优先算法。</p>
<p>很大程度上消除了SSTF的不公平性</p>
<h3 id="循环扫描算法（CSCAN）"><a href="#循环扫描算法（CSCAN）" class="headerlink" title="循环扫描算法（CSCAN）"></a>循环扫描算法（CSCAN）</h3><p>就是在电梯算法的基础上，一个方向找完了，回到起点再找（电梯算法是一个方向找完了转身反方向找）</p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>在两个或多个并发进程中，如果每个进程持有某种资源而又都等待着别的进程释放它或它们现在保持着的资源，否则就不能向前推进。此时，称这一组进程产生了死锁。</p>
<h2 id="死锁的起因和条件"><a href="#死锁的起因和条件" class="headerlink" title="死锁的起因和条件"></a>死锁的起因和条件</h2><h3 id="死锁的原因"><a href="#死锁的原因" class="headerlink" title="死锁的原因"></a>死锁的原因</h3><p>①系统资源不足</p>
<p>②进程推进顺序非法</p>
<h3 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h3><p><strong>①互斥条件</strong></p>
<p>涉及的资源是非共享的，即为临界资源。</p>
<p><strong>②不剥夺条件</strong></p>
<p>进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走。</p>
<p>（根据操作系统的特性，例如windows系统就是不可剥夺的）</p>
<p><strong>③部分分配</strong></p>
<p>进程每次申请它所需要的一部分资源。在等待一新资源的同时，进程继续占用已分配到的资源。</p>
<p><strong>④环路条件</strong></p>
<p>存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中下一个进程所请求。</p>
<h3 id="解决死锁问题的策略"><a href="#解决死锁问题的策略" class="headerlink" title="解决死锁问题的策略"></a>解决死锁问题的策略</h3><p>破坏产生死锁的四个必要条件之一</p>
<ul>
<li>采用静态资源分配方法——预防死锁。</li>
<li>采用有控资源分配方法——避免死锁</li>
<li>死锁的检测与忽略</li>
</ul>
<h3 id="死锁的预防和避免"><a href="#死锁的预防和避免" class="headerlink" title="死锁的预防和避免"></a>死锁的预防和避免</h3><h4 id="静态预防死锁的方法"><a href="#静态预防死锁的方法" class="headerlink" title="静态预防死锁的方法"></a>静态预防死锁的方法</h4><p>在作业调度时为选中的作业分配它所需要的所有资源，当资源一旦分配给该作业后，在其整个运行期间这些资源为它独占。</p>
<h4 id="动态避免死锁的方法"><a href="#动态避免死锁的方法" class="headerlink" title="动态避免死锁的方法"></a>动态避免死锁的方法</h4><h5 id="有序资源分配法（破坏了部分分配和循环等待）"><a href="#有序资源分配法（破坏了部分分配和循环等待）" class="headerlink" title="有序资源分配法（破坏了部分分配和循环等待）"></a>有序资源分配法（破坏了部分分配和循环等待）</h5><p>系统中所有资源都给定一个唯一的编号，所有分配请求必须以上升的次序进行。当遵守上升次序的规则时，若资源可用，则予以分配；否则，请求者等待。（缺点：资源浪费！）</p>
<h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><p>申请者事先说明对各类资源的最大需求量。在进程活动期间动态申请某类资源时，由系统审查现有该类资源的数目是否能满足当前进程的最大需求量，如能满足就予以分配，否则拒绝。</p>
<h3 id="死锁的检测与忽略"><a href="#死锁的检测与忽略" class="headerlink" title="死锁的检测与忽略"></a>死锁的检测与忽略</h3><p>检测：算法复杂，开销很大</p>
<p>忽略：后患无穷</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>假设一个可移动磁头的磁盘具有 200个磁道，其编号为0~199,当它刚刚结束了 125道的存取后，现正在处理143道的服务请求，假设系统当前的请求序列以请求的先后次序排列如下: 86、147、91、177、150、102、175、130。试问对以下几种磁盘IO请求调度算法而言，满足以上请求序列，磁头将分别如何移动?</p>
<p>（1）  先来先服务算法（FCFS）</p>
<p>（2）  最短寻道时间优先调度（SSTF）</p>
<p>（3）  扫描算法（SCAN）</p>
<p>（4）  循环扫描算法（CSCAN）</p>
<p>答：</p>
<p>（1）  FCFS：143→86→147→91→177→150→102→175→130；</p>
<p>（2）  SSTF：143→147→150→130→102→94→91→86→175→177；</p>
<p>（3）  SCAN：143→147→150→175→177→130→102→94→91→86；</p>
<p>（4）  C-SCAN：143→147→150→175→177→86→91→94→102→130。</p>
<p>5-9 三个进程共享四个同类资源，这些资源的分配与释放只能一次一个，已知每一进程最多需要两个资源，试问该系统会发生死锁吗？为什么？</p>
<p>答：该系统不会发生死锁。</p>
<p>因为最坏情况是每个进程都占有一个资源，申请第二个资源，而此时系统中还剩一个资源，不管这个资源分给哪个进程，都能满足它的资源要求，因此它能在有限时间内运行结束而释放它所占有的两个资源，这两个资源又可以分配给另外两个进程，使它们能够运行结束，所以系统不会发生死锁。</p>
<p>5-10 p个进程共享m个同类资源，每一个资源在任一时刻只能供一个进程使用，每一进程对任一资源都只能使用一有限时间，使用完便立即释放，并且每个进程对该类资源的最大需求量小于该类资源的数目，设所有进程对资源的最大需求数目之和小于p+m，试证在该系统中不会发生死锁。</p>
<p>解：采用“反证法”，假定max(i)为第i个进程最大资源需求量，need(i)为第i个进程还需要的资源量，alloc(i)为第i个进程已分配的资源量，则</p>
<p>max(i)&lt;&#x3D;m</p>
<p>max(i)&#x3D;need(i)+alloc(i)</p>
<p>max(1)+L+ max(p)&#x3D;(need(1)+ L…+need(p))+(alloc(1)+ L…+alloc(p))&lt;p+m</p>
<p>若发生死锁，则需要满足下面两个条件，</p>
<p>① 全部分配，alloc(1)+…+alloc(p)&#x3D;m；② 所有进程无限等待</p>
<p>由①②可得， need(1)+…+need(p)&lt;p</p>
<p>则死锁后，p个进程需要的资源小于p，则一定存在进程i，need (i) &#x3D; 0，进程已获得全部资源，进程i 可以执行完，同假设发生矛盾，所以不会发生死锁。</p>
<p>5-11图5.9 表示一带闸门的运河，其上有两架吊桥，吊桥坐落在一条公路上，为使该公路避开一块沼泽地而其横跨运河两次。运河和公路的交通都是单方向的，运河的基本运输由驳船担负。在一艘驳船接近吊桥A 时就拉汽笛警告，若桥上无车辆，吊桥就吊起，直到驳船尾部通过该桥为止，对吊桥B按同样次序处理</p>
<p>(1) 一艘典型驳船的长度为200 米，当它在河道航行时是否会产生死锁？若会，其理由是什么？</p>
<p>(2) 如何能克服一个可能的死锁？请想出一个防止死锁的办法。</p>
<p>(3) 如何利用信号灯的P、V 操作实现车辆和驳船的同步？</p>
<p><img src="/images/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%B8%8E%E8%B0%83%E5%BA%A6/clip_image002.png"></p>
<p>(1) 答：驳船长200 米，当驳船通过了A 桥，其船头到达B 桥，请求B 桥吊起，而此时它的尾部占据A 桥，若这个时候B 桥及B桥到A 桥之间的公路都被汽车占据，而汽车又要求通过A 桥。这样驳船和汽车都无法前进，形成死锁的局面。</p>
<p>(2) 答：方案之一。可规定资源按序申请和分配，从而破坏了死锁的循环等待条件，防止死锁的发生。规定如B 桥的序号小于A 桥的序号，驳船和汽车都必须先申请序号小的资源B 桥，申请得到满足后，再申请序号大的资源A 桥。</p>
<p>(3) 答：将每台车的行驶看作是进程，则有Auto1，Auto2，LAutoi i个汽车进程。将每条驳船的航行看作是进程，则有Ship1，Ship2，LShipj个驳船进程。桥A和桥B对车和船为互斥资源。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">main&#123;</span><br><span class="line">	int SA=<span class="number">1</span>；<span class="regexp">//</span>A桥的互斥信号量<span class="regexp">//</span></span><br><span class="line">	int SB=<span class="number">1</span>；<span class="regexp">//</span>B桥的互斥信号量<span class="regexp">//</span></span><br><span class="line">	cobegin</span><br><span class="line">		Auto1;Auto2;···Autoi;</span><br><span class="line">		Ship1; Ship2; ···Shipj;</span><br><span class="line">	coend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Autoi()&#123;</span><br><span class="line">车在公路上行驶；</span><br><span class="line">P（SB）；</span><br><span class="line">过B桥；</span><br><span class="line">V（SB）；</span><br><span class="line">过弯道；</span><br><span class="line">P（SA）；</span><br><span class="line">过A桥；</span><br><span class="line">V（SA）；</span><br><span class="line">车在公路上行驶；                          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shipj()&#123;</span><br><span class="line">运河航行；</span><br><span class="line">P（SB）；                  </span><br><span class="line">P（SA）；                    </span><br><span class="line">吊起过A桥；                    </span><br><span class="line">运河航行；                             </span><br><span class="line">吊起过B桥；                    </span><br><span class="line">V（SA）；                         </span><br><span class="line">V（SB）；</span><br><span class="line">运河航行；</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5-14在采用银行家算法管理资源分配的系统中，有A、B、C三类资源可供5个进程P1、P2、P3、P4、P5共享。3类资源的总量为(17, 5, 20)，即A类17个，B类5个，C类20个。假设T0时刻各进程对资源的需求和分配情况如下表所示。</p>
<p><img src="/images/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%B8%8E%E8%B0%83%E5%BA%A6/clip_image002-1578241244505.png" alt="img"></p>
<p>（1）  现在系统是否处于安全状态？如是，给出一个安全序列。</p>
<p>（2）  T0时刻，如果进程P4和P1依次提出A、B、C资源请求（2,0,1）和（0,2,0），系统能否满足它们的请求?请说明原因。</p>
<p>答：（1）系统处于安全状态，如P4→P2→P3→P5→P1。</p>
<p>（2）不能满足。由于P4与P1提出请求后，A、B、C剩余（0，1，2），此时A类无，只能等待拥有足够A类资源的进程结束释放A类资源，别的进程才能执行，而此时P4需（0，2，0），P3需（0，0，6），而剩余（0，1，2），不能满足要求，产生死锁。</p>
<p><strong>1．</strong> <strong>设有一个售票大厅，可容纳200人购票。如果厅内不足200人则允许进入，超过则在厅外等候；售票员某时只能给一个购票者服务，购票者买完票后就离开。试问：</strong></p>
<p><strong>（1）</strong> <strong>购票者之间是同步关系还是互斥关系？</strong></p>
<p>答：互斥关系。</p>
<p><strong>用P、V操作描述购票者的工作过程。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">semaphore empty=<span class="number">200</span>;</span><br><span class="line">semaphore mutex=<span class="number">1</span>;</span><br><span class="line">semaphore waiting=<span class="number">0</span>；</span><br><span class="line"><span class="type">void</span> <span class="built_in">buy</span>()</span><br><span class="line">&#123;   <span class="built_in">p</span>(waiting);</span><br><span class="line">	<span class="built_in">p</span>(mutex);</span><br><span class="line">	买票；</span><br><span class="line">	<span class="built_in">v</span>(mutex);</span><br><span class="line">	<span class="built_in">v</span>(empty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waiting</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">p</span>(empty);</span><br><span class="line">	等待；</span><br><span class="line">	waiting++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2019/12/30/OS_%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/30/OS_%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">主存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-29 22:55:22" itemprop="dateCreated datePublished" datetime="2019-12-29T22:55:22Z">2019-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="主存管理概述"><a href="#主存管理概述" class="headerlink" title="主存管理概述"></a>主存管理概述</h1><p>现代操作系统将主存区分为物理主存和逻辑主存2类。</p>
<p>物理主存是共享的物质基础。由多个物理地址构成。</p>
<h2 id="主存共享方式—-分片共享"><a href="#主存共享方式—-分片共享" class="headerlink" title="主存共享方式—-分片共享"></a>主存共享方式—-分片共享</h2><h3 id="分片的方式"><a href="#分片的方式" class="headerlink" title="分片的方式"></a>分片的方式</h3><p>(1) 大小不等的区域—根据用户程序的实际需要决定分区的大小</p>
<p>①分区存储管理</p>
<p>②段式存储管理</p>
<p>(2) 大小相等的区域—以块为单位，根据用户程序的实际需要决定应分配的块数</p>
<p>页式存储管理</p>
<p>(3) 二者结合</p>
<p>段页式存储管理</p>
<p>由于不同程序的物理地址的首地址都是乱七八糟的，不方便用户使用。所以采用逻辑地址（虚地址）将首地址设置为0。逻辑地址和物理地址之间的映射就是地址映射。</p>
<h3 id="程序的逻辑组织"><a href="#程序的逻辑组织" class="headerlink" title="程序的逻辑组织"></a>程序的逻辑组织</h3><h4 id="一维地址结构"><a href="#一维地址结构" class="headerlink" title="一维地址结构"></a>一维地址结构</h4><p>一个程序是一个连续、线性的地址结构；确定线性地址空间中的指令地址或操作数地址只需要一个信息。</p>
<h4 id="二维地址结构"><a href="#二维地址结构" class="headerlink" title="二维地址结构"></a>二维地址结构</h4><p>一个程序由<strong>若干个分段组成</strong>（数据段、代码段、栈段······），每个分段是一个连续的地址区；</p>
<p>确定线性地址空间中的指令地址或操作数地址需要两个信息，一是该信息所在的分段，另一个是该信息在段内的偏移量。</p>
<h1 id="主存管理功能"><a href="#主存管理功能" class="headerlink" title="主存管理功能"></a>主存管理功能</h1><p>实现的功能：主存分配、主存保护、虚拟主存</p>
<ul>
<li>地址映射—-将逻辑地址映射成物理地址</li>
<li>主存分配—-在多用户之间分配物理主存</li>
<li>存储保护—-对各用户区的信息提供保护措施</li>
<li>主存扩充&#x2F;虚拟主存—-扩充逻辑主存区</li>
</ul>
<h2 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h2><p>将程序地址空间中使用的逻辑地址变换成主存中的物理地址的过程，称为地址映射。</p>
<p><strong>地址重定位就是操作系统将逻辑地址转变为物理地址的过程。。。也就是对目标程序中的指令和数据进行修改的过程</strong></p>
<p><strong>将逻辑地址空间重定位到物理地址空间的时机有三种：</strong></p>
<p>1、程序编译连接时。</p>
<p>​			在程序编写或程序编译时确定虚、实地址之间的对应关系，结果是一个不能浮动的程序模块。</p>
<p>2、程序装入内存时。</p>
<p>​			在程序装入过程中随即进行的地址变换方式称为<strong>静态地址映射</strong>。</p>
<p>3、程序执行时。</p>
<p>​			在程序执行期间，随着每条指令和数据的访问自动地连续地进行地址映射，这种地址变换方式称为<strong>动态地址映射</strong>。</p>
<p><strong>静态地址映射与动态地址映射的区别</strong></p>
<table>
<thead>
<tr>
<th align="center">静态地址映射</th>
<th align="center">动态地址映射</th>
</tr>
</thead>
<tbody><tr>
<td align="center">在程序装入过程中在程序执行期间进行地址映射</td>
<td align="center">在程序执行期间进行地址映射进行地址映射</td>
</tr>
<tr>
<td align="center">需软件(重定位装入程序)</td>
<td align="center">需硬件地址变换机构( 重定位寄存器)</td>
</tr>
<tr>
<td align="center">需花费较多CPU时间</td>
<td align="center">地址变换快</td>
</tr>
<tr>
<td align="center">不灵活</td>
<td align="center">灵活</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>一、静态重定位</strong><br>　　<strong>静态重定位是在程序执行之前进行重定位，它根据装配模块将要装入的内存起始位置，直接修改装配模块中的有关使用地址的指令。</strong><br>　　例如，一个以“0”作为参考地址的装配模块，要装入以100为起始地址的存储空间。显然，在装入之前要做某些修改，程序才能正确执行。例如，MOV　 EAX，[500]这条指令的意义，是把相对地址为500的存储单元内容1234装入EAX号累器。现在内容为1234的存储单元的实际地址为1500， 即为相对地址(500)加上装入的地址(1000),因此，MOV　EAX，[500]这条指令中的直接地址码也要相应地加上起始地址，而成为MOV　 EAX，[1500]。<br>　　程序中涉及直接地址的每条指令都要进行这样的修改。需要修改的位置称为重定位项，所做的加实际装入模块起始地址修改中的块起始地址称为重定位因子。<br>　　为支持静态重定位，连接程序在生成统一地址空间和装配模块时，　应产生一个重定位项表，连接程序此时还不知道装配模块将要装入的实际位置，故重定位表 所给出的需修改位置是相对地址所表示的位置。<br>　　操作系统的装入程序要把装配模块和重定位项表一起装入内存。由装配模块的实际装入起始地址得到重定位因子，然后实施如下两步：<br>　　（1）取重定位项，加上重定位因子而得到欲修改位置的实际地址；<br>　　（2）对实际地址中的内容再做加重定位因子的修改，从而完成指令代码的修改。<br>　　对所有的重定位项实施上述两步操作后，静态重定位才完成，尔后可启动程序执行。使用过的重定位项表内存副本随即被废弃。</p>
<p>　　<strong>静态重定位有着无需硬件支持的优点，但存在着如下的缺点：一是程序重定位之后就不能在内存中搬动了；二是要求程序的存储空间是连续的，不能把程序放在若干个不连续的区域内。</strong></p>
<p><strong>二、动态重定位</strong><br>　　<strong>动态重定位是指，不是在程序执行之前而是在程序执行过程中进行地址重定位。更确切地说，是在CPU每次访问内存单元前才进行地址变换。</strong>动态重定位可使装配模 块不加任何修改而装入内存，但是它需要硬件——定位寄存器的支持。<br>　　程序的目标模块装入内存时，与地址有关的各项均保持原来的相对地址不进行任何修改。如MOV　1，[500]这条指令仍是相对地址500。当此模块被 操作系统调度到处理机上执行时，操作系统将把此模块装入的实际起始起始地址减去目标模块的相对基地址，然后将其差值装入定位寄存器中。当CPU取得一条访问内存的指令时，地址变换硬件逻辑自动将指令中的相对地址与定位寄存器中的值相加，再依此和值作为内存绝对地址去访问该单元中的数据。<br>　　由此可见，进行动态重定位的时机是在指令执行过程中，每次访问内存前动态地进行。采取动态重定位可带来两个好处：<br>　　（1）目标模块装入内存时无需任何修改，因而装入之后再搬迁也不会影响其正确执行，这对于存储器紧缩、解决碎片问题是极其有利的；<br>　　（2）一个程序由若干个相对独立的目标模块组成时，每个目标模块各装入一个存储区域，这些存储区域可以不是顺序相邻的，只要各个模块有自己对应的定位寄存器就行。</p>
<p>　　<strong>动态重定位技术所付出的代价是需要硬件支持。</strong></p>
</blockquote>
<h2 id="主存分配"><a href="#主存分配" class="headerlink" title="主存分配"></a>主存分配</h2><p>用于主存分配的数据结构：主存资源信息块、空闲区队列；</p>
<p><strong>主存管理器的一些策略</strong></p>
<p>分配策略——在众多个请求者中选择一个请求者的原则</p>
<p>放置策略——在可用资源中，选择一个空闲区的原则</p>
<p><strong>调入策略</strong>——决定信息装入主存的时机预调策略：预先将信息调入主存请调策略：当需要信息时，将信息调入主存</p>
<p><strong>淘汰策略</strong>——在主存中没有可用的空闲区(对某一程序而言)时，决定哪些信息从主存中移走，即确定淘汰已占用的内存区的原则。</p>
<p><strong>调入策略对页式系统或非页式系统没有多大区别，但是淘汰策略和放置策略在页式和非页式系统中是不同的。（页式的页的大小是固定的）</strong></p>
<h2 id="主存扩充"><a href="#主存扩充" class="headerlink" title="主存扩充"></a>主存扩充</h2><p>实现的方法：</p>
<ul>
<li>程序的全部代码和数据存放在辅存中；</li>
<li>将程序当前执行所涉及的那部分程序代码放入主存中；</li>
<li>程序执行时，当所需信息不在主存，由操作系统和硬件相配合来完成主存从辅存中调入信息，程序继续执行。</li>
</ul>
<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p>由操作系统和硬件相配合来完成主存和辅存之间的信息的动态调度。这样的计算机系统好像为用户提供了一个其存储容量比实际主存大得多的存储器，这个存储器称为虚拟存储器。<strong>本质的大小其实是没有变的，但是给用户的感觉就是变大了，1元钱看成了100元，这100元就是虚拟存储器</strong></p>
<p><strong>虚拟存储器的核心是将程序的访问地址和主存的物理地址分离。为什么这么说？我们知道访问地址其实是逻辑地址（虚地址），它会去进行地址映射找到主存地址（这个功能由操作系统实现，所以用户不用管）。但是引入了虚存后（不要和虚地址搞混淆了），我们不需要了解主存的物理地址，我们只在虚存中运行（当然，真正运行的时候还是调入一部分进主存的）。这样就把访问地址和虚存互相对应（也就说成了和主存的物理地址分离）</strong></p>
<ul>
<li>逻辑地址与物理地址分开</li>
<li>存储空间与虚地址空间分开</li>
<li>提供地址变换机构</li>
</ul>
<p><strong>实现虚拟存储器的物质基础</strong></p>
<ul>
<li>有相当容量的辅存：足以存放应用程序的虚地址空间</li>
<li>有一定容量的主存：存放进入主存的多进程的信息</li>
<li>地址变换机构</li>
</ul>
<h2 id="存储保护"><a href="#存储保护" class="headerlink" title="存储保护"></a>存储保护</h2><p>在多用户环境中，主存储器按区分配给各用户程序使用。为了互不影响，必须由硬件(软件配合)保证各用户程序只能在给定的存储区域内活动，这种措施叫做存储保护。</p>
<h3 id="界地址保护"><a href="#界地址保护" class="headerlink" title="界地址保护"></a>界地址保护</h3><h4 id="上、下界保护"><a href="#上、下界保护" class="headerlink" title="上、下界保护"></a>上、下界保护</h4><p><strong>比较的是物理地址</strong>。</p>
<p>硬件为分给应用程序的每一个连续的主存空间设置一对上下界寄存器—–分别指向该存储空间的上界和下界。</p>
<h4 id="基地址、限长保护"><a href="#基地址、限长保护" class="headerlink" title="基地址、限长保护"></a>基地址、限长保护</h4><p><strong>比较的是逻辑地址</strong></p>
<p>基地址存放的是逻辑地址—段的首地址</p>
<h3 id="存储键保护"><a href="#存储键保护" class="headerlink" title="存储键保护"></a>存储键保护</h3><h1 id="分区存储管理"><a href="#分区存储管理" class="headerlink" title="分区存储管理"></a>分区存储管理</h1><p>对应的是主存分配</p>
<h2 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h2><p>在处理程序的过程中，建立分区，依用户请求的大小分配分区。</p>
<p><img src="/images/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/image-20200104213759918.png"></p>
<p>很明显，空闲区被切碎会产生内存碎片。</p>
<p><strong>动态分区的分配方法中，对用户程序进行动态分配并实现动态地址映射（这个不难理解，由于在动态分区中，系统是根据程序的大小再决定分给程序内存空间的大小，在地址映射中，事先根本就不可能有物理地址让你静态地址映射）</strong></p>
<p><img src="/images/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/image-20200104214348973.png"></p>
<h2 id="分区分配数据结构"><a href="#分区分配数据结构" class="headerlink" title="分区分配数据结构"></a>分区分配数据结构</h2><p>主存资源信息块(M_RIB)</p>
<p><img src="/images/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/image-20200104214534920.png"></p>
<p>分区描述器(PD)</p>
<p><img src="/images/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/image-20200104214549857.png"></p>
<blockquote>
<p>flag：为0  ——空闲区<br>             为1  ——已分配区</p>
<p>size：分区大小</p>
<p>next：空闲区——自由主存队列中的勾链字<br>             已分配区——此项为零</p>
</blockquote>
<h2 id="分区的分配和回收"><a href="#分区的分配和回收" class="headerlink" title="分区的分配和回收"></a>分区的分配和回收</h2><p>注意：动态地址映射只是决定了用户程序什么时候将虚地址映射到物理地址中。但是主存分配给用户程序的地址还没有决定。</p>
<h3 id="分区分配"><a href="#分区分配" class="headerlink" title="分区分配"></a>分区分配</h3><p>动态分区的策略如下：“放置策略”</p>
<p>①寻找空闲块<br>                依申请者所要求的主存区的大小，分区分配程序在自由主存队列中找一个满足用户需要的空闲块；</p>
<p>②若找到了所需的空闲区，有两种情况<br>                i 空闲区与要求的大小相等，将该空闲区分配并从队列中摘除；<br>                ii 空闲区大于所要求的的大小，将空闲区分为两部分：一部分成为已分配区，建立已分配区的描述器；剩下部分仍为空闲区。返回所分配区域的首址；</p>
<p>③否则，告之不能满足要求。</p>
<h3 id="分区回收"><a href="#分区回收" class="headerlink" title="分区回收"></a>分区回收</h3><p>①检查释放分区(即为回收分区)在主存中的邻接情况<br>                <strong>若上、下邻接空闲区，则合并，成为一个连续的空闲区</strong></p>
<p>②若回收分区不与任何空闲区相邻接<br>                建立一个新的空闲区，并加入到空闲区队列中。</p>
<h2 id="放置策略"><a href="#放置策略" class="headerlink" title="放置策略"></a>放置策略</h2><p>选择空闲区的策略，称为放置策略。</p>
<p>本质上是空闲区队列的排序问题：<br>如上述提到的从高地址到低地址的分配方式：对应的就是按照地址增加、减少的次序分类排序<br>其他的排序还有：按照区的大小增加、减少的次序排序</p>
<p>常用的放置策略——</p>
<ul>
<li>首次匹配(首次适应算法)</li>
<li>最佳匹配(最佳适应算法)</li>
<li>最坏匹配(最坏适应算法)</li>
</ul>
<h3 id="首次适应"><a href="#首次适应" class="headerlink" title="首次适应"></a>首次适应</h3><p>首次适应算法是将输入的程序放置到主存里第一个足够装入它的地址<strong>最低</strong>的空闲区中。</p>
<p><img src="/images/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/image-20200104222505368.png"></p>
<p><strong>空闲区队列结构：</strong></p>
<p>空闲区地址由低到高排序</p>
<p><img src="/images/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/image-20200104222944954.png"></p>
<p><strong>首次适应算法的特点</strong></p>
<p>尽可能地利用存储器中低地址的空闲区，而尽量保存高地址的空闲区。</p>
<p><img src="/images/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/image-20200104222548961.png"></p>
<h3 id="最佳适应"><a href="#最佳适应" class="headerlink" title="最佳适应"></a>最佳适应</h3><p>最佳适应算法是将输入的程序放置到主存中与它所需大小最接近的空闲区中。</p>
<p><strong>空闲区队列结构</strong></p>
<p>空闲区大小由小到大排序</p>
<p><img src="/images/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/image-20200104222959824.png"></p>
<p><strong>最佳适应算法的特点</strong></p>
<p>尽可能地利用存储器中小的空闲区，而尽量保存大的空闲区。</p>
<h3 id="最坏适应"><a href="#最坏适应" class="headerlink" title="最坏适应"></a>最坏适应</h3><p>最坏适应算法是将输入的程序放置到主存中与它所需大小差距最大的空闲区中。</p>
<p><img src="/images/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/image-20200104222639015.png"></p>
<p><strong>空闲区队列结构</strong></p>
<p>空闲区大小由大到小排序</p>
<p><img src="/images/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/image-20200104223012937.png"></p>
<p><strong>最坏适应算法的特点</strong></p>
<p>尽可能地利用存储器中大的空闲区。</p>
<h2 id="碎片问题及拼接技术"><a href="#碎片问题及拼接技术" class="headerlink" title="碎片问题及拼接技术"></a>碎片问题及拼接技术</h2><p>在已分配区之间存在着的一些没有被充分利用的空闲区。</p>
<p>所谓拼接技术是指移动存储器中某些已分配区中的信息，使本来分散的空闲区连成一个大的空闲区。</p>
<h1 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h1><p>程序的存放将不再是连续的。</p>
<p>程序的地址空间被等分成大小相等的片，称为<strong>页面</strong>，又称为虚页。<br><strong>一般页面的大小为1KB、2KB、4KB</strong></p>
<p>主存被等分成大小相等的片，称为<strong>主存块</strong>，又称为实页。</p>
<p><strong>主存的块和页面的大小是相等的并且为2的幂次</strong></p>
<p>好处：可以方便的支持虚拟存储，扩充内存。因为它可以只将一部分页面装入主存中即可。也直接解决了碎片问题。</p>
<blockquote>
<p>但是在按区分配中，</p>
</blockquote>
<p>需要解决的问题：</p>
<ul>
<li>页式系统的地址映射—–动态地址映射</li>
<li>请调策略—-当装入部分页面的时候，需要询问当前访问的信息是否在主存中。不在的话，系统会从辅存中调入请求的页面。</li>
<li>放置策略—-确定程序的各个页面分配到主存的哪些块中，以及什么原则挑选主存块</li>
<li>淘汰策略—-当主存块用完后，确定哪些页面被淘汰出主存。</li>
</ul>
<h2 id="页式地址变换"><a href="#页式地址变换" class="headerlink" title="页式地址变换"></a>页式地址变换</h2><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>为了实现从地址空间到物理主存的映象，系统建立的<strong>记录页与内存块之间对应关系的地址变换</strong>的机构称为页面映像表，简称页表。</p>
<p>页表的组成：</p>
<p>​		i 如果选择高速缓冲存储器：地址变换速度快，但成本较高</p>
<p>​		ii 如果选择主存区域：地址变换速度比硬件慢，成本较低主存管理——页式存储管理</p>
<h3 id="虚地址结构"><a href="#虚地址结构" class="headerlink" title="虚地址结构"></a>虚地址结构</h3><p>页号+页内位移。</p>
<p>当CPU给出一个虚地址（指令地址或者操作数地址），将其拆分成页号和页内位移表示该地址对应于物理地址中的具体位置（哪个页面和页面中的哪个位置）</p>
<h3 id="页式地址变换-1"><a href="#页式地址变换-1" class="headerlink" title="页式地址变换"></a>页式地址变换</h3><p><img src="/images/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/image-20200104232557824.png"></p>
<p>页式地址变换步骤</p>
<p>i CPU给出操作数地址(为2500) ；<br>ii  由分页机构自动地把逻辑地址分为两部分，得到页号p和页内相对位移w (p &#x3D;2，w &#x3D;452)；<br>iii 根据页表始址寄存器指示的页表始地址，以页号为索引，找到第2页所对应的块号(为7) ；<br>iv  将块号b和页内位移量w拼接在一起，就形成了访问主存的物理地址(7x1024+452&#x3D;7620)</p>
<p>通过页表将虚地址（也就是逻辑地址）中的页号对应到物理地址中的块号。由于页面的大小和内存块的大小是一样的，所以虚地址的页内位移就是物理地址中的块内位移。</p>
<blockquote>
<p>分区管理的地址映射：</p>
<p>每个进程在分区说明表（ 为了管理分区，设置一张不属于任何进程的分区说明表，也就是放置策略章节对应的分区表）找到自己对应的表项目，<strong>根据表中的物理起始地址+自己的逻辑地址，就得到了实际的物理地址</strong>！目前为止需要注意的是，分区分配中，每个进程的分配的物理空间仍然是连续的!</p>
<p>换一个说法：</p>
<p>作业装入内存时，是将该用户的程序和数据原封不动地装入到内存中。当调度该进程在cpu上执行时，<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">操作系统</a>就自动将该进程在内存的起始地址装入<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E5%9F%BA%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">基址寄存器</a>，将进程的大小装入限长寄存器<br>。当执行指令时，如果地址合法，则将相对地址与<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E5%9F%BA%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">基址寄存器</a>中的地址相加，所得结果就是真正要访问的<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">内存地址</a>；如果地址越界，则发出相应中断，进行处理。</p>
<p>虚实地址映射极为简单。</p>
</blockquote>
<h3 id="联想存储器LSB"><a href="#联想存储器LSB" class="headerlink" title="联想存储器LSB"></a>联想存储器LSB</h3><p>高速、小容量半导体存储部件，又称缓冲存储器</p>
<p>快表</p>
<p>在缓冲存储器中存放正在运行的进程当前用到的页号和对应的块号，又称为快表。</p>
<p>具体可以参见《组成原理》中《存储系统》章节。</p>
<p><strong>注意一点：页表查询只在联想映像不匹配时进行</strong></p>
<h2 id="请调页面的机制"><a href="#请调页面的机制" class="headerlink" title="请调页面的机制"></a>请调页面的机制</h2><p>①简单页式系统：装入一个程序的全部页面才能投入运行。</p>
<p>②请求页式系统：装入一个程序的部分页面即可投入运行。</p>
<p>Q：如何发现所要访问的页面不在主存？</p>
<p>A：扩充页表功能</p>
<p>Q：如何确认所要访问的页面不在主存时如何处理？</p>
<p>A：缺页处理</p>
<h3 id="扩充页表功能"><a href="#扩充页表功能" class="headerlink" title="扩充页表功能"></a>扩充页表功能</h3><p><img src="/images/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/image-20200104233939211.png"></p>
<p>中断位i：标识该页是否在主存</p>
<p>​						若i&#x3D;1，表示此页不在主存；<br>​						若i&#x3D;0，表示该页在主存</p>
<p>辅存地址：该页面在辅存的位置</p>
<h3 id="缺页处理"><a href="#缺页处理" class="headerlink" title="缺页处理"></a>缺页处理</h3><ul>
<li><p>当从虚地址中得到页号，判断页号不在主存的时候，会发送缺页中断。</p>
</li>
<li><p>接下来要将缺页的部分拉回到主存中：</p>
<ul>
<li>判断时候有空闲块：<ul>
<li>有的话就从辅存读入所需的页，并且调整存储分配表和页表，然后重新启动被中断的指令</li>
<li>没有的话根据淘汰算法选择一页淘汰（淘汰掉的页如果还有用就将其放回辅存，没有用就丢掉），调整存储分配表和页表。然后从辅存中读入所需的页</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/image-20200104234642517.png"></p>
<h2 id="淘汰机制和策略"><a href="#淘汰机制和策略" class="headerlink" title="淘汰机制和策略"></a>淘汰机制和策略</h2><p>用来选择淘汰哪一页的规则叫做置换策略，或称淘汰算法。</p>
<p>Q：如何确定那一页被淘汰？</p>
<p>A：根据最近有没有使用、使用频率等</p>
<h3 id="扩充页表功能-1"><a href="#扩充页表功能-1" class="headerlink" title="扩充页表功能"></a>扩充页表功能</h3><p><img src="/images/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/image-20200104234749807.png"></p>
<p>①引用位——标识该页最近是否被访问<br>                                为“0”——该页没有被访问；为“1”——该页已被访问</p>
<p>②改变位——表示该页是否被修改<br>                                为“0”——该页未被修改；为“1”——该页已被修改</p>
<blockquote>
<p>颠簸(thrashing)，又称为“抖动”</p>
<p>简单地说，导致系统效率急剧下降的主存和辅存之间的频繁页面置换现像称为“抖动”。</p>
</blockquote>
<h3 id="缺页中断率"><a href="#缺页中断率" class="headerlink" title="缺页中断率"></a>缺页中断率</h3><p>假定程序p共有n页，系统分配m块，有1≤m≤n；若程序p在运行中：成功的访问次数为s，不成功的访问次数为f；缺页中断率：<br>$$<br>f′&#x3D;f&#x2F; (s+ f)\<br>f′&#x3D; f (r，m，p)；\<br>r：置换算法；m：系统分配的块数；p：程序特征<br>$$</p>
<h3 id="常用的置换算法"><a href="#常用的置换算法" class="headerlink" title="常用的置换算法"></a>常用的置换算法</h3><h4 id="最佳算法（OPT算法）"><a href="#最佳算法（OPT算法）" class="headerlink" title="最佳算法（OPT算法）"></a>最佳算法（OPT算法）</h4><p>当要调入一新页而必须先淘汰一旧页时，所淘汰的那一页应是以后不再要用的，或者是在最长的时间以后才会用到的那页。</p>
<p>简单说，就是不肯可能实现的（你怎么知道那页是以后不用的）</p>
<p><strong>站在现在，往未来看</strong></p>
<h4 id="先进先出淘汰算法（FIFO算法）"><a href="#先进先出淘汰算法（FIFO算法）" class="headerlink" title="先进先出淘汰算法（FIFO算法）"></a>先进先出淘汰算法（FIFO算法）</h4><p>总是<strong>选择在主存中居留时间最长(即最早进入主存</strong>)的一页淘汰。</p>
<p><strong>实现</strong></p>
<ul>
<li>建立一个页面进入主存的先后次序表；</li>
<li>建立一个替换指针，指向最早进入主存的页面；</li>
<li>当需要置换一页时，选择替换指向的那一页，然后调整替换指针的内容（指向替换后最早进入主存的页面，因为之前最早进入的被替换出去了）。</li>
</ul>
<blockquote>
<p>在存储分块表中记录页面进入主存的先后次序：4→5→1→2   当要调入第6页时：如何处理? 5→1→2 →6</p>
</blockquote>
<h4 id="最久未使用淘汰算法-LRU算法"><a href="#最久未使用淘汰算法-LRU算法" class="headerlink" title="最久未使用淘汰算法(LRU算法)"></a>最久未使用淘汰算法(LRU算法)</h4><p>总是<strong>选择最长时间未被使用</strong>的那一页淘汰。</p>
<p><strong>实现</strong></p>
<ul>
<li><p>用引用位考察页面的使用情况；</p>
</li>
<li><p>当访问页面时，将引用位置1，并记时；</p>
</li>
<li><p>当要淘汰一页时，选择时间最长的一页淘汰。</p>
<p>要精确实现很困难</p>
<ul>
<li>硬件方法：采用计数器</li>
<li>软件方法：采用页号栈</li>
</ul>
</li>
</ul>
<h1 id="段式、段页式存储管理"><a href="#段式、段页式存储管理" class="headerlink" title="段式、段页式存储管理"></a>段式、段页式存储管理</h1><h2 id="段式地址空间"><a href="#段式地址空间" class="headerlink" title="段式地址空间"></a>段式地址空间</h2><p>分段是程序中自然划分的一组逻辑意义完整的信息集合。<br>分段的例：代码分段、数据分段、栈段页。</p>
<h3 id="程序地址空间"><a href="#程序地址空间" class="headerlink" title="程序地址空间"></a>程序地址空间</h3><p>由若干个逻辑分段组成，每个分段有自己的名字，对于一个分段而言，它是一个连续的地址区。</p>
<p><img src="/images/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/image-20200105001339566.png"></p>
<h3 id="段式地址结构"><a href="#段式地址结构" class="headerlink" title="段式地址结构"></a>段式地址结构</h3><p><img src="/images/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/image-20200105000832513.png"></p>
<h2 id="段式地址变换"><a href="#段式地址变换" class="headerlink" title="段式地址变换"></a>段式地址变换</h2><p>步骤：</p>
<ul>
<li>取出程序地址(s，w)；</li>
<li>用s检索段表；</li>
<li>如w＜0或w≥L则主存越界；</li>
<li>(B＋w)即为所需主存地址（<strong>B是基址</strong>）</li>
</ul>
<h2 id="页式系统与段式系统的区别"><a href="#页式系统与段式系统的区别" class="headerlink" title="页式系统与段式系统的区别"></a>页式系统与段式系统的区别</h2><h3 id="用户地址空间的区别"><a href="#用户地址空间的区别" class="headerlink" title="用户地址空间的区别"></a>用户地址空间的区别</h3><p>①页式系统中用户地址空间：一维地址空间</p>
<p>②段式系统中用户地址空间：二维地址空间</p>
<h3 id="分段和页面的区别"><a href="#分段和页面的区别" class="headerlink" title="分段和页面的区别"></a>分段和页面的区别</h3><table>
<thead>
<tr>
<th align="center">分段</th>
<th align="center">页面</th>
</tr>
</thead>
<tbody><tr>
<td align="center">信息的<strong>逻辑</strong>划分</td>
<td align="center">信息的<strong>物理</strong>划分</td>
</tr>
<tr>
<td align="center">段长是可变的</td>
<td align="center">页的大小是固定的</td>
</tr>
<tr>
<td align="center">用户可见</td>
<td align="center">用户不可见</td>
</tr>
<tr>
<td align="center">w字段的溢出将产生越界中断</td>
<td align="center">w字段的溢出自动加入到页号中</td>
</tr>
</tbody></table>
<h2 id="段页式系统"><a href="#段页式系统" class="headerlink" title="段页式系统"></a>段页式系统</h2><p>在段式存储管理中结合分页存储管理技术，<strong>在一个分段内划分页面</strong>，就形成了段页式存储管理。</p>
<h3 id="程序地址空间-1"><a href="#程序地址空间-1" class="headerlink" title="程序地址空间"></a>程序地址空间</h3><p>地址结构&#x3D;段号+段内页号+页内位移</p>
<p><img src="/images/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/image-20200105001323037.png"></p>
<p><strong>每一个程序一张段表，每个段对应一张页表，段表中的地址是页表的起始地址</strong></p>
<p><img src="/images/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/image-20200105001435733.png"></p>
<p>段页式地址变换要得到物理地址需要经过3次主存访问（当段表、页表都在主存中）：</p>
<ol>
<li>访问段表，得到页表起始地址</li>
<li>访问页表，得到主存块号</li>
<li>将主存块号与页内位移组合得到物理地址</li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><strong>第七章</strong> <strong>习题及解答</strong></p>
<p>7-11如图7.45所示，主存中有两个空白区。现有如下程序序列：程序1要求50KB；程序2要求60KB；程序3要求70KB。若用首次适应算法和最佳适应算法来处理这个程序序列，试问：哪一种算法可以分配得下 ? 简要说明分配过程 (假定分区描述器所占用的字节数已包含在程序所要求的主存容量中) 。</p>
<p><img src="/images/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/clip_image002.png"></p>
<p>答：(1) 首次适应法：</p>
<p>程序1要求50KB，在起始地址为150KB，大小为120 KB的空白区进行分割。120KB-50KB&#x3D;70KB，分割后剩70KB 的空白区。</p>
<p>程序2要求60KB，在剩余的70KB空白区进行分割。70KB-60KB&#x3D;10KB，分割后剩 10KB的空白区。</p>
<p>程序3要求70KB，在起始地址为300KB，大小为78KB的空白区进行分割。78KB-70KB&#x3D;8KB，分割后剩8KB 的空白区。</p>
<p>因此首次适应法可满足该程序序列的需求。</p>
<p>(2) 最佳适应法</p>
<p>程序1要求50KB，在起始地址为300KB，大小为78 KB的空白区进行分割。78KB-50KB&#x3D;28KB，分割后剩28KB 的空白区。</p>
<p>程序2要求60KB，在起始地址为150KB，大小为120KB的空白区进行分割。120KB-60KB&#x3D;60KB，分割后剩60KB的空白区。</p>
<p>程序3要求70KB，。此时系统中有大小为 28KB 和60KB 的两个空白区，它们均不能满足程序3 的需求。</p>
<p>因此最佳适应法不能满足该程序序列的需求。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2019/12/30/OS_%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/30/OS_%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">设备管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-29 22:55:11" itemprop="dateCreated datePublished" datetime="2019-12-29T22:55:11Z">2019-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设备管理概述"><a href="#设备管理概述" class="headerlink" title="设备管理概述"></a>设备管理概述</h1><p>操作系统的设备管理，又称为I&#x2F;O管理，它负责管理设备和控制I&#x2F;O传输操作。</p>
<p>设备分类：</p>
<ul>
<li><p>存储设备</p>
<p>存储设备又称块设备，是存储信息的设备，如：磁盘、 磁鼓 (以块为单位传输信息) 。</p>
</li>
<li><p>输入输出设备</p>
<p>   输入输出设备又称字符设备，能将信息从计算机外部输入到机内，或反之，如：键盘、显示器、打印机 (以子符为单位传输信息) 。</p>
</li>
<li><p>通信设备</p>
<p>   通信设备负责计算机之间的信息传输，如调制解调器、网卡等。</p>
</li>
</ul>
<p><strong>设备管理的目标</strong></p>
<p>   <strong>(1)</strong> <strong>提高设备利用率</strong></p>
<p><strong>①</strong> <strong>合理分配设备</strong></p>
<p><strong>②</strong> <strong>提高设备与CPU、各外部设备之间的并行性</strong></p>
<p>   <strong>(2)</strong> <strong>方便用户的使用</strong></p>
<p>​       提供使用方便且独立于设备的界面</p>
<p><strong>①</strong> <strong>统一：对各种不同的设备提供一致的界面</strong></p>
<p><strong>②</strong> <strong>独立于设备：用户使用的设备与物理设备无关</strong></p>
<p>（可以看成具有良好的封装性）</p>
<h2 id="设备管理的三大功能"><a href="#设备管理的三大功能" class="headerlink" title="设备管理的三大功能"></a>设备管理的三大功能</h2><p>   <strong>(1)</strong> <strong>状态跟踪</strong></p>
<p>   动态地记录各种设备的状态。设备状态信息保留在设备控制块中。</p>
<p>   <strong>(2)</strong> <strong>设备分配与回收</strong></p>
<p><strong>①</strong> <strong>静态分配</strong> <strong>——</strong> <strong>应用程序级</strong></p>
<p>   程序进入系统时进行分配，退出系统时收回全部资源。</p>
<p><strong>②</strong> <strong>动态分配</strong> <strong>——</strong> <strong>进程级</strong></p>
<p>​        进程提出设备申请时进行分配，使用完毕后立即收回。</p>
<p>   <strong>(3)</strong> <strong>设备控制</strong></p>
<p>   实施设备驱动和中断处理的工作。</p>
<h2 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h2><p>所谓设备独立性是指，用户在程序中使用的设备与实际使用的设备无关，也就是在用户程序中仅使用逻辑设备名。</p>
<p><strong>②</strong> <strong>逻辑设备名</strong></p>
<p>   逻辑设备名，是用户自己指定的设备名 (或设备号)，它是暂时的、可更改的。</p>
<p><strong>③</strong> <strong>物理设备名</strong></p>
<p>   物理设备名，是系统提供的设备的标准名称，它是永久的、不可更改的。</p>
<p><strong>两种类型的设备独立性</strong></p>
<p><strong>①</strong> <strong>一个程序独立于分配给它的某种类型的具体设备</strong> </p>
<p>   系统可以根据设备的使用情况，动态地分配给程序某类设备中的任一台物理设备，程序都能正确地执行。</p>
<p><strong>②</strong> <strong>程序应尽可能与它所使用的I&#x2F;O设备类型无关</strong></p>
<p>   在输入 (或输出)信息时，信息可以从不同类型的输入 (或输出)设备上输入 (或输出)，若要改变输入 (或输出) 设备的类型，程序只需进行最少的修改。 </p>
<p>优点：</p>
<p>​			很明显，方便用户、改善设备利用率、提高系统的可扩展性和可适应性</p>
<p><strong>逻辑设备描述器ldd：</strong></p>
<p>描述了进程的逻辑设备和物理设备名的对应关系。</p>
<h3 id="设备独立性的实现"><a href="#设备独立性的实现" class="headerlink" title="设备独立性的实现"></a>设备独立性的实现</h3><p><strong>①</strong> <strong>在高级语言中用软通道实现</strong></p>
<p>   使用高级语言提供的指派语句，通过指派一个逻辑设备名(通道号)来定义一个设备或文件。</p>
<p>​      如：fd &#x3D; open(“&#x2F;dev&#x2F;lp”, mode) </p>
<p><strong>②</strong> <strong>在批处理系统中，用联接说明语句来定义</strong></p>
<p>   如：OUTPUT1 &#x3D; LPT</p>
<p><strong>③</strong> <strong>在交互系统中，用指派命令来定义</strong></p>
<p>​      如：PDP系列机上的RT11系统</p>
<p>​      ASSIGN 设备物理名  设备逻辑名</p>
<h2 id="设备控制块DCB"><a href="#设备控制块DCB" class="headerlink" title="设备控制块DCB"></a>设备控制块DCB</h2><p>系统为每一台设备都配置了一个用来记录设备的硬件特性、连接和使用情况的一组数据，称为设备控制块。</p>
<p><strong>①</strong> <strong>设备名</strong></p>
<p>   设备的系统名，即设备的<strong>物理名</strong>。</p>
<p><strong>②</strong> <strong>设备属性</strong></p>
<p>   描述设备现行状态的一组属性。</p>
<p><strong>③</strong> <strong>命令转换表</strong></p>
<p>​    转换表包含设备特定的I&#x2F;O例程地址，不具备相应功能的设备在其例程地址上可以填“－1”。</p>
<h1 id="缓存技术"><a href="#缓存技术" class="headerlink" title="缓存技术"></a>缓存技术</h1><p>缓冲是两种不同速度的设备之间传输信息时平滑传输过程的常用手段。</p>
<p>缓冲类别：</p>
<p><strong>①</strong> <strong>缓冲器</strong></p>
<p>​       缓冲器是用来暂时存放数据的一种存储装置，它容量较小，存取速度快。</p>
<p><strong>②</strong> <strong>软件缓冲</strong></p>
<p>​       在I&#x2F;O操作期间用来临时存放I&#x2F;O数据的一块存储区域。</p>
<p>引入缓冲的目的：</p>
<p><strong>①</strong> <strong>处理数据流的生产者与消费者间的速度差异</strong></p>
<p>​    如：从调制解调器收到一个文件，并保存到硬盘上。</p>
<p><strong>②</strong> <strong>协调传输数据大小不一致的设备</strong></p>
<p>​    如：在计算机网络中用来处理消息的分段和重组。</p>
<p><strong>③</strong> <strong>应用程序的拷贝语义</strong></p>
<p>​    如：操作系统需要保证系统调用write的正确语义 (应用程序要写入磁盘的数据就是write系统调用发生时的版本)。</p>
<p>​    方法：在系统调用返回前将应用程序缓冲区复制到内核缓冲区。</p>
<h2 id="利用缓冲技术进行I-x2F-O操作"><a href="#利用缓冲技术进行I-x2F-O操作" class="headerlink" title="利用缓冲技术进行I&#x2F;O操作"></a>利用缓冲技术进行I&#x2F;O操作</h2><h3 id="进程活动时，读入数据"><a href="#进程活动时，读入数据" class="headerlink" title="进程活动时，读入数据"></a>进程活动时，读入数据</h3><p>步骤：</p>
<p>ⅰ 当用户要求在某个设备上进行读操作时，首先从系统中获得一个空的缓冲区 (图中标注的操作①)；</p>
<p>ⅱ 将一个物理记录送到缓冲区中 (图中标注的存在②) ；</p>
<p>ⅲ 当用户请求这些数据时，系统将依据逻辑记录特性从缓冲区中提取并发送到用户进程存储区中 (图中标注的操作③) ；</p>
<p>ⅳ 当缓冲区空而进程又要从中取用数据时该进程被迫等待。此时，操作系统需要重新送数据<strong>填满缓冲区</strong>，进程才能从中取数据继续运行。</p>
<p><strong>要注意操作②与操作③的同步关系</strong></p>
<p><img src="/images/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/image-20200105093504783.png"></p>
<h3 id="进程活动时，输出数据"><a href="#进程活动时，输出数据" class="headerlink" title="进程活动时，输出数据"></a>进程活动时，输出数据</h3><p>步骤：</p>
<p>ⅰ 当用户要求进行写操作时，首先从系统中获得一个空的缓冲区 (图中标注的操作①) ；</p>
<p>ⅱ 将一个逻辑记录从进程存储区传送到缓冲区中 (图中标注操作②) ；  </p>
<p>ⅲ 当<strong>缓冲区写满</strong>时，系统将缓冲区的内容作为物理记录文件写到设备上，使缓冲区再次为空 (图中标注的操作③) ；</p>
<p>ⅳ 只有在系统还来不及腾空缓冲区之前，进程又企图输出信息时，它才需要等待。</p>
<p><strong>要注意操作②与操作③的同步关系</strong></p>
<p><img src="/images/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/image-20200105093615775.png"></p>
<p>上述在保证BUF写、输入是满的前提下再进行输出、输入操作是为了保证数据的可靠性</p>
<h3 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h3><p>在双缓冲方案下，为输入或输出分配两个缓冲区buf1 、 buf2 。</p>
<p>①输入设备先填满BUF1</p>
<p>②进程从BUF1提取数据的同时，输入设备填充BUF2</p>
<p>③当BUF1空、BUF2满时，进程又可从BUF2提起数据，与此同时，输入设备又填充BUF1</p>
<p><img src="/images/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/image-20200105093857679.png"></p>
<p><img src="/images/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/image-20200105093957746.png"></p>
<p>还可以使用缓冲池。</p>
<h3 id="UNIX系统的缓冲区管理"><a href="#UNIX系统的缓冲区管理" class="headerlink" title="UNIX系统的缓冲区管理"></a>UNIX系统的缓冲区管理</h3><p>目的：</p>
<p>加快系统响应、增强系统吞吐量</p>
<p>减少对磁盘的I&#x2F;O操作次数</p>
<p><strong>UNIX系统缓冲管理的思路</strong></p>
<ul>
<li><p>当进程要从磁盘读数据时，首先考虑从高速缓冲中读———–<strong>预先缓存</strong></p>
</li>
<li><p>当进程要写数据到磁盘时，先写入高速缓冲中———–<strong>延迟发送</strong></p>
</li>
</ul>
<p><img src="/images/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/image-20200105100316223.png"></p>
<p><strong>缓冲区队列结构</strong></p>
<p>​    <strong>ⅰ</strong> <strong>设备缓冲区队列</strong> </p>
<p>   与某类设备有关的所有缓冲区组成的队列称为设备缓冲区队列，简称b链。</p>
<p>   <strong>ⅱ</strong> <strong>空闲缓冲区队列</strong> </p>
<p>   可供重新分配使用的缓冲区组成的队列称为空闲缓冲区队列，简称av链。</p>
<p>步骤：</p>
<p>​	 ⅰ 一个buf被分配用于读&#x2F;写某设备上的块时置B_ BUSY&#x3D;1，位于b链上，不在av链上；</p>
<p>​    ⅱ 当读&#x2F;写操作结束时释放该buf，置B_BUSY&#x3D;0，<strong>仍留在b链上，并送入av链尾</strong>；</p>
<ul>
<li>在空闲缓冲区队列中的缓存，只要还没有重新分配就保持原有内容不变</li>
</ul>
<p>​	ⅲ 若进程需要的信息在buf中时在该设备的b链上找到，置B_BUSY&#x3D;1；从av链上摘除，使用完后，又送入av链，链入队尾。</p>
<p>​	ⅳ 对空闲buf空队列的处理<br>​		当需要一个空闲buf时，总是取空闲buf队列(av链) 的首元素；一个使用过的buf释放时，插入到空闲buf队列（av链)的队尾。</p>
<p>​       <strong>实现了精确的最久未使用淘汰算法 (LRU</strong>算法)</p>
<p>​	ⅴ 对延迟写的处理<br>​		当一个具有延迟写标记的buf移到av链头，要用于分配时，立即进行写操作。从av链上摘除，使用完后又送入av头部。</p>
<h2 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h2><h3 id="独占分配"><a href="#独占分配" class="headerlink" title="独占分配"></a>独占分配</h3><p>在一个作业执行前，将它所要使用的设备分配给它；当它结束撤离时，将分配给它的这类设备收回。</p>
<p><strong>让一个作业在整个运行期间独占使用的设备</strong></p>
<p><strong>特点</strong></p>
<p>   ⅰ 临界资源</p>
<p>   ⅱ 费时的I&#x2F;O操作或需人工干预    </p>
<p>可能会引起进程死锁</p>
<h3 id="共享分配"><a href="#共享分配" class="headerlink" title="共享分配"></a>共享分配</h3><p><strong>由多个作业、进程共同使用的设备称为共享设备。</strong></p>
<p><strong>特点</strong></p>
<p>ⅰ 旋转设备，可直接或随机访问</p>
<p>ⅱ 便于共享，转接简单，耗费较少</p>
<p>不会引起进程死锁</p>
<h3 id="虚拟分配"><a href="#虚拟分配" class="headerlink" title="虚拟分配"></a>虚拟分配</h3><p>就是如果要使用独占设备的话，就先将数据输入、输出到辅存中。当进程需要输入数据、输出数据的时候，再把数据输入、输出（从辅存中）。理论上一个独占设备可以和辅存上的多个存储区连接，就形成了独占设备变成共享设备的假象。</p>
<p>本质上是提高了独占设备的利用率。</p>
<blockquote>
<p> <strong>(1)</strong> <strong>虚拟技术</strong></p>
<p>​        所谓虚拟技术，是在一类物理设备上模拟另一类物理设备的技术，是将独占设备转化为共享设备的技术。</p>
<p><strong>(2)</strong> <strong>虚拟设备</strong></p>
<p>​        通常把用来代替独占型设备的那部分外存空间 (包括有关的控制表格)称为虚拟设备。</p>
<p><strong>(3)</strong> <strong>虚拟分配</strong></p>
<pre><code>    当进程需要与独占型设备交换信息时，系统将分配磁盘空间，并建立相应的数据结构，这种分配方法称为设备的虚拟分配。
</code></pre>
</blockquote>
<p><img src="/images/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/image-20200105103151386.png"></p>
<h3 id="SPOOLING系统"><a href="#SPOOLING系统" class="headerlink" title="SPOOLING系统"></a>SPOOLING系统</h3><p>​    SPOOLING系统提供外围设备同时联机操作的功能。利用通道和中断技术，在主机控制之下，由通道完成输入输出工作。系统提供一个软件系统 (包括预输入程序、缓输出程序、井管理程序、预输入表、缓输出表)。它提供输入收存和输出发送的功能，使外部设备可以并行操作。这一软件系统称为SPOOLING系统。</p>
<p><strong>设计思想</strong>（也就是虚拟设备的设计思想）</p>
<p><strong>① 预输入</strong></p>
<p>​       在应用程序需要数据前，OS已将所需数据预先输入到辅存 输入井存放。当应用程序 (或进程) 需要数据时，可直接从辅存中读入主存。</p>
<p><strong>② 缓输出</strong></p>
<p>​       在应用程序执行时，将输出数据写入辅存输出井中。当应用程序 (或进程)执行完毕 (或需要数据时) ，由操作系统将数据输出。</p>
<p>优点：</p>
<p> <strong>① 提供虚拟设备</strong></p>
<p> <strong>②</strong> <strong>外围设备同时联机操作</strong></p>
<p> <strong>③</strong> <strong>加快作业处理速度</strong>              </p>
<p><strong>实现SPOOLING系统的基础</strong></p>
<p><strong>①</strong> <strong>大容量的辅存空间</strong></p>
<p>​    在辅存上需开辟两个较大的输入井和输出井，用以存放大量应用程序的输入信息和输出信息。</p>
<p><strong>②</strong> <strong>硬件基础</strong></p>
<p>​    通道装置、中断系统</p>
<p><strong>③</strong> <strong>数据结构</strong></p>
<p>​    预输入表、缓输出表：描述辅存输入井和输出井的状态变化。</p>
<p>​     如： 输入信息从哪台设备输入，存放在辅存输入井什么位置；输出信息存放在辅存输出井什么位置，从哪台输出设备输出。</p>
<p><strong>所需的软件程序</strong>       </p>
<p><strong>ⅰ</strong> <strong>输入程序</strong>     控制信息从独占设备输入到辅存</p>
<p><strong>ⅱ</strong> <strong>缓输出程序</strong>   控制信息从辅存输出到独占设备</p>
<p><strong>ⅲ</strong> <strong>井管理程序</strong>   控制用户程序和辅存之间的信息交换</p>
<h2 id="输入-输出控制"><a href="#输入-输出控制" class="headerlink" title="输入\输出控制"></a>输入\输出控制</h2><p>端口：设备与计算机通信的硬件连接点。</p>
<p>总线：一组线+一组严格定义的可以描述在线上传输信息的协议。这一组线用来连接一个或者多个设备，这种连接成为总线。</p>
<p>控制器：用于操作端口、总线或设备的一组电器器件。</p>
<h3 id="输入-输出控制方式"><a href="#输入-输出控制方式" class="headerlink" title="输入\输出控制方式"></a>输入\输出控制方式</h3><p><strong>循环测试I&#x2F;O方式</strong></p>
<p><strong>I&#x2F;O中断方式</strong></p>
<p><strong>通道方式</strong></p>
<p><strong>DMA方式</strong>  </p>
<p>具体可见组成原理相关章节</p>
<h3 id="I-x2F-O子系统"><a href="#I-x2F-O子系统" class="headerlink" title="I&#x2F;O子系统"></a>I&#x2F;O子系统</h3><p>对设备的控制和操作由内核的IO子系统来实现。可以对设备进行分类，并且提供接口。</p>
<p><strong>①</strong> <strong>解释用户的I&#x2F;O系统调用</strong>   </p>
<p><strong>②</strong> <strong>设备驱动</strong></p>
<p><strong>③</strong> <strong>中断处理</strong></p>
<p><img src="/images/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/image-20200105103514838.png"></p>
<p><strong>①</strong> <strong>在应用层为用户提供I&#x2F;O应用接口</strong></p>
<p>   对设备的控制和操作则由内核I&#x2F;O子系统来实施。</p>
<p><strong>②</strong> <strong>每个通用设备类型都通过一组标准函数(及接口)来访问</strong></p>
<p>   具体的差别被I&#x2F;O子系统中的内核模块(称为设备驱动程序)所封装，这些设备驱动程序一方面可以定制以适合各种设备，另一方面也提供了一组标准的接口。设备驱动程序层的作用是为内核I&#x2F;O子系统隐藏设备控制器之间的差异。将I&#x2F;O子系统与硬讲分离，简化了操作系统开发人员的任务，也有利于设备的设计与制造。          </p>
<p><strong>设备处理程序</strong></p>
<p>​    设备处理程序是能直接控制设备运转的程序，它根据各类设备的特点和性能来编写。<strong>每一类设备有一个相应的设备处理程序，能控制同类中多台物理设备同时工作。</strong></p>
<h4 id="控制I-x2F-O核心模块的方式"><a href="#控制I-x2F-O核心模块的方式" class="headerlink" title="控制I&#x2F;O核心模块的方式"></a>控制I&#x2F;O核心模块的方式</h4><p><strong>①</strong> <strong>以设备处理进程的方式</strong></p>
<p>   ⅰ 为每一类设备设置一个设备处理进程 (对应的程序就是设备处理程序)；</p>
<p>   ⅱ 当有I&#x2F;O请求来到时该进程被唤醒，进行设备驱动工作；当没有I&#x2F;O请求时，该进程睡眠。</p>
<p>​     由<strong>I&#x2F;O控制模块的接口程序</strong>负责解释用户的I&#x2F;O系统调用，将其转换成I&#x2F;O控制模块认识的命令形式后，将I&#x2F;O请求发给对应的设备处理进程。</p>
<p><strong>②</strong> <strong>将设备与文件一样对待</strong></p>
<p>   将设备与文件一样对待，使用文件系统的系统调用命令进行设备的读、写。         </p>
<p>例子：</p>
<blockquote>
<p>   <strong>(1)</strong> <strong>用户进程请求I&#x2F;O的系统功能调用</strong></p>
<p>​        <strong>系统功能调用的形式为：</strong></p>
<p>​       <strong>doio</strong>(ldev,mode,amount,addr);</p>
<p>​       <strong>ldev</strong>：   逻辑设备名</p>
<p>​       <strong>mode</strong>：  操作模式</p>
<p>​       <strong>amount</strong>：传输数据的数目</p>
<p>​       <strong>addr</strong>：   传送地址</p>
<p>​	(2) I&#x2F;O接口程序(I&#x2F;O过程)</p>
<p><strong>①</strong> <strong>将逻辑设备转换为物理设备</strong></p>
<p>​    ⅰ 获得 I&#x2F;O系统调用中给出的逻辑设备名 (ldev)；</p>
<p>   ⅱ 根据逻辑设备描述器，将逻辑设备名转换为物理设备名。</p>
<p><strong>②</strong> <strong>合法性检查</strong></p>
<p>​    ⅰ 获得 I&#x2F;O系统调用中给出的操作模式mode；</p>
<p>   ⅱ 根据DCB中命令转换表中允许的操作，检查操作的合法性。</p>
<p><strong>③</strong> <strong>形成I&#x2F;O请求块，发消息给对应的设备处理进程</strong></p>
<p>   ⅰ 根据请求的参数形成I&#x2F;O请求块 (IORB)；</p>
<p>   ⅱ 将I&#x2F;O请求块 (IORB)挂到对应的设备请求队列。</p>
<p>​	(3) I&#x2F;O接口程序的描述</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;       <span class="keyword">while</span>  (该进程的逻辑设备描述器队列不空)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>  (与ldev相联结的物理设备找到)</span><br><span class="line">                <span class="keyword">break</span>；    <span class="regexp">/ *找到* /</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>  (该进程的逻辑设备描述器队列为空)</span><br><span class="line">            <span class="keyword">return</span>(错误码)；    <span class="regexp">/ * 设备逻辑名错* /</span></span><br><span class="line">        检查参数与该设备特性是否一致;</span><br><span class="line">        <span class="keyword">if</span>  (不一致)</span><br><span class="line">            <span class="keyword">return</span> (错误码)；    <span class="regexp">/ * 传送参数错 * /</span></span><br><span class="line">        构造iorb；</span><br><span class="line">        把iorb插入到该设备的请求队列中；</span><br><span class="line">        唤醒因等待I/O请求块而睡眠的进程；</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>(4)</strong> <strong>设备处理进程</strong></p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">process</span>  <span class="variable">io</span></span><br><span class="line"><span class="punctuation">&#123;</span>   <span class="variable">l</span>： <span class="variable">while</span>  <span class="punctuation">(</span>设备请求队列不空<span class="punctuation">)</span></span><br><span class="line">    <span class="punctuation">&#123;</span>     取一个<span class="variable">iorb</span>；</span><br><span class="line">          提取请求的详细信息；</span><br><span class="line">          启动<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>操作；</span><br><span class="line">          <span class="variable">sleep</span>  <span class="punctuation">(</span>事件：<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>完成<span class="punctuation">)</span>    <span class="operator">/*</span> <span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>操作<span class="operator">*</span> <span class="operator">/</span></span><br><span class="line">              <span class="operator">/*</span> 等<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>完成后，进入中断处理程序，并在那里唤醒设备处理进程<span class="operator">*</span> <span class="operator">/</span></span><br><span class="line">          <span class="variable">if</span>  <span class="punctuation">(</span>出错<span class="punctuation">)</span>    将错误信息写在该设备的<span class="variable">dcb</span>中；</span><br><span class="line">          传送数据到目的地；</span><br><span class="line">          唤醒请求此<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>操作的进程；</span><br><span class="line">          删除<span class="variable">iorb</span>；</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="variable">sleep</span>  <span class="punctuation">(</span>事件：因无<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>请求<span class="punctuation">)</span>；</span><br><span class="line">    <span class="variable">goto</span> <span class="variable">l</span> ；</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>


</blockquote>
<p><img src="/images/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/image-20200105104624110.png"></p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><strong>第七章</strong> <strong>习题及解答</strong></p>
<p>8-1 什么是设备独立性？引入这一概念有什么好处？</p>
<p>答：所谓设备独立性是指，用户在编制程序时所使用的设备同实际使用的设备无关，也就是在用户程序中仅使用逻辑设备。</p>
<p>引入设备独立性，可使应用程序独立于物理设备。此时，用户编程只需用逻辑设备去请求使用某类设备。当系统中有多台该类设备时，系统将其中的任一台备分配给请求进程，而不必局限于某一指定设备。这样，可以显著地提高资源的利用率和可适应性。</p>
<p>独立性还可以使用户程序独立于设备类型。例如，在进行输出时，既可以利用显示终端进行输出，也可以利用打印机进行输出。有了这种适应性，就可以很方便地实现输出重定向，类似地可以实现输入重定向。</p>
<p>8-4 什么是缓冲？引入缓冲的原因是什么？</p>
<p>答：缓冲是两种不同速度的设备之间传输信息时平滑传输过程的常用手段。</p>
<p>引入缓冲技术的原因有如下几点。</p>
<p>(1) 缓和CPU 和I&#x2F;O设备之间速度不匹配的矛盾。</p>
<p>(2) 减少中断次数和CPU 的中断处理时间。如果没有缓冲，慢速 I&#x2F;O设备每传一个字节就要产生一个中断，CPU 必须处理该中断；如果采用了缓冲，则慢速 I&#x2F;O 设备将缓冲填满时，才向CPU发出中断，减少了中断次数和CPU 的中断处理时间。</p>
<p>(3) 解决 DMA 或通道方式下数据传输的瓶颈问题。DMA或通道方式都用于成批数据传输，在无缓冲的情况下，慢速 I&#x2F;O设备只能一个字节一个字节的传输信息，成了DMA 或通道方式数据传输的瓶颈。缓冲的设置适应了DMA 或通道方式的成批数据传输方式，解决了数据传输的瓶颈问题。</p>
<p>8-5 常用的缓冲技术有哪些？</p>
<p>答：常用的缓冲技术有双缓冲、环形缓冲和缓冲池。</p>
<p>引入双缓冲以提高处理机与I&#x2F;O设备之间的并行操作程度，例如，输入设备备先将第一个缓冲装满数据，在输入设备向第二个缓冲装数据时，处理机就可以从第一个缓冲中取出数据进行处理。第一个缓冲的数据处理完毕，若第二个缓冲已经装满数据，则处理机又可以从第二个缓冲中取出数据进行行处理，而输入设备又向第一个缓冲装填数据。</p>
<p>为了在CPU与 外设对信息的操作速度相差甚远时仍能得到良好并行效果，可以采用环形缓冲技术。环形缓冲技术是在主存中分配一组大小相等的存储区作为缓存区，并将这些缓存区链接起来，每个缓存区中有一个指向下一个缓存区的指针，最后一个缓存区的指针指向第一个缓存区，这样n 个缓存区就成了一个环形缓冲外，系统中有个缓冲链首指针指向第一个缓存区。环形缓冲用于输入输出时，需要两个指针in 和out，in 指向第一个空缓存区，out 指向第一个装满数据的缓存区。输入时，把数据输入到in 所指的空缓存区中，然后 in 模取后移一位，指向下一个空缓存区。输出时， 从out所指的满缓存区中取出数据，然 out 模取后移一位，指向下一个满缓存区。</p>
<p>缓冲池是由若干个大小相等的缓存区组成的。缓冲池中的每一个缓存区都由系统统一管理和动态分配。若某个进程需要使用缓冲时便提出申请，由系统将缓存区分配给它，进程不再使用缓存区时，就将缓存区交还给缓冲池。这样，就可以用少量的缓存区服务更多的进程。缓冲池通常将缓存区排成3 个队列：空闲缓存区队列、输入缓存区队列和输出缓存区队列。</p>
<p>8-8 什么是独占设备？对独占设备如何分配？</p>
<p>答：独占设备是指在一段时间内只允许一个用户进程访问的设备。系统一旦把这类设备分配给某进程后，便由该进程独占直到使用完后释放。多数低速 I&#x2F;O设备都属于独占设备，如打印机等。</p>
<p>独占设备采用独占分配方式，即将一个独占设备分配给某进程后便一直由它独占，直到该进程完成或释放该设备时，系统才能将该设备分配给其他进程。</p>
<p>8-9 什么是共享设备？对共享设备如何分配？</p>
<p>答：共享设备是指在一段时间内允许多个进程同时访问的设备，如磁盘。对共享设备可将其同时分配给多个进程，使用共享分配方式显著提高了设备的利用率，但对设备的访问需进行合理的调度。</p>
<p>8-10 什么是虚拟设备技术？什么是虚拟设备？如何进行行虚拟分配？</p>
<p>答：所谓虚拟设备技术，是在一类物理设备上模拟另一个物理设备的技术，是将独占设备转换成共享设备的技术。目前广泛流行的虚拟设备技术是SPOOLing技术，网络环境中的虚拟打印机。</p>
<p>虚拟设备是指通过虚拟技术将一独占设备变换成若干台逻辑设备，供若干个用户进程使用，通常把这种经过虚拟技术处理的设备称为虚拟设备。引入虚拟设备的目的是为了克服独占设备速度较慢、资源利用率较低的缺点，以提高设备的利用率。</p>
<p>虚拟分配是针对虚拟设备而言的。当进程申请独占设备时，由系统分配给它共享设备，如磁盘的一部分存储空间。当进程要和设备交换信息，系统就将要交换的信息放到这部分存储空间中，在合适的时候，系统再将存储空间中的信息传到独占设备。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2019/12/30/OS_%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/30/OS_%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">文件管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-29 22:54:58" itemprop="dateCreated datePublished" datetime="2019-12-29T22:54:58Z">2019-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文件管理概述"><a href="#文件管理概述" class="headerlink" title="文件管理概述"></a>文件管理概述</h1><p><strong>广义上的I&#x2F;O操作是指不经过CPU的操作，侠义的是指对磁盘的访问</strong></p>
<p>文件是<strong>在逻辑上具有完整意义的信息集合</strong>，它有一个名字以供标识，文件名是以字母开头的字母数字串。</p>
<p>构成文件的基本单位：信息项（单个字符或者字节）、记录</p>
<p>(3) 文件的其他描述</p>
<p>①文件是具有符号名的信息(数据)项的集合</p>
<p>②文件是具有符号名的记录的集合</p>
<p>(4) 文件分类</p>
<p>①按文件的性质和用途分类<br>                系统文件（只能通过系统调用） 、程序库文件（允许用户调用，不允许修改） 、用户文件</p>
<p>②按文件保护级别分类	<br>                不保护文件、 执行文件、 只读文件、 读写文件</p>
<p>③分类按文件流向分类<br>                输入文件、 输出文件、 输入输出文件</p>
<p>(5) 文件名与属性</p>
<p>①文件名<br>每个文件有一个给定的名字，这个名字是由串描述且由文件内容来表示，包括文件符号名和内部标识符。</p>
<ul>
<li><p>用户使用文件符号名进行文件操作</p>
</li>
<li><p>系统使用文件内部标识符管理文件</p>
</li>
</ul>
<p>②文件扩展<br>文件扩展表示文件的使用特征，如：.c   .obj    .lib 等。</p>
<p>③文件属性<br>文件的属性字，表示文件类别、保护级等信息。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件系统是操作系统中负责管理和存取文件信息的软件机构。</p>
<p><strong>文件系统的组成</strong></p>
<p>①管理文件所需的数据结构<br>如目录表、文件控制块、存储分配表</p>
<p>②管理程序</p>
<p>③一组操作</p>
<p><strong>文件系统的功能</strong></p>
<p>①从用户角度看——文件系统实现了“按名存取”的功能。</p>
<p>②从系统角度看——辅存空间管理、构造文件结构、提供文件共享功能、提供存取文件的方法、文件保护、提供一组文件操作命令</p>
<p><strong>文件系统的特点</strong></p>
<p>①使用简单<br>使用文件名、一组文件操作命令。</p>
<p>②安全可靠<br>提供防护措施，在文件遭受破坏时，能及时复。全量备份、增量备份、动态备份、远程备份</p>
<p>③既能共享，又能保密<br>身份验证、存取权限验证。</p>
<p>存储数据的文件存储器具有固定的物理特性，数据在辅存设备上的排序、分布构成了文件的物理结构</p>
<p><strong>文件系统负责实现逻辑特性到物理特性的转换</strong></p>
<h2 id="文件组织的两种结构"><a href="#文件组织的两种结构" class="headerlink" title="文件组织的两种结构"></a>文件组织的两种结构</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>从用户角度看到的文件面貌。即用户对信息进行逻辑组织形成的文件结构。</p>
<p><strong>研究文件逻辑结构的目的：</strong></p>
<p>i 为用户提供一种逻辑结构清晰、使用简便的逻辑文件形式。</p>
<p>ii 用户按文件的逻辑结构形式去存储、检索和加工文件中的信息</p>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>文件的物理结构是信息在物理存储器上的存储方式，是数据的物理表示和组织。</p>
<p><strong>研究文件物理结构的目的</strong></p>
<p>i选择工作性能良好、设备利用率高的物理文件形式。</p>
<p>ii  系统按照文件的物理结构形式和外部设备打交道，控制信息的传输。</p>
<h3 id="逻辑记录与物理记录"><a href="#逻辑记录与物理记录" class="headerlink" title="逻辑记录与物理记录"></a>逻辑记录与物理记录</h3><p>①逻辑记录</p>
<p>文件中按信息在逻辑上的独立含义来划分的信息单位，逻辑记录是对文件进行存取操作的基本单位。</p>
<p>②物理记录</p>
<p>在存储介质上，由连续信息所组成的一个区域称为块，也叫物理记录。</p>
<p>③逻辑记录与物理记录的区别与联系</p>
<p>i 一个是逻辑的概念，一个是物理的概念。</p>
<p>ii 逻辑记录最终要存放到物理记录上。</p>
<h2 id="文件的逻辑结构与存取方法"><a href="#文件的逻辑结构与存取方法" class="headerlink" title="文件的逻辑结构与存取方法"></a>文件的逻辑结构与存取方法</h2><h3 id="流式文件"><a href="#流式文件" class="headerlink" title="流式文件"></a>流式文件</h3><p>流式文件是相关的有序字符的集合，是无结构的。</p>
<p>流式文件是按信息的个数或以特殊字符为界进行存取的。</p>
<p>简单来说就是没有格式的文件</p>
<p>UNIX系统为了方便会将流式文件按照512B的大小划分为若干个逻辑记录，将流式文件转变为记录式文件。</p>
<h3 id="记录式文件"><a href="#记录式文件" class="headerlink" title="记录式文件"></a>记录式文件</h3><p>记录式文件是一种有结构的文件。这种文件在逻辑上总是被看成一组连续顺序的记录的集合。</p>
<p>如果文件中所有记录的长度都相同，就称这种文件为定长记录文件。其长度由记录的数量来决定。</p>
<p>如果文件中记录的长度不相同，就称这种文件为变长记录文件。其长度由各个记录长度相加得到。</p>
<h2 id="文件存取方法"><a href="#文件存取方法" class="headerlink" title="文件存取方法"></a>文件存取方法</h2><p>(1) 顺序存取</p>
<p>后一次存取总是在前一次存取的基础上进行的。顺序存取时不必给出具体的存取位置。</p>
<p>(2) 随机存取</p>
<p>用户以任意次序请求某个记录。随机存取时要指出起始存取位置(例如记录号)。</p>
<h1 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h1><h2 id="连续文件"><a href="#连续文件" class="headerlink" title="连续文件"></a>连续文件</h2><p>连续文件结构是由一组分配在磁盘<strong>连续区域</strong>的物理块组成的。</p>
<p>如果连续文件的逻辑记录和磁盘的物理块一样大，就如下图所示：</p>
<p>连续文件的第一个逻辑记录所在的磁盘块号记录在文件目录项中，同时文件目录还记录了磁盘块的数量。8</p>
<p><img src="/images/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20200105124837487.png"></p>
<p> 连续文件的特点</p>
<p>①连续存取时速度较快</p>
<p>②文件长度一经固定便不易改变</p>
<p>③文件的增生和扩充不易</p>
<p>但是当文件不断创建或者删除的时候，将会造成存储空间的浪费（因为文件长度是固定的，多次创建就是占着茅坑不拉屎）</p>
<h2 id="串联文件"><a href="#串联文件" class="headerlink" title="串联文件"></a>串联文件</h2><p>串联文件结构是<strong>按顺序由串联的块组成</strong>的，即文件的信息存于若干块物理块中，每个物理块的最末一个字作为链接字，它指出后继块的物理地址。文件的最后一块的链接字为结束标记“^”，它表示文件至本块结束。</p>
<p><img src="/images/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20200105124920817.png"></p>
<p>串联文件的特点</p>
<p>①能较好地利用辅存空间</p>
<p>②易于对文件进行增生和扩充</p>
<p>③连续存取时速度较快</p>
<p>串联文件的特点也决定了它适合的是顺序存取方式，不适用于随机存取方式。（就像链表一样，找中间元素得遍历链表，不方便）</p>
<h2 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h2><p>索引文件将逻辑文件顺序地划分与物理存储块长度相同的逻辑块。（不一定）</p>
<p>系统为每个文件建立<strong>逻辑块号与物理块号的对照表</strong>。这张表称为该文件的索引表。文件由数据文件和索引表构成。这种文件称为索引文件。</p>
<p>注意：物理块号可以是不连续的。但是逻辑块号一般是连续的。</p>
<p><img src="/images/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20200105125342000.png"></p>
<p>①索引文件在存储区中占两个区</p>
<p>i 索引区：存放索引表</p>
<p>ii 数据区：存放数据文件</p>
<p>②访问索引文件的操作</p>
<p>i 查文件索引，由逻辑块号查得物理块号</p>
<p>ii 由此磁盘物理块号而获得所要求的信息</p>
<p>索引文件的特点</p>
<p>①易于文件的增删</p>
<p>②直接读写任意记录</p>
<p>有点像页表。每次对文件进行修改，索引表都可能会发生改动。</p>
<h3 id="直接索引"><a href="#直接索引" class="headerlink" title="直接索引"></a>直接索引</h3><p><img src="/images/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20200105130504852.png"></p>
<p>文件目录项中有一组表项用于索引。每一个表项登记的是逻辑记录所在的磁盘块号。</p>
<h3 id="一级间接索引"><a href="#一级间接索引" class="headerlink" title="一级间接索引"></a>一级间接索引</h3><p>需要注意：间接索引表磁盘块号和磁盘块号不是一回事</p>
<p><img src="/images/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20200105130601233.png"></p>
<p>文件目录项中有一组表项，其内容登记的是第一级索引表块的块号。第一级索引表块中的索引表项登记的是文件逻辑记录所在的磁盘块号。</p>
<h3 id="二级间接索引"><a href="#二级间接索引" class="headerlink" title="二级间接索引"></a>二级间接索引</h3><p><img src="/images/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20200105130817288.png"></p>
<p>文件目录项中有一组表项，其内容登记的是第二级索引表块的块号。第二级索引表块中的索引表项登记的第一级索引表块的块号，第一级索引表项中登记的是文件逻辑记录所在的磁盘块号。</p>
<p>套娃下去可以是可以，但是检索的时间就变长了。</p>
<h1 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h1><p>就是为了管理怎么分配文件存储空间的。</p>
<h1 id="文件目录及其结构"><a href="#文件目录及其结构" class="headerlink" title="文件目录及其结构"></a>文件目录及其结构</h1><p>文件目录是记录文件的名字、存放地址及其他有关文件的说明信息和控制信息的数据结构</p>
<p><strong>文件目录项的内容</strong></p>
<p>①文件名</p>
<p>②文件逻辑结构<br>说明该文件的记录是否定长、记录长度及记录个数等。</p>
<p>③文件物理结构：记录文件的物理结构形式<br>连续文件——指出文件第一块的物理地址、文件所占块数<br>串联文件——指出该文件第一块的物理地址<br>索引文件——指出索引表地址</p>
<p>④存取控制信息<br>文件主具有的存取权限、核准的其他用户及其相应的存取权限</p>
<p>⑤管理信息<br>文件建立日期、时间，上一次存取时间、要求文件保留的时间等</p>
<p>⑥文件类型<br>文件的类型，例如可分为数据文件、目录文件、块存储设备文件、字符设备文件</p>
<h2 id="一级文件目录"><a href="#一级文件目录" class="headerlink" title="一级文件目录"></a>一级文件目录</h2><p>系统将已建立的<strong>所有文件的文件名</strong>、存放地址及有关的说明信息放在一张表中，这张表称为一级文件目录。</p>
<p><strong>一级文件目录的特点</strong></p>
<ul>
<li>实现了按名存取的功能，比较简单；</li>
<li>要求文件名和文件之间有一一对应的关系，即：不允许两个文件有相同的名字。</li>
</ul>
<blockquote>
<p>重名问题</p>
<p>所谓“重名”，是指不同用户对不同文件起了相同的名字，即两个或多个文件只有一个相同的符号名。又称为命名冲突。</p>
<p>为了解决命名冲突、获得更灵活的命名能力，文件系统必须采用多级目录结构</p>
</blockquote>
<h2 id="树型文件目录"><a href="#树型文件目录" class="headerlink" title="树型文件目录"></a>树型文件目录</h2><p>在多级目录系统中(除最末一级外)，任何一级目录的目录项可以描述一个目录文件，也可以描述一个非目录文件(数据文件)，而<strong>数据文件一定在树叶上</strong>。这样，就构成了一个树形层次结构。</p>
<h3 id="文件路径名"><a href="#文件路径名" class="headerlink" title="文件路径名"></a>文件路径名</h3><p>多级目录中，文件的路径名是由根目录到该文件的通路上<strong>所有目录文件符号名和该文件的符号名</strong>组成的字符串，相互之间用分隔符分隔。</p>
<p><img src="/images/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20200105133705230.png"></p>
<h1 id="文件共享与安全"><a href="#文件共享与安全" class="headerlink" title="文件共享与安全"></a>文件共享与安全</h1><p>文件共享是指某一个或某一部分文件可以让事先规定的某些用户共同使用。</p>
<p>所谓文件安全，就是文件的保护问题。文件的保护是指文件本身不得被未经文件主授权的任何用户存取，而对于授权用户也只能在允许的存取权限内使用文件。</p>
<p>②如何进文件的保护</p>
<p>需要对用户的权限进行验证。所谓存取权限的验证，是指用户存取文件之前，需要检查用户的存取权限是否符合规定，符合者允许使用，否则拒绝。</p>
<p>③验证用户存取权限的方法</p>
<p>i 访问控制矩阵</p>
<p>ii 存取控制表</p>
<p>iii 用户权限表</p>
<p>iv 口令</p>
<p>v 密码</p>
<h2 id="用文件路径名加快文件的查找"><a href="#用文件路径名加快文件的查找" class="headerlink" title="用文件路径名加快文件的查找"></a>用文件路径名加快文件的查找</h2><p>当前目录是当前用户正在使用的文件所在的目录。当指定当前目录后，用户对文件的所有访问都是相对于“当前目录”进行的。这时，文件路径名是由“当前目录”到信息文件的通路上所有各级目录的符号名加上该信息文件的符号名组成。<strong>用“*”表示当前目录的父节点</strong>。</p>
<h2 id="链接技术"><a href="#链接技术" class="headerlink" title="链接技术"></a>链接技术</h2><p>所谓“链接”，就是在相应目录表目之间进行链接，即一个目录中的表目直接指向另一个目录表目所在的物理位置。</p>
<p>注意，这种链接<strong>不是直接指向文件，而是指向相应的目录表目</strong>。这种办法也称为连访，被共享的文件称为连访文件。</p>
<p>相当于添加共享文件中间的链接</p>
<p>在当前目录下新键一个子目录用于链接其共享文件</p>
<p><img src="/images/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image-20200105134329690.png"></p>
<blockquote>
<p>UNIX&#x2F;Linux下的链接文件有两种，硬连接(Hard Link) 和软连接。</p>
<p>软连接又称符号链接(Symbolic link)。<strong>符号链接文件中并不包括实际的文件数据，而只是包括了它指向文件的路径。</strong>它可以链接到任意的文件和目录，包括处于不同文件系统的文件以及目录。当用户对链接文件操作时，系统会自动的转到对源文件的操作，但是删除链接文件时，并不会删除源文件。</p>
<p>硬连接是指通过索引节点对文件的链接。<strong>保存在系统中的每一个文件都会有一个索引节点</strong>。每当有文件链接文件A时，文件A的索引节点的引用计数+1（因为文件自身对自己索引节点会链接，所以索引节点的初始值为1.）当文件系统进行删除文件的时候，对应的文件索引节点的引用计数-1。只要引用计数不等于0，文件就不会真正删除。</p>
</blockquote>
<h1 id="文件操作和文件备份"><a href="#文件操作和文件备份" class="headerlink" title="文件操作和文件备份"></a>文件操作和文件备份</h1><p>常用的文件操作命令</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create：<span class="regexp">//</span>创建一个新文件</span><br><span class="line"><span class="keyword">delete</span>：<span class="regexp">//</span>从系统目录中撤消一个文件</span><br><span class="line">rename：<span class="regexp">//</span>在系统目录中改变文件的名字</span><br><span class="line">open：<span class="regexp">//</span>打开文件   在用户和文件(或设备)之间建立一个逻辑通路</span><br><span class="line">close：<span class="regexp">//</span>关闭文件  在用户和文件(或设备)之间撤消一个逻辑通路</span><br><span class="line">write：<span class="regexp">//</span>写到一个文件(或设备)上</span><br><span class="line">read：<span class="regexp">//</span>从一个文件(或设备)读入数据信息</span><br></pre></td></tr></table></figure>

<p>①打开文件操作</p>
<p>所谓打开文件就是把<strong>该文件的有关目录表目复制到主存中约定的区域，建立文件控制块</strong>，建立用户和这个文件的联系。</p>
<p>②关闭文件操作</p>
<p>所谓关闭文件就是用户宣布这个文件当前不再使用，<strong>系统将其在主存中的文件控制块删去</strong>，因而也就切断了用户同这个文件的联系。</p>
<h2 id="文件备份"><a href="#文件备份" class="headerlink" title="文件备份"></a>文件备份</h2><p>为了能在软、硬件失效的意外情况下恢复文件，保证文件的完整性、数据的连续可利用性，文件系统提供适当的机构，以便复制备份。</p>
<p><strong>文件备份的方法</strong></p>
<p>①周期性转储</p>
<p>按固定的时间周期把存储器中所有文件的内容转存到某种介质上，通常是磁带或磁盘。在系统失效时，使用这些转存磁盘或磁带，将所有文件重新建立并恢复到最后一次转存时的状态。（全部）</p>
<p>②增量性转储</p>
<p>这种技术转储的只是从上次转储以后已经改变过的信息；增量转储的信息量较小，故转储可在更短的时间周期内进行（部分）</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><strong>1</strong>．何谓数据项、记录和文件？</p>
<p>答：①数据项分为基本数据项和组合数据项。基本数据项描述一个对象某种属性的字符集，具有数据名、数据类型及数据值三个特性。组合数据项由若干数据项构成。</p>
<p>②记录是一组相关数据项的集合，用于描述一个对象某方面的属性。</p>
<p>③文件是具有文件名的一组相关信息的集合。</p>
<p><strong>4</strong>．何谓逻辑文件？何谓物理文件？</p>
<p>答：逻辑文件是物理文件中存储的数据的一种视图方式，不包含具体数据，仅包含物理文件中数据的索引。物理文件又称文件存储结构，是指文件在外存上的存储组织形式。</p>
<p><strong>8</strong>．试说明顺序文件的结构及其优点。</p>
<p>答：第一种是串结构：各记录之间的顺序与关键字无关。第二种是顺序结构：指文件中的所有记录按关键字（词）排列。可以按关键词长短排序或英文字母顺序排序。</p>
<p>顺序文件的最佳应用场合是对诸记录进行批量存取时，存取效率最高；只有顺序文件才能存储在磁带上并有效工作。</p>
<p><strong>15</strong>．什么是索引文件？为什么要引入多级索引？</p>
<p>答：索引文件是指当记录为可变长度时，通常为之建立一张索引表，并为每个记录设置一个表项构成的文件。通常将索引非顺序文件简称为索引文件。索引是为了是用户的访问速度更快，多级索引结构可以有效的管理索引文件，可根据用户的访问情况多级处理。</p>
<p><strong>17</strong>．对目录管理的主要要求是什么？</p>
<p>答：实现按名存取、提高检索目录的速度、文件共享、允许文件重名。</p>
<p><strong>18</strong>．采用单级目录能否满足对目录管理的主要要求？为什么？</p>
<p>答：不能。单级目录在整个文件系统中只建立一张目录表，每个文件占一个目录项，其中含文件名、文件扩展名、文件长度、文件类型、文件物理地址、状态位等其它文件属性。</p>
<p>单级只能实现目录管理的基本功能，不能满足查找速度、允许重名和文件共享的要求。</p>
<p><strong>19</strong>．目前广泛应用的目录结构有哪些？它有什么优点？</p>
<p>答：现代操作系统都采用多级目录结构。基本特点是查询速度快、层次结构清晰、文件管理和保护易于实现。</p>
<p>9-6 设文件B按串联文件构造，并由四个逻辑记录组成 (其大小与磁盘块大小相等，均为512B)。这四个逻辑记录分别存放在第100、157、66、67号磁盘块上，回答如下问题。</p>
<p><img src="/images/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/clip_image001.png"></p>
<p>(1) 画出此串联文件文件的结构，</p>
<p>(2) 若要读文件B第1560字节处的信息，问要访问哪一个磁盘块? 为什么?</p>
<p>(3) 读文件B第1560字节处的信息需要进行多少次I&#x2F;O操作? 为什么?</p>
<p>(1) 答：此串联文件结构如下图所示。</p>
<p>(2) 答：1560&#x2F;512&#x3D;3余24，因此文件第1560逻辑字节在r3逻辑块上，该逻辑块被分配在67号磁盘块上。</p>
<p>(3) 答：要访问67号磁盘块，需要先找到文件目录，然后依次访问100、157和66号磁盘块，最后读取67号磁盘块。因此若文件已打开 (文件目录信息已在内存中) 需要4次I&#x2F;O操作，文件未打开需要5次I&#x2F;O操作。</p>
<p>9-16什么是“重名”问题 ? 二级文件目录结构如何解决这一问题?</p>
<p>答：重名是指不同用户对不同文件起了相同的名字。在二级文件目录结构中，每个用户建立用户文件目录，系统建立主目录，登记所有用户目录的信息，用目录名加文件名唯一标识每个文件解决重名问题。</p>
<p>9-18 假设两个用户共享一个文件系统，用户甲要用到文件a、b、c、e，用户乙要用到文件a、d、e、f。已知：用户甲的文件a与用户乙的文件a实际上不是同一文件；用户甲的文件c与用户乙的文件f实际上是同一文件；甲、乙两用户的文件e是同一文件。试拟定一个文件组织方案，使得甲、乙两用户能共享该文件系统而不致造成混乱。</p>
<p>答：如下图所示。用户甲的主目录名为jia，有四个文件，文件名为a、b、c、e。</p>
<p>用户乙的主目录名为yi，有四个文件，文件名为a、d、e、f。</p>
<p><img src="/images/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/clip_image002.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rhb</p>
  <div class="site-description" itemprop="description">纵浪大化中，不喜亦不惧</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">154</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RShawshank" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RShawshank" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rhb</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://lib.baomitu.com/canvas-nest.js/1.0.1/canvas-nest.js"></script>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
