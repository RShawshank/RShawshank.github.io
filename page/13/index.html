<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rshawshank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="纵浪大化中，不喜亦不惧">
<meta property="og:type" content="website">
<meta property="og:title" content="rhb_blog">
<meta property="og:url" content="http://rshawshank.github.io/page/13/index.html">
<meta property="og:site_name" content="rhb_blog">
<meta property="og:description" content="纵浪大化中，不喜亦不惧">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rhb">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rshawshank.github.io/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>rhb_blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rhb_blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">rao的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">57</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">23</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">142</span></a>

  </li>
        <li class="menu-item menu-item-photos">

    <a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
        <li class="menu-item menu-item-readnote">

    <a href="/readnote" rel="section"><i class="fa fa-book fa-fw"></i>阅读笔记</a>

  </li>
        <li class="menu-item menu-item-somethink">

    <a href="/somethink/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>随笔闲谈</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/RShawshank" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2019/12/30/OS_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/30/OS_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">操作系统概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-29 22:53:49" itemprop="dateCreated datePublished" datetime="2019-12-29T22:53:49Z">2019-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="操作系统和其结构的关系"><a href="#操作系统和其结构的关系" class="headerlink" title="操作系统和其结构的关系"></a>操作系统和其结构的关系</h1><p>首先明确操作系统的作用：<br>1&gt;        方便用户<br>2&gt;        提高资源使用率</p>
<h2 id="操作系统与计算机各层次的关系"><a href="#操作系统与计算机各层次的关系" class="headerlink" title="操作系统与计算机各层次的关系"></a>操作系统与计算机各层次的关系</h2><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E7%A1%AC%E4%BB%B6/image-20191229234139136.png"></p>
<p>操作系统管理系统中的各种资源，控制用户和应用程序的工作流程。</p>
<p>（1)  OS对各层的管理和控制包括下以方面：</p>
<ul>
<li><p>控制CPU的工作</p>
</li>
<li><p>访问存储器</p>
</li>
<li><p>设备驱动、中断处理</p>
</li>
<li><p>控制、管理</p>
</li>
<li><p>提供方便的用户界面</p>
</li>
<li><p>提供优质的服务</p>
</li>
</ul>
<p>(2)    各层对OS的制约和影响</p>
<p>下层硬件环境的制约：</p>
<ul>
<li>提供OS运行环境</li>
<li>限制了OS的功能实现</li>
</ul>
<h2 id="存储程序式计算机的结构和特点"><a href="#存储程序式计算机的结构和特点" class="headerlink" title="存储程序式计算机的结构和特点"></a>存储程序式计算机的结构和特点</h2><p>主要说的就是冯式结构计算机。</p>
<p><strong>集中顺序过程控制的特点</strong></p>
<p>①过程性：模拟人们手工操作</p>
<p>②集中控制：由CPU集中管理</p>
<p>③顺序性：程序计数器</p>
<p>早期的计算机是单用户OS，是顺序计算模型。他的问题就是CPU的利用率不高。</p>
<h2 id="操作系统形成和发展过程"><a href="#操作系统形成和发展过程" class="headerlink" title="操作系统形成和发展过程"></a>操作系统形成和发展过程</h2><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E7%A1%AC%E4%BB%B6/image-20191229234951465.png"></p>
<h3 id="操作系统发展的初期阶段"><a href="#操作系统发展的初期阶段" class="headerlink" title="操作系统发展的初期阶段"></a>操作系统发展的初期阶段</h3><h4 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h4><ul>
<li>独占性</li>
<li>串行性</li>
</ul>
<h4 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a>批处理阶段</h4><p>出现<strong>监管程序</strong></p>
<h4 id="联机批处理"><a href="#联机批处理" class="headerlink" title="联机批处理"></a>联机批处理</h4><p>解决了人机矛盾。</p>
<p>①特点：<strong>监督程序、作业自动过渡</strong></p>
<p>②问题：CPU高速与I&#x2F;O慢速的矛盾</p>
<p>③解决办法：由卫星机负责I&#x2F;O</p>
<p>监管程序是为了审查作业对系统资源的要求，满足就把作业调入主存中。</p>
<p>注意：联机的意思是CPU对I&#x2F;O的控制方式，<strong>如果CPU是直接控制I&#x2F;O的操作，就是联机操作方式</strong>。</p>
<h4 id="脱机批处理"><a href="#脱机批处理" class="headerlink" title="脱机批处理"></a>脱机批处理</h4><p>为了克服CPU高速和&#x2F;O低速之间的矛盾。</p>
<p>①特点：主机与卫星机并行操作</p>
<p>②问题：调度不灵活；保护问题</p>
<p>③解决办法：硬件技术的发展——通道技术、中断技术</p>
<p>主机负责计算、卫星机负责I&#x2F;O工作。作业通过卫星机输入到磁带上，然后移到主机上。</p>
<h4 id="执行系统"><a href="#执行系统" class="headerlink" title="执行系统"></a>执行系统</h4><p>提供了系统保护，避免了磁盘的拆卸。</p>
<p>(1) 什么是执行系统</p>
<p>借助于<strong>通道与中断技术</strong>，由主机控制I&#x2F;O工作。原有的监督程序不仅要负责调度作业自动地运行，而且还要提供I&#x2F;O控制功能。它常驻主存，称为执行系统。</p>
<p>(2) 特点</p>
<p>主机、外设并行操作；增强了保护能力</p>
<p>(3) 基本功能</p>
<p>I&#x2F;O控制功能、调度</p>
<p>(4) 问题主机与外设的并行是有限度的，还依赖于程序运行的特征。</p>
<h3 id="操作系统的形成"><a href="#操作系统的形成" class="headerlink" title="操作系统的形成"></a>操作系统的形成</h3><h4 id="多道程序设计技术"><a href="#多道程序设计技术" class="headerlink" title="多道程序设计技术"></a>多道程序设计技术</h4><blockquote>
<p>其自动处理过程是：首先，由监督程序将磁带上的第一个作业装入内存，并把运行控制权交给该作业。当该作业处理完成时，又把控制权交还给监督程序，再由监督程序把磁带(盘)上的第二个作业调入内存。计算机系统就这样自动地一个作业一个作业地进行处理（顺序性），直至磁带(盘)上的所有作业全部完成（自动性）。内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行（单道性），这样便形成了早期的批处理系统；</p>
</blockquote>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E7%A1%AC%E4%BB%B6/image-20191230103833647.png">从上述分析可知，在输入操作系统结束之前，处理机处于空闲状态，原因是I&#x2F;O处理与本道程序相关。</p>
<p>①  什么是多道程序程序设计技术</p>
<p><strong>多道程序设计技术是在计算机主存中同时存放几道相互独立的程序这些程序在管理程序控制之下，相互穿插地运行。当某道程序因某种原因不能继续运行下去时(如等待外部设备传输数据)，管理程序便将另一道程序投入运行。</strong></p>
<p>②  多道运行的特征</p>
<ul>
<li><strong>多道</strong></li>
<li><strong>宏观上并行</strong></li>
<li><strong>微观上串行</strong>（由下面的运行过程可知，本质上还是串行运行的，只不过提高了CPU的利用率，导致宏观上看前来是并行的）</li>
</ul>
<blockquote>
<p>1、<strong>运行过程</strong>：</p>
<p>​    在该系统中，用户所提交的作业都先存放在外存上并排成一个队列，称为“后备队列”（首先将作业放置在磁盘中，然后再由磁盘调入道内存中）；然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享 CPU和系统中的各种资源。</p>
<p> 2、<strong>优缺点</strong>：</p>
<p>​    提高资源利用率：共享资源的充分利用；</p>
<p>​    提高系统吞吐量：系统在单位时间内完成的总工作量；</p>
<p>​    平均周转时间长：作业从进入系统开始直至作业完成并推出系统所经历的时间；</p>
<p>​    无交互能力：用户无法与自己的作业进行交互；</p>
<p>3、<strong>多道批处理系统应该解决的问题</strong>：</p>
<p>​    处理机的管理；</p>
<p>​    内存的管理；</p>
<p>​    I&#x2F;O设备的管理；</p>
<p>​    文件的管理；</p>
<p>​    作业的管理；</p>
</blockquote>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E7%A1%AC%E4%BB%B6/image-20191230104328746.png"></p>
<h4 id="分时技术"><a href="#分时技术" class="headerlink" title="分时技术"></a>分时技术</h4><p>①    什么是分时技术</p>
<p>22所谓分时技术，是把处理机时间划分成很短的<strong>时间片</strong>(如几百毫秒)轮流分配给各个应用程序使用，如果某个程序在分配的时间片用完之前计算还未完成，该程序就暂时中断，等待下一轮继续计算。</p>
<p><strong>注意：CPU是一个独占资源</strong></p>
<p>②   分时处理</p>
<p>一台计算机与许多终端设备连接，终端用户以联机方式使用计算机。</p>
<h4 id="实时技术"><a href="#实时技术" class="headerlink" title="实时技术"></a>实时技术</h4><p>①什么是实时</p>
<p><strong>计算机对于外来信息能够在被控对象允许的截止期限(deadline)内作出反应。</strong></p>
<p>②实时处理</p>
<p>实时处理以快速反应为特征，对实时信号能在截止期限之内处理并作出反应。<br>实时处理具有实时性和可预测性。</p>
<blockquote>
<p>计算机体系结构与操作系统的关系</p>
<p>(1) 单CPU计算机配置的操作系统</p>
<p>批量操作系统         分时操作系统</p>
<p>实时操作系统         个人计算机操作系统</p>
<p>(2) 具有并行结构的计算机系统配置的操作系统</p>
<p>网络操作系统(计算机网络，松耦合)<br>多处理机操作系统(多处理机系统，紧耦合)<br>集群操作系统(分布存储的多计算机系统)<br>并行分布式系统(分布存储的多计算机系统)<br>分布式系统(具有单一用户界面，支持分布式数据处理)<br>分布式实时系统(支持分布式实时数据处理)</p>
</blockquote>
<h2 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h2><h3 id="资源共享与资源竞争"><a href="#资源共享与资源竞争" class="headerlink" title="资源共享与资源竞争"></a>资源共享与资源竞争</h3><ul>
<li>资源共享：多个计算任务对计算机系统资源的共同享用</li>
<li>资源竞争：多个计算任务对计算机系统资源的争夺</li>
</ul>
<h3 id="操作系统的定义和特征"><a href="#操作系统的定义和特征" class="headerlink" title="操作系统的定义和特征"></a>操作系统的定义和特征</h3><p>(1) 操作系统的定义</p>
<p>操作系统是一个大型的程序系统，它负责计算机系统软、硬件资源的分配；控制和协调并发活动；提供用户接口，使用户获得良好的工作环境。</p>
<p>(2) 操作系统的特征</p>
<p>①   <strong>并发</strong><br>能处理多个同时性活动的能力</p>
<p>②    <strong>共享</strong><br>多个计算任务对系统资源的共同享用</p>
<p>③    <strong>不确定性</strong><br>操作系统能处理大量的、随机的事件序列，使各用户的计算任务正确地完成。</p>
<h2 id="操作系统的资源管理功能"><a href="#操作系统的资源管理功能" class="headerlink" title="操作系统的资源管理功能"></a>操作系统的资源管理功能</h2><p>操作系统的主要功能：</p>
<ul>
<li>对系统资源实施管理和调度</li>
<li>控制和协调并发活动</li>
<li>对外提供用户界面</li>
</ul>
<p>计算机系统中最重要的资源就是<strong>CPU</strong>，<strong>内存</strong>也是计算机系统的重要资源。</p>
<h3 id="处理机管理"><a href="#处理机管理" class="headerlink" title="处理机管理"></a>处理机管理</h3><p>(1) 提出进程调度策略</p>
<p>确定将CPU先分给哪个用户程序，它占用多长时间，下一个又该轮到哪个程序运行等问题。</p>
<p>(2) 给出进程调度算法</p>
<p>确定进程调度下一个进程的顺序</p>
<p>(3) 进行处理机的分派</p>
<p>在调度时机到来时，进行处理机分派。</p>
<h3 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h3><p>(1) 存储分配和存储无关性</p>
<p>确定各应用程序在主存中的位置及所占区域的大小；应用程序无需关心存储细节，由存储管理模块提供地址重定位能力。</p>
<p>(2) 存储保护</p>
<p>系统提供基址、界限寄存器等存储保护方法，使各应用程序相互隔离。</p>
<p>(3) 存储扩充绪论——操作系统的资源管理功能</p>
<p>系统提供虚拟存储技术，扩大逻辑主存。</p>
<h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><p>(1) 设备无关性</p>
<p>设备无关性是指用户向系统申请和使用的设备与实际操作的设备无关，以达到方便用户、提高设备利用率的目的。</p>
<p>(2) 设备分配</p>
<p>操作系统为各应用程序和运行实体分配各种设备。设备分配通常采用三种基本技术：独享、共享及虚拟技术。</p>
<p>(3) 设备的传输控制</p>
<p>设备的传输控制包括：启动设备、中断处理、结束处理三个方面</p>
<h3 id="信息管理（文件系统）"><a href="#信息管理（文件系统）" class="headerlink" title="信息管理（文件系统）"></a>信息管理（文件系统）</h3><p>文件系统为用户提供一种简便的、统一的存取和管理信息的方法，并解决信息的共享、数据的存取控制和保密等问题。</p>
<ul>
<li>信息组织</li>
<li>存取方法</li>
<li>文件共享</li>
<li>文件安全</li>
<li>文件完整性</li>
<li>磁盘空间分配</li>
</ul>
<h2 id="操作系统的基本类型"><a href="#操作系统的基本类型" class="headerlink" title="操作系统的基本类型"></a>操作系统的基本类型</h2><h3 id="批量操作系统"><a href="#批量操作系统" class="headerlink" title="批量操作系统"></a>批量操作系统</h3><p>采用多道程序设计技术。该系统把用户提交的程序组织成作业形式。作业成批送入计算机，然后由作业调度程序自动选择作业，在系统内多道运行。</p>
<p>比较远古。</p>
<p><strong>特点</strong></p>
<ul>
<li><p>系统吞吐率高</p>
<p>合理的搭配多道程序即可</p>
</li>
<li><p>作业周转时间长，用户使用不方便</p>
<blockquote>
<p>用户向系统提交作业到获得系统的处理信息的时间间隔就是作业周转时间</p>
</blockquote>
</li>
</ul>
<h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3><p>分时操作系统是操作系统的另一种类型。它一般采用时间片轮转的办法，使一台计算机同时为多个终端用户服务。该系统对每个用户都能保证足够快的响应时间，并提供交互会话功能。</p>
<p><strong>特点</strong></p>
<p>①并行性</p>
<p>宏观上并行</p>
<p>②独占性</p>
<p>微观上串行，当时间片很短时，就会形成独占的错觉</p>
<p>③交互性</p>
<p>用户和计算机之间可以进行命令行的交互对话</p>
<h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><p>实时操作系统对外部输入的信息，能够在规定的时间内处理完毕并作出反应。</p>
<p><strong>特点</strong></p>
<p>i 可靠性和安全性<br>放在第一位，系统的效率放在第二位。</p>
<p>ii 及时响应</p>
<p>这是实时操作系统的核心特点</p>
<blockquote>
<h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h4><p>配置了实时操作系统的系统。该系统可以对科学实验、医学成像、工业控制、武器装备控制和特定显示系统进行实时控制的系统。</p>
<h4 id="硬实时系统"><a href="#硬实时系统" class="headerlink" title="硬实时系统"></a>硬实时系统</h4><p>系统必须满足应用程序对截止期限(deadline)的要求，若错过了截止期限，将导致灾难性后果。</p>
<h4 id="软实时系统"><a href="#软实时系统" class="headerlink" title="软实时系统"></a>软实时系统</h4><p>系统中截止期限被错过的情况下，只造成系统性能下降而不会带来严重后果。</p>
</blockquote>
<h2 id="个人操作系统"><a href="#个人操作系统" class="headerlink" title="个人操作系统"></a>个人操作系统</h2><p>windows是单用户多任务操作系统</p>
<p>UNIX系统是多用户多任务分时操作系统</p>
<p>Linux系统是多用户多任务系统</p>
<h2 id="多处理机系统"><a href="#多处理机系统" class="headerlink" title="多处理机系统"></a>多处理机系统</h2><p>广义上说，使用多台<a target="_blank" rel="noopener" href="http://www.baike.com/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>协同工作来完成所要求的任务的计算机系统都是多处理机系统。传统的狭义多处理机系统是指利用系统内的多个<a target="_blank" rel="noopener" href="http://www.baike.com/wiki/CPU">CPU</a>并行执行用户多个程序，以提高系统的吞吐量或用来进行冗余操作以提高系统的可靠性。</p>
<p>①    包含两个或多个功能相当的处理器</p>
<p>②    所有处理器共享一个公共内存</p>
<p>③    所有处理器共享I&#x2F;O通道、控制器和外围设备</p>
<p>④    由一个操作系统控制</p>
<h2 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h2><p>网络操作系统把计算机网络中的各台计算机有机地结合起来，提供一种统一、经济而有效的使用各台计算机的方法，实现各个计算机之间的互相传送数据。网络操作系统最主要的特点是<strong>网络中各种资源的共享以及各台计算机之间的通信。</strong></p>
<p>有点类似于集中式</p>
<h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><p> 分布式计算机系统是由多台计算机组成并满足下列条件的系统：系统中任意两台计算机通过通信方式交换信息；<strong>系统中的每一台计算机都具有同等的地位</strong>，即没有主机也没有从机； 每台计算机上的资源为所有用户共享；系统中的任意若千台计算机都可以构成一个子系统，并且还能重构；任何工作都可以分布在几台计算机上，由它们并行工作、协同完成。用于管理分布式计算机系统的操作系统称为分布式计算机系统。该系统的主要特点是：分布性和并行性。分布式操作系统与网络操作系统本质上的不同之处在于分布式操作系统中，若干台计算机相互协同完成同一任务。</p>
<blockquote>
<p>分布式系统和计算机网络系统的共同点是：多数分布式系统是建立在计算机网络之上的，所以分布式系统与计算机网络在物理结构上是基本相同的。<br>他们的区别在于：分布式操作系统的设计思想和网络操作系统是不同的，这决定了他们在结构、工作方式和功能上也不同。网络操作系统要求网络用户在使用网络资源时首先必须了解网络资源，网络用户必须知道网络中各个计算机的功能与配置、软件资源、网络文件结构等情况，在网络中如果用户要读一个共享文件时，用户必须知道这个文件放在哪一台计算机的哪一个目录下；分布式操作系统是以全局方式管理系统资源的，它可以为用户任意调度网络资源，并且调度过程是“透明”的。当用户提交一个作业时，分布式操作系统能够根据需要在系统中选择最合适的处理器，将用户的作业提交到该处理程序，在处理器完成作业后，将结果传给用户。在这个过程中，用户并不会意识到有多个处理器的存在，这个系统就像是一个处理器一样。</p>
</blockquote>
<h1 id="操作系统的结构和硬件支持"><a href="#操作系统的结构和硬件支持" class="headerlink" title="操作系统的结构和硬件支持"></a>操作系统的结构和硬件支持</h1><h2 id="操作系统虚拟机"><a href="#操作系统虚拟机" class="headerlink" title="操作系统虚拟机"></a>操作系统虚拟机</h2><p>配置在裸机上的第一层软件是操作系统。在裸机上配置了操作系统后就构成了操作系统虚拟机。</p>
<h3 id="操作系统虚拟机的指令系统"><a href="#操作系统虚拟机的指令系统" class="headerlink" title="操作系统虚拟机的指令系统"></a>操作系统虚拟机的指令系统</h3><p>裸机的指令系统：机器指令</p>
<p>操作系统虚拟机的指令系统：<br>1、操作命令</p>
<ul>
<li><strong>键盘命令</strong></li>
<li><strong>作业控制语言</strong></li>
<li><strong>图形化用户界面</strong></li>
</ul>
<p>2、系统功能调用</p>
<h2 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h2><h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><p>操作系统由许多层构成，每一层都提供一项功能，并且该功能依赖于该层以内的各层。“洋葱结构”。</p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E7%A1%AC%E4%BB%B6/image-20191230145411109.png"></p>
<p>各层之间的模块只能<strong>是单向依赖或单向调用</strong>（如只允许上层或外层模块调用下层或内层模块）关系。<strong>将整体式结构的无序性变为有序性</strong>。</p>
<p><strong>优点</strong>：化整为零（功能分解）；结构清晰、不构成循环；易于调试、易于修改、易于扩充、易于维护、易于保证正确性（增加或替换一层不影响其它层）</p>
<h3 id="微内核OS结构（客户机／服务器）"><a href="#微内核OS结构（客户机／服务器）" class="headerlink" title="微内核OS结构（客户机／服务器）"></a>微内核OS结构（客户机／服务器）</h3><p>在微内核设计背后的思想是为了实现高可靠性，将操作系统划分成小的、良好定义的模块，只有其中一个模块–微内核–运行在内核态上，其余的模块，由于功能相对弱些，则作为普通用户进程运行。特别地由于把每个设备驱动和文件系统分别作为普通用户，这些模块中的错误虽然会使这些模块崩溃，但是不会使得整系统死机。</p>
<p>特点如下：</p>
<p>1.<strong>运行在核心态的内核</strong>：内核提供所有操作系统基本都具有的那些操作，只提供了一个很小的功能集合。</p>
<p>2.<strong>运行在用户态的并以客户机／服务器方式运行的进程层</strong>：除内核部分外，操作系统所有的其他部分被分成若干个相对独立的进程，每一个进程实现一组服务，称为服务进程。</p>
<blockquote>
<p>客户机&#x2F;服务器运行模式：<br>客户机进程与服务器进程之间的通信是采用发送消息进行的，这是因为每个进程属于不同的虚拟地址空间，它们之间不能直接通信，必须通过内核进行，而内核则是被映射到每个进程的虚拟地址空间内的，它可以操纵所有进程。客户机进程发出消息，内核将消息传给服务进程。服务进程执行相应的操作，其结果又通过内核用发消息方式返回给客户机进程。</p>
<p>客户机&#x2F;服务器运行模式的优点：<br>将操作系统分成若干个小的并且自包含的分支（服务进程），每个分支运行在独立的用户进程中，相互之间通过规范一致的方式接收发送或消息而联系起来。操作系统在内核中建立起了最小的机制，而把策略留给用户空间中的服务进程，这带来了很大的灵活性。<br>可靠：分支独立只包含，单一故障不影响其它。<br>灵活：方便增加新的服务功能。<br>适宜于分布式环境：不同服务进程可以运行在不同处理器或计算机上。</p>
<p>客户机&#x2F;服务器运行模式的缺点：<br>所有的用户进程只能通过微内核相互通信，微内核本身就成为系统的瓶颈，在一个通信很频繁的系统中，微内核往往不能提供很好的效率。</p>
</blockquote>
<h3 id="实例操作系统的结构"><a href="#实例操作系统的结构" class="headerlink" title="实例操作系统的结构"></a>实例操作系统的结构</h3><h4 id="UNIX操作系统的结构"><a href="#UNIX操作系统的结构" class="headerlink" title="UNIX操作系统的结构"></a>UNIX操作系统的结构</h4><ul>
<li>UNIX核心层<ul>
<li>处理机管理</li>
<li>存储管理</li>
<li>设备管理</li>
<li>文件系统</li>
</ul>
</li>
<li>UNIX实用层<ul>
<li>实用程序 —— 编辑程序、调试程序、系统状态监控、 文件管理等实用程序 </li>
<li>存储管理软件工具 ——源代码控制程序SCCS、文档准备程序包等</li>
</ul>
</li>
</ul>
<h4 id="Linux系统的核心结构"><a href="#Linux系统的核心结构" class="headerlink" title="Linux系统的核心结构"></a>Linux系统的核心结构</h4><p>Linux系统一般有4个主要部分：</p>
<p><strong>内核、shell、文件系统和应用程序</strong>。内核、shell和文件系统一起形成了基本的操作系统结构，它们使得用户可以运行程序、管理文件并使用系统。</p>
<blockquote>
<p>shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是一个命令解释器。</p>
</blockquote>
<p><strong>用户态和核心态</strong></p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E7%A1%AC%E4%BB%B6/image-20191230150210049.png"></p>
<p>Linux系统将自身划分为两部分，一部分为核心软件，即是kernel，也称作<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/4271323.htm">内核空间</a>，另一部分为普通应用程序，这部分称为用户空间。</p>
<h4 id="windows系统的结构"><a href="#windows系统的结构" class="headerlink" title="windows系统的结构"></a>windows系统的结构</h4><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E7%A1%AC%E4%BB%B6/image-20191230150704399.png"></p>
<h2 id="运行时的组织结构"><a href="#运行时的组织结构" class="headerlink" title="运行时的组织结构"></a>运行时的组织结构</h2><p>调用一个给定的OS的内部例程有两种方式：</p>
<ul>
<li>系统功能调用方式</li>
</ul>
<p>只能通过用户程序间接调用：</p>
<ul>
<li>客户端&#x2F;服务器方式</li>
</ul>
<p>将操作系统服务作为系统服务进程来提供，服务请求和服 务响应是通过消息传递来实现的。<br>提供服务的是服务器，调用服务的是客户端</p>
<h2 id="处理机的特权级"><a href="#处理机的特权级" class="headerlink" title="处理机的特权级"></a>处理机的特权级</h2><p><strong>区分处理机状态是为了保护操作系统</strong></p>
<p>处理机的态，又称为处理机的特权级，是中央处理机的工作状态。当前处理机正在执行哪类程序，决定处理机的态。</p>
<h3 id="处理机状态的分类"><a href="#处理机状态的分类" class="headerlink" title="处理机状态的分类"></a>处理机状态的分类</h3><p>① 管态 (Supervisor mode)</p>
<p> 操作系统的<strong>管理程序执行时机器所处的状态</strong>，又称处理机的特权级。<strong>在此状态下处理机可使用全部指令(包括一组 特权指令)；使用全部系统资源(包括整个存储区域)。</strong> </p>
<p>② 用户态(User mode)</p>
<p> <strong>用户程序执行时机器所处的状态称为用户态</strong>。在此状态下禁止使用特权指令，不能直接取用资源与改变机器状态， 并且只允许用户程序访问自己的存储区域。</p>
<blockquote>
<p>处理机状态的特权指令集</p>
<p>① 涉及外部设备的输入&#x2F;输出指令 </p>
<p>② 修改特殊寄存器的指令 </p>
<p>③ 改变机器状态的指令</p>
</blockquote>
<blockquote>
<p> 实例操作系统处理机的状态</p>
<p>① DOS系统<br>        不分态</p>
<p> ② Windows 系统<br>        3环 用户态<br>        0环 系统态<br>        还有1、2环预留 </p>
<p>③ UNIX系统 (Linux)系统<br>        00 核态<br>        01 管态<br>        11 用户态</p>
</blockquote>
<h2 id="中断及其处理"><a href="#中断及其处理" class="headerlink" title="中断及其处理"></a>中断及其处理</h2><p>在上述的处理机的状态可见，假设用户程序执行时，超过了它的权限要求，就要把系统从用户态转变为管态。在这个过程中，系统将发生中断。</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>所谓中断是指某个事件 (例 如电源掉电、定点加法溢出 或I&#x2F;O传输结束等) 发生时， 系统中止现行程序的运行、 引出处理事件程序对该事件 进行处理，处理完毕后返回 继续执行 断点继续执行的过程。</p>
<p>需要明确的是中断是硬件和软件结合实现的：硬件实现的中断进入；软件的中断处理过程。</p>
<h3 id="中断类型"><a href="#中断类型" class="headerlink" title="中断类型"></a>中断类型</h3><p>(1) 按中断功能分类 </p>
<p>① 输入输出中断： I&#x2F;O传输结束或出错中断 </p>
<p>② 外中断： 时钟中断、操作员控制台中断、通信中断等 </p>
<p>③ 机器故障中断 ：电源故障、主存取指令错等 </p>
<p>④ 程序性中断 ：定点溢出、用户态下用核态指令、非法操作 </p>
<p>⑤ 访管中断 ：对操作系统提出某种需求时所发出的中断（例如：printf）</p>
<p>(2) 按中断方式分类 </p>
<p>① 强迫性中断： 不是正在运行的程序所期待的中断。 如：输入输出中断、外中断、机器故障中断、程序性中断 </p>
<p>② 自愿中断： 是运行程序所期待的事件。 如：访管中断</p>
<p>(3) 按中断来源分类</p>
<p>① 中断 ：由处理机外部事件引起的中断 </p>
<p>② 俘获 ：由处理机内部事件引起的中断 </p>
<p>③ 中断与俘获的例</p>
<h3 id="中断进入（响应）"><a href="#中断进入（响应）" class="headerlink" title="中断进入（响应）"></a>中断进入（响应）</h3><p>(1) 保护现场和恢复现场 </p>
<p>① 现场</p>
<p>在中断的那一时刻能确保程序继续运行的有关信息。 </p>
<p>ⅰ 后继指令所在主存的单元号<br>ⅱ 程序运行所处的状态<br>ⅲ 指令执行情况<br>ⅳ 程序执行的中间结果等</p>
<p>② 保护现场</p>
<p>当中断发生时，必须立即把现场信息保存在主存中，这一 工作称之为保护现场。</p>
<p>③ 恢复现场</p>
<p>程序重新运行之前，把保留的该程序现场信息从主存中送 至相应的指令计数器、通用寄存器或一些特殊的寄存器中。 完成这些工作称为恢复现场。</p>
<p>(2) 程序状态字 (psw) </p>
<p>① 定义 </p>
<p>反映程序执行时机器所处的现行状态的代码。</p>
<p>② 内容</p>
<p>指令地址、指令执行情况、处理机状态、应屏蔽的中断等。</p>
<p>③ 程序状态字的例子</p>
<p>ⅰ IBM 370 机          程序状态字内容 → PSW：寄存器<br>ⅱ IBM PC 机           程序状态字内容 → CS IP 指令地址、 flag 标志寄存器<br>ⅲ PDP 11系列机    程序状态字内容 → PC 指令计数器  、PS 处理器状态寄存器</p>
<p>(3) 什么是中断响应</p>
<p>中断响应是当中央处理机发现已有中断请求时，中止现行 程序执行，并自动引出中断处理程序的过程。</p>
<p>(4) 中断响应所需的硬件支持</p>
<p>指令计数器、处理机状态寄存器、系统堆栈、中断向量表</p>
<p>(5) 中断响应过程</p>
<p>① 保留程序断点及处理机有关信息 </p>
<p>② 自动转入相应的中断处理程序执行</p>
<p>(6) 中断响应的实质</p>
<p><strong>交换指令地址及处理机的状态信息</strong></p>
<h3 id="软件中断处理"><a href="#软件中断处理" class="headerlink" title="软件中断处理"></a>软件中断处理</h3><p>当硬件完成了中断进入过程后，由相应的中断处理程序得到控制权，进入了软件的中断处理过程。</p>
<h3 id="Linux系统的特权级与中断处理"><a href="#Linux系统的特权级与中断处理" class="headerlink" title="Linux系统的特权级与中断处理"></a>Linux系统的特权级与中断处理</h3><p>硬件部分和上述讨论的一致。区别在于其软件部分。</p>
<p>Linux将中断分为两个部分：</p>
<ul>
<li>上半部：中断处理有严格时间限制的工作，是关键而紧迫的部分。</li>
<li>下半部：处理可以稍后完成的工作，是可以被打断的。</li>
</ul>
<h1 id="操作系统的用户接口"><a href="#操作系统的用户接口" class="headerlink" title="操作系统的用户接口"></a>操作系统的用户接口</h1><h2 id="用户工作环境"><a href="#用户工作环境" class="headerlink" title="用户工作环境"></a>用户工作环境</h2><h3 id="用户工作环境的形成"><a href="#用户工作环境的形成" class="headerlink" title="用户工作环境的形成"></a>用户工作环境的形成</h3><p>由OS为用户提供：</p>
<p>(1) 系统提供各种硬件、软件资源</p>
<p>(2) 设计并提供使用方便的命令集合</p>
<p>(3) 将OS装入计算机并初始化，形成可供使用的工作环境</p>
<h3 id="操作系统的初启"><a href="#操作系统的初启" class="headerlink" title="操作系统的初启"></a>操作系统的初启</h3><p>(1) 系统引导的任务</p>
<p>将操作系统的<strong>必要部分</strong>装入主存并对系统进行初始化工作，最终使系统处于命令接收状态。</p>
<ul>
<li>初始引导：把系统核心装入主存中的指定位置，并在指定地址启动</li>
<li>核心初始化：执行系统核心的初启子程序，初始化系统核心数据（初始化系统数据结构和参数）</li>
<li>系统初始化：为用户使用系统做准备</li>
</ul>
<p>经过这三个阶段，OS就处在接收命令的状态。</p>
<p>(2) 系统引导的方式</p>
<p><strong>①现场独立引导方式(滚雪球方式，bootup)</strong></p>
<p>OS核心文件存储在系统本身的存储设备中，由系统自己将OS核心程序读入主存并运行，建立一个操作环境。</p>
<p>适用于微机和大多数系统</p>
<p><strong>②辅助下装方式（download）</strong></p>
<p>OS主要文件不放在系统本身的存储设备中，在系统启动后执行下装操作，从另外的计算机系统中将操作系统常驻部分传送到该计算机中，使它形成一个操作环境。</p>
<p>适用于多计算机系统、由主控机与前端机构成的系统以及分布式系统。</p>
<p>(3) 独立引导方式(滚雪球方式) 的过程</p>
<p>①初始引导</p>
<ul>
<li>系统加电；</li>
<li>执行初始引导程序，对系统硬件和配置进行自检，保证系统没有硬件错误；</li>
<li>从<strong>硬盘中读入操作系统引导程序</strong>，并将控制权交给该程序模块。</li>
</ul>
<p>②引导程序执行</p>
<ul>
<li>引导程序执行，<strong>将操作系统核心文件读入内存，并将控制交给核心的初始化程序</strong>。</li>
</ul>
<p>③核心初始化</p>
<p><strong>初始化系统数据结构及参数</strong></p>
<ul>
<li>系统加电建立进程有关的数据结构；</li>
<li>获得自由存储空间的容量，建立存储管理的数据结构；</li>
<li>建立系统设备和文件系统的数据结构；</li>
<li>初始化时钟。</li>
</ul>
<p>④系统初始化</p>
<ul>
<li>完善OS的操作环境，装载命令处理程序(或图形用户界面)，并初始化；</li>
<li>在多用户系统中，为每个终端建立命令解释进程，使系统处于命令接收状态。</li>
</ul>
<p>(4) Linux系统初启</p>
<p><strong>Linux系统是以滚雪球的方式启动</strong></p>
<p>加电或复位→BIOS的启动→ Boot  Loader → OS初始化</p>
<h3 id="系统生成"><a href="#系统生成" class="headerlink" title="系统生成"></a>系统生成</h3><p>所谓系统生成，就是指为了满足物理设备的约束和需要的系统功能，通过组装一批模块来产生一个清晰的、使用方便的操作系统的过程。</p>
<p>一般是厂商进行组装</p>
<h2 id="应用程序的处理"><a href="#应用程序的处理" class="headerlink" title="应用程序的处理"></a>应用程序的处理</h2><h3 id="处理应用程序的步骤"><a href="#处理应用程序的步骤" class="headerlink" title="处理应用程序的步骤"></a>处理应用程序的步骤</h3><p>编辑——编译——-连接——–运行</p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20180825125442147.png"></p>
<blockquote>
<p><strong>编译：</strong></p>
<p>高级语言(我们这里指C<strong>源文件</strong>) 代码 转化为 汇编代码</p>
<p>1.1.1 预处理<br>预处理过程通过预处理器来完成, 预处理器是程序中处理输入数据，产生能用来输入到其他程序的数据的程序。输出被称为输入数据预处理过的形式，常用在之后的程序比如编译器中.</p>
<p>本文只讨论C预处理器, C预处理器是C语言、C++语言的预处理器。用于在编译器处理程序之前预扫描源代码，完成 头文件的包含, 宏扩展, 条件编译, 行控制(line control) 等操作。</p>
<p>对于C&#x2F;C++语言预处理一般分为以下几个过程:</p>
<p>1.1.1.1 包含文件<br>所谓包含文件即为头文件 #include 到的文件, 在预处理的过程中会将其加入到预处理器的输出文件中, 以供编译程序处理.</p>
<p><strong>汇编</strong>：</p>
<p>将汇编代码翻译成目标机器语言的过程. 生成的目标文件也就是与源程序在逻辑上等效的机器语言代码.</p>
<p>生成的机器语言代码被称为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81">目标代码</a>, 生成的二进制文件被称为<strong>目标文件（.o）</strong>, 也成为二进制文件.</p>
<p><strong>链接：</strong></p>
<p>链接过程是由<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%93%BE%E6%8E%A5%E5%99%A8">链接器</a>进行操作的. 链接器（英语：Linker），又译为链接器、连结器，是一个程序，将一个或多个由编译器或汇编器生成的目标文件外加库链接为一个<strong>可执行文件</strong>。</p>
<p><strong>2.1.1 静态链接(编译时)</strong><br>链接器将函数的代码从其所在地（目标文件或静态链接库中）拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。<br>优点: 只需保证在开发者的计算机有正确的库文件，在以二进制发布时不需考虑在用户的计算机上库文件是否存在及版本问题.<br>缺点: 生成的可执行文件体积较大。当初正是为了避免此问题，才开发了动态库技术。</p>
<p><strong>2.1.1 动态链接 (加载, 运行时)</strong><br>所谓动态链接，就是把一些经常会共用的代码（静态链接的OBJ程序库）制作成DLL档，当可执行文件调用到DLL档内的函数时，操作系统才会把DLL档加载存储器内，DLL档本身的结构就是可执行档，当程序有需求时函数才进行链接。透过动态链接方式，存储器浪费的情形将可大幅降低。静态链接库则是直接链接到可执行文件。<br><strong>DLL档本身也是可执行文件, 在程序执行的时候直接进行动态调用即可</strong>.<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20180825125503231.png"></p>
<table>
<thead>
<tr>
<th align="center">静态链接</th>
<th align="center"><strong>动态链接</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">编译时</td>
<td align="center">加载, 运行时</td>
</tr>
<tr>
<td align="center">lib在编译时就组装进exe文件</td>
<td align="center">程序运行时exe文件可以动态的加载dll</td>
</tr>
<tr>
<td align="center">不用考虑计算机库文件版本</td>
<td align="center">节省内存, 维护性高</td>
</tr>
<tr>
<td align="center">整个软件包只有exe文件</td>
<td align="center">软件包中有exe和dll</td>
</tr>
<tr>
<td align="center">lib文件是外部函数和变量, 在编译时复制进目标程序, 后缀为.a</td>
<td align="center">dll文件本身是可执行的, 在运行时动态链接, 可以包含源码, 数据, 资源的多种组合, 后缀为.so</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="连接类型"><a href="#连接类型" class="headerlink" title="连接类型"></a>连接类型</h3><h4 id="静态连接"><a href="#静态连接" class="headerlink" title="静态连接"></a>静态连接</h4><p>一个源程序经编译后，生成一个可重定位的目标模块，并产生内部符号表和外部符号表，供连接程序(Link)使用。</p>
<p>①内部符号表</p>
<p>​		本模块可以被其他程序调用的入口点。</p>
<p>②外部调用表</p>
<p>​		本模块要调用的外部的程序模块名。操作系统的用户接口——应用程序的处理</p>
<p>③连接需要做的工作</p>
<ul>
<li>将各模块连接成为一个整体；</li>
<li>构造全程符号表，在其中填写模块的逻辑地址；</li>
<li>查找各程序段的外部调用表，填入对应调用函数的地址</li>
</ul>
<p>④静态连接的缺点</p>
<p>​			静态连接将所需的外部函数链接到目标文件中形成为一个可执行文件。若多个应用程序都调用了同一个库中的外部函数，那么，多个应用程序的目标文件中都会包含这个外部函数对应的代码</p>
<h4 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h4><p>动态连接不需要将外部函数链接到目标文件中。而是在<strong>应用程序中需要调用外部函数的地方作记录</strong>，并说明要使用的外部函数名和引用入口号。</p>
<h2 id="用户接口（用户界面）"><a href="#用户接口（用户界面）" class="headerlink" title="用户接口（用户界面）"></a>用户接口（用户界面）</h2><p>操作系统的用户接口分为：操作接口和程序接口。</p>
<p>(1) 操作界面(命令接口) </p>
<p>用户使用操作界面来组织工作流程和控制程序的运行。</p>
<p>(2)系统功能服务界面(程序接口)        </p>
<p>用户程序在其运行过程中，使用系统功能调用来请求操作系统的服务。</p>
<h3 id="操作接口"><a href="#操作接口" class="headerlink" title="操作接口"></a>操作接口</h3><p>分为以下三种形式：其形式和操作系统的类型有关。</p>
<ul>
<li>键盘命令（具有交互操作方式的操作系统：分时操作系统、个人计算机操作系统，是联机处理方式）</li>
<li>图形化界面（具有交互操作方式的操作系统：分时操作系统、个人计算机操作系统）</li>
<li>作业控制语言（批处理操作系统，是脱机处理方式）</li>
</ul>
<h4 id="作业控制语言（JCL）"><a href="#作业控制语言（JCL）" class="headerlink" title="作业控制语言（JCL）"></a>作业控制语言（JCL）</h4><ul>
<li>一种命令语言，包括作业处理命令和资源请求命令</li>
<li>脱机方式下系统提供作业控制语言</li>
<li>批处理系统中作业的组成<ul>
<li>作业申请：作业名、需用CPU时间、最迟完成时间、资源请求（主存、外设）等</li>
<li>操作说明书：编辑命令、编译命令、连接命令、运行命令等</li>
<li>程序与数据</li>
</ul>
</li>
</ul>
<p>结合之前的脱机处理方式，这种方式要求我们提前预测可能出现的处理，因为无法控制作业的运行过程。</p>
<h4 id="键盘命令"><a href="#键盘命令" class="headerlink" title="键盘命令"></a>键盘命令</h4><ul>
<li>操作系统为联机用户提供的一种操作命令，用户通过这一组命令直接控制和干预程序的运行</li>
<li>系统为联机用户提供键盘命令</li>
<li>键盘命令的功能<ul>
<li>分时操作系统——用于注册、通信、注销的各类命令</li>
<li>个人计算机操作系统——用于通信的各类命令</li>
</ul>
</li>
</ul>
<h4 id="图形用户界面"><a href="#图形用户界面" class="headerlink" title="图形用户界面"></a>图形用户界面</h4><ul>
<li>菜单驱动方式面向屏幕的交互方式，将键盘命令以屏幕方式来体现；命令和系统能完成的操作，用菜单分类分窗口列出；用户像点菜一样选择命令或某种操作，以控制系统去完成指定的工作；菜单系统的类型有多种，如下拉式菜单、上推式菜单和随机弹出式菜单</li>
<li>图符驱动方式图符（Icon）也称图标，是一个小小的图符符号，代表操作系统中的命令、系统服务、操作功能、各种资源。良好的用户交互界面，将菜单驱动、图符驱动、面向对象技术等集成在一起，形成一个图文并茂的视窗操作环境。</li>
</ul>
<p>图形用户界面的特点</p>
<ul>
<li>所有程序以统一的窗口形式出现</li>
<li>提供统一的菜单格式</li>
<li>系统资源、系统命令、操作功能以图标表示</li>
<li>统一的操作方法</li>
</ul>
<blockquote>
<p>(1) MS-DOS  ─ ─ 键盘命令、系统功能调用</p>
<p>(2) Windows─ ─图形用户界面、系统功能调用</p>
<p>(3) Linux (UNIX) ─键盘命令(XWindow)、系统功能调用</p>
</blockquote>
<h3 id="系统功能调用（程序接口）"><a href="#系统功能调用（程序接口）" class="headerlink" title="系统功能调用（程序接口）"></a>系统功能调用（程序接口）</h3><p>系统功能调用是用户在程序一级请求操作系统服务的一种手段，它是带有一定功能号的“访管指令”。其功能是由操作系统中的程序完成的，即由软件方法实现的。</p>
<p>用户程序如何调用系统功能：通过访管方式。</p>
<p>需要注意到系统的程序是处于管态的，用户程序是处于用户态的。我们无法像用户程序调用用户程序一样调用系统程序（会发生处理机状态的转换）。</p>
<h4 id="访管方式"><a href="#访管方式" class="headerlink" title="访管方式"></a>访管方式</h4><p><strong>访管指令(自愿进管指令)</strong></p>
<p>svc  n   svc   表示机器访管指令的操作码记忆符，n为地址码(功能号)</p>
<blockquote>
<p>用户可以使用不同功能号的访管指令来请求不同的功能</p>
</blockquote>
<p><strong>访管中断</strong></p>
<p>当处理机执行到访管指令时发生中断，该中断称为访管中断，它表示正在运行的程序对操作系统的某种需求。</p>
<p>借此中断，机器状态由用户态转为管态。访管中断处理程序会转到用户程序所需要的系统程序。</p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20191230205109633.png"></p>
<h4 id="系统调用的特点"><a href="#系统调用的特点" class="headerlink" title="系统调用的特点"></a>系统调用的特点</h4><p>不同的操作系统，系统调用实现的具体方法有所不同，但其实质特点相同：</p>
<ul>
<li><strong>每个系统调用对应一个系统调用号</strong>（要请求调用某个系统功能就要在访管时给出对应的功能号）</li>
<li>每个系统调用有一个对应的执行程序段</li>
<li>每个系统调用要求一定数量的输入参数和返回值</li>
<li>整个系统有一个系统调用执行程序入口地址表</li>
</ul>
<blockquote>
<p>系统功能调用vs. 库函数</p>
<p>在程序设计语言(如C语言)中，往往提供与各系统调用对应的库函数，应用程序可通过对应的库函数来使用系统调用</p>
<p>库函数的目的是<strong>隐藏访管指令细节</strong>，使系统调用更象过程调用，但一般地说，库函数属于用户程序而非系统程序（但是有些库函数是不涉及系统调用的）</p>
<p><strong>库函数在执行是不会导致CPU状态的变化，但是其系统调用的代码属于OS，故在系统调用的代码执行的时候就会让CPU的状态由用户态变为管态</strong></p>
<p>操作系统为用户提供系统调用也出于安全和效率考虑，使得用户态程序不能自由地访问内核关键数据结构或直接访问硬件资源</p>
</blockquote>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20191230205720371.png"></p>
<blockquote>
<p>Linux系统调用由两部分组成：</p>
<ul>
<li>核心函数：实现系统调用功能的(内核)代码</li>
<li>接口函数：提供给应用程序的API，以库函数形式存在Linux的lib.a中</li>
</ul>
<p>Linux系统调用控制程序</p>
<p>(1)取系统调用号，检验合法性；</p>
<p>(2)建立调用堆栈，保护现场信息；</p>
<p>(3)根据系统调用号定位核心函数地址；</p>
<p>(4)根据通用寄存器内容，从用户栈中取入口参数；</p>
<p>(5)核心函数执行，把结果返回应用程序；</p>
<p>(6)执行退栈操作，判别调度程序scheduler是否将执行。</p>
</blockquote>
<h1 id="习题补充"><a href="#习题补充" class="headerlink" title="习题补充"></a>习题补充</h1><p><strong>第一章 习题及解答</strong></p>
<p>1-2批处理系统和分时系统各具有什么特点？为什么分时系统的响应较快？</p>
<p>答：在批处理系统中操作人员将作业成批装入计算机，在程序运行期间用户不能干预，用户使用计算机的方式是脱机操作方式。批处理系统中作业成批处理，系统内多道程序是并发执行的，所以其特点是：系统吞吐率高，但作业周转时间长，用户使用不方便。</p>
<p>在分时系统中不同用户通过各自的终端以交互方式共同使用一台计算机，计算机以“分时”的方法轮流为每个用户服务，用户使用计算机的方式是联机操作方式。分时系统的主要特点是多个用户同时使用计算机的同时性，人机问答方式的交互性，每个用户独立使用计算机的独占性以及系统快速响应的及时性。</p>
<p>分时系统一般采用时间片轮转的方法，使一台计算机同时为多个终端用户服务，因此分时系统的响应较快。</p>
<p>1-3实时信息处理系统和分时系统从外表看来很相似，它们有什么本质的区别呢？</p>
<p>答：实时信息处理系统和分时系统从外表来看，都是一台计算机连接一个或多个终端设备；用户以联机方式直接与计算机交互。二者的本质区别是：</p>
<p>实时信息处理系统采用的进程调度策略是优先调度策略，而分时系统采用的进程调度策略是时间片轮转调度策略。</p>
<p>实时信息处理系统的终端设备通常只是作为执行装置或咨询装置，不允许用户编写新的程序或修改已有的程序。而分时系统的用户可以通过终端设备修改程序，可以与系统交互以控制程序的运行。</p>
<p>1-5什么是多道程序设计技术？试述多道程序运行的特征？</p>
<p>答：多道程序设计技术是指同时多个作业或程序进入主存并允许它们交替执行和共享系统中的各类资源。当一道程序因某种原因如 I&#x2F;O 请求而暂停执行时，CPU立即转去执行另一道程序。多道程序运行具有如下特征：</p>
<p>多道：计算机内存中同时存放几道相互独立的程序。</p>
<p>宏观上并行：同时进入系统的几道程序都处于运行过程中，它们先后开始了各自的运行，但都未运行完毕。</p>
<p>微观上串行：从微观上看，主存中的多道程序轮流或分时地占有处理机，交替执行。</p>
<p>1-9 设一计算机系统有输入机一台、打印机两台，现有A、B两道程序同时投入运行，且程序A先运行，程序B后运行。程序A的运行轨迹为：计算50ms，打印信息100ms，再计算50ms，打印信息100ms，结束。程序B运行的轨迹为：计算50ms，输入数据80ms，再计算100ms，结束。回答如下问题。</p>
<p>（1）用图画出这两道程序并发执行时的工作情况。</p>
<p>（2）说明在两道程序运行时，CPU 有无空闲等待?若有，在哪段时间内等?为什么会空闲等待?</p>
<p>（3）程序 A、B 运行时有无等待现象?在什么时候会发生等待现象?</p>
<p>答：（1） 这两道程序并发执行时的工作情况如下图所示。</p>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/clip_image001.png" alt="img"><img src="file:///C:/Users/rao/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png" alt="img"><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/clip_image001.png" alt="img"><img src="file:///C:/Users/rao/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png" alt="img"></p>
<table>
<thead>
<tr>
<th>CPU</th>
<th>50ms</th>
<th>50ms</th>
<th>50ms</th>
<th>100ms</th>
</tr>
</thead>
<tbody><tr>
<td>输入机</td>
<td></td>
<td></td>
<td>80ms</td>
<td></td>
</tr>
<tr>
<td>打印机1</td>
<td></td>
<td>100ms</td>
<td></td>
<td>100ms</td>
</tr>
<tr>
<td>打印机2</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>A</td>
<td></td>
<td>B</td>
<td></td>
</tr>
</tbody></table>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/clip_image004.jpg"></p>
<p>（2）CPU有空闲等待，当B 50ms计算完后，A 100ms打印仍在进行，中间CPU空闲 50ms。</p>
<p>（3）程序 A、B运行时有等待现象。当 B 80ms输入完成后，需等待20ms后才能进行计算。</p>
<p><strong>第二章 习题及解答</strong></p>
<p>2-1什么是操作系统虚拟机？</p>
<p>答：操作系统是最基本的系统软件，它是硬件功能的第一层扩充。配置了操作系统的计算机称为操作系统虚拟机。</p>
<p>操作系统虚拟机除了可使用原来裸机提供的各种基本硬件指令，还可以使用操作系统提供的操作命令和系统调度命令。</p>
<p>2-3什么是处理机的态？为什么要区分处理机所谓态？</p>
<p>答：所谓处理机的态就是处理机当前处于何种状态，正在执行哪类程序。为了保护操作系统，至少需要区分两种状态：管态和用户态。</p>
<p>操作系统是计算机系统中最重要的系统软件，为了能正确地进行管理和控制，其本身是不能被破坏的。为此，系统应能建立一个保护环境。当用户程序执行时，应有所限制，其所需资源必须向操作系统提出请求，自己不能随意取用系统资源，如不能直接启动外部设备的工作，更不能改变机器状态等。因此系统必须区分处理机的工作状态，即区分当时正在执行的程序的类别。</p>
<p>2-4 什么是管态？什么是用户态？二者有何区别？</p>
<p>答：管态又称为系统态，是操作系统的管理程序执行时机器所处的状态。在此状态下中央处理机可以使用全部机器指令，包括一组特权指令 (例如，涉及外部设备的输入&#x2F;输出指令、改变机器状态或修改存储保护的指令) ，可以使用所有的资源，允许访问整个存储区。</p>
<p>用户态又称为目态，是用户程序执行时机器所处的状态。在此状态下禁止使用特权指令，不能直接取用资源与改变机器状态，并且只允许用户程序访问自己的存储区域。</p>
<p>二者的区别如下所述。</p>
<p>（1）处理机当前正在执行的程序类别不同。管态执行的是系统程序；用户态执行的是用户程序。</p>
<p>（2）执行的指令范围不同。管态下可以执行全部指令；用户态不能执行特权指令。</p>
<p>（3）使用资源范围不同。管态可以使用全部系统资源；用户态只能使用用户私有资源，如只能访问自己的存储区域。</p>
<p>2-6按中断的功能来分，中断有哪几种类型？</p>
<p>答：按中断的功能来分，中断有如下五种类型：</p>
<p>(1) I&#x2F;O 中断 </p>
<p>(2) 外中断 </p>
<p>(3) 硬件故障中断 </p>
<p>(4) 程序性中断</p>
<p>(5) 访管中断</p>
<p>2-11 什么是程序状态字？在微机中它一般由哪两个部分组成？</p>
<p>答：程序状态字是指反映程序执行时机器所处的运行状态的代码。在微机中它一般由指令计数器 PC 和处理机状态寄存器 PS 组成。</p>
<p>2-12 什么是向量中断？什么是中断向量？</p>
<p>答：向量中断是指当中断发生时，由中断源自己引导处理机进入中断服务程序的中断过程。中断向量就是存储该类型中断服务例行程序的入口地址和处理器状态字的存储单元。</p>
<p>2-18 Linux系统的中断处理为什么要分为上半部和下半部?</p>
<p>答：操作系统的中断机制实现了I&#x2F;O设备与CPU以及多进程之间的同时执行，大大提高了系统效率。</p>
<p>操作系统的中断处理程序比较复杂，而且在系统一级处理时不允许打断。如何提高中断处理的效率？如何解决处理时间短的要求和处理事务复杂性的矛盾？Linux提出了一个很好的解决办法。Linux系统将中断处理程序分为两部分，将中断响应后必须立即处理的工作即刻执行（而且其执行时必须关中断），而将更多的处理工作向后推迟执行。即将中断处理程序分为上半部（tophalf）和下半部（bottom half）。Linux系统将中断处理程序分为上半部和下半部的目的是为了缩短关中断的时间，提高系统的处理能力。</p>
<p><strong>第三章  习题及解答</strong></p>
<p>3-3 处理应用程序分为哪几个步骤？这些步骤之间有什么关系？</p>
<p>答：处理应用程序分为四个步骤：编辑，编译，连接和运行。这些步骤是相互关联、顺序执行的。具体表现为：</p>
<p>每个步骤处理的结果产生下一个步骤所需要的文件；</p>
<p>每一个步骤能否正确地执行，依赖于前一个步骤是否成功地完成。</p>
<p>3-5 用户与操作系统的接口是什么？一个分时系统提供什么接口？一个批处理系统又提供什么接口？</p>
<p>答：用户与操作系统的接口是操作系统提供给用户与计算机打交道的外部机制。一个分时系统提供的接口有系统功能调用和键盘操作命令。一个批处理系统提供的接口有系统功能调用和作业控制语言。</p>
<p>3-8 什么是系统调用？对操作系统的服务请求与一般的子程序调用有什么区别？</p>
<p>答：系统调用是用户在程序一级请求操作系统服务的一种手段。编程人员利用系统调用，在源程序一级动态请求和释放系统资源，调用系统中已有的系统功能来完成那些与机器硬件部分相关的工作以及控制程序的执行等。因此，系统调用像一个黑箱子那样，对用户屏蔽了操作系统的具体动作而只提供有关的功能。</p>
<p>系统调用与一般过程调用的主要区别如下：（1）程序的性质不同。系统调用服务例程是操作系统程序的一部分，它在核态下执行。而用户子程序是用户程序的一部分，它在用户态下执行。（2）调用方式不同。系统调用是通过陷入到操作系统内核来实现的，调用它们需要中断处理机制来提供系统服务。而子程序调用是在用户程序中直接调用。</p>
<p>3-10 简述系统调用的执行过程。</p>
<p>答：系统调用命令的具体格式因系统而异，但由用户程序进入系统调用的步骤及执行过程大体相同。其执行过程如下：</p>
<p>1．保护用户程序的现场信息，同时把系统调用命令的编号等参数放入指定的存储单元；</p>
<p>2．根据系统调用命令的编号查找系统调用入口表，找到相应系统功能调用子程序的入口地址；</p>
<p>3．转到该子程序执行，当系统调用命令执行完毕，相应的结果通常返回给参数，这些参数放在指定的存储单元里；</p>
<p>4．系统调用命令执行完毕后恢复用户程序执行的现场信息，同时把系统调用命令的返回参数或参数区首址放入指定的寄存器中，供用户程序使用。</p>
<p>3-12 在Linux系统中，增加一个新的系统调用需要做哪些工作?</p>
<p>答：在Linux系统中，增加一个新的系统调用需要做的工作包括如下几个方面。</p>
<p>(1) 编写一个新增加的功能的服务例程。编写新增的服务例程，并加到内核中去，即在&#x2F;usr&#x2F;src&#x2F;linux&#x2F;kernel&#x2F;sys.c文件中增加一个新的函数。</p>
<p>(2) 增加一个新的系统调用号。在linux中，每个系统调用被赋予一个唯一的系统调用号。找到linux中定义系统调用号定义的文件 (在include&#x2F;asm-i386&#x2F;unistd.h头文件中)。在此文件中按其规定的格式添加一项。</p>
<p>(3) 在系统调用表中登记新的系统调用号以及对应的服务例程。系统调用表记录了内核中所有已注册过的系统调用，它是系统调用的跳转表，实际上是一个函数指针数组，表中依次保存所有系统调用的函数指针。找到linux中的系统调用表 (Linux系统调用表保存在arch&#x2F;i386&#x2F;kernel&#x2F;下的entry.S中)。在此文件中按其规定的格式增加一个新的系统调用号以及对应的服务例程。</p>
<p>(4) 新增加的服务例程要为Linux系统接受，必须重新编译内核，生成新的包含新增服务例程的内核。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2019/12/28/Algorithm_%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/28/Algorithm_%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">选择算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-28 00:36:10" itemprop="dateCreated datePublished" datetime="2019-12-28T00:36:10Z">2019-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h1><h2 id="选择问题"><a href="#选择问题" class="headerlink" title="选择问题"></a>选择问题</h2><p>从n个元素的集合中选择<strong>第i个顺序统计量</strong>的问题形式化地归结为“选择问题”。</p>
<blockquote>
<p>中位数和顺序统计量</p>
<p>1）顺序统计量：在一个由n个元素组成的集合中，第i个顺序统计量(order statistic)是该集合中的第i小的元素。如：在一个元素集合中，最小值是第1个顺序统计量（i&#x3D;1）；最大值是第n个顺序统计量（i&#x3D;n）</p>
<p>2）中位数：对一个有n个元素的集合，将数据排序后，位置在最中间的数称为该集合的中位数。</p>
</blockquote>
<p>假设集合中的元素是互异的（可推广至包含重复元素的情形）。</p>
<p>输入：一个包含n个（互异）元素的集合A和一个整数i，1≤i≤n。<br>输出：元素x∈A，且A中恰好有i-1个其他元素小于它。</p>
<p>解决的办法：</p>
<p>1）排序元素集合排序后，位于第i位的元素即为该集合的第i个顺序统计量。时间复杂度：O(nlogn)</p>
<p>2）选择算法设法找出元素集合里面的第i小元素，该元素为集合的第i个顺序统计量。时间复杂度：O(n)</p>
<h2 id="最大值和最小值问题"><a href="#最大值和最小值问题" class="headerlink" title="最大值和最小值问题"></a>最大值和最小值问题</h2><p>在一个有n个元素的集合中，需要做多少次比较才能确定其最小元素或者最大值呢？n-1次，时间：O(n)</p>
<p><strong>这是求解上述问题的最好结果</strong></p>
<p>不失一般性，就变成了求解上述第i小的问题。</p>
<h2 id="快速选择算法（Quick-Selection）"><a href="#快速选择算法（Quick-Selection）" class="headerlink" title="快速选择算法（Quick Selection）"></a>快速选择算法（Quick Selection）</h2><p> 通常用来<strong>在未排序的数组</strong>中寻找第k小&#x2F;第k大的元素。快速选择及其变种是实际应用中最常使用的高效选择算法。</p>
<p>快速选择的总体思路与快速排序一致，选择一个元素作为基准来对元素进行分区，将小于和大于基准的元素分在基准左边和右边的两个区域。不同的是，快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。这降低了平均时间复杂度，从O(nlog n)至**O(n)**，不过最坏情况仍然是O(n^2^)。</p>
<h3 id="Quick-Selection原理"><a href="#Quick-Selection原理" class="headerlink" title="Quick Selection原理"></a>Quick Selection原理</h3><p>Quick Selection算法和Quick Sort算法是由同一个作者提出，这两者之间有很大的相似之处——分治，即将问题的规模一次次的减小，直到求出最终解。</p>
<p>目标：找到第n大的数</p>
<ol>
<li>随机产生一个pivot</li>
<li>根据这个pivot，将小于其的数放左边，大于其的数放右边</li>
<li>更新第n大数的估计值的位置，选择其中一边，直到&#x3D;n</li>
<li>重复2、3步骤</li>
</ol>
<p><img src="https://i.loli.net/2021/01/17/Lt1cWGlzU5VK2uj.png"></p>
<h3 id="Quick-Select复杂度分析"><a href="#Quick-Select复杂度分析" class="headerlink" title="Quick Select复杂度分析"></a>Quick Select复杂度分析</h3><p>1、时间复杂度</p>
<p>完整的平均时间复杂度分析非常复杂，在这里不再赘述。有兴趣的可以<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/5945193/average-runtime-of-quickselect/25796762#25796762">看这里</a>。<br>一般来说，因为我们才用了随机选取pivot的过程，平均来看，我们可以假设每次pivot都能选在中间位置。设算法时间复杂度为T(n)。在第一层循环中，我们将pivot与n个元素进行了比较，这个时间为cn 。<br>所以第一步时间为：T(n) &#x3D; cnc + T(n&#x2F;2)。其中T(n&#x2F;2)为接下来递归搜索其中一半的子数组所需要的时间。<br>在递归过程中，我们可以得到如下公式：<br>T(n&#x2F;2) &#x3D; c(n&#x2F;2) + T(n&#x2F;4)<br>T(n&#x2F;4) &#x3D; c(n&#x2F;4) + T(n&#x2F;8)<br>…<br>T(2) &#x3D; 2<em>c + T(1)<br>T(1) &#x3D; 1</em>c<br>将以上公式循环相加消除T项可以得到：<br>T(n) &#x3D; c(n + n&#x2F;2 + n&#x2F;4 + n&#x2F;8 + … + 2 + 1) &#x3D; 2n &#x3D; O(n)<br>因此得到Quick Select算法的时间复杂度为O(n)。</p>
<p>1）造成最坏情况是O(n^2^)的原因分析：类似快速排序的最坏情况。</p>
<p>2、空间复杂度</p>
<p>算法没有使用额外空间，swap操作是inplace操作，所以算法的空间复杂度为O(1)。</p>
<h3 id="Quick-Select-Java实现"><a href="#Quick-Select-Java实现" class="headerlink" title="Quick Select Java实现"></a>Quick Select Java实现</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">Leetcode 215 Top k</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        k=nums.length+<span class="number">1</span>-k;</span><br><span class="line">        <span class="keyword">while</span>(begin&lt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> quick_select(nums,begin,end);</span><br><span class="line">            <span class="keyword">if</span>(pos==k-<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pos&lt;k-<span class="number">1</span>)begin=pos+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> end=pos-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[k-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">quick_select</span><span class="params">(<span class="type">int</span>[] s,<span class="type">int</span> right,<span class="type">int</span> left)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i=right,j=left;</span><br><span class="line">        <span class="type">int</span> x=s[right];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;s[j]&gt;=x)<span class="comment">//找到右边最近一个小于x的值</span></span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span>s[j];</span><br><span class="line">                s[i]=temp;<span class="comment">//填坑</span></span><br><span class="line">                s[j]=s[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="comment">//此时 s[j]==x</span></span><br><span class="line">            <span class="comment">//从左向右找数填s[j]</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;s[i]&lt;=x)</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span>s[i];</span><br><span class="line">                s[j]=temp;<span class="comment">//填坑</span></span><br><span class="line">                s[i]=s[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="comment">//此时 s[i]==x</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出时 i==j，将x填入坑中</span></span><br><span class="line">        s[i]=x;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最坏情况为线性时间的选择算法（五分化中项的中项）"><a href="#最坏情况为线性时间的选择算法（五分化中项的中项）" class="headerlink" title="最坏情况为线性时间的选择算法（五分化中项的中项）"></a>最坏情况为线性时间的选择算法（五分化中项的中项）</h3><p><strong>本质上还是快速选择算法，但是我们在选择枢纽元的时候，有既定的策略—–五分化中项的中项（也叫中位数的中位数）。这样就可以保证在最坏情况下依然是线行O（n）的复杂度</strong></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ol>
<li><p>将输入数组的n个元素划分成[n&#x2F;5]组，<strong>每组5个元素</strong>，且最多只有一组由剩下的n mod 5个元素组成</p>
</li>
<li><p><strong>寻找这[n&#x2F;5]个元素的中位数</strong>，首先对这组元素进行插入排序，然后确定每组有序元素的中位数，即第三个元素</p>
</li>
<li><p>把每组找出的中位数重组为一个新的数组，找出其中位数x（递归调用SELECT以找出中位数x，如果由偶数个中位数，约定x是较小的中位数）</p>
</li>
<li><p>使用PARTITION，将x对输入数组进行划分，返回k，低区的k - 1个元素小于x，高区的n - k个元素大于x<br>（partition的工作原理是将一个数组划分成两段，其中一段的元素都小于主元，另一段数组的元素都大于主元）</p>
</li>
<li><p>比较k和i的大小，如果i &lt; k，在低区递归调用SELECT，如果i &gt; k，在高区递归调用SELECT，如果i &#x3D; k，直接返回x。</p>
</li>
</ol>
<p>简单来说：我们选择的枢纽元是中位数的中位数X，其他的和快速选择算法一致，递归求解第K大的值。</p>
<p><strong>时间复杂度分析</strong></p>
<p>对于大于中位数的中位数x，大于x的元素个数至少有：<br>3(⌈1&#x2F;2⌈n&#x2F;5⌉⌉−2）⩾3n&#x2F;10−6<br>那么，递归至多作用于（7n&#x2F;10+6）个元素。<br>算法中的<br>第(3)步时间复杂度为T(⌈n&#x2F;5⌉)<br>第(5)步的时间复杂度为T(7n&#x2F;10+6)<br>我们可以得到算法的总时间复杂度为<br>T(n)≤T(⌈n&#x2F;5⌉)+T(7n&#x2F;10+6)+O(n)<br>假设一个任意常数C，使得T(n)≤cn<br>又假设O(n)的上界为an<br>那么带入c，a得到：<br>T(n)⩽9cn&#x2F;10+7c+an&#x3D;cn+(−9n&#x2F;10+7c+an)<br>只需要证明: −9n&#x2F;10+7c+an⩽0 即可<br>该不等式等价于：c⩾10a(n&#x2F;(n−70))<br>所以当n&gt;140时，c⩾20a这样就可以满足不等式。<br>因此最坏情况下选择算法的运行时间是线性的。</p>
<h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面给定的是二次取中算法的说明性描述</span></span><br><span class="line">SELECT2(<span class="type">int</span> a[],<span class="type">int</span> i,<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在集合a中找第i小元素，且n为集合a的元素数量</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//采用插入排序直接对a进行分类并返回第i小的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把a分成大小为r的（n/r）个子集合，忽略多余的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m[r];<span class="comment">//表示这些子集合的中间值集合</span></span><br><span class="line">    v=SELECT2(m,(n/r)/<span class="number">2</span>,(n/r));<span class="comment">//得到中间值的中间值v</span></span><br><span class="line">        j=PARTITION(a,v);<span class="comment">//得到v在a中是第j小元素</span></span><br><span class="line">    <span class="keyword">if</span>(i==j)</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i&lt;j)<span class="comment">//说明要往下区寻找</span></span><br><span class="line">        <span class="keyword">return</span> SELECT2(s,i,j-<span class="number">1</span>);<span class="comment">//s是a[1：j-1]</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span>  SELECT2(R,i-j,n-j);<span class="comment">//R是a[j+1:n]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><p>记T(n)是SELECT2所需的最坏情况时间</p>
<p>对特定的r分析SELECT2：选取r&#x3D;5。</p>
<p>假定A中的元素各不相同，则有</p>
<ul>
<li>若n≤r，则采用插入法直接对A分类并返回第i小元素           →         Ο(1)</li>
<li>把A分成大小为r的(n&#x2F;r)个子集合，忽略多余的元素             →         Ο(n)</li>
<li>得到m的集合（中间值）                                                         →         Ο(n)</li>
<li>v&#x3D;SELECT2(m,(n&#x2F;r)&#x2F;2,(n&#x2F;r));&#x2F;&#x2F;得到中间值的中间值v             →          T(n&#x2F;5)</li>
<li>j&#x3D;PARTITION(a,v);&#x2F;&#x2F;得到v在a中是第j小元素                           →          Ο(n)</li>
<li>else if(i&lt;j)&#x2F;&#x2F;说明要往下区寻找                                                 →         T(3n&#x2F;4)，当n≥24<br>    return SELECT2(s,i,j-1);&#x2F;&#x2F;s是a[1：j-1]<br>else<br>    return  SELECT2(R,i-j,n-j);&#x2F;&#x2F;R是a[j+1:n]</li>
</ul>
<p>用归纳法(代入法)可证：T(n)≤20cn</p>
<p>故，在r&#x3D;5地情况下，<strong>求解n个不同元素选择问题的算法</strong>SELECT2的最坏情况时间是Ο(n)。</p>
<h5 id="进一步分析"><a href="#进一步分析" class="headerlink" title="进一步分析"></a>进一步分析</h5><p><strong>若A中有相同的元素时，上述结论T(n)&#x3D;O(n)可能不成立</strong>。</p>
<p>原因：</p>
<p>步骤⑤经PARTITION调用所产生的S和R两个子集合中可能存在一些元素等于划分元素v,可能导致|S|或|R|大于0.7n+1.2，从而影响到算法的效率。</p>
<p>例如：设r&#x3D;5,且A中有相同元素。不妨假设其中有0.7n+1.2个元素比v小，而其余的元素都等于v。<br>则，经过PARTITION，这些等于v的元素中至多有一半可能在落在S中，故|S|≤0.7n+1.2+(0.3n-1.2)&#x2F;2&#x3D;0.85n+0.6。<br>同理，|R|≤0.85n+0.6。<br>可得，此时步骤④和⑥所处理的元素总数将是<br>T(n&#x2F;5)+T(0.85n+0.6)≈1.05n+0.6&gt;n<br>不再是线性关系。故有T(n)≠Ο(n)</p>
<h5 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h5><p>方法一：将A集合分成3个子集合U,S和R，其中U是由A中所有与v相同的元素组成，S是由A中所有比v小的元素组成，R则是A中所有比v大的元素组成。</p>
<p>同时步骤⑥更改：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case </span><br><span class="line"><span class="meta">:|S|≥k:return(SELECT2(S,k,|S|)</span></span><br><span class="line"><span class="meta">:|S|+|U|≥k:return(v)</span></span><br><span class="line"><span class="meta">:else:</span> return(SELECT2(R,k-|S|-|U|,|R|))</span><br><span class="line">endcase</span><br></pre></td></tr></table></figure>

<p>从而保证|S|和|R|≤0.7n+1.2成立，故关于T(n)的分析仍然成立。即T(n) &#x3D; Ο(n)</p>
<h2 id="中位数问题"><a href="#中位数问题" class="headerlink" title="中位数问题"></a>中位数问题</h2><p>示例：</p>
<p>石油管的最优位置Olay教授正在为一家石油公司咨询，公司正在计划建造一条由东向西的大型管道。该管道要穿过一个有n口井的油田。从每口井中都有一条喷油管沿最短路径与主管道直接相连(或南或北)</p>
<p>问题：给定各口井的x坐标和y坐标。问，Olay教授如何选择主管道的最优位置，使得喷管长度总和最小？</p>
<blockquote>
<p>带权中位数：首先也是将这个数组的数据按一定的顺序排列， 带权中位数（Weighted Median）对于n个互不相同的元素集合x1、x2……xn，其权重依次为w1、w2……wn。令W &#x3D;<br>$$<br>\sum_{i&#x3D;1}^n{Wi}&#x3D;1<br>$$<br>，则带权中位数X<del>K</del>满足：（这里的权重可以用这个数据出现的频率来表示，或者这个数据的重要性）</p>
<p>$$<br>\sum_{X_i&lt;X_k} W_i&lt;\frac{1}{2}<br>$$</p>
<p>$$<br>\sum_{X_i&gt;X_k} W_i&lt;&#x3D;\frac{1}{2}<br>$$</p>
</blockquote>
<h3 id="带权中位数的应用"><a href="#带权中位数的应用" class="headerlink" title="带权中位数的应用"></a>带权中位数的应用</h3><p>（1）一维空间上的问题</p>
<p>一条直线上有若干个带权的点p1,p2,…,pn，它们的权重分别是ω1,ω2,…,ωn，在该直线上寻找一个点p，使得<br>$$<br>\sum_{i&#x3D;1}^nW_id(p,p_i)<br>$$<br>最小，其中d(a,b)表示点a与b之间的距离d(a,b)&#x3D;|a-b|——称点p为该n个点的一维带权中位数。</p>
<p><strong>称点p为该n个点的一维带权中位数。</strong></p>
<p>（2）二维空间上的问题</p>
<p>设二维平面上分布着n个点p1, p2,… pn，点pi的坐标用(xi,yi)表示，每个点附有一个权重ωi，<br>$$<br>\sum_{i&#x3D;1}^n{Wi}&#x3D;1<br>$$<br>。<br>定义点p1(x1,y1)与点p2(x2,y2)之间的距离是<br>d(p1, p2)&#x3D;|x1-x2|+|y1-y2|（称为Manhattan距离）<br>问题：在二维平面上找一个点p(x,y)，使得<br>$$<br>\sum_{i&#x3D;1}^nW_id(p,p_i)<br>$$<br>最小，则称p为该二维平面上n个点的带权中位数。</p>
<p>问题：为什么使<br>$$<br>\sum_{i&#x3D;1}^nW_id(p,p_i)<br>$$<br>最小的点满足<br>$$<br>\sum_{p_i&lt;p} W_i&lt;&#x3D;\frac{1}{2}和 \sum_{p_i&gt;p} W_i&lt;\frac{1}{2}？<br>$$</p>
<p>带权中位数问题常见算法：</p>
<p>1：朴素算法：</p>
<p>方法：枚举集合点，进行计算</p>
<p>时间复杂度：O（N^2）</p>
<p>2：递推算法：</p>
<p>1．朴素递推：</p>
<p>方法：分别计算对于一个点从左右过来的总代价，求其最小值</p>
<p>时间复杂度：O（N）</p>
<p>2．递推改进算法</p>
<p>  方法：利用前面证明的结论和带权中位数的定义，只需要一次扫描即可</p>
<p>  时间复杂度：O（N）</p>
<p>3：分治算法：</p>
<p>1．   O（NlogN）的算法</p>
<p>方法：二分集合点，比较集合点为M与M+1时的谁更优，不断缩小范围</p>
<p>2．   O（N）的二分改进算法</p>
<p>方法：二分集合点，但利用了已知信息，将时间复杂度降到O（N）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2019/12/26/Algorithm_%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/26/Algorithm_%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">概率分析和随机算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-25 23:48:52" itemprop="dateCreated datePublished" datetime="2019-12-25T23:48:52Z">2019-12-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概率分析和随机算法"><a href="#概率分析和随机算法" class="headerlink" title="概率分析和随机算法"></a>概率分析和随机算法</h1>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/12/26/Algorithm_%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2019/12/26/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/26/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">组成原理-输入输出系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-25 23:30:39" itemprop="dateCreated datePublished" datetime="2019-12-25T23:30:39Z">2019-12-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">组成原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h1><p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/20190112155751236.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/20190112155821404.png"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="IO系统具有的特点"><a href="#IO系统具有的特点" class="headerlink" title="IO系统具有的特点"></a>IO系统具有的特点</h3><ul>
<li>异步性：外围设备相对于处理机是异步工作的。</li>
<li>实时性：当外围设备与处理机交互时，由于设备的类型不同，它们的工作步调是不同的，处理机必须按照不同设备所要求传送方式和传输速率不失时机地为设备提供服务，这就要求实时性控制；</li>
<li>与设备无关性：各种外部设备必须根据其特点和要求选择一种标准接口和处理机进行连接，它们之间的差别必须由设备本身的控制器通过硬件和软件来填补；这样，处理机本身无须了解外设的具体细节，可以采用统一的硬件和软件对其管理。</li>
</ul>
<h3 id="输入过程"><a href="#输入过程" class="headerlink" title="输入过程"></a>输入过程</h3><p>1、CPU将一个地址放在地址总线上，选择设备</p>
<p>2、CPU等候输入设备的数据成为有效</p>
<p>3、CPU从数据总线读入数据</p>
<h3 id="输出过程"><a href="#输出过程" class="headerlink" title="输出过程"></a>输出过程</h3><p>1、CPU将一个地址放在地址总线上，选择设备</p>
<p>2、CPU把数据放在数据总线上；</p>
<p>3、输出设备认为数据有效，取走数据</p>
<h2 id="输入输出方式"><a href="#输入输出方式" class="headerlink" title="输入输出方式"></a>输入输出方式</h2><ul>
<li>无条件IO方式难做到</li>
</ul>
<p>在程序的适当位置直接安排I&#x2F;O指令，当程序执行到这些I&#x2F;O指令时，<strong>CPU默认外设始终是准备就绪的</strong>（I&#x2F;O总是准备好接收CPU的输出数据，或总是准备好向CPU输入数据），无需检查I&#x2F;O的状态，就进行数据的传输；</p>
<p>硬件接口电路和软件控制程序都比较简单。输入时，必须确保CPU执行I&#x2F;O指令读取数据时，外设已将数据准备好；输出时，必须确保外部设备的数据锁存器为空，即外设已将上次的数据取走，等待接收新的数据，否则会导致数据传送出错，但一般的外设难以满足这种要求。</p>
<ul>
<li>程序控制IO方式</li>
</ul>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20191226161108043.png"></p>
<p>如果不设置查询次数，就可能会无限次循环导致死机。</p>
<p><strong>设备状态字寄存器：</strong></p>
<ol>
<li>用来标志设备的工作状态，以便接口对外部设备进行监视。</li>
<li>CPU通过程序查询设备状态位来判断设备的状态。</li>
<li>因此，设备状态寄存器是设备对主机的窗口，主机通过它了解设备的状态，并对设备设置操作方式。</li>
<li>设备状态寄存器又叫设备状态字（DSW）是设备所有状态的集合，每种状态均用一个触发器来表示。</li>
</ol>
<p>程序控制I&#x2F;O方式特点：<strong>何时对何设备进行输入输出操作完全受CPU控制</strong>，外围设备与CPU处于异步工作关系，数据的输入&#x2F;输出都要经过CPU。</p>
<ul>
<li>中断IO方式</li>
</ul>
<p>当外设准备好后，<strong>主动</strong>通知CPU并进行接收或输出数据的方法；</p>
<p>CPU接到外设的通知后暂停现行的工作，转入中断服务程序，和外设交换数据，等中断程序处理完毕后，再返回到被中断的原程序中继续以前被暂停的工作。</p>
<ul>
<li>DMA</li>
</ul>
<p>是一种完全由硬件执行的I&#x2F;O交换方式</p>
<ul>
<li>通道方式和IO处理机方式</li>
</ul>
<p>在复杂的计算机系统中，外围设备的台数一般比较多，设备的种类、工作方式和工作速度的差别很大，为了把对外围设备的管理工作从CPU中分离出来，采用通道或I&#x2F;O处理机方式。</p>
<p>通道是能够专门执行I&#x2F;O指令的处理机，它可以实现对外围设备的统一管理，以及外设与主存之间的数据传输。</p>
<p>（通道可以跑简单的IO程序）</p>
<p>I&#x2F;O处理机是通道方式的进一步发展，它的结构更接近于一般处理机。</p>
<h2 id="中断请求和响应"><a href="#中断请求和响应" class="headerlink" title="中断请求和响应"></a>中断请求和响应</h2><p>可以实现主机和外设之间的并行工作。</p>
<h3 id="中断的类型"><a href="#中断的类型" class="headerlink" title="中断的类型"></a>中断的类型</h3><p>内部中断：来自于CPU内部的指令中断请求，分为软件中断和异常。</p>
<p>外部中断：中断请求来自CPU外部，又分为可屏蔽和不可屏蔽中断。</p>
<p>不可屏蔽中断NMI：由系统内部硬件引发的中断，优先级高于外部硬件中断，且不受中断允许标志位的影响，所以是不可屏蔽中断。</p>
<p>可屏蔽中断：由外设通过中断请求线向处理器申请而产生的中断，处理器可以用指令来屏蔽（禁止），即不响应它的中断请求。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20191226165258341.png"></p>
<h3 id="中断的基本功能"><a href="#中断的基本功能" class="headerlink" title="中断的基本功能"></a>中断的基本功能</h3><h4 id="中断请求信号保持与清除"><a href="#中断请求信号保持与清除" class="headerlink" title="中断请求信号保持与清除"></a>中断请求信号保持与清除</h4><p>使用硬件方式实现</p>
<h4 id="中断源识别"><a href="#中断源识别" class="headerlink" title="中断源识别"></a>中断源识别</h4><p>识别中断号。</p>
<h4 id="中断控制"><a href="#中断控制" class="headerlink" title="中断控制"></a>中断控制</h4><p>中断触发方式：是指外设以什么逻辑信号去申请中断，即边沿触发和电平触发两种方式。</p>
<p>中断排队方式：当系统有多个中断源时，就可能出现同时有几个中断源都申请中断，而处理器在一个时刻只能响应并处理一个中断请求；为此，要进行中断排队。处理器按“优先级高的先服务”的原则提供服务。</p>
<ul>
<li>按优先级排队：根据任务的轻重缓急，给每个中断源指定CPU响应的优先级，任务紧急的先响应，可以暂缓的后响应。</li>
<li>循环轮流排队：不分级别高低，CPU轮流响应各个中断源的中断请求。</li>
</ul>
<h4 id="中断嵌套"><a href="#中断嵌套" class="headerlink" title="中断嵌套"></a>中断嵌套</h4><p>当CPU正在处理某个中断时，会出现优先级更高的中断源申请中断；为了使更紧急的、级别更高的中断源及时得到服务，需要暂时打断（挂起）当前正在执行的中断服务程序，去处理级别更高的中断请求，处理完成后再返回被打断了的中断服务程序继续执行。</p>
<p>但级别相同或级别低的中断源不能打断级别高的中断服务，这就是所谓的中断嵌套。</p>
<p>可屏蔽中断可以进行中断嵌套。NMI不可以进行中断嵌套。</p>
<h4 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h4><p>处理器用指令来控制中断屏蔽触发器的状态，从而控制是否接受某个特殊外设的中断请求。</p>
<p>处理器内部也有一个中断允许触发器，只有当其为“1”（即开中断），CPU才能响应外部中断。</p>
<h4 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h4><p>硬件<strong>响应</strong>优先序：未被屏蔽的几个中断源同时提出申请时，CPU选择服务对象的顺序由硬件电路实现，<strong>用户不能修改。</strong></p>
<ul>
<li>响应优先序是指CPU对设备中断请求进行响应的先后次序</li>
</ul>
<p>软件<strong>服务</strong>优先序：在各中断服务程序开头，用软件设置自己的中断屏蔽字，以此改变实际服务顺序。</p>
<ul>
<li>服务优先序是指CPU实际完成中断处理程序的先后次序</li>
</ul>
<h4 id="中断的处理"><a href="#中断的处理" class="headerlink" title="中断的处理"></a>中断的处理</h4><p>注意多重中断处理流程。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20191226170332390.png"></p>
<h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>DMA的设计是为了解决中断处理程序中每次传送一个字节、字就要响应中断的麻烦。</p>
<p>方式：</p>
<ul>
<li>外设与主存间建立一个由硬件管理的数据通路</li>
<li>CPU不介入外设与主存的数据传送操作</li>
<li>减少CPU开销，提升效率</li>
</ul>
<p>通常系统总线是由CPU管理的，在ＤＭＡ方式时，就希望CPU把这些总线让出来，即CPU连到这些总线上的线处于第三态(高阻状态)，而由DMA控制器接管，控制传送的字节数，判断DMA是否结束，以及发出DMA结束信号。因此DMA控制器必须有以下功能:</p>
<p>1、能向CPU发出系统保持(HOLD)信号，提出总线接管请求；</p>
<p>2、当CPU发出允许接管信号后，负责对总线的控制，进入DMA方式;</p>
<p>3、能对存储器寻址及能修改地址指针，实现对内存的读写；</p>
<p>4、能决定本次DMA传送的字节数，判断DMA传送是否借宿。</p>
<p>5、发出DMA结束信号，使CPU恢复正常工作状态。</p>
<p>DMA传输将从一个地址空间复制到另外一个地址空间。当CPU初始化这个传输动作，传输动作本身是由DMA控制器来实行和完成。  典型例子—移动一个外部内存的区块到芯片内部更快的内存区。</p>
<p>对于实现ＤＭＡ传输，它是由DMA控制器直接掌管总线（地址总线、数据总线和控制总线），因此，存在一个总线控制权转移问题</p>
<p>DMA传输开始前：　　　　CPU——&gt;DMA控制器</p>
<p>DMA传输结束后：              DMA控制器——&gt;CPU</p>
<p>一个完整的DMA传输过程必须经历DMA请求、DMA响应、DMA传输、DMA结束4个步骤。</p>
<p>DMA方式是一种完全由硬件进行组信息传送的控制方式，具有中断方式的优点，<strong>即在数据准备阶段，CPU与外设并行工作。</strong></p>
<h3 id="DMA传输步骤"><a href="#DMA传输步骤" class="headerlink" title="DMA传输步骤"></a>DMA传输步骤</h3><p>申请阶段：一个设备接口试图通过总线直接向另一个设备发送数据(一般是大批量的数据)，它会先向CPU发送DMA请求信号；</p>
<p>响应阶段：CPU收到DMA请求信号后，在当前的总线周期结束后，会按DMA信号的优先级和提出DMA请求的先后顺序响应DMA信号；</p>
<p>数据传送阶段：CPU对某个设备接口响应DMA请求时，会让出总线控制权；于是在DMA控制器的管理下，外设和存储器直接进行数据交换，而不需CPU干预；</p>
<p>传送结束阶段：数据传送完毕后，设备接口会向CPU发送DMA结束信号，交还总线控制权。</p>
<h3 id="DMA传输模式"><a href="#DMA传输模式" class="headerlink" title="DMA传输模式"></a>DMA传输模式</h3><h4 id="停止CPU访问内存"><a href="#停止CPU访问内存" class="headerlink" title="停止CPU访问内存"></a>停止CPU访问内存</h4><p>当需要传送一批数据时，DMA控制器首先要求CPU放弃对总线的控制权；然后开始进行数据传送。在一批数据传送完毕后，DMA控制器通知CPU可以使用内存，并把总线控制权交还给CPU。<strong>在这种DMA传送过程中，CPU基本处于不工作状态或者说保持状态。</strong></p>
<h4 id="周期挪用"><a href="#周期挪用" class="headerlink" title="周期挪用"></a>周期挪用</h4><p>停止CPU访问内存会导致内存使用效率不高。</p>
<p>当I&#x2F;O设备没有DMA请求时，CPU按程序要求访问内存；一旦I&#x2F;O设备有DMA请求，则由I&#x2F;O设备挪用一个或几个内存周期。</p>
<blockquote>
<p>DMA要求访问主存时，CPU暂停<strong>一个或多个存储周期</strong>。一个数据传送结束后，CPU继续运行。</p>
<p>CPU现场没有变动，仅延缓了指令的执行</p>
</blockquote>
<p>I&#x2F;O设备要求DMA传送时可能遇到两种情况：</p>
<ul>
<li>当CPU不需要访问内存时，此时I&#x2F;O访内与CPU访内没有冲突，即I&#x2F;O设备挪用一二个内存周期对CPU执行程序没有任何影响；</li>
<li>CPU也同时要求访问内存，这就产生了访存冲突，在这种情况下<strong>I&#x2F;O设备访存优先</strong>。</li>
</ul>
<h4 id="DMA和CPU交替访问内存"><a href="#DMA和CPU交替访问内存" class="headerlink" title="DMA和CPU交替访问内存"></a>DMA和CPU交替访问内存</h4><p>如果CPU的工作周期比内存存取周期长很多，此时采用交替访存的方法，可以使DMA传送和CPU同时发挥最高的效率。</p>
<p>将主存的存取周期分成两段：一段给CPU使用，一段给DMAC使用。</p>
<p>缺点是硬件的代价很大，会很复杂。</p>
<h3 id="DMA和中断的区别"><a href="#DMA和中断的区别" class="headerlink" title="DMA和中断的区别"></a>DMA和中断的区别</h3><ol>
<li>中断通过程序传送数据，DMA靠硬件来实现。</li>
<li>中断时机为两指令之间，DMA响应时机为两存储周期之间。</li>
<li>中断不仅具有数据传送能力，还能处理异常事件。DMA只能进行数据传送。</li>
<li>DMA仅挪用了一个存储周期，不改变CPU现场。</li>
<li>DMA请求的优先权比中断请求高。CPU优先响应DMA请求，是为了避免DMA所连接的高速外设丢失数据。</li>
<li>DMA利用了中断技术</li>
</ol>
<h2 id="通道方式"><a href="#通道方式" class="headerlink" title="通道方式"></a>通道方式</h2><p>DMA方式依赖硬件逻辑支持，随着设备数量的增加，DMA控制器增加，成本也相应增加。</p>
<p>设置专用的输入输出处理机（通道），分担输入输出管理的全部或大部分工作。</p>
<p>吸取了DMA技术，增加了软件管理，设有专用通道指令</p>
<p>层次性的I&#x2F;O系统</p>
<ul>
<li>一个主机可以连接多个通道</li>
<li>一个通道可以管理<strong>多个设备控制器</strong></li>
<li>一个设备控制器又可以控制多台设备。</li>
</ul>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/20171130091852029"></p>
<p>⑴字节多路通道<br>　　它适用于连接打印机、终端等低速或中速的I&#x2F;O设备。这种通道以字节为单位交叉工作：当为一台设备传送一个字节后，立即转去为另一它设备传送一个字节。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20191226173353103.png"></p>
<p>⑵选择通道<br>　　它适用于连接磁盘、磁带等高速设备。这种通道以“组方式”工作，每次传送一批数据，传送速率很高，但在一段时间<strong>只能为一台设备服务。每当一个I&#x2F;O请求处理完之后，就选择另一台设备并为其服务。</strong></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20191226173426866.png"></p>
<p>⑶成组多路通道<br>　　这种通道综合了字节多路通道分时工作和选择通道传输速率高的特点，其实质是：对通道程序采用多道程序设计技术，使得与通道连接的设备可以并行工作。</p>
<ul>
<li>多个设备以数据组（块）为单位交叉使用通道。</li>
<li>设备占用通道时，连续传送一组数据，然后将出让通道使用权</li>
<li>数据组的大小因设备而异，有256B、512B或1KB等。</li>
</ul>
<h3 id="通道控制方式与DMA控制方式的区别"><a href="#通道控制方式与DMA控制方式的区别" class="headerlink" title="通道控制方式与DMA控制方式的区别"></a>通道控制方式与DMA控制方式的区别</h3><p>1）DMA控制方式中需要CPU来控制所传输数据块的大小，传输的内存地址；通道控制方式中这些信息都是由通道来控制管理的。</p>
<p>2）一个DMA控制器对应一台设备与内存传递数据，而一个通道可以控制多台设备与内存的数据交换。</p>
<p>—– I&#x2F;O通道与一般处理器的区别：I&#x2F;O通道的指令类型单一，其所能执行的命令主要局限于与I&#x2F;O操作有关的指令；通道没有自己的内存，通道所执行的通道程序放在主机的内存中，也就是说通道是与CPU共享内存的。</p>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>(1)接口：接口是两个不同部件或系统之间的连接部分，可以是两个硬设备(可以都是计算机，也可以都是外部设备)之间的连接，也可以是软件系统中两个独立程序块之间的连接。</p>
<p>(2)中断：计算机系统运行时，若系统外部、内部或现行程序本身出现某种非预期的事件，CPU将暂时停下现行程序，转向为该事件服务，待事件处理完毕，再恢复执行原来被终止的程序，这个过程称为中断。</p>
<p>(3) 中断处理优先级:处理优先级是指CPU实际完成中断处理程序的先后次序。对单级中断而言,先被CPU响应的中断服务程序先完成；对多重中断而言，先被CPU响应的中断不一定先完成，这与中断屏蔽密切相关。</p>
<p>(4) 中断屏蔽: 为了便于利用程序控制中断处理的先后顺序，可通过程序有选择地封锁部分中断源发出的中断请求，而允许其余部分中断仍得到响应，这种方式称为中断屏蔽。</p>
<p>(5) 多重中断: 若在中断服务程序执行过程中，如果允许CPU响应其它中断请求，则这种中断称为多重中断，也称中断嵌套。</p>
<p>(6) 中断向量: 通常将中断服务程序的入口地址和程序状态字(有的机器不包含此项)称为中断向量。</p>
<p>(7) 中断响应优先级: 响应优先级是指CPU对各设备中断请求进行响应的先后次序，它根据中断事件的重要性和迫切性而定。当几个设备同时有中断请求时，优先级高的先响应，优先级低的后响应。</p>
<p>(8) 中断隐指令: CPU响应中断之后，经过某些操作，转去执行中断服务程序。这些操作是由硬件直接实现的，把它称为中断隐指令。中断隐指令并不是指令系统中的一条真正的指令，它没有操作码，所以中断隐指令是一种不允许、也不可能为用户使用的特殊指令。</p>
<p>(9) 程序中断I&#x2F;O: 当主机启动外设后，无需等待查询，而是继续执行原来的程序，外设在做好输入输出准备时，向主机发出中断请求，主机接到请求后就暂时中止原来执行的程序，转去执行中断服务程序对外部请求进行处理，在中断处理完毕后返回原来的程序继续执行。</p>
<p>(10)程序查询I&#x2F;O: 程序查询方式是一种程序直接控制方式,这是主机与外设间进行信息交换的最简单的方式,输入和输出完全是通过CPU执行程序来完成的。一旦某一外设被选中并启动后，主机将查询这个外设的某些状态位，看其是否准备就绪？若外设未准备就绪，主机将再次查询；若外设已准备就绪，则执行一次I&#x2F;O操作。</p>
<p>(11)DMA: 直接存储器存取控制方式DMA方式下外设与主存之间传送数据时，CPU仍可执行主程序.</p>
<p>(12)周期挪用:周期挪用是指利用CPU不访问存储器的那些周期来实现DMA操作，此时DMAC可以使用总线而不用通知CPU也不会妨碍CPU的工作。</p>
<p>(13)通道: 通道方式是DMA方式的发展，在通道方式下，数据的传送方向、存取数据的内存起始地址及传送的数据块长度等都由独立于CPU的通道来进行控制，因此，通道方式可进一步减少CPU的干预。</p>
<p>(14)选择型通道: 对于这种高速传输，通道难以同时对多个这样的设备进行操作，只能一次对一个设备进行操作,这种通道称为选择通道。</p>
<p>(15)通道指令: 通道程序是由一系列通道指令组成的，通道指令一般包含被交换数据在内存中应占据的位置、传送方向、数据块长度及被控制的I&#x2F;O设备的地址信息、特征信息（例如是磁带设备还是磁盘设备）等.</p>
<p>(16)输入设备:向计算机输入数据和信息的设备.</p>
<p>(17)输出设备:是人与计算机交互的一种部件，用于数据的输出。</p>
<p>(18)显示分辨率:显示分辨率是显示器在显示图像时的分辨率，分辨率是用点来衡量的，显示器上这个“点”就是指像素(pixel)。</p>
<p>(19)点距: 点距指屏幕上相邻两个同色像素单元之间的距离，即两个红色（或绿、蓝）像素单元之间的距离。</p>
<p>(20)行反转扫描法: 先对所有行线送”1”，所有列线送“0”，读键盘行扫描值；然后反过先对所有行线送”0”，然后对所有列线送“1”，并读键盘列扫描值。</p>
<h3 id="简要问题"><a href="#简要问题" class="headerlink" title="简要问题"></a>简要问题</h3><p>1)什么是接口?它有哪些功能?</p>
<p>2)主机与外部设备之间如何连接?</p>
<p>3)主机与外部设备信息交换的控制方式有哪些?各有什么特点?</p>
<p>4)什么是程序程序查询I&#x2F;O方式,简要说明其工作原理.</p>
<p>5)比较单级中断和多重中断处理流程的异同点.</p>
<p>6)中断隐指令完成什么功能?</p>
<p>7)为什么在保护现场和恢复现场的过程中,CPU必须关中断?</p>
<p>8)CPU响应中断的条件有哪些?</p>
<p>9)什么是中断向量,简要分析中断向量方式下形成中断向量的基本方法.</p>
<p>10)为什么采用DMA方式能提高成组数据传送的速度?</p>
<p>11)什么是中断优先级?它具有哪两层含义?划分优先等级的原则是什么?</p>
<p>12)计算机中断系统中使用屏蔽技术有什么好处?</p>
<p>13)计算机中断响应后，如何调出中断服务程序?</p>
<p>14)DMA方式传送数据前，主机应向DMA接口输送哪些参数?</p>
<p>15)比较中断I&#x2F;O和DMA的一统点。</p>
<p>16)比较DMA与通道的异同点。</p>
<p>17)中断系统中设计中断允许和中断屏蔽的作用分别是什么?两者是否可以合二为一?</p>
<p>解：(1)接口是两个不同部件或系统之间的连接部分，可以是两个硬设备(可以都是计算机，也可以都是外部设备)之间的连接，也可以是软件系统中两个独立程序块之间的连接。</p>
<p>具有的功能：1)寻址功能。2)数据输入&#x2F;输出功能。3)匹配主机与外设的速度差距。4)实现数据格式转换或逻辑电平转换。5)传送主机命令。6)反映设备的工作状态。</p>
<p>(2)主机通过接口连接I&#x2F;O设备，接口实现主机与外设的连接和信息的交换。</p>
<p>(3) 主机与外部设备信息交换的控制方式有:程序查询控制方式、程序中断控制方式、直接存储器存取控制方式(DMA)、通道方式、外围处理机方式。</p>
<p>特点：程序查询控制方式接口设计简单，但是CPU与外设只能串行工作，由于CPU的速度比外设的速度要高得多，所以在信息传送过程中，CPU的大量时间是花费在查询和等待上，从而使系统效率大大降低。</p>
<p>程序中断控制方式：允许外部设备用“中断”信号中止CPU正在执行的程序。具体他说，当接口电路需要与CPU进行数据交换（输入、输出等）时，便由接口电路向CPU发出一个中断请求信号，CPU响应这一中断请求，并调用中断服务程序完成一个或多个字节的信息交换。这种方式不需要接口软件主动查询，而是由接口电路主动通知CPU，即在设备准备数据阶段，CPU与外设能并行工作，使得接口软件的效率比较高。</p>
<p>直接存储器存取控制方式：数据传输的基本单位是数据块；所传输的数据是从设备直接送入内存的,或者相反；整块数据的传送是在控制器的控制下完成的；</p>
<p>通道方式：CPU发出启动通道的指令，通道就开始工作。I&#x2F;O通道控制I&#x2F;O控制器工作，I&#x2F;O控制器又控制I&#x2F;O设备。这样，一个通道可以连接多个I&#x2F;O控制器，而一个I&#x2F;O控制器又可以连接若干台同类型的外部设备。</p>
<p>外围处理机方式: 通常用于大、中型计算机系统中。由于PPU基本上独立于主机工作，其结构更接近一般处理机，甚至就是一般的通用微小型计算机。它可以完成IOP的功能，还可以完成码制变换、格式处理、数据块检错、纠错等操作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2019/12/25/Algorithm_%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/25/Algorithm_%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">分治策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-24 23:29:41" itemprop="dateCreated datePublished" datetime="2019-12-24T23:29:41Z">2019-12-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分治策略"><a href="#分治策略" class="headerlink" title="分治策略"></a>分治策略</h1><p>分治法遵循三个基本步骤：</p>
<p>1）分解（Divide）：将原问题分为若干个规模较小、相互独立，性质与原问题一样的子问题；</p>
<p>2）解决（Conquer）：若子问题规模较小、可直接求解时则直接解；否则<strong>“递归”</strong>求解各个子问题，即继续将较大子问题分解为更小的子问题，然后用同一策略继续求解子问题。</p>
<p>3）合并（Combine）：将子问题的解合并成原问题的解。</p>
<h2 id="递归式求解的三种方法"><a href="#递归式求解的三种方法" class="headerlink" title="递归式求解的三种方法"></a>递归式求解的三种方法</h2><p>通常遇到的输入规模为n的递归式，形式如下：</p>
<p>$$T(n) &#x3D; aT(n&#x2F;b) + f(n)$$</p>
<p>该式描述的是：它将规模为n的问题分解为a个子问题，每个子问题规模为n&#x2F;b，其中a和b都是正常数。a个子问题递归地进行求解，每个花费时间T(n&#x2F;b)。<strong>函数f(n)包含了问题分解和子问题解合并的代价</strong>。例如，描述Strassen算法的递归式中，a&#x3D;7，b&#x3D;2，f(n) &#x3D; Θ(n2) 。</p>
<p>接下来分析求解上述式子的三种方法</p>
<h3 id="代入法"><a href="#代入法" class="headerlink" title="代入法"></a>代入法</h3><p>  实质上就是数学归纳法，先对一个小的值做假设，然后推测更大的值得正确性。</p>
<p>​    1.猜测解的形式；</p>
<p>​    2.用数学归纳法求出解中的常数，并证明解是正确的。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>T(n) &#x3D; 2T(n&#x2F;2) + n</p>
<ul>
<li>step one: 猜测<br> 上述等式可以转换为 T(n)&#x2F;n &#x3D; 2T(n&#x2F;2)&#x2F;n + 1<br> 令 S(n) &#x3D; T(n)&#x2F;n<br> 则S(n) &#x3D; S(n&#x2F;2) + 1<br> 而这种形式与以下的等式很像(这是关键步骤)<br> lgn &#x3D; lg (n&#x2F;2) + 1 (此处lg2 &#x3D; 1)<br> 因此可以推测 T(n) &#x2F; n &#x3D; clgn (c是常数)</li>
</ul>
<p>因此猜出其解为 T(n) &#x3D; O(nlgn)</p>
<ul>
<li>step two: 数学归纳法证明这个解的合理性<br> 直接代入去运算</li>
</ul>
<h3 id="递归树法"><a href="#递归树法" class="headerlink" title="递归树法"></a>递归树法</h3><p>利用递归树方法求算法复杂度，其实是提供了一个好的猜测，简单而直观。在递归树中，每一个结点表示一个单一问题的代价，子问题对应某次递归函数调用。我们将树中每层中的代价求和，得到每层代价，然后将所有层的代价求和，得到所有层次的递归调用总代价。简单来说就是将递归的一层一层分析出来，再累加求和。</p>
<p>   递归树最适合用来生成好的猜测，然后可用代入法来验证猜测是否正确。当使用递归树来生成好的猜测时，常常要忍受一点儿“不精确”，因为关注的是如何寻找解的一个上界。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><img src="/images/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/20160201091404071"></p>
<p><img src="/images/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/20160201091411294"></p>
<p><img src="/images/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/20160201091528638"></p>
<p><img src="/images/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/20160201091655389"></p>
<p> 在递归树中，每一个结点都代表一个子代价，每层的代价是该层所有子代价的总和，总问题的代价就是所有层的代价总和。所以，我们利用递归树求解代价，只要知道每一层的代价和层数即可。</p>
<p>   这些，都需要直观的找出规律，以上图为例，当递归调用到叶子T(1)时所用到的递归次数就是整棵递归树的深度。我们从图中可以得到第i层的结点的代价为n&#x2F;(4^i)，当n&#x2F;(4^i)&#x3D;1即i &#x3D; log4(n)时，递归到达了叶子，故整棵递归树的深度为log4(n)。总代价是所有层代价的总和。</p>
<h3 id="主方法（最普适）"><a href="#主方法（最普适）" class="headerlink" title="主方法（最普适）"></a>主方法（最普适）</h3><blockquote>
<p><strong>定理4.1（主定理）</strong> 令 a≥1 和 b&gt;1 是常数，f(n) 是一个函数，T(n) 是定义在非负整数上的递归式：<br> $T(n) &#x3D; aT(n&#x2F;b) + f(n)$<br> 那么T(n)有如下渐进界：</p>
<ol>
<li>若对某个常数 ε&gt;0 有 f(n) &#x3D; O(nlog<del>b</del>^a^-ε)，则 T(n) &#x3D; Θ(nlog<del>b</del>^a^) 。</li>
<li>若 f(n) &#x3D; Θ(nlogba)，则 T(n) &#x3D; Θ(nlog<del>b</del>^a^lgn) 。</li>
<li>若对某个常数 ε&gt;0 有 f(n) &#x3D; Ω(nlog<del>b</del>^a^+ε)，且**对某个常数 c&lt;1 和所有足够大的 n 有 af(n&#x2F;b) ≤ cf(n)**，则 T(n) &#x3D; Θ(f(n)) 。</li>
</ol>
<p><img src="/images/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/20160201085628397"></p>
</blockquote>
<p>将余项f(n)与<strong>函数 nlog<del>b</del>^a^</strong> 进行比较， 直觉上来说两个函数的较大者决定了递归式的解，如情况一是 nlogba 较大，情况3是 f(n) 较大。而情况2是两者一样大，这种情况需要乘上一个对数因子。</p>
<p>这里要注意主方法不能求解的地方，所有的大于和小于都是多项式意义上的大于和小于，对于有些递归式夹在三种情况的间隙中，是无法用主方法来求解的。下面解释一下什么是多项式意义上的小于和大于：  </p>
<blockquote>
<p>  f(x)多项式大于g(x):存在实数e&gt;0,使得f(x)&gt;g(x)n^e^<br>  f(x)多项式小于g(x):存在实数e&gt;0,使得f(x)&lt;g(x)n^e^</p>
</blockquote>
<p>举个例子，有递归式T(n) &#x3D; 2T(n&#x2F;2)+nlgn。</p>
<p>对于这个递归式，我们有 a &#x3D; 2，b &#x3D; 2， f(n) &#x3D; n，因此 nlog<del>b</del>^a^ &#x3D; nlog<del>2</del>^2^ &#x3D; Θ(n^1^) 。</p>
<p><img src="/images/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/image-20191225125958169.png"></p>
<blockquote>
<p>但是nlogn仅仅渐进大于n</p>
<p>因为对于任意c&gt;0,均有logn &lt; n^c^(由洛必达法则可知)。</p>
<p><img src="/images/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/image-20191225130856418.png"></p>
</blockquote>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>T(n) &#x3D; 9T(n&#x2F;3) + n</p>
<p>对于这个递归式，我们有 a &#x3D; 9，b &#x3D; 3， f(n) &#x3D; n，因此 nlog<del>b</del>^a^ &#x3D; nlog<del>3</del>^9^ &#x3D; Θ(n^2^) 。而 f(n) &#x3D; n 渐进小于 Θ(n^2^)，所以可以应用于主定理的情况1，从而得到解 T(n) &#x3D; Θ(n^2^) 。</p>
<p>T(n) &#x3D; T(2n&#x2F;3) + 1</p>
<p>其中，a &#x3D; 1， b &#x3D; 3&#x2F;2， f(n) &#x3D; 1，因此 nlog<del>b^</del>a^ &#x3D; nlog<del>3&#x2F;2</del>^1^ &#x3D; n^0^ &#x3D; 1 。由于 f(n) &#x3D; Θ(1) ，与Θ(nlog<del>b</del>^a^)恰好相等，可应用于情况2，从而得到解 T(n) &#x3D; Θ(lgn) 。</p>
<p>T(n) &#x3D; 3T(n&#x2F;4) + nlgn</p>
<p>我们有 a &#x3D; 3，b &#x3D; 4，f(n) &#x3D; nlgn，因此nlog<del>b</del>^a^ &#x3D; nlog<del>4</del>^3^ &#x3D; O(n^0.793^) 。由于 f(n) &#x3D; Θ(nlgn) &#x3D; Ω(n) &#x3D; Ω(n^0.793+0.207^)，因此可以考虑应用于情况3，其中 ε &#x3D; 0.207。但需要检查是否满足条件：当 n 足够大时，存在 c&lt;1 使 af(n&#x2F;b) ≤ cf(n) 。</p>
<ul>
<li>令 3f(n&#x2F;4) ≤ cf(n) 有<br> 3n&#x2F;4lg(n&#x2F;4) ≤ cnlgn<br> 3&#x2F;4(lgn - lg4) ≤ clgn<br> (3&#x2F;4 - c)lgn ≤ 3&#x2F;4lg4</li>
</ul>
<p>容易发现，当 c ≥ 3&#x2F;4 时，上式对于足够大的 n 恒成立。因此可以使用主定理的情况3，得出递归式的解为 T(n) &#x3D; Θ(nlgn) 。</p>
<h2 id="最大子数组问题"><a href="#最大子数组问题" class="headerlink" title="最大子数组问题"></a>最大子数组问题</h2><p>已知数组A，在A中寻找“和最大”的非空连续子数组。——称这样的连续子数组为最大子数组(maximum subarray)</p>
<h3 id="方法一：暴力求解"><a href="#方法一：暴力求解" class="headerlink" title="方法一：暴力求解"></a>方法一：暴力求解</h3><p>暴力求解的时间复杂度为O（n^2^）</p>
<h3 id="方法二：分治求解"><a href="#方法二：分治求解" class="headerlink" title="方法二：分治求解"></a>方法二：分治求解</h3><p>分治求解的核心在于递归。所以需要考虑最大子数组如何满足递归的要求。</p>
<p>首先，将数组分成均分为两个部分。那么最大子数组可能存在的位置可能存在的情况有三种：</p>
<ol>
<li>最大子数组在左边的数组中</li>
<li>最大子数组在右边数组中</li>
<li>最大子数组跨越了左右两个子数组</li>
</ol>
<p>递归的结束：左右子数组的元素为1时，就可以结束递归了。</p>
<p>递归层需要做的事情：计算左右子数组的最大子数组和横跨左右子数组的最大数组。<br>在求解横跨左右子数组的最大数组时，可以从mid出发，分别向左和向右找出“和最大”的子区间，mid分别是左右区间的终点和起点。然后合并这两个区间即可得到跨越中点时的A[low … high]的最大子数组。</p>
<p>递归的返回值：返回MAX（左右子数组的最大子数组，横跨左右子数组的最大数组）</p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>对A[low..mid]和A[mid+1..high]两个子问题递归求解，每个子问题的规模是n&#x2F;2，所以每个子问题的求解时间为T(n&#x2F;2)，两个子问题递归求解的总时间是2T(n&#x2F;2)。</p>
<p>FIND-MAX-CROSSING-SUBARRAY的时间是Θ(n)。</p>
<p>所以T(n)&#x3D;Θ(nlgn）</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">Leetcode 53.最大子序和</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> maxSubArraySum(nums,<span class="number">0</span>,l-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArraySum</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r)</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归的结束：当只有子数组只有一个元素的时候</span></span><br><span class="line">        <span class="keyword">if</span>(l==r)</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">        <span class="type">int</span> mid=(r+l)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span>  <span class="operator">=</span> Math.max(maxSubArraySum(nums,mid+<span class="number">1</span>,r),maxCrossingSum(nums,l,mid,r));</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxSubArraySum(nums,l,mid),temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxCrossingSum</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> mid ,<span class="type">int</span> r)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftsum=Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//从mid的左边走，一直走到最大子数组的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=mid;i&gt;=l;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;=leftsum)</span><br><span class="line">            leftsum=sum;</span><br><span class="line">        &#125;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rightsum=Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;rightsum)</span><br><span class="line">            rightsum=sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftsum+rightsum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Strassen矩阵乘法"><a href="#Strassen矩阵乘法" class="headerlink" title="Strassen矩阵乘法"></a>Strassen矩阵乘法</h2><p>矩阵乘法是种极其耗时的运算。</p>
<p>以C &#x3D; A • B为例，其中A和B都是 n x n 的矩阵。根据矩阵乘法的定义，计算过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SQUARE-MATRIX-MULTIPLY(A, B)</span><br><span class="line">n = A.rows</span><br><span class="line">let C be a <span class="keyword">new</span> <span class="title class_">nxn</span> matrix</span><br><span class="line"><span class="type">for</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> to n</span><br><span class="line">    <span class="type">for</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span> to n</span><br><span class="line">        c[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="type">for</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span> to n</span><br><span class="line">            c[i][j] += a[i][k] * b[k][j]</span><br><span class="line"><span class="keyword">return</span> C</span><br></pre></td></tr></table></figure>

<p>由于存在三层循环，它的时间复杂度将达到O(n3)。</p>
<p>这是一个很可怕的数字。但是，凭着科学家们的智慧，这个数正在一步步下降。本文介绍经典的Strassen算法，该算法将时间复杂度降低到O(nlg7) ≈ O(n2.81)。别小看这个细微的改进，当n非常大时，该算法将比平凡算法节约大量时间。</p>
<h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>Strassen算法基于分治的思想，因此我们首先考虑一个简单的分治策略。</p>
<p>每个 n x n 的矩阵都可以分割为四个 n&#x2F;2 x n&#x2F;2 的矩阵：</p>
<p><img src="/images/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/1186132-ab97111959554711.webp"></p>
<p>因此可以将公式C &#x3D; A • B改写为</p>
<p><img src="/images/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/1186132-a643e20f23008d91.webp"></p>
<p>于是上式就等价于如下四个公式：</p>
<p><small>（式3-3）</small><br> C11 &#x3D; A11 • B11 + A12 • B21<br> C12 &#x3D; A11 • B12 + A12 • B22<br> C21 &#x3D; A21 • B11 + A22 • B21<br> C22 &#x3D; A21 • B12 + A22 • B22</p>
<blockquote>
<p>注：任意两个子矩阵块的乘可以沿用同样的规则：如果子矩阵的阶大于2，则将子矩阵分成更小的子矩阵，直到每个子矩阵只含一个元素为止。从而构造出一个递归计算过程。</p>
</blockquote>
<p>每个公式需要计算两次矩阵乘法和一次矩阵加法，使用T(n)表示 n x n 矩阵乘法的时间复杂度，那么我们可以根据上面的分解得到一个递推公式。</p>
<p>T(n) &#x3D; 8T(n&#x2F;2) + Θ(n^2^)</p>
<p>其中，8T(n&#x2F;2)表示8次矩阵乘法，而且相乘的矩阵规模降到了n&#x2F;2。Θ(n^2^)表示4次矩阵加法的时间复杂度以及合并C矩阵的时间复杂度。</p>
<p>要想计算出T(n)并不复杂，可以采用画递归树的方式计算，结果是T(n) &#x3D; Θ(n^3^)</p>
<p>可见，简单的分治策略并没有起到加速运算的效果。</p>
<h3 id="Strassen算法"><a href="#Strassen算法" class="headerlink" title="Strassen算法"></a>Strassen算法</h3><p>让我们回头观察前面使用分治策略的时候为什么无法提高速度。</p>
<p>因为分解后的问题包含了8次矩阵相乘和4次矩阵相加，就是这8次矩阵相乘导致了速度不能提升。于是我们想到能<strong>不能减少矩阵相乘的次数，取而代之的是矩阵相加的次数增加</strong>。Strassen正是利用了这一点。</p>
<p>现在，我们来看一下Strassen算法的原理。</p>
<p>仍然把每个矩阵分割为4份，然后创建如下10个中间矩阵：</p>
<p>S1 &#x3D; B12 - B22<br> S2 &#x3D; A11 + A12<br> S3 &#x3D; A21 + A22<br> S4 &#x3D; B21 - B11<br> S5 &#x3D; A11 + A22<br> S6 &#x3D; B11 + B22<br> S7 &#x3D; A12 - A22<br> S8 &#x3D; B21 + B22<br> S9 &#x3D; A11 - A21<br> S10 &#x3D; B11 + B12</p>
<p>接着，计算7次矩阵乘法：</p>
<p>P1 &#x3D; A11 • S1<br> P2 &#x3D; S2 • B22<br> P3 &#x3D; S3 • B11<br> P4 &#x3D; A22 • S4<br> P5 &#x3D; S5 • S6<br> P6 &#x3D; S7 • S8<br> P7 &#x3D; S9 • S10</p>
<p>最后，根据这7个结果就可以计算出C矩阵：<br> C11 &#x3D; P5 + P4 - P2 + P6<br> C12 &#x3D; P1 + P2<br> C21 &#x3D; P3 + P4<br> C22 &#x3D; P5 + P1 - P3 - P7</p>
<p>我们可以把P矩阵和S矩阵展开，并带入最后的式子计算，会发现恰好是公式3中的四个式子。也就是说，Strassen为了计算公式3，绕了一大圈，用了更多的步骤，成功的把计算量变成了7个矩阵乘法和18个矩阵加法。虽然矩阵加法增加了好几倍，而矩阵乘法只减小了1个，但在数量级面前，18个加法仍然渐进快于1个乘法。这就是该算法的精妙之处。</p>
<p>同样地，我们可以写出Strassen算法的递推公式：</p>
<p>T(n) &#x3D; 7T(n&#x2F;2) + Θ(n2)</p>
<p>使用递归树或主方法可以计算出结果：</p>
<p>T(n) &#x3D; Θ(nlg7) ≈ Θ(n2.81)</p>
<p>下图展示了平凡算法和Strassen算法的性能差异，n越大，Strassen算法节约的时间越多。</p>
<p><img src="/images/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/1186132-d4454de5a866191b.webp" alt="性能比较"></p>
<h2 id="最近点对问题"><a href="#最近点对问题" class="headerlink" title="最近点对问题"></a>最近点对问题</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2019/12/25/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-CPU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/25/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-CPU/" class="post-title-link" itemprop="url">组成原理-CPU</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-24 21:44:22" itemprop="dateCreated datePublished" datetime="2019-12-24T21:44:22Z">2019-12-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">组成原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/2019011215573123.png"></p>
<h1 id="CPU的组成和功能"><a href="#CPU的组成和功能" class="headerlink" title="CPU的组成和功能"></a>CPU的组成和功能</h1><p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-CPU/1552225-8b09b1de21af5f76.png"></p>
<p>cpu&#x3D;运算器+控制器。</p>
<p>运算器：数据加工。</p>
<p>控制器：</p>
<ul>
<li>程序控制: 程序中指令执行顺序控制 </li>
<li>操作控制: 将机器指令翻译成执行部件所需操作控制信号</li>
<li>时序控制: 控制操作信号的产生时间、持续时间</li>
<li>异常控制: 异常处理，外设交互</li>
</ul>
<h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p><strong>控制器：</strong>程序计数器、指令寄存器、指令译码器、时序产生器和操作控制器组成。</p>
<p>取指令，将机器指令<strong>译码</strong>并生成<strong>执行部件</strong>所需的<strong>控制信号序列</strong>，控制信号送至各执行部件控点，引起逻辑门开闭，建立正确的数据通路，从而完成指令功能。</p>
<ul>
<li><strong>硬布线控制器</strong>  (时序逻辑型) (硬件实现)</li>
<li><strong>微程序控制器</strong>  (存储程序型) (软件实现)</li>
</ul>
<h1 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h1><p>在指令的执行周期完成后，处理器会判断是否出现中断请求，只有在出现中断请求时才会进入中断周期。</p>
<!--以下是上课的学习笔记-->

<h1 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h1><p>执行部件间传送信息的路径（数据流）</p>
<ul>
<li><strong>共享通路（总线）</strong></li>
<li><strong>专用通路</strong></li>
</ul>
<p><strong>在总线结构中，可同时进行的数据传输数量取决于总线的数量</strong></p>
<h4 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h4><p>总线上可以有多个模块同时接收数据，但是某一时刻只能有一个模块向总线发送数据。因此，接入到总线上的部件需要进行输出控制，以防止总线上的数据冲突。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20191225144536035.png"></p>
<h4 id="双总线结构"><a href="#双总线结构" class="headerlink" title="双总线结构"></a>双总线结构</h4><p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20191225144858947.png"></p>
<h4 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h4><p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20191225144921158.png"></p>
<h1 id="指令周期与时序（重要）"><a href="#指令周期与时序（重要）" class="headerlink" title="指令周期与时序（重要）"></a>指令周期与时序（重要）</h1><h2 id="指令周期-1"><a href="#指令周期-1" class="headerlink" title="指令周期"></a>指令周期</h2><ul>
<li>定长指令周期：传统的三级时序—–以最慢的指令周期同步</li>
<li>变长指令周期：指令需要多少时间就给多少时间</li>
</ul>
<p><strong>取指令、执行指令反复循环</strong></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20191225145027383.png"></p>
<ul>
<li>时钟周期（震荡周期、节拍脉冲） ——能完成依次微操作</li>
<li>机器周期（CPU周期）&#x3D; 多个时钟周期 ——–从主存读出一条指令的最短时间（也就是访问一次内存的最短时间）</li>
</ul>
<p>指令周期可划分如下阶段</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20191225145338190.png"></p>
<h2 id="取值周期"><a href="#取值周期" class="headerlink" title="取值周期"></a>取值周期</h2><p>取值周期就是按PC内容取出指令，并计算后续指令的地址：<br>有跳转指令的就计算跳转后的指令的地址；没有就顺序执行。</p>
<h2 id="译码-x2F-取操作数周期"><a href="#译码-x2F-取操作数周期" class="headerlink" title="译码&#x2F;取操作数周期"></a>译码&#x2F;取操作数周期</h2><p>识别指令类型，并根据指令地址码字段的值访问相应的寄存器或主存单元。</p>
<p>这部分包括了操作数地址计算和取操作数的阶段。</p>
<h4 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h4><p>控制器向算术逻辑运算单元和数据通路中的其他部件发送操作控制命令，对前面准备好的操作数进行操作，将操作的状态信息保存在PSW中。<strong>如果出现程序转移，则在执行周期内决定转移地址</strong></p>
<h4 id="写回"><a href="#写回" class="headerlink" title="写回"></a>写回</h4><p>将运算结果写到寄存器或存储器中。</p>
<h4 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h4><p>实际的指令周期还包括了中断周期（完成现行程序与中断程序的切换）、总线周期（完成总线操作与总线控制权的转移）、IO周期（完成输入输出操作）。</p>
<h4 id="指令周期数据流示例"><a href="#指令周期数据流示例" class="headerlink" title="指令周期数据流示例"></a>指令周期数据流示例</h4><p>可以分析分析与不同总线的数据通路之间的运行的周期数。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20191225151042573.png"></p>
<h3 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h3><p>硬布线控制中采用的时序体制是三级时序体制。微程序控制器采用的是两级时序体制。</p>
<h4 id="时序产生器与控制器–同步控制"><a href="#时序产生器与控制器–同步控制" class="headerlink" title="时序产生器与控制器–同步控制"></a>时序产生器与控制器–同步控制</h4><p>时序产生器循环产生周期电位、节拍电位，供控制器对信号进行时间调制。简单来说就是对各种信号进行时间同步。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20191225150508227.png"></p>
<h4 id="现代时序系统—异步控制"><a href="#现代时序系统—异步控制" class="headerlink" title="现代时序系统—异步控制"></a>现代时序系统—异步控制</h4><p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20191225202524104.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20191225150533112.png"></p>
<h3 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h3><ul>
<li>同步控制方式—–使用的是定长指令周期</li>
<li>异步控制方式—–使用的是变长指令周期</li>
<li>混合控制方式—–使计算机处于同步和异步交替工作方式</li>
</ul>
<h2 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h2><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>将控制器看成产生固定时序控制信号的逻辑电路。</p>
<h3 id="单周期硬布线控制器"><a href="#单周期硬布线控制器" class="headerlink" title="单周期硬布线控制器"></a>单周期硬布线控制器</h3><p>使用的是同步控制</p>
<p><strong>固定指令周期硬布线控制器设计步骤</strong></p>
<p>1、设计三级时序产生器：所有指令固定机器周期数、节拍数<br>2、列出所有机器指令的指令周期流程图，明确每个节拍的控制信号<br>3、找出产生同一微操作控制信号的条件<br>4、写出各微操作控制信号的布尔表达式<br>5、化简<br>6、实现</p>
<h3 id="多周期硬布线控制器"><a href="#多周期硬布线控制器" class="headerlink" title="多周期硬布线控制器"></a>多周期硬布线控制器</h3><p><strong>核心是设计时序产生器状态机</strong></p>
<p>使用的是异步控制</p>
<ul>
<li>一条指令多个时钟周期</li>
<li>一个时钟周期一个状态</li>
<li>一个状态对应一组并发信号</li>
</ul>
<p><strong>可变周期硬布线控制器设计步骤</strong></p>
<p>1、列出所有机器指令的指令周期流程图，明确每个节拍的控制信号<br>2、绘制指令执行状态转换图<br>3、根据状态转换图构建状态机真值表，实现有限状态机组合逻辑<br>4、实现控制器组合逻辑电路</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20191225205455789.png"></p>
<p>指令结束阶段可能会进入中断</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20191225205200955.png"></p>
<h2 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h2><p>使用的是 <strong>存储逻辑</strong></p>
<ul>
<li><strong>将并发信号事先存储为微指令</strong></li>
<li>一条指令对应多条微指令</li>
<li><strong>状态等同与存储器地址</strong></li>
</ul>
<p>微程序控制器是利用软件方法来设计硬件的技术。将完成指令所需要的控制信号按格式编写成微指令，存放到控制存储器。</p>
<ul>
<li>一条机器指令对应一段微程序（多条微指令）</li>
<li>指令取指执行—&gt;微程序的执行—–&gt;执行多条微指令—–&gt;依次生成控制信号</li>
</ul>
<h3 id="微命令和微操作"><a href="#微命令和微操作" class="headerlink" title="微命令和微操作"></a>微命令和微操作</h3><p>微程序–&gt;微指令–&gt;微命令</p>
<p>微命令：控制部件向执行部件发出的各种控制命令</p>
<p>微操作：执行部件收到微命令后所进行的操作</p>
<p><strong>微命令是可以在CPU周期内并行执行的，但是微程序是只能串行执行。</strong></p>
<p>操作控制字段是微指令主体，每一位都是一个微指令。</p>
<p>微程序中多条微指令的先后关系由微指令格式中的<strong>测试字段</strong>和<strong>下地址字段</strong>给出。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20191225210308226.png"></p>
<h2 id="微程序设计"><a href="#微程序设计" class="headerlink" title="微程序设计"></a>微程序设计</h2><h3 id="微指令格式"><a href="#微指令格式" class="headerlink" title="微指令格式"></a>微指令格式</h3><p>分为水平型和垂直型。</p>
<h4 id="水平型微指令"><a href="#水平型微指令" class="headerlink" title="水平型微指令"></a>水平型微指令</h4><p>在一个微周期中<strong>同时给出多个微命令</strong>的微指令。编码方式如下“微指令编码方式”</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20191225231213793.png"></p>
<h4 id="垂直型微指令"><a href="#垂直型微指令" class="headerlink" title="垂直型微指令"></a>垂直型微指令</h4><p>类似汇编语言，把微指令代码化。</p>
<p>基本上淘汰了。</p>
<h3 id="微指令编码方式"><a href="#微指令编码方式" class="headerlink" title="微指令编码方式"></a>微指令编码方式</h3><p><strong>直接表示法</strong></p>
<p>将微指令操作控制字段的每一个二进制位定义成一个微命令，用1或者0表示相应的微命令的有无。</p>
<p>缺点：字长太长</p>
<p>解决方法：</p>
<ul>
<li>改直接表示为编码表示</li>
<li>去掉下址字段，采用PC&#x3D;PC+1的方式生成微指令</li>
<li>改水平微指令为垂直微指令（牺牲并行性）</li>
</ul>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20191225232115891.png"></p>
<p>此时没有下址字段，故PC的生成方式如下图所示：</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20191225232205758.png"></p>
<p><strong>字段直接译码法</strong></p>
<p>将微指令格式中的操作控制字段分成诺干组，每组中包含诺干个互斥性微命令，将相容性微命令安排在不同组。（将互斥性微命令编码是因为他们之间是不可能同时出现的）</p>
<p><strong>注意：要预留一个信号表示什么指令都不给</strong></p>
<h2 id="PS-1"><a href="#PS-1" class="headerlink" title="PS"></a>PS</h2><h3 id="一些名词的含义"><a href="#一些名词的含义" class="headerlink" title="一些名词的含义"></a>一些名词的含义</h3><p>指令周期：取指令并执行一条指令所需要的时间，一般由若干个机器周期组成，包括从取指令、分析指令到执行完所需的全部时间。</p>
<p>数据通路：数据在功能部件之间传送的路径。</p>
<p>时钟周期：由CPU时钟定义的定长时间间隔，是CPU工作的最小时间单位，也称节拍脉冲或T周期。</p>
<p>同步控制：选取部件中最长的操作时间作为统一的时间间隔标准，使所有部件都在这个时间间隔内启动并完成操作。</p>
<p>异步控制：系统不设立统一的时间间隔标准(基准时钟除外)，各部件按各自的时钟工作，分别实现各自的时序控制，时间衔接通过应答通讯方式(又称握手方式)实现。</p>
<p>联合控制：同步控制与异步控制相结合。对大多数节拍数相近的指令，采用同步控制；而对少数节拍数多不固定的指令，采用异步控制。</p>
<p>单周期处理器：所有指令在一个时钟周期内完成的处理器。</p>
<p>多周期处理器：每条指令的执行分成多个阶段，每个时钟周期完成一个阶段的工作。</p>
<p>微操作：执行部件收到微命令后所进行的操作。</p>
<p>相容性微命令：能同时并行执行的微命令。</p>
<p>互斥性微命令：不能并行执行的微操作。</p>
<p>微指令：由微指令产生的一组实现一定微操作功能的微命令的组合。</p>
<p>微程序：实现一条指令功能的若干条微指令的集合。</p>
<p>微程序控制器：采用微程序设计方法设计的控制器。指令执行过程中所需要的所有控制信号以微指令的方式存在在控制存储器中，指令执行时，逐条读出微指令，以产生执行执行过程中所需要的控制信号。</p>
<p>控制存储器：微程序控制器中用于存放解释所有指令微程序的存储器。</p>
<p>硬布线控制器：又称为组合逻辑控制器，指令执行所需要的控制信号直接由逻辑门电路和触发器等构成的电路产生，与微程序控制器相比，具有结构复杂但速度快的特点。</p>
<h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><p>1)中央处理器的基本功能是什么?从实现其功能的角度分析，它应由哪些部件组成?</p>
<p>答：五方面的功能：</p>
<p>指令执行顺序的控制。即控制程序中的指令按事先规定的顺序自动地执行，从而保证程序执行过程中，指令在逻辑上的相互关系不被改变。</p>
<p>指令的操作控制。即产生指令执行过程中所需要的信号，以控制执行部件按指令规定的操作运行。</p>
<p>时间控制，即对每个控制信号进行定时，以便按规定的时间顺序启动各操作。对于任何一条指令而言，如果操作控制信号的时间不正确，则指令的功能也就不能正确实现。</p>
<p>数据加工处理。即对数据进行算术、逻辑运算，或将数据在相关部件之间传送。</p>
<p>异常和中断处理。如处理运算中的异常及处理外部设备的中断服务请求等。</p>
<p>组成：中央处理器主要由控制器和运算器两部分构成。控制器的主要功能包括：取指令、计算下一条指令的地址、对指令译码、产生相应的操作控制信号、控制指令执行的步骤和数据流动的方向。运算器是执行部件，由算术逻辑单元和各种寄存器组成。</p>
<p><strong>2)CPU</strong>内部有哪些寄存器?它们的功能分别是什么?</p>
<p>答：**(1)** **指令寄存器(IR)**：IR用于保存指令。从主存储器取出的指令存放在IR中，直到新的指令从主存中取出为止。</p>
<p>   <strong>(2)</strong> <strong>程序计数器(PC)</strong> <strong>：</strong>PC保存将要执行的指令地址，故又称指令地址寄存器。CPU取指令时，将PC的内容送到主存地址寄存器，然后修改PC的值形成下一条将要执行的指令地址</p>
<p><strong>(3)</strong> **地址寄存器(AR)**：AR用来保存当前CPU所要访问的主存单元地址，无论CPU是取指令还是存取数据，都必须先将要访问的主存单元地址送AR，直到读&#x2F;写操作完成。</p>
<p>(4)**通用寄存器组(GR)**：通用的含义是指寄存器的功能有多种用途，GR可作为ALU的累加器、变址寄存器、地址指针、指令计数器、数据缓冲器，用于存放操作数(包括源操作数、目的操作数及中间结果)和各种地址信息等。</p>
<p> <strong>(5)</strong> <strong>数据缓冲寄存器(DR)</strong></p>
<p>DR作为CPU和主存之间的数据缓冲寄存器用于存放操作数、运算结果或中间结果，以减少访问主存的次数；也可存放从主存中读出的数据，或准备写入主存的数据。</p>
<p>   <strong>(6)</strong> <strong>程序状态字寄存器(PSW)</strong></p>
<p>PSW用于保存由算术运算指令、逻辑运算指令、测试结果等建立的各种条件标志。常见的状态信息包括进位标志(C)、溢出标志(V)、结果为负数标志(S)及结果为零标志(Z)等。</p>
<p>**3)**什么是取指周期?取指周期内应完成哪些操作?</p>
<p> 答：取指周期就是从开始取指令到取指令完成所需要的时间。取指周期要完成两方面的操作，一是将PC的值送存储器地址寄存器MAR，并完成储单元去取指令；二是如何形成后续指令地址：</p>
<p>·顺序执行指令时，将PC内容加当前指令所占用的主存单元数(以字节为单位)；</p>
<p>·当出现转移时，根据寻址方式、转移条件、转移的目标地址等内容计算得到。</p>
<p>**4)**<strong>指令有几种执行方式?说明各自的特点。</strong></p>
<p>答：指令的执行方式有顺序执行方式、重叠执行方式和流水执行三种方式。</p>
<p>顺序执行方式：是一种串行执行方式，取出一条指令的操作全部结束后才能开始下一条指令的指令周期，这种方式控制简单，程序的执行速度慢。</p>
<p>重叠执行方式：是一种局部并行方式，通常将当前指令的执行阶段与下一条指令的取指阶段重叠进行，这种方式控制较复杂，但可以提高程序的执行速度；</p>
<p>流水执行方式：是一种并行执行方式，它将指令的执行分多个阶段（每个阶段的任务由特定的功能部件完成），一般而言，在该执行方式下，指令间的并行程度比重叠执行方式要高，控制更为复杂，可以更快地提高程序的执行速度。</p>
<p>**5)**<strong>计算机为什么要设置时序系统?说明指令周期、机器周期、和时钟周期的含义。</strong></p>
<p>答：指令执行过程中的所有操作必须按照一定的次序完成，而且这些操作持续的时间也有严格的限制，因此，在计算机系统中需要设置时序系统，对指令执行过程中的所有控制信号进行时间控制，以保证指令功能的正确实现。</p>
<p>通常将一条指令从取出到执行完成所需要的时间称为<strong>指令周期，</strong>包括取指周期和执行周期，指令周期通过右若干和机器周期组成，所包含的机器周期的数量随指令功能和寻址方式的不同而不同。</p>
<p><strong>机器周期</strong>分成若干个节拍电位时间段，通常以CPU完成一次微操作所需要的时间为基础来定义节拍电位的时间；由CPU时钟定义的定长时间间隔，是CPU工作的最小时间单位，也称<strong>节拍脉冲或T周期</strong>。</p>
<ol start="6">
<li><strong>组合逻辑控制器与微程序控制器各有什么特点?</strong></li>
</ol>
<p> 答：硬布线控制器又称为组合逻辑控制器，这种控制器中的控制信号直接由各种类型的逻辑门电路和触发器等构成，与微程序控制器相比，具有结构复杂但速度快的特点。</p>
<p>微程序控制器的设计采用了存储技术和程序设计技术，使复杂的控制逻辑得到简化。通过过读出存放在微程序控制器中微指令产生指令执行过程中所需要的控制信号，所以，与硬布线控制器相比，微程序控制器的速度较慢。</p>
<ol start="7">
<li><strong>说明程序与微程序，指令与微指令的异同</strong></li>
</ol>
<p>答：微程序是多条微指令系列的集合,用于实现指令的功能,属于机器指令级别，对用于的透明性不强，存放在CPU内的控制存储器中；程序则是为了完成某一应用功能所编写的指令（包括机器语言指令或高级语言指令）集合，属于高级语言级别，对用户的透明性好，运行时存放在计算机的主存中。</p>
<p>指令是指挥计算机执行某种功能的命令，是构成程序的基本单位，由操作码和地址字段构成；而微指令则用于微程序控制器中产生指令执行过程中所需要的微命令，是构成微程序的基本单位，由操作控制字段、判别测试字段和下地址字段等组成。</p>
<p>  **8)**<strong>微命令有哪几种编码方法?它们是如何实现的?</strong>  </p>
<p>答：微指令的微命令有三种编码方法，分别是直接表示方法、字段直接译码法和混合控制法。 </p>
<p><strong>直接表示法</strong>的基本思想是：将微指令操作控制字段的每个二进制位定义为一个微命令，用“1”或“0”表示相应的微命令的“有”或“无”。</p>
<p><strong>字段直接译码法</strong>的基本思想是：将微指令格式中的操作控制字段分成若干组，每组中包含若干个互斥性微命令，将相容性的微命令安排在不同组。</p>
<p><strong>混合控制法：</strong>将直接表示法与字段直接译码法混合使用，以便在微指令字长、并行性及执行速度和灵活性等方面进行折衷，发挥它们的共同优点。</p>
<p><strong>9)简述微程序控制器和硬布线控制器的设计方法?</strong></p>
<p> 答： <strong>微程序控制器设计方法：</strong></p>
<p>1)分析指令执行的数据通路，列出每条指令在所有寻址方式下的执行操作流程和每一步所需要的控制信号；</p>
<p>2)对指令的操作流程进行细化，将每条指令的每个微操作分配到具体的机器周期的各个时间节拍信号上；</p>
<p>(3)设计微指令格式、微命令编码方法和程序组织方式；</p>
<p>(4)编制每条指令的微程序；并按照所设计的微程序组织方式存放到控存中；</p>
<p>(5)对微命令进行同步控制，并送数据通路的相关控制点。</p>
<p><strong>硬布线控制器设计方法：</strong></p>
<p>1)分析指令执行的数据通路，列出每条指令在所有寻址方式下的执行操作流程和每一步所需要的控制信号；</p>
<p>2)对指令的操作流程进行细化，将每条指令的每个微操作分配到具体的机器周期的各个时间节拍信号上，即对操作控制信号进行同步控制。</p>
<p>3)对每一个控制信号进行逻辑综合，得到每个控制信号的逻辑表达式。</p>
<p>4)最后采用逻辑门或PLA或ROM实现逻辑表达式的功能，各控制信号送数据通路的相关控制点。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2019/12/23/Algorithm_%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/23/Algorithm_%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-23 15:15:08" itemprop="dateCreated datePublished" datetime="2019-12-23T15:15:08Z">2019-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="概叙"><a href="#概叙" class="headerlink" title="概叙"></a>概叙</h1><p>术语说明：</p>
<ul>
<li><strong>稳定</strong> ：如果a原本在b前面，而a&#x3D;b，排序之后a仍然在b的前面；</li>
<li><strong>不稳定</strong> ：如果a原本在b的前面，而a&#x3D;b，排序之后a可能会出现在b的后面；</li>
<li><strong>内排序</strong> ：所有排序操作都在内存中完成；</li>
<li><strong>外排序</strong> ：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>
</ul>
<p><img src="/images/%E6%8E%92%E5%BA%8F/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzMyMjA2MzctMTA1NTA4ODExOC5wbmc.jpg"></p>
<p>当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序。</p>
<p>  快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；</p>
<p><img src="/images/%E6%8E%92%E5%BA%8F/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzMwNDMxNjgtMTg2NzgxNzg2OS5wbmc.jpg"></p>
<h1 id="1-插入排序—直接插入排序-Straight-Insertion-Sort"><a href="#1-插入排序—直接插入排序-Straight-Insertion-Sort" class="headerlink" title="1.插入排序—直接插入排序(Straight Insertion Sort)"></a>1.插入排序—直接插入排序(Straight Insertion Sort)</h1><p>插入排序简单来说就是不断从后面将数据插入前面已经排好序的过程。</p>
<p>由此可知：前面的队列一定是排好序的。在插入的过程中可能会导致前面排好序的数据往后移，腾出位置。</p>
<p>动画演示：</p>
<img src="/images/%E6%8E%92%E5%BA%8F/849589-20171015225645277-1151100000.gif" style="zoom:25%;" />



<h1 id="2-归并排序（Merge-Sort）"><a href="#2-归并排序（Merge-Sort）" class="headerlink" title="2.归并排序（Merge Sort）"></a>2.归并排序（Merge Sort）</h1><p>简单来说，归并排序就是将一个无序的序列分解成诺干个有序的子序列，然后依次归并。</p>
<p>一般采取的是递归的方式进行设计。</p>
<p>递归的结束标志是：当分解的序列只有一个元素时。</p>
<p>递归层需要做的是：将子序列排序。</p>
<p>递归层返回的是：排好序的子序列</p>
<p>递归请见：</p>
<p>动画演示：</p>
<p><img src="/images/%E6%8E%92%E5%BA%8F/849589-20171015230557043-37375010.gif"></p>
<p>看不明白？再看一个。</p>
<p><img src="/images/%E6%8E%92%E5%BA%8F/aHR0cHM6Ly91cGxvYWQud2lraW1lZGlhLm9yZy93aWtpcGVkaWEvY29tbW9ucy9jL2NjL01lcmdlLXNvcnQtZXhhbXBsZS0zMDBweC5naWY.jpg"></p>
<h1 id="3、堆排序（Heap-Sort）"><a href="#3、堆排序（Heap-Sort）" class="headerlink" title="3、堆排序（Heap Sort）"></a>3、堆排序（Heap Sort）</h1><p> <strong>堆排序（Heapsort）</strong> 是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<ul>
<li>算法描述</li>
<li>步骤1：将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>步骤2：将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</li>
<li>步骤3：由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
<li>演示</li>
</ul>
<p><img src="/images/%E6%8E%92%E5%BA%8F/849589-20171015231308699-356134237.gif"></p>
<p> 算法分析</p>
<ul>
<li>最佳情况：T(n) &#x3D; O(nlogn)</li>
<li>最差情况：T(n) &#x3D; O(nlogn)</li>
<li>平均情况：T(n) &#x3D; O(nlogn)</li>
</ul>
<h1 id="4、快速排序（Quick-Sort）"><a href="#4、快速排序（Quick-Sort）" class="headerlink" title="4、快速排序（Quick Sort）"></a>4、快速排序（Quick Sort）</h1><p> <strong>快速排序</strong> 的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<ul>
<li><p>算法描述</p>
<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li>步骤1：从数列中挑出一个元素，称为 “基准”（<strong>pivot</strong> ）；</li>
<li>步骤2：重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>步骤3：递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
</li>
<li><p>示例</p>
</li>
</ul>
<p>概括来说为 挖坑填数+分治法</p>
<p>下面举例来进行说明，主要有三个参数，i为区间的开始地址，j为区间的结束地址，X为当前的开始的值</p>
<p>第一步，i&#x3D;0,j&#x3D;9,X&#x3D;72（X可以理解成此时a[0]是挖了一个洞，东西放在X哪里。这个洞可以填入其他数据）</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>72</strong></td>
<td align="center">6</td>
<td align="center">57</td>
<td align="center">88</td>
<td align="center">60</td>
<td align="center">42</td>
<td align="center">83</td>
<td align="center">73</td>
<td align="center">48</td>
<td align="center">85</td>
</tr>
</tbody></table>
<p>第二步，从j开始由后向前找，找到比X小的第一个数a[8]&#x3D;48,此时：a[0]&#x3D;a[8]；i++<br>进行替换。这样a[0]这个坑被填上了，但是a[7]这个坑多出来了。</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">48</td>
<td align="center">6</td>
<td align="center">57</td>
<td align="center">88</td>
<td align="center">60</td>
<td align="center">42</td>
<td align="center">83</td>
<td align="center">73</td>
<td align="center"><strong>72</strong></td>
<td align="center">85</td>
</tr>
</tbody></table>
<p>第三步，从i开始由前往后找，找到比X大的第一个数a[3]&#x3D;88,（此处找比X大的数是因为在后半截的数据均要比72才算实现目的）此时：a[8]&#x3D;a[3]；j–<br>a[8]的坑被填上了，但是a[3]的坑又出现了。</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">48</td>
<td align="center">6</td>
<td align="center">57</td>
<td align="center">88</td>
<td align="center">60</td>
<td align="center">42</td>
<td align="center">83</td>
<td align="center">73</td>
<td align="center"><strong>88</strong></td>
<td align="center">85</td>
</tr>
</tbody></table>
<p>此时：i&#x3D;3；j&#x3D;7；X&#x3D;72（因为经过上几轮的比较，我们可以得出前3个数均比72小，后3个数都比72大，不予考虑）</p>
<p>再重复上面的步骤，<strong>先从后向前找，再从前向后找</strong>。</p>
<p>第四步，从j&#x3D;7开始由后向前找，找到比X小的第一个数a[5]&#x3D;42，a[3] &#x3D; a[5]; i++;</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">48</td>
<td align="center">6</td>
<td align="center">57</td>
<td align="center">42</td>
<td align="center">60</td>
<td align="center">42</td>
<td align="center">83</td>
<td align="center">73</td>
<td align="center"><strong>88</strong></td>
<td align="center">85</td>
</tr>
</tbody></table>
<p>第五步，从i&#x3D;5开始由前往后找，i&#x3D;j&#x3D;5，所以退出，将X填入a[5]</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">48</td>
<td align="center">6</td>
<td align="center">57</td>
<td align="center">42</td>
<td align="center">60</td>
<td align="center">72</td>
<td align="center">83</td>
<td align="center">73</td>
<td align="center"><strong>88</strong></td>
<td align="center">85</td>
</tr>
</tbody></table>
<p>一轮结束。</p>
<p>接下来对两个子区间[0,4]和[6,9]重复上面的操作即可</p>
<p>总结：</p>
<blockquote>
<p>1．i &#x3D;L; j &#x3D; R; 将基准数挖出形成第一个坑a[i]。</p>
<p>2．j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</p>
<p>3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</p>
<p>4．再重复执行2，3二步，直到i&#x3D;&#x3D;j，将基准数填入a[i]中</p>
</blockquote>
<ul>
<li>动图演示</li>
</ul>
<p><img src="/images/%E6%8E%92%E5%BA%8F/849589-20171015230936371-1413523412.gif"></p>
<p>算法分析</p>
<ul>
<li>最佳情况：T(n) &#x3D; O(nlogn)</li>
<li>最差情况：T(n) &#x3D; O(n2)</li>
<li>平均情况：T(n) &#x3D; O(nlogn)</li>
</ul>
<h1 id="排序算法的下界"><a href="#排序算法的下界" class="headerlink" title="排序算法的下界"></a>排序算法的下界</h1><p>排序，涉及到被排序的序列和排序的方法。（比较）排序算法时间的下界对被排序的序列和排序方法做了以下限制</p>
<ul>
<li><p>没有关于被排序序列的先验信息，譬如序列内数据的分布、范围等，即认为序列内元素在一个开区间内均匀分布。同时，序列内元素互异。（可以从两个方面理解元素互异的限制，其一是对于随机的序列而言，两元素相同的概率约为0；其二是比较排序中没有对相同元素的特殊处理）</p>
</li>
<li><p>排序方法中仅仅利用了比较运算来确定元素的顺序。不失一般性，假设每次比较仅取2个元素，比较其大小。</p>
<p><strong>（比较）排序算法的算法时间复杂度等价为确定输入序列的排列方式需要多少次比较操作。</strong></p>
</li>
</ul>
<blockquote>
<p>选择，插入，归并，快速排序算法，在确定排序顺序时都仅仅依赖于对排序关键字对进行比较，它们确定决策时的依据均是”如果这个元素的排序关键字比另一个元素的排序关键字小，那么就进行相应操作，否则，进行其他操作或者什么也不做”，这些排序算法就是比较排序。</p>
</blockquote>
<h2 id="基于比较排序的下界"><a href="#基于比较排序的下界" class="headerlink" title="基于比较排序的下界"></a>基于比较排序的下界</h2><p>将比较排序定义为仅仅通过比较元素对来确定排序顺序，</p>
<p>Ω符号给出了下界，因此称“<strong>对于任意大的n，任何比较排序算法在最坏情况下至少需要cnlgn次比较操作（对于某个常量c成立)”由于每次比较至少需要花费常量时间，对于n个元素的基于比较的排序操作，能够得出一个时间为Ω(nlgn)的下界。</strong></p>
<p>关于此下界的说明：</p>
<p>1.它仅仅指最坏情况。在最坏情况下，该排序必定需要Ω（nlgn)次比较操作。</p>
<p>2.Ω(nlgn)这一下界不依赖于任何算法，只要该算法是一个比较排序。</p>
<h3 id="决策二叉树"><a href="#决策二叉树" class="headerlink" title="决策二叉树"></a>决策二叉树</h3><p>决策树：用于证明排序算法的下界，是一个二叉树，每个节点是元素之间一组可能的排序，比较的结果是树的边，下图表示将a，b，c排序的算法</p>
<p><img src="/images/%E6%8E%92%E5%BA%8F/1288560-20190506212758599-1563702061.png"></p>
<p><strong>定理：任何只用到比较的算法最坏情况下需要Ω（nlgn)次比较！！</strong></p>
<p>证明：假设高度为h，具有l个可达叶结点的决策树。输入n!种可能的排列都是叶结点，所以n!&lt;&#x3D;l。且l&lt;&#x3D;2^h^</p>
<p>两边取对数即可得证。</p>
<p><strong>推论：堆排序和归并排序都是渐近最优的比较排序算法</strong></p>
<p>以比较为基础的有序检索算法最坏情况下的时间下界：</p>
<p>定理 ：设A(1:n)含有n(n≥1)个不同的元素，且有A(1) &lt; A(2) &lt; …&lt; A(n)。</p>
<p>以<strong>以比较为基础的算法</strong>去判断给定的x是否有，则，最坏情况下，任何这样的算法所需的最小比较次数FIND(n)有：</p>
<p><img src="/images/%E6%8E%92%E5%BA%8F/image-20191228003422720.png"></p>
<p>1）任何一种以比较为基础的有序检索算法，在最坏情况下的计算时间都不低于Ο(logn)。因此，不可能存在最坏情况比二分检索数量级还低的算法。</p>
<p>2）二分检索是解决检索问题的最优的最坏情况算法</p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/MobiusStrip/article/details/83785159">https://blog.csdn.net/MobiusStrip/article/details/83785159</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2019/12/23/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/23/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">组成原理-指令系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-23 12:57:36" itemprop="dateCreated datePublished" datetime="2019-12-23T12:57:36Z">2019-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">组成原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/20190111184347604.png"></p>
<ul>
<li>指令要求计算机完成什么功能？ - - - -设置操作码</li>
<li>指令要求计算机处理什么数据？ - - - -设置数据源&#x2F;目</li>
<li>计算机怎样得到要处理的数据？ - - - -设置寻址方式</li>
</ul>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191223224549538.png"></p>
<h2 id="不同地址数量的指令"><a href="#不同地址数量的指令" class="headerlink" title="不同地址数量的指令"></a>不同地址数量的指令</h2><p>分为三地址指令、双地址指令、单地址指令、零地址指令</p>
<p>①三地址指令：一般地址域中A1、A2分别确定第一、第二操作数地址,A3确定结果地址。下一条指令的地址通常由程序计数器按顺序给出。</p>
<p>②二地址指令：地址域中A1确定第一操作数地址和结果地址，A2确定第二操作数地址。</p>
<p>③单地址指令：地址域中A 确定第一操作数地址。固定使用某个寄存器存放第二操作数和操作结果。因而在指令中隐含了它们的地址。</p>
<p>④零地址指令：在堆栈型计算机中，操作数一般存放在下推堆栈顶的两个单元中,结果又放入栈顶,地址均被隐含，因而大多数指令只有操作码而没有地址域。</p>
<table>
<thead>
<tr>
<th></th>
<th align="left"></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>三地址指令</td>
<td align="left">操作码op</td>
<td>address1</td>
<td>address2</td>
<td>address3</td>
<td>（address1） op （address2）-&gt; (address3)</td>
</tr>
<tr>
<td>双地址指令</td>
<td align="left">操作码op</td>
<td>address1</td>
<td>address2</td>
<td></td>
<td>（address1）op （address2）-&gt; （address1）or（address2）</td>
</tr>
<tr>
<td>单地址指令</td>
<td align="left">操作码op</td>
<td>address1</td>
<td></td>
<td></td>
<td>（address1）op -&gt;（address1） （address1）op（ACC）-&gt; （address1）</td>
</tr>
</tbody></table>
<p>零地址指令：</p>
<ol>
<li>机器指令无地址码</li>
<li>空操作、停机操作、中途返回</li>
</ol>
<h2 id="寻址方式及指令寻址"><a href="#寻址方式及指令寻址" class="headerlink" title="寻址方式及指令寻址"></a>寻址方式及指令寻址</h2><h3 id="顺序寻址"><a href="#顺序寻址" class="headerlink" title="顺序寻址"></a>顺序寻址</h3><p>CPU中设置有PC计数器。注意PC+1中的1是一条指令的长度，不是一个字节。</p>
<h3 id="跳跃寻址"><a href="#跳跃寻址" class="headerlink" title="跳跃寻址"></a>跳跃寻址</h3><p>就是JMP。</p>
<h2 id="操作数寻址方式"><a href="#操作数寻址方式" class="headerlink" title="操作数寻址方式"></a>操作数寻址方式</h2><h3 id="立即数寻址"><a href="#立即数寻址" class="headerlink" title="立即数寻址"></a>立即数寻址</h3><p>地址码字段就是操作数本身。</p>
<p>优点：因为将数据和指令一并送入CPU内部的寄存器中，执行指令速度快。便于程序设计。，不需要访问内存</p>
<p>缺点：数据大小受字段位数限制。</p>
<p>MOV AX .2000H</p>
<h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>操作数已经在CPU的内部寄存器中。</p>
<p>优点：执行速度快。不需要访问内存</p>
<p>缺点：能访问的数据大小一般与计算机字长有关。也受寄存器数量限制</p>
<p>MOV AX ,BX</p>
<h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p>地址码字段直接给出操作数在内存的地址。</p>
<p>特点：提供了访问主存的操作。</p>
<p>缺点：速度慢。地址字段的位数决定了访问空间大小</p>
<p>MOV AX ,[2000H]</p>
<h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p>地址码字段给出的是操作数地址的地址。第一次访问主存：获得操作数的地址。第二次访问主存：获得操作数。</p>
<p>明显用速度换访问空间。</p>
<p>MOV AX ,[SOMETHING]  &#x2F;&#x2F;something在内存中。</p>
<h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><p>地址码字段给出的是寄存器编号。也是两次访问：第一次访问寄存器：获得操作数地址。第二次访问主存：获得操作数。</p>
<p>例如：MOV AL , [BX]</p>
<h3 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h3><p>可用于跳转指令。</p>
<p>有效地址为程序计数器PC中的内容+指令中的形式地址。</p>
<p><strong>注意：因为在执行指令的时候，PC会变。这里取的PC的值是下一条将要执行指令的地址。</strong></p>
<h3 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h3><p>指定一个基址寄存器，与本指令地址无关。</p>
<p>例如：MOV AX ,32[B]</p>
<h3 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h3><p>MOV AX , 32[SI]</p>
<p>可以用在循环中。</p>
<p>和基址寻址的不同点是SI是可以修改的。基址B是不可修改的。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191223233913438.png"></p>
<h2 id="指令格式设计"><a href="#指令格式设计" class="headerlink" title="指令格式设计"></a>指令格式设计</h2><ul>
<li>根据指令数量的要求是否支持操作码扩展，确定操作码字段的位数</li>
<li>根据对操作数的要求确定地址码字段的个数</li>
<li>根据寻址方式的要求，为每个地址码字段确定寻址方式字段位数</li>
<li>确定采用定长指令还是变长指令</li>
</ul>
<p>例题：</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224000148075.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224000222378.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224000250587.png"></p>
<h2 id="MIPS指令概述"><a href="#MIPS指令概述" class="headerlink" title="MIPS指令概述"></a>MIPS指令概述</h2><p>只有三种指令格式</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224205156695.png"></p>
<ul>
<li><strong>R型指令</strong></li>
</ul>
<p>操作数只能来自寄存器，运算结果也只能存入寄存器。是RR型指令</p>
<p>如果表示移位运算，则表示对Rt的内容进行移位，所移位数有shamt确定。</p>
<ul>
<li><strong>I型指令</strong></li>
</ul>
<p>立即数指令。</p>
<ul>
<li><strong>J型指令</strong></li>
</ul>
<p>无条件转移指令。无条件转移的目标地址有PC高4位与26位直接地址左移后的值拼接而成。</p>
<p><strong>注意：不单设寻址方式说明字段。</strong></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224210041029.png"></p>
<p><strong>每一条指令都只有一种寻址方式。</strong></p>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p><strong>立即数寻址</strong></p>
<p><strong>目标寄存器在右边，源寄存器在左边</strong> 和汇编语言恰好相反？？？</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224210907954.png" alt="image-20191224210907954"></p>
<p><strong>寄存器直接寻址</strong></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224210954328.png"></p>
<p><strong>基址寻址</strong></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224211013152.png"></p>
<p><strong>相对寻址</strong></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224211058011.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224211112555.png"></p>
<h2 id="MIPS指令详解"><a href="#MIPS指令详解" class="headerlink" title="MIPS指令详解"></a>MIPS指令详解</h2><h3 id="R型指令"><a href="#R型指令" class="headerlink" title="R型指令"></a>R型指令</h3><p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224213904379.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224213916117.png"></p>
<p>三种不同类型</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224213952859.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224214001172.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224214009616.png"></p>
<h3 id="I型指令"><a href="#I型指令" class="headerlink" title="I型指令"></a>I型指令</h3><p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224214218941.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224214227288.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224214240566.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224214248828.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224214256109.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224214305157.png"></p>
<h3 id="J型指令"><a href="#J型指令" class="headerlink" title="J型指令"></a>J型指令</h3><p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20191224214317827.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2019/12/21/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/21/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/" class="post-title-link" itemprop="url">组成原理-运算方法和运算器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-20 21:55:10" itemprop="dateCreated datePublished" datetime="2019-12-20T21:55:10Z">2019-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">组成原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="运算方法和运算器"><a href="#运算方法和运算器" class="headerlink" title="运算方法和运算器"></a>运算方法和运算器</h1><p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/20190109141301451.png"></p>
<h2 id="定点数运算及溢出检测"><a href="#定点数运算及溢出检测" class="headerlink" title="定点数运算及溢出检测"></a>定点数运算及溢出检测</h2><p>在机器当中采用补码进行运算。</p>
<p><strong>补码加法</strong>：[X＋Y]<del>补</del>&#x3D; [X]<del>补</del>＋[Y]<del>补</del> （mod M）</p>
<p><strong>补码减法</strong>：[X−Y]<del>补</del> &#x3D; [X]<del>补</del>＋[−Y]<del>补</del> &#x3D; [X]<del>补</del>−[Y]<del>补</del></p>
<p>1、这就意味着对所有的数进行运算，都要将其变成补码的形式后再进行运算。<br>2、得到的答案也是补码，再进行补码转原码。</p>
<p>在硬件的角度考虑：要想使用加法器去实现减法操作，就需要求出[−Y]<del>补</del></p>
<p><strong>求补公式</strong>：[−Y]<del>补</del>&#x3D; [ [Y]<del>补</del> ]<del>补</del></p>
<h3 id="数溢出的概念及其判断方法"><a href="#数溢出的概念及其判断方法" class="headerlink" title="数溢出的概念及其判断方法"></a>数溢出的概念及其判断方法</h3><p>溢出：运算结果超出了某种数据类型的表示范围。</p>
<blockquote>
<p>溢出和进位的区别：</p>
<ol>
<li>溢出是错误，进位不是错误（进位是在运算范围内！溢出就是计算错误）</li>
<li>溢出是有符号数相加发生的错误: 如 两个正数相加&#x3D;负数，两个负数相加&#x3D;正数； 进位是无符号数运算结果超出范围。</li>
</ol>
<p>溢出是针对有符号数而言的。只有当正+正&#x3D;负或者负+负&#x3D;正的时候就表示溢出。如两个操作数符号相同而运算结果的符号与之相反时OV（溢出位）&#x3D;1，反之，OV&#x3D;0。</p>
<p>进位是<strong>针对无符号数而言的</strong>。它的进位就相当于有符号数中的溢出.</p>
<p>通俗一点说就是，即使有符号数相加&#x2F;相减导致了CF&#x3D;1也没什么意义，不能说明结果的正确与否。</p>
</blockquote>
<blockquote>
<p>1、CF的判断</p>
<p>①加法</p>
<p>十进制角度，如果两无符号数相加，结果大于2^n^-1（n为位数），则CF&#x3D;1，否则CF&#x3D;0；</p>
<p>二进制角度，如果两无符号数相加，最高位向前有进位，则CF&#x3D;1，否则CF&#x3D;0。</p>
<p>②减法</p>
<p>十进制角度，如果两无符号数相减，减数大于被减数（也即结果不在0—2^n^-1内），则CF&#x3D;1，否则CF&#x3D;0；</p>
<p>二进制角度，如果两无符号数相减，最高位向前游借位，则CF&#x3D;1，否则CF&#x3D;0。</p>
<p>2、OF的判断</p>
<p>①加法</p>
<p>十进制角度，如果两有符号数相加，结果不在-2^(n-1)~2^(n-1)-1内，则OF&#x3D;1，否则OF&#x3D;0；</p>
<p>二进制角度，如果两有符号数同号，而相加结果与之异号，则OF&#x3D;1，否则OF&#x3D;0。</p>
<p>②减法</p>
<p>十进制角度，如果有符号数相减结果在-2^(n-1)~2^(n-1)-1内，则OF&#x3D;1，否则OF&#x3D;0；</p>
<p>二进制角度，如果两个数异号，而相减结果与被减数符号相反，则OF&#x3D;1，否则OF&#x3D;0。</p>
</blockquote>
<p><strong>溢出的检测：</strong></p>
<p>1、对操作数和运算结果的符号进行检测：正+正的运算结果的符号位一定是正</p>
<p>2、对最高数据位进位和符号位进位进行检测：<br>正+正的符号位不进位，但是当最高位数据位进位的时候就会顶到符号位上。<br>负+负的符号位进位，当最高位数据位进位恰好把符号位修改回来。但是最高位数据位不进位就会导致符号位错误。<br><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221121410704.png"></p>
<p><strong>双符号位的溢出检测</strong>：</p>
<p>3、变形补码（也叫模4补码）：把两个数的符号位放在一起，即每个参与运算的数据都有两个符号位（00表示正数、11表示负数）</p>
<p> 一个符号位只能表示正、负两种情况，当产生溢出时，符号位的含义就会发生混乱。如果将符号位扩充为两位，其所能表示的信息量将随之扩大，既能检测是否溢出，又能指出结果的符号。在双符号位的情况下，把左边的符号位叫做<code>真符</code>因为它代表了该数真正的符号，两个符号位都作为数的一部分参加运算。这种编码又称为<code>变形补码</code>。<br>    双符号位的含义如下：</p>
<ul>
<li>S1S2&#x3D;00        结果为正数，无溢出</li>
<li>S1S2&#x3D;01        结果正溢</li>
<li>S1S2&#x3D;10        结果负溢</li>
<li>S1S2&#x3D;11        结果为负数，无溢出</li>
</ul>
<p>​	</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221122148907.png"></p>
<p><strong>无符号数运算的溢出判断</strong>（其实是没有溢出的问题，就是借位的问题）</p>
<p>1、无符号数加法的溢出可用ALU的进位表示</p>
<p>2、无符号数减法的溢出可用带加&#x2F;减功能的ALU的进位取反后表示(意思是向最高位的上一位借位)</p>
<h2 id="定点数补码加、减运算器设计"><a href="#定点数补码加、减运算器设计" class="headerlink" title="定点数补码加、减运算器设计"></a>定点数补码加、减运算器设计</h2><h3 id="补码串行加法器"><a href="#补码串行加法器" class="headerlink" title="补码串行加法器"></a>补码串行加法器</h3><p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221134249817.png"></p>
<p>有符号溢出检测方是中第一种：正+正&#x3D;负</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221134948402.png"></p>
<p>有符号溢出检测方法是第二种：符号位进位和最高位进位异或</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221134822849.png"></p>
<p>有符号溢出检测是第三种：双符号位</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221135104643.png"></p>
<p>无符号溢出检测：无符号溢出就是数据放不下，故这里需要考虑的是最高位的进位</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221135355913.png"></p>
<p>思考：有符号和无符号加法器有什么区别？</p>
<p>A：无符号加减法不存在溢出问题，只是将进位或借位存储在CF中。<br>机器不知道你进行的运算是否有符号，如果你进行的是有符号运算，你需要查看OF，否则不需要。<br>所以，溢出不溢出，是由程序员判断的，机器不知道。<br>但是无符号的“溢出”和有符号的不一样。</p>
<p><strong>串行进位的效率</strong></p>
<p>要等前一个数的进位。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221140105534.png"></p>
<p><strong>串行加法器的时间延迟</strong></p>
<p>n个全加器延迟，考虑片内并行性，2n+1个门电路延迟。（一个全加器是3个门电路延迟）</p>
<h3 id="并行进位加法器"><a href="#并行进位加法器" class="headerlink" title="并行进位加法器"></a>并行进位加法器</h3><p>把串行进位的进位位带入，就可以消除串行进位的进位位要等待的时间。加快运算</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221140129707.png"></p>
<p>然后将带入的算式添加到并行进位运算器中：</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221143544617.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221140923147.png"></p>
<p>将多个并行加法器连接在一起，构建多位串行进位的并行进位加法器</p>
<p>将多位数的数据拆分，并行进行加法：A<del>15-12</del>等</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221141245531.png"></p>
<p>但是，这样存在一个问题：依旧需要串行等待。仿照上述方法，将进位打破</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221141224288.png"></p>
<p>进行到这一步。只需要将P1到P3和G1到G3的值计算得到，就可以完全进行并行进位。</p>
<p>于是，得到的电路图为：</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221141546885.png"></p>
<p><strong>电路延迟示例</strong></p>
<p>16位先行进位系统（8级门电路延迟）</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191228102202657.png"></p>
<p>64位先行进位系统（12级门电路延迟）</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191228102314643.png" alt="image-20191228102314643"></p>
<h2 id="原码一位乘法"><a href="#原码一位乘法" class="headerlink" title="原码一位乘法"></a>原码一位乘法</h2><h3 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h3><p><strong>只针对补码而言</strong></p>
<p>**算术左移和逻辑左移的效果是一样的,效果都是*2<br>逻辑右移最高位补0,算术右移最高位补符号位.**算术右移的效果是&#x2F;2</p>
<blockquote>
<p>逻辑左移&#x3D;算数左移，右边统一添0 </p>
<p>逻辑右移，左边统一添0 </p>
<p>算数右移，左边添加的数和符号有关</p>
</blockquote>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221145714185.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221145324851.png"></p>
<p>从手工计算的二进制乘法，可以得到最右边一位是可以直接输出的，故可以每次左移一位，输出的最右边的一位放置在乘法数上（因为0.101在1进行乘法运算后就没用了，可以移动为00.10，于是最左边的0可以用来放置FA循环累加的部分积—最右边的数0）</p>
<h2 id="补码一位乘法"><a href="#补码一位乘法" class="headerlink" title="补码一位乘法"></a>补码一位乘法</h2><h3 id="补码和真值的转换公式"><a href="#补码和真值的转换公式" class="headerlink" title="补码和真值的转换公式"></a>补码和真值的转换公式</h3><p>$$<br>设[X]<em>补&#x3D;X_0.X_1X_2……X_n\<br>当X&gt;&#x3D;0,X_0&#x3D;0,[X]<em>补&#x3D;0.X_1X_2……X_n&#x3D;\sum</em>{i&#x3D;1}^{n}X_i<em>2^{-i}&#x3D;X\<br>当X&lt;0,X_0&#x3D;1,[X]<em>补&#x3D;1.X_1X_2……X_n&#x3D;2+X\<br>所以：\<br>X&#x3D;1.X_1X_2……X_n-2&#x3D;-1+0.X_1X_2……X_n&#x3D;-1+\sum</em>{i&#x3D;1}^{n}X_i</em>2^{-i}\<br>X&#x3D;-X_0+\sum</em>{i&#x3D;1}^{n}X_i*2^{-i}<br>$$</p>
<h3 id="补码的右移"><a href="#补码的右移" class="headerlink" title="补码的右移"></a>补码的右移</h3><p>在补码运算的机器中，一个数不论其正负，连同符号位向右移一位，符号位保持不变，就等于乘1&#x2F;2.<br>$$<br>X&#x3D;-X_0+\sum_{i&#x3D;1}^{n}X_i<em>2^{-i}\<br>1&#x2F;2X&#x3D;-1&#x2F;2X_0+1&#x2F;2\sum_{i&#x3D;1}^{n}X_i</em>2^{-i}\<br>&#x3D;-X_0+1&#x2F;2\sum_{i&#x3D;0}^{n}X_i*2^{-(i+1)}\<br>补码形式：[1&#x2F;2X]_补&#x3D;X_0.X_0X_1X_2……X_n<br>$$</p>
<h3 id="补码乘法规则"><a href="#补码乘法规则" class="headerlink" title="补码乘法规则"></a>补码乘法规则</h3><p>$[X<em>Y]_补 ≠ [X]_补</em>[Y]_补$</p>
<p>$[X<em>Y]_补 &#x3D; [X]_补</em>Y$</p>
<p>原码乘法的主要问题是符号位不能参加运算，单独用一个异或门产生乘积的符号位。故自然提出能否让符号数字化后也参加乘法运算，补码乘法就可以实现符号位直接参加运算。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221150430061.png"></p>
<h2 id="乘法运算器设计"><a href="#乘法运算器设计" class="headerlink" title="乘法运算器设计"></a>乘法运算器设计</h2><h3 id="原码一位乘法器设计"><a href="#原码一位乘法器设计" class="headerlink" title="原码一位乘法器设计"></a>原码一位乘法器设计</h3><ul>
<li>作完加法，一定移位</li>
<li>n次加法</li>
<li>符号位单独计算</li>
</ul>
<p><strong>核心运算</strong></p>
<p>累加 ∑ <strong>&#x3D;</strong> ∑ <strong>+ 0</strong>  ∑ <strong>&#x3D;</strong> ∑ <strong>+ X</strong></p>
<p>逻辑右移 ∑ <strong>&#x3D;</strong> ∑ &#x2F; 2</p>
<p><strong>分支合并</strong></p>
<p>累加 ∑ <strong>&#x3D;</strong> ∑+YnX 节约多路选择器</p>
<p><strong>减少寄存器访问</strong></p>
<p> ∑ &#x3D; (∑ +YnX)&#x2F;2</p>
<p>先移位再锁存，提升速度</p>
<p><strong>运算计数控制</strong></p>
<p>简单状态机控制，计数器比较</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221151751785.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221152243602.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191228104847178.png"></p>
<h3 id="补码一位乘法设计"><a href="#补码一位乘法设计" class="headerlink" title="补码一位乘法设计"></a>补码一位乘法设计</h3><ul>
<li>n+1次加法</li>
<li>符号位参与运算</li>
<li>不需要单独计算符号位</li>
</ul>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221152356635.png"></p>
<p>例子:</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221152759847.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191228104909857.png"></p>
<h3 id="阵列乘法器设计"><a href="#阵列乘法器设计" class="headerlink" title="阵列乘法器设计"></a>阵列乘法器设计</h3><p>阵列乘法器的设计目的是为了避免原码一位乘法器中不断循环累加造成的时间浪费</p>
<p>阵列包括了：与门阵列和FA阵列</p>
<p><strong>横向进位阵列乘法器时延分析：</strong></p>
<p>每一行加法器都存在串行进位的关系<br>6必须等到5计算后才能接着计算（6接收的是5的运算值，把它当作x、y）</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221162247407.png"></p>
<p><strong>斜向进位阵列乘法器时延分析</strong></p>
<p>将进位送入下一级后，同级的FA之间就不存在串行关系。原因在于：1的进位值对P2产生影响，故1的进位值送入左边还是下一级的2都不会对结果产生影响。</p>
<p>最后一行是串行FA。因为没有下一级送进位了，故只能串行送。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221162546278.png"></p>
<h2 id="定点数除法"><a href="#定点数除法" class="headerlink" title="定点数除法"></a>定点数除法</h2><h3 id="恢复余数除法（绝对值）"><a href="#恢复余数除法（绝对值）" class="headerlink" title="恢复余数除法（绝对值）"></a>恢复余数除法（绝对值）</h3><p>当余数为正数：够减，商上1，余数左移一位，再与除数做减法比较</p>
<p>当余数为负数：不够减，商上0<br>1、<strong>加除数恢复成原来的值，将余数左移一位，再与除数做减法比较</strong></p>
<p>重复直至商满足要求。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221165806432.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221165757356.png"></p>
<p>因为要恢复余数，所以运算步数是不确定的。</p>
<p>上商是根据余数是否&gt;0</p>
<h3 id="加-x2F-减交替除法（不恢复余数法）"><a href="#加-x2F-减交替除法（不恢复余数法）" class="headerlink" title="加&#x2F;减交替除法（不恢复余数法）"></a>加&#x2F;减交替除法（不恢复余数法）</h3><p><strong>当余数小于0的时候，不需要恢复余数，余数左移+y</strong>。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221170156432.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20191221170959244.png"></p>
<p>上商是根据左移出的哪位来上的。</p>
<h2 id="浮点数加减运算"><a href="#浮点数加减运算" class="headerlink" title="浮点数加减运算"></a>浮点数加减运算</h2><p>浮点数规格化：把一个浮点数转化成指定的格式。</p>
<p>尾数规格化：00.1xxxxx或者11.0xxxxx</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1、对阶<br>将两个数的阶码转化成一样大小。这样有一个数的尾数将会发生改变</p>
<p>2、尾数的运算<br>将对阶后的尾数进行加减运算</p>
<p>3、尾数规格化处理<br>对加减运算后的尾数进行规格化处理，同时阶码也改变了</p>
<p>4、舍入<br>0舍1入。如果没有丢掉有效数字，就不需要舍入。</p>
<p>5、浮点数的溢出处理<br>因为是双符号数，溢出规则同双符号数的溢出规则。</p>
<blockquote>
<p>上溢：超出所能表示的最大正数<br>下溢：超出所能表示的最小负数</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2019/12/20/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/20/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%AE%A1%E7%AE%97/" class="post-title-link" itemprop="url">组成原理-数据的表示和计算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-19 22:32:08" itemprop="dateCreated datePublished" datetime="2019-12-19T22:32:08Z">2019-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">组成原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机数据表示"><a href="#计算机数据表示" class="headerlink" title="计算机数据表示"></a>计算机数据表示</h1><p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/20190109093513934.png"></p>
<h2 id="数制和编码"><a href="#数制和编码" class="headerlink" title="数制和编码"></a>数制和编码</h2><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><h3 id="真值和机器数"><a href="#真值和机器数" class="headerlink" title="真值和机器数"></a>真值和机器数</h3><p>机器数是将符号”数字化”的数，是数字在计算机中的二进制表示形式。因为有符号占据一位，数的形式值就不等于真正的数值，带符号位的机器数对应的数值称为机器数的真值。 例如二进制真值数-011011，它的机器数为 1011011。</p>
<h3 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h3><p>BCD码(Binary-Coded Decimal)，亦称为二进码十进制数或二-十进制代码。<strong>用4位二进制数来表示1位十进制数中的0～9这10个数字</strong>，是一种二进制的数字编码形式，用二进制编码的十进制代码。BCD码这种编码形式利用了四个位元来储存一个十进制的数码，使二进制和十进制之间的转换得以快捷的进行。</p>
<ul>
<li>有权码：8421码，2421码，5421码</li>
<li>无权码：余3码，余3循环码，格雷码</li>
</ul>
<blockquote>
<p>为什么使用BCD码：这种编码技巧最常用于会计系统的设计里，因为会计制度经常需要对很长的数字串作准确的计算。相对于一般的浮点式记数法，采用BCD码，<code>既可保存数值的精确度，又可免去使计算机作浮点运算时所耗费的时间</code>。此外，对于其他需要<code>高精确度</code>的计算，BCD编码亦很常用。</p>
</blockquote>
<h4 id="8421码"><a href="#8421码" class="headerlink" title="8421码"></a>8421码</h4><p>8421 BCD码是最基本和最常用的BCD码，它和四位自然二进制码相似，各位的权值为8、4、2、1，故称为有权BCD码。和四位自然二进制码不同的是，它只选用了四位二进制码中前10组代码，即<strong>用0000~1001分别代表它所对应的十进制数，余下的六组代码不用</strong>。如十进制数8的BCD码是1000。</p>
<h4 id="5421码"><a href="#5421码" class="headerlink" title="5421码"></a>5421码</h4><p>  5421 BCD码是有权BCD码，从高位到低位的权值分别为5、4、2、1。</p>
<p>​	数码6可以用0110和1100表示</p>
<h4 id="2421码"><a href="#2421码" class="headerlink" title="2421码"></a>2421码</h4><p>  2421 BCD码为有权BCD码，从高位到低位的权值分别为2、4、2、1。</p>
<h4 id="余3码"><a href="#余3码" class="headerlink" title="余3码"></a>余3码</h4><p>无权码，是对9的补码</p>
<p>  余3码是8421 BCD码的每个码组加3(0011)形成的。常用于BCD码的运算电路中。</p>
<h3 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h3><h4 id="字符编码ASCII码"><a href="#字符编码ASCII码" class="headerlink" title="字符编码ASCII码"></a>字符编码ASCII码</h4><p>可以表示数字、大小写字母和一定数量的专用符号（#等）</p>
<h4 id="汉字的编码"><a href="#汉字的编码" class="headerlink" title="汉字的编码"></a>汉字的编码</h4><h2 id="机器数及其特点"><a href="#机器数及其特点" class="headerlink" title="机器数及其特点"></a>机器数及其特点</h2><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p>
<blockquote>
<p>[+1]原 &#x3D; 0000 0001</p>
<p>[-1]原 &#x3D; 1000 0001</p>
</blockquote>
<h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>反码的表示方法是:</p>
<p>正数的反码是其本身</p>
<p>负数的反码是在其原码的基础上, <strong>符号位不变</strong>，其余各个位取反.</p>
<blockquote>
<p>[+1] &#x3D; [00000001]原 &#x3D; [00000001]反</p>
<p>[-1] &#x3D; [10000001]原 &#x3D; [11111110]反</p>
</blockquote>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>补码的表示方法是:</p>
<p>正数的补码就是其本身</p>
<p>负数的补码是在其原码的基础上, <strong>符号位不变</strong>, 其余各位取反, 最后+1. (即在反码的基础上+1)</p>
<p><strong>补码的模是最高位所在的权重。</strong>例如32位字长的数据的补码的模就是2的32次方。</p>
<p>换言之：负数的补码&#x3D;模+负数。</p>
<blockquote>
<p>[+1] &#x3D; [00000001]原 &#x3D; [00000001]反 &#x3D; [00000001]补</p>
<p>[-1] &#x3D; [10000001]原 &#x3D; [11111110]反 &#x3D; [11111111]补</p>
</blockquote>
<h3 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h3><p>移码通常用于表示浮点数的阶码。移码只用于表示整数。</p>
<p>移码的表示方法是：</p>
<p><strong>数值位与补码相同，符号位与补码相反</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>整数类型</th>
<th>原码</th>
<th>反码</th>
<th>补码</th>
<th>移码</th>
</tr>
</thead>
<tbody><tr>
<td>正整数</td>
<td>0+本身</td>
<td>0+本身</td>
<td>0+本身</td>
<td>补码符号位取反</td>
</tr>
<tr>
<td>负整数</td>
<td>1+本身</td>
<td>1+各位取反</td>
<td>反码加1</td>
<td>补码符号位取反</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>小数类型</th>
<th>原码</th>
<th>反码</th>
<th>补码</th>
</tr>
</thead>
<tbody><tr>
<td>正小数</td>
<td>0+小数位</td>
<td>0+小数位</td>
<td>0+小数位</td>
</tr>
<tr>
<td>负小数</td>
<td>1+小数位</td>
<td>1+小数位取反</td>
<td>反码加1</td>
</tr>
</tbody></table>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20191220204556649.png"></p>
<p>当0的反码有两种：00000或者11111。但是0的补码就只有一种00000（11111+1&#x3D;00000）。</p>
<h2 id="定点与浮点数据表示"><a href="#定点与浮点数据表示" class="headerlink" title="定点与浮点数据表示"></a>定点与浮点数据表示</h2><h3 id="定点"><a href="#定点" class="headerlink" title="定点"></a>定点</h3><p>表示定点小数和整数。要求是小数点的位置是固定的，这样就可以不用在字长中表示小数点的位置，就可以利用字长表示更多的有效数字位。</p>
<p>缺点是：定点数的数据的表示范围有限。</p>
<p>以原码为例：</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/1512908-20190330192643947-1659098809.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/1512908-20190330192648588-1501715330.png"></p>
<p>以补码为例：原码的定点小数最小负数为1.1111111其补码表示为1.000000（-1)</p>
<p>​							 原码的定点整数最小负数为11111111其补码表示为1000000（-2的n次方）</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20191220215530807.png"></p>
<h3 id="定点数的运算"><a href="#定点数的运算" class="headerlink" title="定点数的运算"></a>定点数的运算</h3><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>浮点数表示为：<strong>N &#x3D; r^E^ × M</strong></p>
<p> 式子里面r是浮点数阶码的底在计算机中是隐含的，通常情况下r&#x3D;2。E和M都是带符号的定点数，E叫做阶码，M叫做尾数。其中<strong>E的大小越大，能表示的数范围越大，M的位数越大，数的有效精度越高</strong>。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20191220215700853.png"></p>
<p>M&lt;1；且同时给出了阶符和尾符。尾数值是小于1的。</p>
<h4 id="IEEE754标准"><a href="#IEEE754标准" class="headerlink" title="IEEE754标准"></a>IEEE754标准</h4><p>在IEEE754标准中，此时<strong>移码与补码只差符号位的定理不符合</strong></p>
<p>移码是在原码的基础上加的，原码的范围是-127到+127（有+0与-0）<br>阶码的范围是1到254，就是说阶码没有0与255的说法（无全0与全1）<br>IEEE754规定，全1是无穷大，而全1减127就是10000000也就是负0，原码的负0加127后表示的阶码是无穷大<br>IEEE754规定，全0是非规范数，那么全0是怎么加出来的呢，就是原码的10000001<br>-127·-1~-0·+0·+127<br>（-1变全0非规范数）·（-2变1）·（-127变126）·（+0变127）·（+127变254）·（-0变255无穷大）</p>
<p><strong>注意只有一个符号位</strong></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20191220215757126.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20191220215826834.png"></p>
<p>浮点数省略了基数和阶码的符号位；注意：尾码的符号位由符号位S表示。</p>
<p>需要注意的是，规格化后的尾数是省略了1.的（M表示的就是1.M）</p>
<h2 id="数据校验的基本原理"><a href="#数据校验的基本原理" class="headerlink" title="数据校验的基本原理"></a>数据校验的基本原理</h2><p>增加冗余码（校验位）</p>
<p>码距：同一个编码中，任意两个合法编码之间不同二进制位数的最小值。<br>例如：0011与0001的码距是1，一位错误时无法识别（都在编码中，无法识别是否错误）</p>
<p>校验码中增加冗余项是为了增大码距。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/1582915-20190217194922300-14479341.png"></p>
<p><img src="https://img2018.cnblogs.com/blog/1582915/201902/1582915-20190217195012063-855997305.png" alt="img"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/1582915-20190217195300452-1560693948-1576825050111.png"></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/1582915-20190217195457992-1898842470.png"></p>
<h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>奇校验：编码规则是整个校验码（包含有效信息和校验位）中的1的个数为奇数个。</p>
<p>同理：偶校验。</p>
<p>实现：校验位只有1位。编码效率高。</p>
<p>错误部分可检测出来。无纠错能力。其码距为2.</p>
<h4 id="改进奇偶校验"><a href="#改进奇偶校验" class="headerlink" title="改进奇偶校验"></a>改进奇偶校验</h4><p><strong>1、双向奇偶校验</strong><br>目标情况：<br><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/20190811221250704.png" alt="改进的奇偶校验——目标情况"><br>检错分析：<br><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/20190811221548469.png" alt="改进的奇偶校验——检错分析"><br>（1）可纠正 1 位错误<br>（2）可检测出某行（列）上的奇数个错误<br>（3）可检出部分偶数个错误的情况<br>（4）不能检测出错码分布在矩形 4 个顶点上的错误</p>
<p><strong>一般在同步传输方式中常采用奇校验，异步传输方式中常采用偶校验</strong></p>
<h3 id="CRC校验"><a href="#CRC校验" class="headerlink" title="CRC校验"></a>CRC校验</h3><p>接受方提前获得生成多项式，对CRR校验后的数据进行<strong>模2除运算</strong>。如果余数不是0，就意味着出现了编码错误。</p>
<p>根据余数，还可以判断具体错误的位置。</p>
<p><strong>设CRC码 N 位，其中数据位 k 位，校验位 r 位（冗余位）</strong></p>
<p>​    <strong>N &#x3D; k + r ≤ 2^r^ − 1   （2r个余数，0表示正确，N位中的每一位出错余数皆不同）</strong></p>
<h4 id="生成多项式"><a href="#生成多项式" class="headerlink" title="生成多项式"></a>生成多项式</h4><p><strong>生成多项式特征</strong></p>
<ul>
<li>任意位发生错误都应使余数不为0</li>
<li>不同位发生错误余数不同</li>
<li>余数左移一位继续作模2除，应使余数循环，<strong>循环周期</strong> N&#x3D;k+r ？</li>
</ul>
<h4 id="CRC校验原理"><a href="#CRC校验原理" class="headerlink" title="CRC校验原理"></a>CRC校验原理</h4><p>其实很简单的问题，其根本思想就是先在要发送的帧后面附加一个数（这个就是用来校验的校验码，但要注意，这里的数也是二进制序列的，下同），生成一个新帧发送给接收端。当然，这个附加的数不是随意的，它要使所生成的新帧能与发送端和接收端共同选定的某个特定数整除（注意，这里不是直接采用二进制除法，而是采用一种称之为“模2除法”）。到达接收端后，再把接收到的新帧除以（同样采用“模2除法”）这个选定的除数。因为在发送端发送数据帧之前就已通过附加一个数，做了“<strong>去余”处理</strong>（也就已经能整除了），所以结果应该是没有余数。如果有余数，则表明该帧在传输过程中出现了差错。</p>
<blockquote>
<p>“模2除法”与“算术除法”类似，但它既不向上位借位，也不比较除数和被除数的相同位数值的大小，只要以相同位数进行相除即可。模2加法运算为：1+1&#x3D;0，0+1&#x3D;1，0+0&#x3D;0，无进位，也无借位；模2减法运算为：1-1&#x3D;0，0-1&#x3D;1，1-0&#x3D;1，0-0&#x3D;0，也无进位，无借位。相当于二进制中的<strong>逻辑异或运算</strong>。也就是比较后，两者对应位相同则结果为“0”，不同则结果为“1”。如100101除以1110，结果得到商为11，余数为1，如图5-9左图所示。如11×11&#x3D;101，如图5-9右图所示。</p>
<p> <img src="/images/组成原理-数据的表示和计算/350840-20181115093017301-618187360.png" style="zoom:67%;" /><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%AE%A1%E7%AE%97/350840-20181115092958804-1621118286.png"></p>
</blockquote>
<p><strong>CRC校验码计算示例：</strong><br>现假设选择的CRC生成多项式为G（X） &#x3D; X<del>4</del> + X<del>3</del> + 1，要求出二进制序列10110011的CRC校验码。下面是具体的计算过程：<br>①将多项式转化为二进制序列，由G（X） &#x3D; X<del>4</del> + X<del>3</del> + 1可知二进制一种有五位，第4位、第三位和第零位分别为1，则序列为11001<br>②多项式的位数位5，则在数据帧的后面加上5-1位0，数据帧变为101100110000，然后使用模2除法除以除数11001，得到余数。</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/20170622115737528.png"></p>
<p>③将计算出来的CRC校验码添加在原始帧的后面，真正的数据帧为101100110100，再把这个数据帧发送到接收端。<br>④接收端收到数据帧后，用上面选定的除数，用模2除法除去，验证余数是否为0，如果为0，则说明数据帧没有出错。</p>
<h4 id="CRC的纠错"><a href="#CRC的纠错" class="headerlink" title="CRC的纠错"></a>CRC的纠错</h4><p>在接收端收到了CRC码后用生成多项式为G(x)去做模2除，若得到余数为0,则码字无误。若如果有一位出错，则余数不为0，而且不同位出错，其余数也不同。可以证明，余数与出错位的对应关系只与码制及生成多项式有关，而与待测字（信息位）无关。【<strong>CRC码被G(x)整除，所得的余数与出错位之间有唯一的对应关系。根据这一关系便可立即确定出错位的位置。</strong>】</p>
<p>循环校验</p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20191220152432673.png"></p>
<h3 id="海明校验"><a href="#海明校验" class="headerlink" title="海明校验"></a>海明校验</h3><p>  海明码的检错、纠错基本思想是<strong>将有效信息按某种规律分成若干组，每组安排一个校验位进行奇偶性测试，然后产生多位检测信息，并从中得出具体的出错位置，最后通过对错误位取反（也是原来是1就变成0，原来是0就变成1）来将其纠正。</strong></p>
<blockquote>
<p>海明码的编码规则如下：</p>
<p>  设有k个校验位P<del>k</del>,P<del>k-1</del>,…,P<del>1</del>,n个数据位为D<del>n-1</del>,D<del>n-2</del>,…,D<del>1</del>,D<del>0</del>,对应的海明码为H<del>n+k</del>,H<del>n+k-1</del>,…,H<del>1</del>,H<del>0</del>,那么：</p>
<p> （1）P<del>1</del>在海明码的位置，即H<del>j</del>&#x3D;P<del>i</del>,且,数据位则依程序从低到高占据海明码中剩下的位置。</p>
<p> （2）海明码中任意一位都是由若干个校验码来检验的，其对应关系如下：被校验的海明位的下标等于所有参与校验该位的检验位的下标之和，而校验位由自身校验。</p>
</blockquote>
<p><strong>步骤：</strong></p>
<p><strong>1、计算检验位的位数</strong></p>
<p>假设用N表示添加了校验码位后整个信息的二进制位数，用K代表其中有效信息位数，r表示添加的校验码位，它们之间的关系应满足：N&#x3D;K＋r≤2^r^－1。（一位纠错功能）</p>
<p><strong>原理是分成r组进程奇偶校验就会产生r位检错信息，可指出2^r^种状态。其中一种状态是无错，其余状态就可以指出哪位出错</strong></p>
<blockquote>
<p>  如K&#x3D;5，则要求2^r^-r≥5+1&#x3D;6，根据计算可以得知r的最小值为4，也就是要校验5位信息码，则要插入4位校验码。如果信息码是8位，则要求2^r^-r≥8+1&#x3D;9，根据计算可以得知r的最小值也为4。</p>
</blockquote>
<p><strong>2、确定校验码位置</strong></p>
<p>校验码<strong>必须</strong>是在2^n^次方位置，如第1、2、4、8、16、32，……位（对应2^0^、2^1^、2^2^、2^3^、2^4^、2^5^，……，是从最左边的位数起的），这样一来就知道了信息码的分布位置，也就是非2^n^次方位置，如第3、5、6、7、9、10、11、12、13，……位（是从最左边的位数起的）。<strong>这种分组关系是因为任何数都可以分成2的幂次方相加的形式</strong></p>
<blockquote>
<p>假设现有一个8位信息码，即b<del>1</del>、b<del>2</del>、b<del>3</del>、b<del>4</del>、b<del>5</del>、b<del>6</del>、b<del>7</del>、b<del>8</del>，它需要插入4位校验码，即p<del>1</del>、p<del>2</del>、p<del>3</del>、p<del>4</del>，也就是整个经过编码后的数据码（称之为“码字”）共有12位。根据以上介绍的校验码位置分布规则可以得出，这12位编码后的数据就是p<del>1</del>、p<del>2</del>、b<del>1</del>、p<del>3</del>、b<del>2</del>、b<del>3</del>、b<del>4</del>、p<del>4</del>、b<del>5</del>、b<del>6</del>、b<del>7</del>、b<del>8</del>。</p>
</blockquote>
<p><strong>3、确定校验码</strong></p>
<p>每个校验位的值代表了代码字中部分数据位的奇偶性（最终要根据是采用奇校验，还是偶校验来确定），其所在位置决定了要校验的比特位序列。总的原则是：<strong>第i位校验码从当前位开始，每次连续校验i（这里是数值i，不是第i位，下同）位后再跳过i位，然后再连续校验i位，再跳过i位，以此类推。最后根据所采用的是奇校验，还是偶校验即可得出第i位校验码的值。</strong></p>
<p> 校验码的具体计算方法如下：</p>
<blockquote>
<p>p1（第1个校验位，也是整个码字的第1位）的校验规则是：从当前位数起，<strong>校验1位</strong>，然后跳过1位，再校验1位，再跳过1位，……。这样就可得出p1校验码位可以校验的码字位包括：第1位（也就是p1本身）、第3位、第5位、第7位、第9位、第11位、第13位、第15位，……。然后根据所采用的是奇校验，还是偶校验，最终可以确定该校验位的值。</p>
<p>p2（第2个校验位，也是整个码字的第2位）的校验规则是：从当前位数起，<strong>连续校验2位</strong>，然后跳过2位，再连续校验2位，再跳过2位，……。这样就可得出p2校验码位可以校验的码字位包括：第2位（也就是p2本身）、第3位，第6位、第7位，第10位、第11位，第14位、第15位，……。同样根据所采用的是奇校验，还是偶校验，最终可以确定该校验位的值。</p>
<p>p3（第3个校验位，也是整个码字的第4位）的校验规则是：从当前位数起，<strong>连续校验4位</strong>，然后跳过4位，再连续校验4位，再跳过4位，……。这样就可得出p4校验码位可以校验的码字位包括：第4位（也就是p4本身）、第5位、第6位、第7位，第12位、第13位、第14位、第15位，第20位、第21位、第22位、第23位，……。同样根据所采用的是奇校验，还是偶校验，最终可以确定该校验位的值。</p>
<p>p4（第4个校验位，也是整个码字的第8位）的校验规则是：从当前位数起，<strong>连续校验8位</strong>，然后跳过8位，再连续校验8位，再跳过8位，……。这样就可得出p4校验码位可以校验的码字位包括：第8位（也就是p4本身）、第9位、第10位、第11位、第12位、第13位、第14位、第15位，第24位、第25位、第26位、第27位、第28位、第29位、第30位、第31位，……。同样根据所采用的是奇校验，还是偶校验，最终可以确定该校验位的值。</p>
</blockquote>
<p><strong>4、实现校验和纠错</strong></p>
<p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/20140406194503531"></p>
<p>从表中可以得出以下两个规律：</p>
<ul>
<li>所有校验码所在的位是只由对应的校验码进行校验，如第1位（只由p1校验）、第2位（只由p2校验）、第4位（只由p3校验）、第8位（只由p4校验）、第16位（只由p5校验），……。也就是<strong>这些位如果发生了差错，影响的只是对应的校验码的校验结果，不会影响其它校验码的校验结果</strong>。这点很重要，如果最终发现只是一个校验组中的校验结果不符，则直接可以知道是对应校验组中的校验码在传输过程中出现了差错。</li>
<li><strong>所有信息码位均被至少两个校验码进行了校验，也就是至少校验了两次</strong>。查看对应的是哪两组校验结果不符，然后根据上表就可以很快确定是哪位信息码在传输过程中出了差错。</li>
</ul>
<p> 海明码校验的方式就是<strong>各校验码对它所校验的位组进行“异或运算”</strong></p>
<p>G1&#x3D;p1⊕b1⊕b2⊕b4⊕b5⊕……</p>
<p>G2&#x3D;p2⊕b1⊕b3⊕b4⊕b6⊕b7⊕b10⊕b11⊕……</p>
<p>G3&#x3D; p3⊕b2⊕b3⊕b4⊕b8⊕b9⊕b10⊕b11⊕……</p>
<p>G4&#x3D; p4⊕b5⊕b6⊕b7⊕b8⊕b9⊕b10⊕b11⊕……</p>
<p>G5&#x3D; p5⊕b12⊕b13⊕b14⊕b15⊕b16⊕b17⊕b18⊕b19⊕b20⊕b21⊕b11⊕b23⊕b24⊕b25⊕b26⊕……</p>
<p> 正常情况下（也就是整个码字不发生差错的情况下），在<strong>采用偶校验时</strong>，各校验组通过异或运算后的<strong>校验结果均应该是为0</strong>，也就是前面所说的G1、G2、G3、G4，……均为0，因为此时1为偶数个，进行异或运算后就是0；而<strong>采用奇校验时，各组校验结果均应是为1</strong>。</p>
<blockquote>
<p> 现在举一个例子来说明，假设传输的海明码为&#x3D;&#x3D;11&#x3D;&#x3D;1&#x3D;&#x3D;0&#x3D;&#x3D;001&#x3D;&#x3D;1&#x3D;&#x3D;1101（一共12位，带高亮的4位就是校验码），从中可以知道它有四个校验组：G1、G2、G3、G4，然而到达接收端经过校验后发现只有G4&#x3D;1（也就是只有这组校验结果不等于0），通过前面介绍的校验规律可以很快地发现是G4校验组中的p4校位码（也就是整个码字中的第8位）错了（<strong>因为只有一组校验结果出现差错时，则肯定只是对应的校验位出了差错</strong>），也就是最终的码字变成了：111000001101。</p>
<p>再假设G3、G4两个校验值都不为0，也就是都等于1。通过上表中比较G3、G4两个校验组（注意本示例中码字长度一共才12位，只需要比较前12位）中共同校验的码位可是以很快发现是b8，也就是第12位出现了差错，也就是最终的码字变成了：111000011100。</p>
</blockquote>
<p><strong>PS：指错字G1、G2、G3、G4&#x3D;0000的时候不一定无错！！</strong></p>
<blockquote>
<p>如P1、b1、P2三位同时出错，G2和G1依旧是0。</p>
</blockquote>
<p>原因是：<strong>海明校验还是基于奇偶校验的</strong></p>
<p><strong>ps：一位错和两位错不能由指错字区别！！！</strong></p>
<blockquote>
<p>如b1、b2同时出错，与仅b3出错的指错字是一样的：0110</p>
</blockquote>
<p>海明码最高一个校验位，被称为总校验位，它的值，是通过对全部数据位和其它全部校验位（不含P13本身）执行偶校验计算求得的。</p>
<h3 id="校验码总结"><a href="#校验码总结" class="headerlink" title="校验码总结"></a>校验码总结</h3><p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20191220220213444.png"></p>
<h2 id="c语言中的数据存储方式"><a href="#c语言中的数据存储方式" class="headerlink" title="c语言中的数据存储方式"></a>c语言中的数据存储方式</h2><table>
<thead>
<tr>
<th>类型</th>
<th align="center">长度&#x2F;子节</th>
<th align="center">取值范围</th>
<th align="center">存储方式</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td align="center">1</td>
<td align="center">-128~127</td>
<td align="center">有符号二进制补码形式</td>
</tr>
<tr>
<td>[signed]char</td>
<td align="center">1</td>
<td align="center">-128~127</td>
<td align="center"></td>
</tr>
<tr>
<td>unsigned char</td>
<td align="center">1</td>
<td align="center">0~255</td>
<td align="center"></td>
</tr>
<tr>
<td>short[int]</td>
<td align="center">2</td>
<td align="center">-32768~32768</td>
<td align="center"></td>
</tr>
<tr>
<td>unsigned short[int]</td>
<td align="center">2</td>
<td align="center">0~65535</td>
<td align="center"></td>
</tr>
<tr>
<td>int</td>
<td align="center">4</td>
<td align="center">-2147483648~2147483647</td>
<td align="center">定点有符号二进制补码形式</td>
</tr>
<tr>
<td>[signed]int</td>
<td align="center">4</td>
<td align="center">-2147483648~2147483647</td>
<td align="center"></td>
</tr>
<tr>
<td>unsigned int</td>
<td align="center">1</td>
<td align="center">0~4294967295</td>
<td align="center"></td>
</tr>
<tr>
<td>long[int]</td>
<td align="center">2</td>
<td align="center">-2147483648~2147483647</td>
<td align="center"></td>
</tr>
<tr>
<td>unsigned long[int]</td>
<td align="center">4</td>
<td align="center">-2147483648~2147483647</td>
<td align="center"></td>
</tr>
<tr>
<td>unsigned long [int]</td>
<td align="center">4</td>
<td align="center">0~4294967295</td>
<td align="center"></td>
</tr>
<tr>
<td>float</td>
<td align="center">4</td>
<td align="center">-3.4<em>10^38~3.4</em>10^38</td>
<td align="center">浮点形式存储</td>
</tr>
<tr>
<td>double</td>
<td align="center">8</td>
<td align="center">-1.798<em>10^308~1.798</em>10^308</td>
<td align="center">浮点形式存储</td>
</tr>
<tr>
<td>long double</td>
<td align="center">8</td>
<td align="center">-1.798<em>10^308~1.798</em>10^308</td>
<td align="center">浮点形式存储</td>
</tr>
</tbody></table>
<p>备注：<br>short int&lt;&#x3D;int&lt;&#x3D;long int&lt;&#x3D;long long int<br>float&lt;&#x3D;double&lt;&#x3D;long double</p>
<h3 id="int型"><a href="#int型" class="headerlink" title="int型"></a>int型</h3><ol>
<li>占用4个字节，即：32b，有符号位：从左数第一位。</li>
<li>取值范围：-2^31^ ~ 2^31^-1。<br>原因：0 代表 +0，-0 代表 -2^31^，故负数比整数多一个。</li>
<li>数据以<strong>补码</strong>的形式存放在内存中。</li>
<li>对于+0和-0在内存中的存储方式。</li>
</ol>
<h3 id="unsigned-int型"><a href="#unsigned-int型" class="headerlink" title="unsigned int型"></a>unsigned int型</h3><ol>
<li>占用4个字节，即：32b，无符号位。</li>
<li>取值范围：0 ~ 2^32^。</li>
<li>数据以<strong>补码</strong>的形式存放在内存中。</li>
</ol>
<h3 id="float型和double型"><a href="#float型和double型" class="headerlink" title="float型和double型"></a>float型和double型</h3><p>遵循IEEE745规范。</p>
<h3 id="char型"><a href="#char型" class="headerlink" title="char型"></a>char型</h3><p>在内存中以ASCII码的形式存储。</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p><img src="/images/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%AE%A1%E7%AE%97/134S535R-0.png"></p>
<p>算术运算式中，低类型能够转换为高类型。【<strong>一般只是形式上有所改变， 而不影响数据的实质内容， 而较高类型的数据转换为较低类型时则可能有些数据丢失。</strong>】</p>
<blockquote>
<p>​    a.若两种类型的字节数不同，转换成字节数高的类型</p>
<p>​    b.若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型</p>
</blockquote>
<p> (1) 浮点型与整型 </p>
<blockquote>
<p><strong>将浮点数(单双精度)转换为整数时，将舍弃浮点数的小数部分， 只保留整数部分。</strong> <u>将整型值赋给浮点型变量，数值不变，只将形式改为浮点形式， 即小数点后带若干个0。</u>注意：赋值时的类型转换实际上是强制的。</p>
</blockquote>
<p> (2) 单、双精度浮点型 </p>
<blockquote>
<p>由于c语言中的浮点值总是用双精度表示的，所以float 型数据只是在尾部加0延长为double型数据参加运算，然后直接赋值。<strong>double型数据转换为float型时，通过截尾数来实现，截断前要进行四舍五入操作。</strong></p>
</blockquote>
<p> (3) char型与int型 </p>
<blockquote>
<p>int型数值赋给char型变量时，<strong>只保留其最低8位，高位部分舍弃。</strong><br>char型数值赋给int型变量时， 一些编译程序不管其值大小都作正数处理，而另一些编译程序在转换时，若char型数据值大于127，就作为负数处理。对于使用者来讲，如果原来char型数据取正值，转换后仍为正值;如果原来char型值可正可负，则转换后也仍然保持原值， 只是数据的内部表示形式有所不同。</p>
</blockquote>
<p> (4) int型与long型 </p>
<blockquote>
<p>long型数据赋给int型变量时，将低16位值送给int型变量，而将高16 位截断舍弃。(这里假定int型占两个字节)。 </p>
<p>将int型数据送给long型变量时，其外部值保持不变，而内部形式有所改变。 </p>
</blockquote>
<p>(5) 无符号整数 </p>
<blockquote>
<p>将一个unsigned型数据赋给一个占据同样长度存储单元的整型变量时(如：unsigned→int、unsigned long→long，unsigned short→short) ，原值照赋，内部的存储方式不变，但外部值却可能改变。</p>
<p>将一个非unsigned整型数据赋给长度相同的unsigned型变量时， 内部存储形式不变，但外部表示时总是无符号的。</p>
</blockquote>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>真值：正号和负号分别用“+”和“-”表示，数据位保持二进制值不变的数据表示方法。</p>
<p>数值数据：计算机所支持的一种数据类型，用于科学计算，常见的数值数据类型包括小数、整数、浮点数数等。 </p>
<p>非数值数据：计算机所支持的一种数据类型，一般用来表示符号或文字等没有数值值的数据。</p>
<p>机器数：数据在机器中的表示形式，是正负符号数码化后的二进制数据。</p>
<p>变形补码：用两个二进制位来表示数字的符号位，其余与补码相同。即“00”表示正，“11”表示负。 </p>
<p>规格化：将非规格化的数处理成规格化数的过程。规格化数规定尾数用纯小数表示，且真值表示时小数点后第一位不为0（以机器数表示时对小数点后第一位的规定与具体的机器数的形式有关）。</p>
<p>机器零：计算机保存数字的位有限，所能表示最小的数也有范围，其中有一个范围之中的数据无法精确表示，当实际的数据处在这个无法精确表示的数据范围时计算机就将该数作为机器零来处理，因此，计算机中的机器零其实对应的不是一个固定的数，而是一个数据表示范围。 </p>
<p>BCD码：用4位二进制数来表示1位十进制数中的0~9这10个数码，即二进制表示的十进制数。 </p>
<p>汉字内码：计算机内部存储、处理加工和传输汉字时所用的由0和1符号组成的代码。</p>
<p>码距：一组编码中对应位上数字位不同的最小个数。 </p>
<p>奇偶校验：通过检测校验码中1的个数的奇&#x2F;偶性是否改变来判断数据是否出错的一种数据校验方法。 </p>
<p>海明校验：是一种基于多重奇校验且具有检测与纠正错误的校验方法。其基本原理是将有效信息按某种规律分成若干组，每组安排一个校验位进行奇偶测试，就能提供多位检错信息，以指出最大可能是哪位出错，从而将其纠正。</p>
<p>循环冗余校验：是数据通信领域中最常用的一种具有检测与纠正错误能力差错校验码，基利用生成多项式并基于模2运算建立编码规则。</p>
<p>检错：检测被传送的信息中是否发生差错。 </p>
<p>纠错：纠正信息在传送或存储过程中所发生的错误。</p>
<h3 id="简要问题"><a href="#简要问题" class="headerlink" title="简要问题"></a>简要问题</h3><p>1)为什么计算机中采用二进制?</p>
<p>答：因为二进制具有运算简单和表示简单的优点，除此之外还有可靠和容易实现等特点。</p>
<p>具体来说，是因为：</p>
<p>（1）技术实现简单，计算机是由逻辑电路组成，逻辑电话通常只有两个状态，开关</p>
<p>的接通与断开，这两种状态正好可以用“1”和“0”表示。 </p>
<p>（2）简化运算规则：两个二进制数和、积运算组合各有三种，运算规则简单，有利</p>
<p>于简化计算机内部结构，提高运算速度。 </p>
<p>（3）适合逻辑运算：逻辑代数是逻辑运算的理论依据，二进制只有两个数码，正好</p>
<p>与逻辑代数中的“真”和“假”相吻合。 </p>
<p>（4）易于进行转换，二进制与十进制数易于互相转换。</p>
<p>2)为什么计算机中采用补码表示带符号的整数?</p>
<p>答：采用补码运算具有如下两个特征：</p>
<p>（1）因为使用补码可以将符号位和其他位统一处理，同时，减法也可以按加法来处理，即如果是补码表示的数，不管是加减法都直接用加法运算即可实现。</p>
<p>（2）两个用补码表示的数相加时，如果最高位（符号位）有进位，则进位被舍弃。</p>
<p>这样的运算有两个好处：</p>
<p>（a）使符号位能与有效值部分一起参加运算，从而简化运算规则。从而可以简化运算器的结构，提高运算速度；（减法运算可以用加法运算表示出来。）</p>
<p>（b）加法运算比减法运算更易于实现。使减法运算转换为加法运算，进一步简化计算机中运算器的线路设计。</p>
<p>3)浮点数的表示范围和精确度分别由什么决定?字长一定时浮点数的表示范围与精确度之间有和关系?</p>
<p>答：浮点数的表示范围由阶码的位数决定，精确度由尾数的位数决定。</p>
<p>当机器字长一定时，分给阶码的位数越多，尾数占用的位数就越少，则数的表示范围越大。而尾数占用的位数减少，必然会减少数的有效数位，即影响数的精度。</p>
<p>4)汉字输入码、机内码和字型码在汉字处理过程中各有何作用？</p>
<p>答：汉字输入码、机内码和字型码，分别用于汉字的输入、汉字在计算机内的处理以及汉字的显示和打印。</p>
<p>具体来说，计算机要对汉字信息进行处理，首先要将汉字转换成计算机可以识别的二进制形式并输入到计算机，这是由汉字输入码完成的；汉字输入到计算机后，还需要转换成内码才能被计算机处理，显然，汉字内码也应该是二进制形式。如果需要显示和打印汉字，还要将汉字的内码转换成字形码。</p>
<p>5)在机内码中如何区分两个ASCII码字符和一个汉字?</p>
<p>答：将一个汉字看成是两个扩展ASCII码，使表示GB2312汉字的两个字节的最高位都为1，而每个ASCII码字符中每个字节的最高位为0。这样就能区别一个机内码到底对应一个汉字还是两个西文字符。</p>
<p>6)“8421码就是二进制数”。这种说法对吗？为什么？</p>
<p>答：这种说法是不对的。8421码是一种最简单的有权码，它选取4位二进制数的前10个代码0000～1001分别对应表示十进制数的10个数码。若按权求和，和数就等于该代码所对应的十进制数。</p>
<p>8421码是一种编码方式，用于十进位制与二进制数之间的转换。</p>
<p>而二进制数是用0和1两个数码来表示的数。二者是不同的概念，不能等同。</p>
<p>7)如何识别浮点数的正负？浮点数能表示的数值范围和数值的精确度取决于什么？</p>
<p>答：当采用一般浮点数格式表示浮点数时,阶码和尾数都各包含一位符号位。浮点数的正负由尾数的的符号位决定。当采用IEEE754格式时，通过数符就能判断出浮点数的正负。</p>
<p>浮点数能表示的数值范围和数值的精确度，分别取决于阶码的位数和尾数的位数。</p>
<p>8)简述CRC的纠错原理。</p>
<p>答：发送部件将某信息的CRC码传送至接收部件，接收部件收到CRC码后，仍用约定的生成多项式G(x)去除，若余数为0，表示传送正确；若余数不为0，表示出错，再由余数的值来确定哪一位出错，从而加以纠正。具体的纠错原理如下：</p>
<p>（1）不论错误出现在哪一位,均要通过将出错位循环左移到最左边的一位上时被纠正；</p>
<p>（2）不为零余数的具有循环特性。即在余数后面补一个零除以生成多项目式,将得到下一个余数,继续在新余数基础上补零除以生成多项式,继续该操作，余数最后能循环到最开始的余数。</p>
<p>（3）CRC就是利用不为零余数的循环特性,在循环计算余数的同时，将收到的CRC编码同步移动，当余数循环到等于最左边位出错对应的余数时，表明已将出错的位移到CRC码的最左边,对出错位进行纠错。</p>
<p>（4）继续进行余数的循环计算,并同步移动CRC编码,当余数又回到最开始的值时,纠错后的CRC码又回到了最开始的位置。至此，完成CRC的纠错任务。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rhb</p>
  <div class="site-description" itemprop="description">纵浪大化中，不喜亦不惧</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">142</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RShawshank" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RShawshank" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rhb</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://lib.baomitu.com/canvas-nest.js/1.0.1/canvas-nest.js"></script>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
