<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rshawshank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="纵浪大化中，不喜亦不惧">
<meta property="og:type" content="website">
<meta property="og:title" content="rhb_blog">
<meta property="og:url" content="http://rshawshank.github.io/page/3/index.html">
<meta property="og:site_name" content="rhb_blog">
<meta property="og:description" content="纵浪大化中，不喜亦不惧">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rhb">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rshawshank.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>rhb_blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rhb_blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">rao的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">57</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">23</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">140</span></a>

  </li>
        <li class="menu-item menu-item-photos">

    <a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
        <li class="menu-item menu-item-readnote">

    <a href="/readnote" rel="section"><i class="fa fa-book fa-fw"></i>阅读笔记</a>

  </li>
        <li class="menu-item menu-item-somethink">

    <a href="/somethink/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>随笔闲谈</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/RShawshank" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/29/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/29/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/" class="post-title-link" itemprop="url">java-面向对象思想</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-29 09:26:25" itemprop="dateCreated datePublished" datetime="2021-12-29T09:26:25Z">2021-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h1><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="泛化关系（Generalization）"><a href="#泛化关系（Generalization）" class="headerlink" title="泛化关系（Generalization）"></a>泛化关系（Generalization）</h3><p>用来描述继承关系，在 Java 中使用 extends 关键字。</p>
<h3 id="实现关系-Realization"><a href="#实现关系-Realization" class="headerlink" title="实现关系 (Realization)"></a>实现关系 (Realization)</h3><p>用来实现一个接口，在 Java 中使用 implements 关键字。</p>
<h3 id="关联关系-Association"><a href="#关联关系-Association" class="headerlink" title="关联关系 (Association)"></a>关联关系 (Association)</h3><p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p>
<p>【代码表现】：成员变量</p>
<h3 id="聚合关系-Aggregation"><a href="#聚合关系-Aggregation" class="headerlink" title="聚合关系 (Aggregation)"></a>聚合关系 (Aggregation)</h3><p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p>
<p>聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。</p>
<p>【代码表现】：成员变量</p>
<h3 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="组合关系 (Composition)"></a>组合关系 (Composition)</h3><p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p>
<p>组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期</p>
<p>【代码表现】：成员变量</p>
<h3 id="依赖关系-Dependency"><a href="#依赖关系-Dependency" class="headerlink" title="依赖关系 (Dependency)"></a>依赖关系 (Dependency)</h3><p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：</p>
<ul>
<li>A 类是 B 类方法的局部变量；</li>
<li>A 类是 B 类方法的参数；</li>
<li>A 类向 B 类发送消息，从而影响 B 类发生变化。</li>
</ul>
<p>【代码表现】：局部变量、方法的参数或者对静态方法的调用</p>
<h3 id="各种关系的强弱顺序"><a href="#各种关系的强弱顺序" class="headerlink" title="各种关系的强弱顺序"></a>各种关系的强弱顺序</h3><p>泛化&#x3D;实现&gt;组合&gt;聚合&gt;关联&gt;依赖</p>
<h2 id="面向对象的六大原则"><a href="#面向对象的六大原则" class="headerlink" title="面向对象的六大原则"></a>面向对象的六大原则</h2><h3 id="1、单一职责原则SRP"><a href="#1、单一职责原则SRP" class="headerlink" title="1、单一职责原则SRP"></a>1、单一职责原则SRP</h3><p>面向对象的六大原则就一个类而言，应该仅有一个引起它变化的原因。</p>
<p>简单的说就是：一个类中应该是一组相关性很高的函数、数据的封装。两个不一样的功能不应该放在一个类中。</p>
<p>这个原则没有具体的划分界限，需要根据个人经验，具体业务逻辑而定。这也是优化代码的第一步。试想一下，如果所有的功能写在一个类里，那么这个类会越来越大，越来越复杂，越不易修改维护。那么根据功能，各自独立拆分出来，岂不是逻辑会清晰些。</p>
<h3 id="2、开闭原则OCP"><a href="#2、开闭原则OCP" class="headerlink" title="2、开闭原则OCP"></a>2、开闭原则OCP</h3><p>定义是：软件中的对象（类、模块、函数等）应该对于<strong>扩展是开放的，但是对于修改是封闭的</strong>。当软件需要变化时，我们<u>尽量</u>通过扩展的方式来实现变化，而不是通过修改已有的代码来实现（可能引入的代码会破坏原有系统）。</p>
<h3 id="3、里氏替换原则LSP"><a href="#3、里氏替换原则LSP" class="headerlink" title="3、里氏替换原则LSP"></a>3、里氏替换原则LSP</h3><p>定义：所有引用父类的地方，必须能使用子类的对象。简单地说就是<strong>将父类替换为他的子类是不会出现问题</strong>，反之，未必可以。</p>
<p>那么里氏替换原则就是依赖于面向对象语言的<strong>继承</strong>与<strong>多态</strong>。核心原理是<strong>抽象</strong>。</p>
<p>这里列举一下继承的优缺点：<br>优点：<br>（1）代码重用，减少创建类的成本，每个子类都拥有父类的方法与属性。<br>（2）子类与父类基本相似，但与父类又有所区别。<br>（3）提高代码的可扩展性。<br>缺点：<br>（1）继承是侵入性的，只要继承就必须拥有父类所有的属性与方法。<br>（2）可能造成子类代码冗余、灵活性降低。</p>
<p>开闭原则和里氏替换原则是生死相依的、不离不弃的。他们都强调了抽象这一重要的特性。</p>
<p>看着定义很是抽象，但是通俗的理解就是由子类实例化的父类引用，在使用这个引用时，感觉就像是使用了父类一样。一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;...&#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;...&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="comment">// 类型是A，但实际是B类型实例化的，就是依赖多态</span></span><br><span class="line">    a.method();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、依赖倒置原则DIP"><a href="#4、依赖倒置原则DIP" class="headerlink" title="4、依赖倒置原则DIP"></a>4、依赖倒置原则DIP</h3><p>定义：指代一种特定的解耦方式，使得高层次的模块不依赖于低层次的模块的实现细节的目的。他有一下几个关键点：<br>（1）高层模块不依赖于低层模块，应该都依赖其抽象。<br>（2）抽象不依赖细节。<br>（3）细节应依赖抽象。</p>
<p>解释：在Java中，<strong>抽象就是指接口或者抽象类，两者都是不能直接被实例化的</strong>；<strong>细节就是实现类，实现接口或者继承抽象类而产生的就是细节</strong>，也就是可以加上一个关键字new产生的对象。<strong>高层模块就是调用端，底层模块就是具体实现类。</strong></p>
<p>依赖倒置原则在Java中的表现就是：<strong>模块间通过抽象发生，实现类之间不发生直接依赖关系，其依赖关系是通过接口或者抽象类产生的。如果类与类直接依赖细节，那么就会直接耦合，那么当修改时，就会同时修改依赖者代码，这样限制了可扩展性。</strong></p>
<h3 id="5、接口隔离原则ISP"><a href="#5、接口隔离原则ISP" class="headerlink" title="5、接口隔离原则ISP"></a>5、接口隔离原则ISP</h3><p>定义：类间的依赖关系应该建立在最小的接口上，将庞大、臃肿的接口拆分成更小的、更具体的接口。目的是系统的解耦，从而更容易重构、更改和重新部署。</p>
<h3 id="6、迪米特原则LOD"><a href="#6、迪米特原则LOD" class="headerlink" title="6、迪米特原则LOD"></a>6、迪米特原则LOD</h3><p>定义：一个类应该对自己需要耦合或者调用的类知道的最少，类的内部如何实现与调用者或者依赖者没有关系，调用者或依赖者只需知道他需要的方法，其他可以一概不管。这样使得系统具有更低的耦合与更好的可扩展性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/23/java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/23/java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">java-类加载全过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-22 16:59:21" itemprop="dateCreated datePublished" datetime="2021-12-22T16:59:21Z">2021-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="类加载全过程"><a href="#类加载全过程" class="headerlink" title="类加载全过程"></a>类加载全过程</h1><p>一个Java文件从编码完成到最终执行，一般主要包括两个过程</p>
<ul>
<li><p>编译</p>
<p>即把java文件，通过javac命令编译成字节码，也就是.class文件。</p>
</li>
<li><p>运行</p>
<p>则是把编译生成的.class文件交给Java虚拟机(JVM)执行。</p>
</li>
</ul>
<p>类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。</p>
<p>JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且<strong>只加载一次</strong>。</p>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>类加载的过程主要分为三个部分：</p>
<ul>
<li>加载</li>
<li>链接</li>
<li>初始化</li>
</ul>
<p>而链接又可以细分为三个小部分：</p>
<ul>
<li>验证</li>
<li>准备</li>
<li>解析</li>
</ul>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20211223103209.jpeg" alt="img"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载指的是把class字节码文件从各个来源通过类加载器装载入内存中。</p>
<p>这里有两个重点：</p>
<ul>
<li><strong>字节码来源</strong>。一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译</li>
<li><strong>类加载器</strong>。一般包括<strong>启动类加载器</strong>，<strong>扩展类加载器</strong>，<strong>应用类加载器</strong>，以及用户的<strong>自定义类加载器</strong>。</li>
</ul>
<p><strong>注：为什么会有自定义类加载器？</strong></p>
<ul>
<li>一方面是由于java代码很容易被反编译，如果需要对自己的代码加密的话，可以对编译后的代码进行加密，然后再通过实现自己的自定义类加载器进行解密，最后再加载。</li>
<li>另一方面也有可能从非标准的来源加载代码，比如从网络来源，那就需要自己实现一个类加载器，从指定源进行加载。</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。</p>
<p>包括对于<strong>文件格式的验证</strong>，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？</p>
<p>对于<strong>元数据的验证</strong>，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？</p>
<p>对于<strong>字节码的验证</strong>，保证程序语义的合理性，比如要保证类型转换的合理性。</p>
<p>对于<strong>符号引用的验证</strong>，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>主要是为类变量（注意，不是实例变量）分配内存，并且赋予<strong>初值</strong>。</p>
<p>特别需要注意，<strong>初值，不是代码中具体写的初始化的值</strong>，而是Java虚拟机根据不同变量类型的默认初始值。</p>
<p>比如8种<strong>基本类型</strong>的初值，默认为0；<strong>引用类型</strong>的初值则为null；<strong>常量</strong>的初值即为代码中设置的值，final static tmp &#x3D; 456， 那么该阶段tmp的初值就是456</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将常量池内的符号引用替换为直接引用的过程。</p>
<p>两个重点：</p>
<ul>
<li><strong>符号引用</strong>。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。</li>
<li><strong>直接引用</strong>。可以理解为一个内存地址，或者一个偏移量。比如<strong>类方法，类变量</strong>的直接引用是指向方法区的<strong>指针</strong>；而<strong>实例方法，实例变量</strong>的直接引用则是从实例的头指针开始算起到这个实例变量位置的<strong>偏移量</strong></li>
</ul>
<p>举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。</p>
<p>在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>这个阶段主要是对<strong>类变量</strong>初始化，是执行类构造器的过程。类构造器<clinit>()方法是由编译器自动收集类中的所有类变量的<strong>赋值</strong>动作和**静态语句块(static块)**中的语句合并产生的。</p>
<p>换句话说，只对static修饰的变量或语句进行初始化。</p>
<p>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。</p>
<p>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</p>
<ul>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。</li>
</ul>
<p>Java程序初始化顺序：</p>
<blockquote>
<p> 1、父类的静态变量<br> 2、父类的静态代码块<br> 3、子类的静态变量<br> 4、子类的静态代码块<br> 5、父类的非静态变量<br> 6、父类的非静态代码块<br> 7、父类的构造方法<br> 8、子类的非静态变量<br> 9、子类的非静态代码块<br> 10、子类的构造方法</p>
</blockquote>
<h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><ol>
<li>创建类的实例，也就是new一个对象</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（Class.forName(“com.lyj.load”)）</li>
<li>初始化一个类的子类（会首先初始化子类的父类）</li>
<li>JVM启动时标明的启动类，即文件名和类名相同的那个类</li>
</ol>
<p>  除此之外，下面几种情形需要特别指出：</p>
<p> 对于一个final类型的静态变量，如果该变量的值在编译时就可以确定下来，那么这个变量相当于“宏变量”。Java编译器会在编译时直接把这个变量出现的地方替换成它的值，因此即使程序使用该静态变量，也不会导致该类的初始化。反之，如果final类型的静态Field的值不能在编译时确定下来，则必须等到运行时才可以确定该变量的值，如果通过该类来访问它的静态变量，则会导致该类被初始化。</p>
<h2 id="类的引用"><a href="#类的引用" class="headerlink" title="类的引用"></a>类的引用</h2><h3 id="主动引用（一定会初始化）"><a href="#主动引用（一定会初始化）" class="headerlink" title="主动引用（一定会初始化）"></a>主动引用（一定会初始化）</h3><p>当虚拟机启动，先初始化main方法所在的类<br>1.new一个类的对象<br>2.调用类的静态成员(除了final常量)和静态方法<br>3.使用java.lang.reflect包的方法对类进行反射调用<br>4.当初始化一个类的时候，如果其父类没有被初始化，则会先初始化它的父类</p>
<h3 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h3><p>1.访问一个静态域时，只有真正的声名这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类被初始化<br>2.通过数组引用定义类时，不会触发此类的初始化<br>3.引用常量不会触发此类的初始化(常量在链接阶段就存入调用类的常量池中了)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;mian方法所在类被初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  ClassNotFoundException&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          类的主动引用，一定会引起类的初始化 当虚拟机启动，先初始化main方法所在的类</span></span><br><span class="line"><span class="comment">          1.new一个类的对象</span></span><br><span class="line"><span class="comment">          2.调用类的静态成员(除了final常量)和静态方法</span></span><br><span class="line"><span class="comment">          3.使用java.lang.reflect包的方法对类进行反射调用</span></span><br><span class="line"><span class="comment">          4.当初始化一个类的时候，如果其父类没有被初始化，则会先初始化它的父类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//new一个类的对象</span></span><br><span class="line">        <span class="comment">//Animal animal = new Animal();//mian方法所在类被初始化 父类被初始化</span></span><br><span class="line">        <span class="comment">//调用类的静态成员(除了final常量)和静态方法</span></span><br><span class="line">        <span class="comment">//System.out.println(Animal.num);//mian方法所在类被初始化 3</span></span><br><span class="line">        <span class="comment">//System.out.println(Animal.name);//mian方法所在类被初始化 父类被初始化 狗</span></span><br><span class="line">        <span class="comment">//Animal.print();//mian方法所在类被初始化 父类被初始化 动物在叫</span></span><br><span class="line">        <span class="comment">//使用java.lang.reflect包的方法对类进行反射调用</span></span><br><span class="line">        <span class="comment">//Class c1 = Class.forName(&quot;exam.reflect.Cat&quot;);// mian方法所在类被初始化 父类被初始化 子类被初始化</span></span><br><span class="line">        <span class="comment">//当初始化一个类的时候，如果其父类没有被初始化，则会先初始化它的父类</span></span><br><span class="line">        <span class="comment">//Cat cat = new Cat();// mian方法所在类被初始化 父类被初始化 子类被初始化</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">           类的被动引用  不会发生类的初始化</span></span><br><span class="line"><span class="comment">           1.访问一个静态域时，只有真正的声名这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类被初始化</span></span><br><span class="line"><span class="comment">           2.通过数组引用定义类时，不会触发此类的初始化</span></span><br><span class="line"><span class="comment">           3.引用常量不会触发此类的初始化(常量在链接阶段就存入调用类的常量池中了)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//子类引用父类的静态变量，不会子类被初始化</span></span><br><span class="line">        <span class="comment">//System.out.println(Cat.name);mian方法所在类被初始化 父类被初始化 狗通过数组引用定义类时，不会触发此类的初始化</span></span><br><span class="line">        <span class="comment">//Animal[] animals = new Animal[5];//mian方法所在类被初始化</span></span><br><span class="line">        <span class="comment">//Cat[] cats = new Cat[6];//mian方法所在类被初始化</span></span><br><span class="line">        <span class="comment">//引用常量不会触发此类的初始化</span></span><br><span class="line">        <span class="comment">//System.out.println(Animal.NAME);//mian方法所在类被初始化 动物</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类被初始化&quot;</span>);</span><br><span class="line">        name = <span class="string">&quot;猫&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span>  <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类被初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">color</span>  <span class="operator">=</span> <span class="string">&quot;黄色&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="类加载器的原理"><a href="#类加载器的原理" class="headerlink" title="类加载器的原理"></a>类加载器的原理</h2><h3 id="类缓存"><a href="#类缓存" class="headerlink" title="类缓存"></a>类缓存</h3><p>标准的Java SE类加载器可以按要求查找类，一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过，JVM垃圾收集器可以回收这些Class对象。</p>
<h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20211224153606.webp" alt="img"></p>
<p><strong>A.从Java虚拟机的角度：</strong></p>
<p><strong>1.Bootstrap ClassLoader启动类加载器</strong><br><strong>2.其他类加载器</strong><br>从JVM的角度，加载器只分为两类,即JVM自身实现的Bootstrap启动类加载器，和其他JVM以外的所有类加载器。Bootstrap翻译为根，故也叫根类加载器。</p>
<p><strong>B.从开发者的角度：</strong></p>
<p><strong>1.Bootstrap ClassLoader根类加载器</strong><br><strong>2.Extension ClassLoader拓展类加载器</strong><br><strong>3.Application ClassLoader应用程序类加载器</strong><br>1.根类加载器，加载位于&#x2F;jre&#x2F;lib目录中的或者被参数-Xbootclasspath所指定的目录下的核心Java类库。此类加载器是Java虚拟机的一部分，使用native代码(C++)编写。</p>
<p>2.扩展类加载器，加载位于&#x2F;jre&#x2F;lib&#x2F;ext目录中的或者java.ext.dirs系统变量所指定的目录下的拓展类库。此加载器由sun.misc.Launcher ExtClassLoader实现。</p>
<p>3.系统类加载器，加载用户路径(ClassPath)上所指定的类库。此加载器由sun.misc.Launcher$ AppClassLoader实现。</p>
<blockquote>
<p><strong>引导类加载器（bootstrap class loader）</strong><br> （1）它用来加载 Java 的核心库(JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar,sun.boot.class.path路径下的内容)，是用原生代码（C语言）来实现的，并不继承自 java.lang.ClassLoader。<br> （2）加载扩展类和应用程序类加载器。并指定他们的父类加载器。</p>
<p><strong>扩展类加载器（extensions class loader）</strong><br> （1）用来加载 Java 的扩展库(JAVA_HOME&#x2F;jre&#x2F;ext&#x2F;*.jar，或java.ext.dirs路径下的内容) 。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java类。<br> （2）由sun.misc.Launcher$ExtClassLoader实现。</p>
<p><strong>应用程序类加载器（application class loader）</strong><br> （1）它根据 Java 应用的类路径（classpath，java.class.path 路径下的内容）来加载 Java 类。<strong>一般来说，Java 应用的类都是由它来完成加载的。</strong><br> （2）由sun.misc.Launcher$AppClassLoader实现。</p>
</blockquote>
<p>类加载器加载Class大致要经过如下8个步骤：</p>
<ol>
<li>检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。</li>
<li>如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。</li>
<li>请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。</li>
<li>请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。</li>
<li>当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。</li>
<li>从文件中载入Class，成功后跳至第8步。</li>
<li>抛出ClassNotFountException异常。</li>
<li>返回对应的java.lang.Class对象。</li>
</ol>
<h2 id="类加载器的代理模式"><a href="#类加载器的代理模式" class="headerlink" title="类加载器的代理模式"></a>类加载器的代理模式</h2><p>代理模式即是将指定类的加载交给其他的类加载器。常用双亲委托机制。</p>
<p>JVM的类加载机制主要有如下3种。</p>
<ul>
<li>全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</li>
<li>双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。</li>
<li>缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。</li>
</ul>
<h4 id="1、双亲委托机制"><a href="#1、双亲委托机制" class="headerlink" title="1、双亲委托机制"></a>1、双亲委托机制</h4><p>双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，如果都不能加载则报错——ClassNotFoundException。这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。</p>
<p>  双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</p>
<p>值得注意是，双亲委托机制是代理模式的一种，但并不是所有的类加载器都采用双亲委托机制。在tomcat服务器类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。</p>
<h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>（1）首先检查请求的类型是否已经被这个类装载器装载到命名空间中了，如果已经装载，直接返回；否则转入步骤2。</p>
<p>（2）委派类加载请求给父类加载器，如果父类加载器能够完成，则返回父类加载器加载的Class实例；否则转入步骤3。</p>
<p>（3）调用本类加载器的findClass（…）方法，试图获取对应的字节码，如果获取的到，则调用defineClass（…）导入类型到方法区；如果获取不到对应的字节码或者其他原因失败，返回异常给loadClass（…）， loadClass（…）转抛异常，终止加载过程（注意：这里的异常种类不止一种）。</p>
<p> <strong>- 注意：被两个类加载器加载的同一个类，JVM认为是不相同的类。</strong></p>
<h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><p>通常当你需要动态加载资源的时候 , 你至少有三个 ClassLoader 可以选择 :<br> 1.系统类加载器或叫作应用类加载器 (system classloader or application classloader)<br> 2.当前类加载器<br> 3.当前线程类加载器</p>
<p><strong>• 当前线程类加载器是为了抛弃双亲委派加载链模式。</strong><br> 每个线程都有一个关联的上下文类加载器。如果你使用new Thread()方式生成新的线程，新线程将继承其父线程的上下文类加载器。如果程序对线程上下文类加载器没有任何改动的话，程序中所有的线程将都使用系统类加载器作为上下文类加载器。<br> <strong>• Thread.currentThread().getContextClassLoader()</strong></p>
<h2 id="tomcat服务器的类加载器"><a href="#tomcat服务器的类加载器" class="headerlink" title="tomcat服务器的类加载器"></a>tomcat服务器的类加载器</h2><p>每个 Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式(不同于前面说的双亲委托机制)，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。但也是为了保证安全，这样核心库就不在查询范围之内。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/17/java-%E5%AD%97%E8%8A%82%E7%A0%81%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/17/java-%E5%AD%97%E8%8A%82%E7%A0%81%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">java-字节码操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-17 15:26:50" itemprop="dateCreated datePublished" datetime="2021-12-17T15:26:50Z">2021-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="字节码操作"><a href="#字节码操作" class="headerlink" title="字节码操作"></a>字节码操作</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>java的动态性的两种常见方式</p>
<ul>
<li>字节码操作</li>
<li>反射</li>
</ul>
<p>运行时操作字节码可以实现的功能如下：</p>
<ul>
<li><p>动态生成新的类</p>
</li>
<li><p>动态改变某个类的结构（添加&#x2F;删除&#x2F;修改 新的属性）</p>
</li>
</ul>
<p>优势：</p>
<ul>
<li><p>比反射开销小，性能高。</p>
</li>
<li><p>JAVAasist性能高于反射，低于ASM</p>
</li>
</ul>
<p>常见的字节码操作类库</p>
<ul>
<li><p>BCEL</p>
<p> Byte Code Engineering Library (BCEL) ，这是 Apache Software Foundation 的 Jakarta 项目的一部分。 BCEL 是 Java classworking 广泛 使用的一种 框架 , 它 可以让您深入 JVM 汇编语言进行类操作的细节。 BCEL 与 Javassist 有不同的处理字节码方法， BCEL 在实际的 JVM 指令层次上进行操作 (BCEL 拥有丰富的 JVM 指令级支持 ) 而 Javassist 所 强调 的是源代码 级别的 工作 。</p>
</li>
<li><p>ASM</p>
<p> 是一个轻量级 java 字节码操作框架，直接涉及到 JVM 底层的操作和 指令</p>
</li>
<li><p>CGLIB</p>
<p>是一个强大的，高性能，高质量的 Code</p>
</li>
<li><p>Javaassist </p>
<p>性能较ASM差，跟cglib差不多，但是用用简单，很多框架都在使用</p>
</li>
</ul>
<h2 id="javassist"><a href="#javassist" class="headerlink" title="javassist"></a>javassist</h2><p>使用Javassist需要使用javassist.jar</p>
<p>优势：</p>
<p>  比反射开销小，性能高。<br>  JAVAsist性能高于反射，低于ASM</p>
<p>局限性：</p>
<p>  JDK新语法不支持（包括泛型、枚举），不支持注解修改，但可以通过底层的javasist类来解决，具体参考：javassist.bytecode.annotaion<br>  不支持数组的初始化，如 String[]{“1”,”2”}，除非只有数组的容量为1<br>  不支持内部类和匿名类<br>  不支持 continue 和 break 表达式。<br>  对于继承关系，有些不支持 。例如：- class A{} - class B extends A{} - class C enxends B {}</p>
<p>应用场景：</p>
<p>  AOP:<br>    给一个类增加新的方法<br>    给一段语句前面和后面（before&#x2F;after&#x2F;around）动态的加代码<br>  Reflection:起到类似反射的效果</p>
<p>javassist 的最外层的 API 和 JAVA 的反射包中的 API 颇为类似 。</p>
<p>它主要由 CtClass ， CtMethod, ，以及 CtField 几个类组成。用以执行和 JDK 反射 API 中 java.lang.Class ， java.lang.reflect.Method ， java.lang.reflect.Method .Field 相同的 操作 。<br>方法操作</p>
<p>  修改已有方法的方法体体（插入代码到已有方法体）<br>  新增方法 删除方法<br>  占位符参数介绍：</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20211217164511.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtConstructor;</span><br><span class="line"><span class="keyword">import</span> javassist.CtField;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test10</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault(); <span class="comment">// 类池</span></span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">class1</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;com.gs.Emp&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建属性</span></span><br><span class="line">    <span class="type">CtField</span> <span class="variable">f1</span> <span class="operator">=</span> CtField.make(<span class="string">&quot;private int num;&quot;</span>, class1);</span><br><span class="line">    <span class="type">CtField</span> <span class="variable">f2</span> <span class="operator">=</span> CtField.make(<span class="string">&quot;private String name;&quot;</span>, class1);</span><br><span class="line">    class1.addField(f1);</span><br><span class="line">    class1.addField(f2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建方法</span></span><br><span class="line">     </span><br><span class="line">    <span class="type">CtMethod</span> <span class="variable">setName</span> <span class="operator">=</span> CtMethod.make(<span class="string">&quot;public void setName(String name)&#123;this.name = name;&#125;&quot;</span>, class1);</span><br><span class="line">    <span class="type">CtMethod</span> <span class="variable">getName</span> <span class="operator">=</span> CtMethod.make(<span class="string">&quot;public String getName()&#123;return name;&#125;&quot;</span>, class1);</span><br><span class="line">    class1.addMethod(setName);</span><br><span class="line">    class1.addMethod(getName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加构造器。  如果是带参构造器，需要传递参数类型，基本数据类型用CtClass获取，引用类型，需要用pool获取</span></span><br><span class="line">    <span class="type">CtConstructor</span> <span class="variable">constructor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtConstructor</span>(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;CtClass.intType,pool.get(<span class="string">&quot;java.lang.String&quot;</span>)&#125;, class1);</span><br><span class="line">    constructor.setBody(<span class="string">&quot;&#123;this.num = num;this.name = name;&#125;&quot;</span>); <span class="comment">//构造器的方法体</span></span><br><span class="line">    </span><br><span class="line">    class1.writeFile(<span class="string">&quot;E:/myjava&quot;</span>); <span class="comment">//将上面写好的类，写入到这个工作空间中</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;生成类成功！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903751082328072">Java 动态字节码技术 - 掘金 (juejin.cn)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/16/java-%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/16/java-%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E/" class="post-title-link" itemprop="url">java-脚本引擎</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-16 10:20:21" itemprop="dateCreated datePublished" datetime="2021-12-16T10:20:21Z">2021-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="脚本引擎"><a href="#脚本引擎" class="headerlink" title="脚本引擎"></a>脚本引擎</h1><p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20211216102211.jpg"></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>脚本引擎就是一个计算机编程语言的解释器</p>
<p>JAVA脚本引擎是从JDK6.0之后添加的新功能。 </p>
<p>脚本引擎介绍：</p>
<ul>
<li>使得Java应用程序可以通过一套固定的接口与各种脚本引擎交互，从而达到在Java平台上调用各种脚本语言的目的。</li>
<li>Java脚本API是连通Java平台和脚本语言的桥梁。 </li>
<li>可以把一些复杂异变的业务逻辑交给脚本语言处理，这又大大提高了开发效率</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在日常的Java项目中，我们免不了会遇到这样的需求：</p>
<ol>
<li>动态地获取并运行自定义脚本文件，以实现特定的功能</li>
<li>对数据流执行用户自定义的数据有效性、公式计算、数据处理ETL（如数据截取、拼接）等不同业务逻辑</li>
<li>对用户输入的代码或脚本文件进行测试、运行，确保其语法正确、功能正常</li>
<li>处理需要灵活配置且不断变更的动态业务规则</li>
<li>代码的热更新、热修复</li>
</ol>
<p>诸如此类的需求若采用硬编码实现，则迭代成本相当高，每次改动都需要进行开发、测试、部署。同时业务规则的频繁变更会导致代码的开发和维护成本大大提高</p>
<h2 id="js语言简介"><a href="#js语言简介" class="headerlink" title="js语言简介"></a>js语言简介</h2><p>js属于的是解释性语言。</p>
<ul>
<li><p>支持动态类型，弱类型，在程序运行的时候才进行编译，效率不较低。</p>
</li>
<li><p>不像编译性语言，源代码不能直接翻译成<strong>机器语言</strong>，先翻译成<strong>中间代码</strong>，再由<strong>解释器</strong>对中间代码进行解释运行。</p>
</li>
<li><p>程序不需要编译，程序运行时才翻译成机器语言，每执行一次都要翻译一次。</p>
</li>
<li><p>一般，<code>编译性语言的运行效率比解释性语言更高</code>；但是不能一概而论，部分解释性语言的解释器通过在运行时动态优化代码，甚至能使解释性语言的性能超过编译性语言；</p>
</li>
</ul>
<h2 id="简单的实现过程"><a href="#简单的实现过程" class="headerlink" title="简单的实现过程"></a>简单的实现过程</h2><h3 id="查找脚本引擎"><a href="#查找脚本引擎" class="headerlink" title="查找脚本引擎"></a>查找脚本引擎</h3><ol>
<li><p>通过脚本名称获取：</p>
<p>ScriptEngineManager:为ScriptEngine提供实例化机制。</p>
<p>　　方法：getEngineByName(String shortName);&#x2F;&#x2F;查找并创建指定名称的脚本引擎</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>().getEngineByName(<span class="string">&quot;JavaScript&quot;</span>); </span><br></pre></td></tr></table></figure>
</li>
<li><p>通过文件扩展名获取:</p>
<p>ScriptEngine:是一个接口，该接口提供了基本的脚本功能（包括执行脚本，设置和获取值的方法）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>().getEngineByExtension(<span class="string">&quot;js&quot;</span>);  </span><br><span class="line"></span><br><span class="line">方法：</span><br><span class="line">    	 get(String key);<span class="comment">//获取指定key所对应的值，这里的key看做变量名称，值看做变量名所对应的值。</span></span><br><span class="line"></span><br><span class="line">　　　　　eval(String script)；<span class="comment">//执行指定的脚本代码</span></span><br><span class="line"></span><br><span class="line">　　　　　eval(Reader reader)；<span class="comment">//执行指定的脚本文件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过MIME类型获取:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>().getEngineByMimeType(<span class="string">&quot;text/javascript&quot;</span>);  </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="语言绑定"><a href="#语言绑定" class="headerlink" title="语言绑定"></a>语言绑定</h3><p>脚本语言支持API使用语言绑定对象实现Java语言编写的程序与脚本语言间的数据传递。语言绑定对象实际上就是一个简单的<strong>哈希表</strong>，用来存放和获取需要共享的数据，其定义的接口为javax.script.Bindings，继承自java.util.Map接口。一个脚本引擎在执行过程中可能会使用多个语言绑定对象，不同语言绑定对象的作用域不同。ScriptEngine类提供out和get方法对脚本引擎中特定作用域的默认语言绑定对象进行操作。 </p>
<p>使用默认的语言绑定对象： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useDefaultBinding</span><span class="params">()</span> <span class="keyword">throws</span> ScriptException &#123;  </span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">    engine.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Alex&quot;</span>);  </span><br><span class="line">    engine.eval(<span class="string">&quot;var message = &#x27;Hello, &#x27; + name;&quot;</span>);  <span class="comment">//执行指定的脚本代码</span></span><br><span class="line">    engine.eval(<span class="string">&quot;println(message);&quot;</span>);  </span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> engine.get(<span class="string">&quot;message&quot;</span>);  </span><br><span class="line">    System.out.println(obj);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>亦可以自定义语言绑定对象（如语言绑定对象中包含程序自己独有的数据等情形……）： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useCustomBinding</span><span class="params">()</span> <span class="keyword">throws</span> ScriptException &#123;  </span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">    <span class="type">Bindings</span> <span class="variable">bindings</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleBindings</span>();  </span><br><span class="line">    bindings.put(<span class="string">&quot;hobby&quot;</span>, <span class="string">&quot;playing games&quot;</span>);  </span><br><span class="line">    engine.eval(<span class="string">&quot;println(&#x27;I like &#x27; + hobby);&quot;</span>, bindings);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="脚本引擎执行脚本方法"><a href="#脚本引擎执行脚本方法" class="headerlink" title="脚本引擎执行脚本方法"></a>脚本引擎执行脚本方法</h3><p>一、</p>
<ol>
<li>执行脚本方法，首先肯定是要在脚本中定义方法，然后执行。</li>
<li>执行时需要将engine转换为Invcable,然后调用其中的invokeFun</li>
</ol>
<p>　　Invocable:由ScriptEngines实现的可选接口，其方法允许调用先前已执行的脚本中的程序（方法）。</p>
<ol start="3">
<li>调用Object invokeFunction(String name, Object… args)；执行指定方法。</li>
</ol>
<p>　　name为方法名称，args为方法参数，返回是一个Object对象　</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.script.Invocable;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptEngine;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptEngineManager;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRhino</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ScriptException &#123;</span><br><span class="line">        <span class="type">ScriptEngineManager</span> <span class="variable">sem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>();</span><br><span class="line">        <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> sem.getEngineByName(<span class="string">&quot;javascript&quot;</span>);</span><br><span class="line">        <span class="comment">//定义方法的字符串形式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">funAdd</span> <span class="operator">=</span> <span class="string">&quot;function add(a,b)&#123;&quot;</span></span><br><span class="line">                    + <span class="string">&quot;      var sum = a + b;&quot;</span></span><br><span class="line">                    + <span class="string">&quot;     return sum;&quot;</span></span><br><span class="line">                    + <span class="string">&quot;  &#125;&quot;</span>;</span><br><span class="line">        engine.eval(funAdd);<span class="comment">//这一步可以看做将方法写入脚本</span></span><br><span class="line">        <span class="type">Invocable</span> <span class="variable">invo</span> <span class="operator">=</span> (Invocable)engine;<span class="comment">//转换成Invocable</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行脚本中方法</span></span><br><span class="line">            result = invo.invokeFunction(<span class="string">&quot;add&quot;</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">17</span>,<span class="number">23</span>&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二、</p>
<ol>
<li>执行脚本文件，首先我们要指定文件的路径。</li>
<li>通过这个路径构建一个Reader对象</li>
<li>调用eval(Reader reader)；&#x2F;&#x2F;执行指定的脚本文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptEngine;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptEngineManager;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRhino</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ScriptException &#123;</span><br><span class="line">        <span class="comment">//E:\eclipse\Rhino</span></span><br><span class="line">        <span class="type">ScriptEngineManager</span> <span class="variable">sem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>();</span><br><span class="line">        <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> sem.getEngineByName(<span class="string">&quot;javascript&quot;</span>);</span><br><span class="line">        <span class="comment">//脚本文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;E:\\eclipse\\Rhino\\test.js&quot;</span>;<span class="comment">//</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">read</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过脚本文件路径构造Reader对象</span></span><br><span class="line">            read = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(path));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行脚本文件</span></span><br><span class="line">        engine.eval(read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="脚本执行的上下文"><a href="#脚本执行的上下文" class="headerlink" title="脚本执行的上下文"></a>脚本执行的上下文</h3><p>脚本引擎通过执行过程中的上下文对象获取与脚本执行相关的信息，同时允许程序员通过此对象配置脚本引擎的行为。其上下文对象来自javax.script.ScriptContext接口，类似于J2EE中javax.servlet.ServletContext接口，该接口主要包含3类信息：</p>
<h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><p>默认情况下，脚本输入输出都是在标准控制台中，可以通过setReader和setWriter方法对输出流进行重定向，可以通过setErrorWriter方法进行错误输出重定向。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：将输出重定向到文件  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scriptToFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ScriptException &#123;  </span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">    <span class="type">ScriptContext</span> <span class="variable">context</span> <span class="operator">=</span> engine.getContext();  </span><br><span class="line">    context.setWriter(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>));  </span><br><span class="line">    engine.eval(<span class="string">&quot;println(&#x27;Hello World!&#x27;);&quot;</span>);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h4><p>上下文中通过setAttribute和getAttribute方法获取和设置属性，类似于ServletContext中设置和获取属性操作。与ServletContext中不同的是，ScriptContext中的属性是有作用域之分的，ScriptContext按不同的顺序在不同的作用域中进行属性查找（类似于JSP中EL表达式属性的作用域）。通过ScriptContext的getScopes可以得到其中所有可用的作用域，其中预定义了两个作用域：常量ScriptContext.ENGINE_SCOPE（当前的脚本引擎）和ScriptContext.GLOBAL_SCOPE（从同一引擎工厂中创建的所有脚本引擎对象）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scriptContextAttribute</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">    <span class="type">ScriptContext</span> <span class="variable">context</span> <span class="operator">=</span> engine.getContext();  </span><br><span class="line">    context.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Alex&quot;</span>, ScriptContext.GLOBAL_SCOPE);  </span><br><span class="line">    context.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Bob&quot;</span>, ScriptContext.ENGINE_SCOPE);  </span><br><span class="line">    context.getAttribute(<span class="string">&quot;name&quot;</span>); <span class="comment">//值为Bob  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="语言绑定对象"><a href="#语言绑定对象" class="headerlink" title="语言绑定对象"></a>语言绑定对象</h4><p>语言绑定对象位于ScriptContext中，同样也有作用域之分，范围越小，优先级越高。执行如下代码，输出的name值为Bob。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scriptContextBindings</span><span class="params">()</span> <span class="keyword">throws</span> ScriptException &#123;  </span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">    <span class="type">ScriptContext</span> <span class="variable">context</span> <span class="operator">=</span> engine.getContext();  </span><br><span class="line">    <span class="type">Bindings</span> <span class="variable">bindings1</span> <span class="operator">=</span> engine.createBindings();  </span><br><span class="line">    bindings1.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Alex&quot;</span>);  </span><br><span class="line">    context.setBindings(bindings1, ScriptContext.GLOBAL_SCOPE);  </span><br><span class="line">    <span class="type">Bindings</span> <span class="variable">bindings2</span> <span class="operator">=</span> engine.createBindings();  </span><br><span class="line">    bindings2.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Bob&quot;</span>);  </span><br><span class="line">    context.setBindings(bindings2, ScriptContext.ENGINE_SCOPE);  </span><br><span class="line">    engine.eval(<span class="string">&quot;println(name);&quot;</span>);    <span class="comment">//Bob  </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>也可以通过ScriptContext获取语言绑定对象： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useScriptContextValues</span><span class="params">()</span> <span class="keyword">throws</span> ScriptException &#123;  </span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">    <span class="type">ScriptContext</span> <span class="variable">context</span> <span class="operator">=</span> engine.getContext();  </span><br><span class="line">    <span class="type">Bindings</span> <span class="variable">bindings</span> <span class="operator">=</span> context.getBindings(ScriptContext.ENGINE_SCOPE);  </span><br><span class="line">    bindings.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Alex&quot;</span>);  </span><br><span class="line">    engine.eval(<span class="string">&quot;println(name);&quot;</span>);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>前面说到语言绑定对象存在于上下文环境中，故context中保存的自定义属性其实也是保存于语言绑定对象中的，如2中的语言绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeInBindings</span><span class="params">()</span> <span class="keyword">throws</span> ScriptException &#123;  </span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">    <span class="type">ScriptContext</span> <span class="variable">context</span> <span class="operator">=</span> engine.getContext();  </span><br><span class="line">    context.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Alex&quot;</span>, ScriptContext.GLOBAL_SCOPE);  </span><br><span class="line">    engine.eval(<span class="string">&quot;println(name);&quot;</span>);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="脚本编译"><a href="#脚本编译" class="headerlink" title="脚本编译"></a>脚本编译</h4><p>脚本语言一般均是解释执行的，相对于编译执行的语言，效率较低一些。当脚本语言需要多次重复执行时，可以先对煎熬本进行编译，避免重复解析，提高效率（注：脚本编译需要脚本引擎支持，实现javax.script.Compilable接口）。JavaSE中自带的JavaScript引擎是支持对脚本进行编译的，编译的脚本用javax.script.CompiledScript来表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScriptCompile</span> <span class="keyword">extends</span> <span class="title class_">JsScriptRunner</span> &#123;  </span><br><span class="line">    <span class="comment">//对脚本进行编译  </span></span><br><span class="line">    <span class="keyword">public</span> CompiledScript <span class="title function_">compile</span><span class="params">(String scriptText)</span> <span class="keyword">throws</span> ScriptException &#123;  </span><br><span class="line">        <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">        <span class="keyword">if</span> (engine <span class="keyword">instanceof</span> Compilable) &#123;  </span><br><span class="line">            <span class="type">CompiledScript</span> <span class="variable">script</span> <span class="operator">=</span> ((Compilable) engine).compile(scriptText);  </span><br><span class="line">            <span class="keyword">return</span> script;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//先编译再执行  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String scriptText)</span> <span class="keyword">throws</span> ScriptException &#123;  </span><br><span class="line">        <span class="type">CompiledScript</span> <span class="variable">script</span> <span class="operator">=</span> compile(scriptText);  </span><br><span class="line">        <span class="keyword">if</span> (script == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;  </span><br><span class="line">            script.eval();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">ScriptCompile</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptCompile</span>();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            sc.run(<span class="string">&quot;println(&#x27;Hello&#x27;);&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ScriptException ex) &#123;  </span><br><span class="line">            Logger.getLogger(ScriptCompile.class.getName()).log(Level.SEVERE, <span class="literal">null</span>, ex);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>Java虚拟机支持脚本的意义在于实现函数式的编程，即脚本中最重要的便是方法。一些脚本引擎允许使用者单独调用脚本中的某个方法，支持此操作的脚本引擎可以通过实现javax.script.Invocable接口，支持顶层方法或者某对象中成员方法的调用。使用方法调用时最好先检查脚本引擎是否实现了Invocable接口，JavaSE中的JavaScript引擎已实现了Invocable接口。</p>
<ol>
<li><p>在Java中调用脚本中的顶层方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeFunction</span><span class="params">()</span> <span class="keyword">throws</span> ScriptException, NoSuchMethodException &#123;  </span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">    <span class="type">String</span> <span class="variable">scriptText</span> <span class="operator">=</span> <span class="string">&quot;function greet(name) &#123; println(&#x27;Hello, &#x27; + name); &#125; &quot;</span>;  </span><br><span class="line">    engine.eval(scriptText);  </span><br><span class="line">    <span class="type">Invocable</span> <span class="variable">invocable</span> <span class="operator">=</span> (Invocable) engine;  </span><br><span class="line">    invocable.invokeFunction(<span class="string">&quot;greet&quot;</span>, <span class="string">&quot;Alex&quot;</span>);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>调用脚本中某对象的成员方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeMethod</span><span class="params">()</span> <span class="keyword">throws</span> ScriptException, NoSuchMethodException &#123;  </span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">    <span class="type">String</span> <span class="variable">scriptText</span> <span class="operator">=</span> <span class="string">&quot;var obj = &#123; getGreeting : function(name) &#123; return &#x27;Hello, &#x27; + name; &#125; &#125;; &quot;</span>;  </span><br><span class="line">    engine.eval(scriptText);  </span><br><span class="line">    <span class="type">Invocable</span> <span class="variable">invocable</span> <span class="operator">=</span> (Invocable) engine;  </span><br><span class="line">    <span class="type">Object</span> <span class="variable">scope</span> <span class="operator">=</span> engine.get(<span class="string">&quot;obj&quot;</span>);  </span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocable.invokeMethod(scope, <span class="string">&quot;getGreeting&quot;</span>, <span class="string">&quot;Alex&quot;</span>);   <span class="comment">//第一个参数为方法所属对象  </span></span><br><span class="line">    System.out.println(result);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>指定脚本中的方法为Java接口的实现</p>
<p> Greet是Java实现的接口，包含一个方法getGreeting，通过Invocable.getInterface()方法指定脚本中的方法为Java接口的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useInterface</span><span class="params">()</span> <span class="keyword">throws</span> ScriptException &#123;  </span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">    <span class="type">String</span> <span class="variable">scriptText</span> <span class="operator">=</span> <span class="string">&quot;function getGreeting(name) &#123; return &#x27;Hello, &#x27; + name; &#125; &quot;</span>;  </span><br><span class="line">    engine.eval(scriptText);  </span><br><span class="line">    <span class="type">Invocable</span> <span class="variable">invocable</span> <span class="operator">=</span> (Invocable) engine;  </span><br><span class="line">    <span class="type">Greet</span> <span class="variable">greet</span> <span class="operator">=</span> invocable.getInterface(Greet.class);  </span><br><span class="line">    System.out.println(greet.getGreeting(<span class="string">&quot;Alex&quot;</span>));  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Nashorn-JavaScript脚本引擎"><a href="#Nashorn-JavaScript脚本引擎" class="headerlink" title="Nashorn JavaScript脚本引擎"></a>Nashorn JavaScript脚本引擎</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/15/java-%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/15/java-%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">java-动态编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-15 13:39:32" itemprop="dateCreated datePublished" datetime="2021-12-15T13:39:32Z">2021-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h1><p>动态编译，就是在程序运行时产生java类，并编译成class文件。</p>
<h2 id="动态编译的实现方式"><a href="#动态编译的实现方式" class="headerlink" title="动态编译的实现方式"></a>动态编译的实现方式</h2><p>正常情况下先编译（明文源码到字节码），后执行（JVM加载字节码，获得类模板，实例化，方法使用）。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20211215143048.png" alt="程序流程图"></p>
<h3 id="相关类介绍"><a href="#相关类介绍" class="headerlink" title="相关类介绍"></a>相关类介绍</h3><p>JavaCompiler: 负责读取源代码，编译诊断，输出class<br>JavaFileObject: 文件抽象，代表源代码或者编译后的class<br>JavaFileManager: 管理JavaFileObject，负责JavaFileObject的创建和保存位置<br>ClassLoader: 根据字节码，生成类模板</p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>由于代码在编译的时候，类定义甚至类名称还不存在，所以没法直接声明使用的。只能定义一个接口代替之，具体实现留给后面的动态编译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用-JavaCompiler-接口来编译-java-源程序-最简单的"><a href="#使用-JavaCompiler-接口来编译-java-源程序-最简单的" class="headerlink" title="使用 JavaCompiler 接口来编译 java 源程序(最简单的)"></a>使用 JavaCompiler 接口来编译 java 源程序(最简单的)</h3><p>通过 ToolProvider 类的静态方法 getSystemJavaCompiler 来得到一个 JavaCompiler 接 口的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JavaCompiler</span> <span class="variable">compiler</span> <span class="operator">=</span> ToolProvider.getSystemJavaCompiler();</span><br></pre></td></tr></table></figure>

<p>javaCompiler 中最核心的方法是 run。通过这个方法能编译 java 源程序。这个方法有 3 个固 定参数和 1 个可变参数。前 3 个参数分别用来为 java 编译器提供参数、得到 Java 编译器的输出信息及接收编译器的 错误信息,后面的可变参数能传入一个或多个 Java 源程式文件。如果 run 编译成功,返回 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> compiler.run(<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,sourceFile);</span><br><span class="line">System.out.println(result==<span class="number">0</span>?<span class="string">&quot;编译成功&quot;</span>：<span class="string">&quot;编译失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一个参数：为java编译器提供参数</p>
</li>
<li><p>第二个参数：得到java编译器的输出信息</p>
</li>
<li><p>第三个参数：接收编译器的错误信息</p>
</li>
<li><p>第四个参数：可变参数（String数组）能传入一个或者多个java源文件</p>
</li>
<li><p>返回值：0表示编译成功，非0表示编译失败</p>
</li>
<li><p>如果前 3 个参数传入的是 null,那么 run 方法将以标准的输入、输出代替,即 System.in、 System.out 和 System.err。如果我们要编译一个 hello.java 文件,并将使用标准输入输出,run 的使用方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">results</span> <span class="operator">=</span> tool.run(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="string">&quot;Hello.java&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用-StandardJavaFileManager-编译-Java-源程序"><a href="#使用-StandardJavaFileManager-编译-Java-源程序" class="headerlink" title="使用 StandardJavaFileManager 编译 Java 源程序"></a>使用 StandardJavaFileManager 编译 Java 源程序</h3><p>StandardJavaFileManager 类能非常好地控制输入、输出,并且能通过 DiagnosticListener 得到诊断信息,而 DiagnosticCollector 类就是 listener 的实现。</p>
<p>使用 StandardJavaFileManager 需要两步。<br>首先建立一个 DiagnosticCollector 实例及通过 JavaCompiler 的 getStandardFileManager()方法得到一个 StandardFileManager 对象。<br>最后通过 CompilationTask 中的 call 方法编译源程序</p>
<h3 id="源代码的文件级动态编译"><a href="#源代码的文件级动态编译" class="headerlink" title="源代码的文件级动态编译"></a>源代码的文件级动态编译</h3><p>java源码以文件的形式存在本地，程序去指定路径加载源文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">classPath</span> <span class="operator">=</span> File2Class.class.getResource(<span class="string">&quot;/&quot;</span>).getPath();</span><br><span class="line"><span class="comment">//在这里我们是动态生成定义，然后写入文件。也可以直接读一个已经存在的文件</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;import classloader.Printer;&quot;</span> </span><br><span class="line">    + <span class="string">&quot;public class MyPrinter1 implements Printer &#123;&quot;</span> </span><br><span class="line">    + <span class="string">&quot;public void print() &#123;&quot;</span> </span><br><span class="line">    + <span class="string">&quot;System.out.println(\&quot;test1\&quot;);&quot;</span> </span><br><span class="line">    + <span class="string">&quot;&#125;&#125;&quot;</span>;</span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(classPath + <span class="string">&quot;MyPrinter1.java&quot;</span>);</span><br><span class="line">writer.write(str);;</span><br><span class="line">writer.close();</span><br><span class="line"><span class="comment">//获得系统编译器</span></span><br><span class="line"><span class="type">JavaCompiler</span> <span class="variable">compiler</span> <span class="operator">=</span> ToolProvider.getSystemJavaCompiler();</span><br><span class="line"><span class="comment">//获得java文件管理器</span></span><br><span class="line"><span class="type">StandardJavaFileManager</span> <span class="variable">fileManager</span> <span class="operator">=</span> compiler.getStandardFileManager(<span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//读入源文件</span></span><br><span class="line"><span class="type">Iterable</span> <span class="variable">fileObject</span> <span class="operator">=</span> fileManager.getJavaFileObjects(classPath + <span class="string">&quot;MyPrinter1.java&quot;</span>);</span><br><span class="line"><span class="comment">//生成编译任务</span></span><br><span class="line">JavaCompiler.<span class="type">CompilationTask</span> <span class="variable">task</span> <span class="operator">=</span> compiler.getTask(</span><br><span class="line">                <span class="literal">null</span>, fileManager, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, fileObject);</span><br><span class="line"><span class="comment">//执行编译任务</span></span><br><span class="line">task.call();</span><br><span class="line">fileManager.close();</span><br><span class="line"><span class="comment">//指定class路径，默认和源代码路径一致，加载class</span></span><br><span class="line"><span class="type">URLClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;file:&quot;</span> + classPath)&#125;);</span><br><span class="line"><span class="type">Printer</span> <span class="variable">printer</span> <span class="operator">=</span> (Printer)classLoader.loadClass(<span class="string">&quot;MyPrinter1&quot;</span>).newInstance();</span><br><span class="line">printer.print();</span><br></pre></td></tr></table></figure>

<h3 id="源代码的内存级动态编译"><a href="#源代码的内存级动态编译" class="headerlink" title="源代码的内存级动态编译"></a>源代码的内存级动态编译</h3><p>上节源代码落地了，这节让我们看下源代码和class全程在内存不落地，如何实现动态编译。思路是生成源代码对应的JavaFileObject时，从内存string读取；生成class对应的JavaFileObject时，以字节数组的形式存到内存。JavaFileObject是一个interface， SimpleJavaFileObject是JavaFileObject的一个基本实现，当自定义JavaFileObject时，继承SimpleJavaFileObject，然后改写部分函数。<br>自定义JavaSourceFromString，作为源代码的抽象文件（来自JDK API文档）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A file object used to represent source coming from a string.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaSourceFromString</span> <span class="keyword">extends</span> <span class="title class_">SimpleJavaFileObject</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The source code of this &quot;file&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> String code;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new JavaSourceFromString.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name of the compilation unit represented by this file object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> code the source code for the compilation unit represented by this file object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JavaSourceFromString(String name, String code) &#123;</span><br><span class="line">    <span class="built_in">super</span>(URI.create(<span class="string">&quot;string:///&quot;</span> + name.replace(<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;/&#x27;</span>) + Kind.SOURCE.extension), Kind.SOURCE);</span><br><span class="line">    <span class="built_in">this</span>.code = code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> CharSequence <span class="title function_">getCharContent</span><span class="params">(<span class="type">boolean</span> ignoreEncodingErrors)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaClassFileObject，代表class的文件抽象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaClassFileObject</span> <span class="keyword">extends</span> <span class="title class_">SimpleJavaFileObject</span> &#123;</span><br><span class="line">    <span class="comment">//用于存储class字节</span></span><br><span class="line">    ByteArrayOutputStream outputStream;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JavaClassFileObject</span><span class="params">(String className, Kind kind)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(URI.create(<span class="string">&quot;string:///&quot;</span> + className.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>) + kind.extension), kind);</span><br><span class="line">        outputStream = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OutputStream <span class="title function_">openOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> outputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] getClassBytes() &#123;</span><br><span class="line">        <span class="keyword">return</span> outputStream.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ClassFileManager，修改JavaFileManager生成class的JavaFileObject的行为，另外返回一个自定义ClassLoader用于返回内存中的字节码对应的类模板</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassFileManager</span> <span class="keyword">extends</span> <span class="title class_">ForwardingJavaFileManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JavaClassFileObject classFileObject;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new instance of ForwardingJavaFileManager.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileManager delegate to this file manager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">ClassFileManager</span><span class="params">(JavaFileManager fileManager)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(fileManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a JavaFileObject file object for output</span></span><br><span class="line"><span class="comment">     * representing the specified class of the specified kind in the given location.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> JavaFileObject <span class="title function_">getJavaFileForOutput</span><span class="params">(Location location, String className, JavaFileObject.Kind kind, </span></span><br><span class="line"><span class="params">    FileObject sibling)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        classFileObject = <span class="keyword">new</span> <span class="title class_">JavaClassFileObject</span>(className, kind);</span><br><span class="line">        <span class="keyword">return</span> classFileObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//获得一个定制ClassLoader，返回我们保存在内存的类</span></span><br><span class="line">    <span class="keyword">public</span> ClassLoader <span class="title function_">getClassLoader</span><span class="params">(Location location)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClassLoader</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="type">byte</span>[] classBytes = classFileObject.getClassBytes();</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用自定义的JavaFileObject&#x2F;JavaFileManager来动态编译</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;import Printer;&quot;</span> </span><br><span class="line">    + <span class="string">&quot;public class MyPrinter2 implements Printer &#123;&quot;</span> </span><br><span class="line">    + <span class="string">&quot;public void print() &#123;&quot;</span></span><br><span class="line">    + <span class="string">&quot;System.out.println(\&quot;test2\&quot;);&quot;</span></span><br><span class="line">    + <span class="string">&quot;&#125;&#125;&quot;</span>;</span><br><span class="line"><span class="comment">//生成源代码的JavaFileObject</span></span><br><span class="line"><span class="type">SimpleJavaFileObject</span> <span class="variable">fileObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaSourceFromString</span>(<span class="string">&quot;MyPrinter2&quot;</span>, str);</span><br><span class="line"><span class="type">JavaCompiler</span> <span class="variable">compiler</span> <span class="operator">=</span> ToolProvider.getSystemJavaCompiler();</span><br><span class="line"><span class="comment">//被修改后的JavaFileManager</span></span><br><span class="line"><span class="type">JavaFileManager</span> <span class="variable">fileManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassFileManager</span>(compiler.getStandardFileManager(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line"><span class="comment">//执行编译</span></span><br><span class="line">JavaCompiler.<span class="type">CompilationTask</span> <span class="variable">task</span> <span class="operator">=</span> compiler.getTask(<span class="literal">null</span>, fileManager, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, Arrays.asList(fileObject));</span><br><span class="line">task.call();</span><br><span class="line"><span class="comment">//获得ClassLoader，加载class文件</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> fileManager.getClassLoader(<span class="literal">null</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">printerClass</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;MyPrinter2&quot;</span>);</span><br><span class="line"><span class="comment">//获得实例</span></span><br><span class="line"><span class="type">Printer</span> <span class="variable">printer</span> <span class="operator">=</span> (Printer) printerClass.newInstance();</span><br><span class="line">printer.print();</span><br></pre></td></tr></table></figure>

<h2 id="慎用动态编译"><a href="#慎用动态编译" class="headerlink" title="慎用动态编译"></a>慎用动态编译</h2><ul>
<li>在框架中谨慎使用</li>
<li>不要在要求高性能的项目使用<br>动态编译毕竟需要一个编译过程，与静态编译相比多了一个执行环节，因此在高性能项目中不要使用动态编译。</li>
<li>动态编译要考虑安全问题<br>它是非常典型的注入漏洞，只要上传一个恶意Java程序就可以让你所有的安全工作毁于一旦。</li>
<li>记录动态编译过程<br>建议记录源文件、目标文件、编译过程、执行过程等日志，不仅仅是为了诊断，还是为了安全和审计，对Java项目来说，空中编译和运行是很不让人放心的，留下这些依据可以更好地优化程序</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://seanwangjs.github.io/2018/03/13/java-runtime-compile.html">Java 类运行时动态编译技术 - Fenrier Lab (seanwangjs.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904181623439368">深入理解Java的动态编译 - 掘金 (juejin.cn)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/08/%E9%B2%81%E8%BF%85%E5%8F%A5%E5%AD%90%E6%91%98%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/08/%E9%B2%81%E8%BF%85%E5%8F%A5%E5%AD%90%E6%91%98%E5%BD%95/" class="post-title-link" itemprop="url">鲁迅句子摘录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-08 14:51:59" itemprop="dateCreated datePublished" datetime="2021-12-08T14:51:59Z">2021-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.如果你遇见社会上有不平事，万不可挺身而出，讲公道话，否则，事情倒会移到你头上来，甚至于会被指作反动分子的。如果你遇见有人被冤枉，被诬陷的，即使明知道他是好人，也万不可挺身而出，去给他解释或分辩，否则，你就会被人说是他的亲戚，或得了他的贿路；倘使那是女人，就要被疑为她的情人的；如果他较有名，那便是党羽。——《世故三昧》<br>2.中国人的性情是总喜欢调和折中的，譬如你说，这屋子太暗，须在这里开一个窗，大家一定不允许的。但如果你主张拆掉屋顶他们就来调和，愿意开窗了。——《无声的中国》<br>3.楼下一个男人病得要死，那间壁的一家唱着留声机；对面是弄孩子。楼上有两人狂笑；还有打牌声。河中的船上有女人哭着她死去的母亲。人类的悲欢并不相通，我只觉得他们吵闹。——《小杂感》<br>4.真的猛士敢于直面惨淡的人生，敢于正视淋漓的鲜血。<br>5.你要灭一个人，一是骂杀，一是捧杀。<br>6.悲剧将人生的有价值的东西毁灭给人看，喜剧将那无价值的撕破给人看。<br>7.面具戴太久，就会长到脸上，在想揭下来，除非伤筋动骨扒皮。——《鲁迅日记》<br>8.愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。此后如竟没有炬火：我便是唯一的光。<br>9.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/11/17/java-%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/17/java-%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">java-并发（三）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-16 16:00:51" itemprop="dateCreated datePublished" datetime="2021-11-16T16:00:51Z">2021-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="八、J-U-C-其他组件"><a href="#八、J-U-C-其他组件" class="headerlink" title="八、J.U.C-其他组件"></a>八、J.U.C-其他组件</h1><h2 id="fork-join框架"><a href="#fork-join框架" class="headerlink" title="fork-join框架"></a>fork-join框架</h2><p>​	Fork&#x2F;Join框架是Java 7提供的一个用于并行执行任务的框架，<strong>是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架</strong>。Fork&#x2F;Join框架要完成两件事情：</p>
<p>　　1.任务分割：首先Fork&#x2F;Join框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割</p>
<p>　　2.执行任务并合并结果：分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据。</p>
<p><em>Fork&#x2F;Join</em>框架简化了并行程序的原因有：</p>
<ul>
<li>它简化了线程的创建，在框架中线程是自动被创建和管理。</li>
<li>它自动使用多个处理器，因此程序可以扩展到使用可用处理器。</li>
</ul>
<p>由于支持真正的并行执行，Fork&#x2F;Join框架可以显著减少计算时间，并提高解决图像处理、视频处理、大数据处理等非常大问题的性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinExample</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkJoinExample</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (last - first &lt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// 任务足够小则直接计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> first; i &lt;= last; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拆分成小任务</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> first + (last - first) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">ForkJoinExample</span> <span class="variable">leftTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinExample</span>(first, middle);</span><br><span class="line">            <span class="type">ForkJoinExample</span> <span class="variable">rightTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinExample</span>(middle + <span class="number">1</span>, last);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            result = leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">ForkJoinExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinExample</span>(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">    <span class="type">Future</span> <span class="variable">result</span> <span class="operator">=</span> forkJoinPool.submit(example);</span><br><span class="line">    System.out.println(result.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于<em>Fork&#x2F;Join</em>框架的一个有趣的地方是：它使用工作窃取算法来平衡线程之间的负载：如果一个工作线程没有事情要做，它可以从其他仍然忙碌的线程窃取任务。</p>
<p>Fork&#x2F;Join框架在<code>java.util.concurrent</code>包下被实现。它的核心有4个类：</p>
<ul>
<li><strong>ForkJoinTask<V></strong>: 这是一个抽象任务类，并且运行在<code>ForkJoinPool</code>中。</li>
<li><strong>ForkJoinPool</strong>:这是一个线程池管理并运行众多<code>ForkJoinTask</code>任务。</li>
<li><strong>RecursiveAction</strong>: <code>ForkJoinTask</code>的子类，这个类没有返回值。</li>
<li><strong>RecursiveTask<V></strong>: <code>ForkJoinTask</code>的子类，有返回值。</li>
</ul>
<p>基本上，我们<strong>解决问题的代码是在<code>RecursiveAction</code>或者<code>RecursiveTask</code>中进行的，然后将任务提交由ForkJoinPool执行，ForkJoinPool处理从线程管理到多核处理器的利用等各种事务。</strong></p>
<p>我们先来理解一下这些类中的关键方法。</p>
<p>ForkJoinTask<V></p>
<p>这是一个运行在<code>ForkJoinPool</code>中的抽象的任务类。类型<code>V</code>指定了任务的返回结果。ForkJoinTask是一个类似线程的实体，它表示任务的轻量级抽象，而不是实际的执行线程。该机制允许由ForkJoinPool中的少量实际线程管理大量任务。其关键方法是：</p>
<ul>
<li><strong>final ForkJoinTask<V> fork()</strong></li>
<li><strong>final V join()</strong></li>
<li><strong>final V invoke()</strong></li>
</ul>
<p><code>fork()</code>方法提交并执行异步任务，该方法返回<code>ForkJoinTask</code>并且调用线程继续运行。</p>
<p><code>join()</code>方法等待任务直到返回结果。</p>
<p><code>invoke()</code>方法是组合了<code>fork()</code>和<code>join()</code>，它开始一个任务并等待结束返回结果。</p>
<p>此外，<code>ForkJoinTask</code>中还提供了用于一次调用多个任务的两个静态方法</p>
<ul>
<li><strong>static void invokeAll(ForkJoinTask<?> task1, ForkJoinTask<?> task2)</strong> :执行两个任务</li>
<li><strong>static void invokeAll(ForkJoinTask&lt;?&gt;… taskList)</strong>:执行任务集合</li>
</ul>
<p>RecursiveAction</p>
<p>这是一个递归的<code>ForkJoinTask</code>子类，不返回结果。<code>Recursive</code>意思是任务可以通过分治策略分成自己的子任务。</p>
<p>我们必须重写<code>compute()</code>方法,并将计算代码写在其中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>RecursiveTask<V></p>
<p>和<code>RecursiveAction</code>一样，但是<code>RecursiveTask</code>有返回结果，结果类型由<code>V</code>指定。我们仍然需要重写<code>compute()</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected abstract V compute();</span><br></pre></td></tr></table></figure>

<p>ForkJoinPool</p>
<p>任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务(工作窃取算法)。</p>
<p>这是<em>Fork&#x2F;Join</em>框架的核心类。它<strong>负责线程的管理和<code>ForkJoinTask</code>的执行</strong>，为了执行<code>ForkJoinTask</code>，首先需要获取到<code>ForkJoinPool</code>的实例。</p>
<p>有两种构造器方式可以获取<code>ForkJoinPool</code>的实例，第一种使用构造器创建：</p>
<ul>
<li><strong>ForkJoinPool()</strong>: 使用默认的构造器创建实例，该构造器创建出的池与系统中可用的<strong>处理器数量相等</strong>。</li>
<li><strong>ForkJoinPool(int parallelism)</strong>:该构造器指定处理器数量，创建具有自定义并行度级别的池，该级别的并行度必须大于0，且不超过可用处理器的实际数量。</li>
</ul>
<p>获取ForkJoinPool实例的第二种方法是使用以下ForkJoinPool的静态方法获取公共池实例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ForkJoinPool <span class="title function_">commonPool</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>这种方式创建的池不受<code>shutdown()</code>或者<code>shutdownNow()</code>方法的影响，但是他会在<code>System.exit()</code>时会自动中止。任何依赖异步任务处理的程序在主体程序中止前都应该调用<code>awaitQuiescence()</code>方法。该方式是静态的，可以自动被使用。</p>
<p>e.g.</p>
<p>在创建好<em>ForkJoinPool</em>实例之后,可以使用下面的方法执行任务：</p>
<ul>
<li><T>T invoke(ForkJoinTask<T> task):执行指定任务并返回结果，该方法是异步的，调用的线程会一直等待直到该方法返回结果，对于<em>RecursiveAction</em>任务来说，参数类型是<em>Void</em>.</li>
<li>void execute(ForkJoinTask&lt;?&gt; task):异步执行指定的任务，调用的线程一直等待知道任务完成才会继续执行。</li>
</ul>
<p>另外，也可以通过<em>ForkJoinTask</em>自己拥有的方法<code>fork()</code>和<code>invoke()</code>执行任务。在这种情况下，如果任务还没在<em>ForkJoinPool</em>中运行，那么<code>commonPool()</code>将会自动被使用。</p>
<p>值得注意的一点是：<em>ForkJoinPool</em>使用的是守护线程，当所有的用户线程被终止是它也会被终止，这意味着可以不必显示的关闭ForkPoolJoin（虽然这样也可以）。如果是<em>common pool</em>的情况下，调用<code>shutdown</code>没有任何效果，应为这个池总是可用的。</p>
<p><strong>使用<em>RecursiveAction</em></strong> </p>
<p>假设要对一个很大的数字数组进行变换，为了简单简单起见，转换只需要将数组中的每个元素乘以指定的数字。下面的代码用于转换任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTransform</span> <span class="keyword">extends</span> <span class="title class_">RecursiveAction</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">100_000</span>;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayTransform</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> number, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt; threshold) &#123;</span><br><span class="line">            computeDirectly();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (end + start) / <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="type">ArrayTransform</span> <span class="variable">subTask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayTransform</span>(array, number, start, middle);</span><br><span class="line">            <span class="type">ArrayTransform</span> <span class="variable">subTask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayTransform</span>(array, number, middle, end);</span><br><span class="line"> </span><br><span class="line">            invokeAll(subTask1, subTask2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">computeDirectly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">            array[i] = array[i] * number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这是一个<em>RecursiveAction</em>的子类，我们重写了<code>compute()</code>方法。</p>
<p>数组和数字从它的构造函数传递。参数start和end指定要处理的数组中的元素的范围。如果数组的大小大于阈值，这有助于将数组拆分为子数组，否则直接对整个数组执行计算。</p>
<p>观察<em>else</em>中的代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (end - start &lt; threshold) &#123;</span><br><span class="line">        computeDirectly();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (end + start) / <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="type">ArrayTransform</span> <span class="variable">subTask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayTransform</span>(array, number, start, middle);</span><br><span class="line">        <span class="type">ArrayTransform</span> <span class="variable">subTask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayTransform</span>(array, number, middle, end);</span><br><span class="line"> </span><br><span class="line">        invokeAll(subTask1, subTask2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，将数组分成两个部分，并分别创建他们的子任务，反过来，子任务也可以递归的进一步划分为更小的子任务，直到其大小小于直接调用<code>computeDirectly();</code>方法的的阈值。</p>
<p>然后，在<em>main</em>函数中创建<em>ForkJoinPool</em>执行任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayTransform</span> <span class="variable">mainTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayTransform</span>(array, number, <span class="number">0</span>, SIZE);</span><br><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">pool.invoke(mainTask);</span><br></pre></td></tr></table></figure>

<p>或者使用<em>common pool</em>执行任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayTransform</span> <span class="variable">mainTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayTransform</span>(array, number, <span class="number">0</span>, SIZE);</span><br><span class="line">mainTask.invoke();</span><br></pre></td></tr></table></figure>

<p>这里是全部的测试程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinRecursiveActionTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE</span> <span class="operator">=</span> <span class="number">10_000_000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] array = randomArray();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;数组中的初始元素： &quot;</span>);</span><br><span class="line">        print();</span><br><span class="line"> <span class="comment">//ArrayTransform 是一个继承RecursiveAction的类，在覆写compute方法时改写成递归方法</span></span><br><span class="line">        <span class="type">ArrayTransform</span> <span class="variable">mainTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayTransform</span>(array, number, <span class="number">0</span>, SIZE);</span><br><span class="line">  <span class="comment">//ForkJoinPool是一个线程池管理并运行众多ForkJoinTask任务。</span></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">       <span class="comment">//invoke()方法是组合了fork()和join()，它开始一个任务并等待结束返回结果。</span></span><br><span class="line">        pool.invoke(mainTask);</span><br><span class="line">        System.out.println(<span class="string">&quot;并行计算之后的元素：&quot;</span>);</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] randomArray() &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[SIZE];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">            array[i] = random.nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.print(array[i] + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如您所见，使用随机生成的1,000万个元素数组进行测试。由于数组太大，我们在计算前后只打印前10个元素，看效果如何:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">数组中的初始元素:</span></span><br><span class="line">42, 98, 43, 14, 9, 92, 33, 18, 18, 76,</span><br><span class="line">并行计算之后的元素：</span><br><span class="line">378, 882, 387, 126, 81, 828, 297, 162, 162, 684,</span><br></pre></td></tr></table></figure>

<p><strong>使用<em>RecursiveTask</em></strong> </p>
<p>这个例子中，展示了如何使用带有返回值的任务，下面的任务计算在一个大数组中出现偶数的次数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayCounter</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="type">int</span>[] array;</span><br><span class="line">    <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">100_000</span>;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayCounter</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt; threshold) &#123;</span><br><span class="line">            <span class="keyword">return</span> computeDirectly();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (end + start) / <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="type">ArrayCounter</span> <span class="variable">subTask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayCounter</span>(array, start, middle);</span><br><span class="line">            <span class="type">ArrayCounter</span> <span class="variable">subTask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayCounter</span>(array, middle, end);</span><br><span class="line"> </span><br><span class="line">            invokeAll(subTask1, subTask2);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> subTask1.join() + subTask2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">computeDirectly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如你所见，这个类是<em>RecursiveTask</em>的子类并且重写了<code>compute()</code>方法，并且返回了一个整型的结果。</p>
<p>这里还使用了<code>join()</code>方法去合并子任务的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> subTask1.join() + subTask2.join();</span><br></pre></td></tr></table></figure>

<p>测试程序就和<em>RecursiveAction</em>的一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinRecursiveTaskTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE</span> <span class="operator">=</span> <span class="number">10_000_000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] array = randomArray();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">ArrayCounter</span> <span class="variable">mainTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayCounter</span>(array, <span class="number">0</span>, SIZE);</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">evenNumberCount</span> <span class="operator">=</span> pool.invoke(mainTask);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;偶数的个数： &quot;</span> + evenNumberCount);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] randomArray() &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[SIZE];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">            array[i] = random.nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序就会看到如下的结果：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">偶数的个数： <span class="number">5000045</span></span><br></pre></td></tr></table></figure>

<p><strong>并行性试验</strong></p>
<p>这个例子展示并行性的级别如何影响计算时间:</p>
<p><code>ArrayCounter</code>类让阈值可以通过构造器传入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayCounter</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="type">int</span>[] array;</span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayCounter</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> threshold)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">        <span class="built_in">this</span>.threshold = threshold;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt; threshold) &#123;</span><br><span class="line">            <span class="keyword">return</span> computeDirectly();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (end + start) / <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="type">ArrayCounter</span> <span class="variable">subTask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayCounter</span>(array, start, middle, threshold);</span><br><span class="line">            <span class="type">ArrayCounter</span> <span class="variable">subTask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayCounter</span>(array, middle, end, threshold);</span><br><span class="line"> </span><br><span class="line">            invokeAll(subTask1, subTask2);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> subTask1.join() + subTask2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">computeDirectly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试程序将并行度级别和阈值作为参数传递：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParallelismTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE</span> <span class="operator">=</span> <span class="number">10_000_000</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] array = randomArray();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">parallelism</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line"> </span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"> </span><br><span class="line">        <span class="type">ArrayCounter</span> <span class="variable">mainTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayCounter</span>(array, <span class="number">0</span>, SIZE, threshold);</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(parallelism);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">evenNumberCount</span> <span class="operator">=</span> pool.invoke(mainTask);</span><br><span class="line"> </span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;偶数的个数: &quot;</span> + evenNumberCount);</span><br><span class="line"> </span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> (endTime - startTime);</span><br><span class="line">        System.out.println(<span class="string">&quot;执行时间： &quot;</span> + time + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] randomArray() &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[SIZE];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">            array[i] = random.nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序允许您使用不同的并行度和阈值轻松测试性能。注意，它在最后打印执行时间。尝试用不同的参数多次运行这个程序，并观察执行时间。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul>
<li><em>Fork&#x2F;Join</em>框架的设计简化了java语言的并行程序</li>
<li><em>ForkJoinPool</em> 是<em>Fork&#x2F;Join</em>框架的核心，它允许多个<code>ForkJoinTask</code>请求由少量实际线程执行，每个线程运行在单独的处理核心上</li>
<li>既可以通过构造器也可以通过静态方法<em>common pool</em>去获取<em>ForkJoinPool</em>的实例</li>
<li><em>ForkJoinTask</em>是一个抽象类，它表示的任务比普通线程更轻。通过覆盖其compute()方法实现计算逻辑</li>
<li><em>RecursiveAction</em>是一个没有返回值的<em>ForkJoinTask</em> </li>
<li><em>RecursiveTask</em>是一个有返回值的<em>ForkJoinTask</em> </li>
<li><em>ForkJoinPool</em>与其它池的不同之处在于，它使用了工作窃取算法，该算法允许一个线程完成了可以做的事情，从仍然繁忙的其他线程窃取任务</li>
<li><em>ForkJoinPool</em>中的线程是守护线程，不必显式地关闭池</li>
<li>执行一个<em>ForkJoinTask</em>既可以通过调用它自己的<code>invoke()</code>或<code>fork()</code>方法，也可以提交任务给<em>ForkJoinPool</em>并调用它的<code>invoke()</code>或者<code>execute()</code>方法</li>
<li>直接使用<em>ForkJoinTask</em>自身的方法执行任务，如果它还没运行在<code>ForkJoinPool</code>中那么将运行在<em>common pool</em>中</li>
<li>在<code>ForkJoinTask</code>中使用<code>join()</code>方法，可以合并子任务的结果</li>
<li><code>invoke()</code>方法会等待子任务完成，但是<code>execute()</code>方法不会</li>
</ul>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。<strong>阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</strong></p>
<p>当试图向队列添加元素而队列已满，或是想从队列移出元素而队列为空的时候，阻塞队列（blockingqueue)导致线程阻塞。</p>
<p>阻塞队列提供了四种处理方法:</p>
<table>
<thead>
<tr>
<th>方法\处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<p>异常：是指当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</p>
<ul>
<li>返回特殊值：插入方法会返回是否成功，成功则返回true。移除方法，则是从队列里拿出一个元素，如果没有则返回null</li>
<li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里take元素，队列也会阻塞消费者线程，直到队列可用。</li>
<li>超时退出：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出。</li>
</ul>
<p>BlockingQueue的核心方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Queue</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将给定元素设置到队列中，如果设置成功返回true, 否则抛出异常。如果是往限定了长度的队列中设置值，推荐使用offer()方法。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将给定的元素设置到队列中，如果设置成功返回true, 否则返回false. e的值不能为空，否则抛出空指针异常。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将元素设置到队列中，如果队列中没有多余的空间，该方法会一直阻塞，直到队列中有多余的空间。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将给定元素在给定的时间内设置到队列中，如果设置成功返回true, 否则返回false.</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中获取值，如果队列中没有值，线程会一直阻塞，直到队列中有值，并且该方法取得了该值。</span></span><br><span class="line">    E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在给定的时间里，从队列中获取值，如果没有取到会抛出异常。</span></span><br><span class="line">    E <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列中剩余的空间。</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">remainingCapacity</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中移除指定的值。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列中是否拥有该值。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将队列中值，全部移除，并发设置到给定的集合中。</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">drainTo</span><span class="params">(Collection&lt;? <span class="built_in">super</span> E&gt; c)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定最多数量限制将队列中值，全部移除，并发设置到给定的集合中。</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">drainTo</span><span class="params">(Collection&lt;? <span class="built_in">super</span> E&gt; c, <span class="type">int</span> maxElements)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在深入之前先了解下下ReentrantLock 和 Condition:<br>重入锁ReentrantLock:<br>ReentrantLock锁在同一个时间点只能被一个线程锁持有；而可重入的意思是，ReentrantLock锁，可以被单个线程多次获取。<br>ReentrantLock分为“公平锁”和“非公平锁”。它们的区别体现在获取锁的机制上是否公平。“锁”是为了保护竞争资源，防止多个线程同时操作线程而出错，ReentrantLock在同一个时间点只能被一个线程获取(当某线程获取到“锁”时，其它线程就必须等待)；ReentraantLock是通过一个FIFO的等待队列来管理获取该锁所有线程的。在“公平锁”的机制下，线程依次排队获取锁；而“非公平锁”在锁是可获取状态时，不管自己是不是在队列的开头都会获取锁。<br>主要方法：</p>
<ul>
<li>lock()获得锁</li>
<li>lockInterruptibly()获得锁，但优先响应中断</li>
<li>tryLock()尝试获得锁，成功返回true,否则false，该方法不等待，立即返回</li>
<li>tryLock(long time,TimeUnit unit)在给定时间内尝试获得锁</li>
<li>unlock()释放锁</li>
</ul>
<p>Condition：await()、signal()方法分别对应之前的Object的wait()和notify()</p>
<ul>
<li>和重入锁一起使用</li>
<li>await()是当前线程等待同时释放锁</li>
<li>awaitUninterruptibly()不会在等待过程中响应中断</li>
<li>signal()用于唤醒一个在等待的线程，还有对应的singalAll()方法</li>
</ul>
<h3 id="阻塞队列的成员"><a href="#阻塞队列的成员" class="headerlink" title="阻塞队列的成员"></a>阻塞队列的成员</h3><table>
<thead>
<tr>
<th>队列</th>
<th>有界性</th>
<th>锁</th>
<th>数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayBlockingQueue</td>
<td>bounded(有界)</td>
<td>加锁</td>
<td>arrayList</td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td>optionally-bounded</td>
<td>加锁</td>
<td>linkedList</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>unbounded</td>
<td>加锁</td>
<td>heap</td>
</tr>
<tr>
<td>DelayQueue</td>
<td>unbounded</td>
<td>加锁</td>
<td>heap</td>
</tr>
<tr>
<td>SynchronousQueue</td>
<td>bounded</td>
<td>加锁</td>
<td>无</td>
</tr>
<tr>
<td>LinkedTransferQueue</td>
<td>unbounded</td>
<td>加锁</td>
<td>heap</td>
</tr>
<tr>
<td>LinkedBlockingDeque</td>
<td>unbounded</td>
<td>无锁</td>
<td>heap</td>
</tr>
</tbody></table>
<p>下面分别简单介绍一下：</p>
<ul>
<li>ArrayBlockingQueue：是一个用数组实现的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。支持公平锁和非公平锁。【注：每一个线程在获取锁的时候可能都会排队等待，如果在等待时间上，先获取锁的线程的请求一定先被满足，那么这个锁就是公平的。反之，这个锁就是不公平的。公平的获取锁，也就是当前等待时间最长的线程先获取锁】</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界队列，此队列的长度为Integer.MAX_VALUE。此队列按照先进先出的顺序进行排序。</li>
<li>PriorityBlockingQueue： 一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的顺序。</li>
<li>DelayQueue： 一个实现PriorityBlockingQueue实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素。（DelayQueue可以运用在以下应用场景：1.缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。2.定时任务调度。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。）</li>
<li>SynchronousQueue： 一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</li>
<li>LinkedTransferQueue： 一个由链表结构组成的无界阻塞队列，相当于其它队列，LinkedTransferQueue队列多了transfer和tryTransfer方法。</li>
<li>LinkedBlockingDeque： 一个由链表结构组成的双向阻塞队列。队列头部和尾部都可以添加和移除元素，多线程并发时，可以将锁的竞争最多降到一半。</li>
</ul>
<h3 id="ArrayBlockingQueue、LinkedBlockingQueue以及DelayQueue介绍"><a href="#ArrayBlockingQueue、LinkedBlockingQueue以及DelayQueue介绍" class="headerlink" title="ArrayBlockingQueue、LinkedBlockingQueue以及DelayQueue介绍"></a>ArrayBlockingQueue、LinkedBlockingQueue以及DelayQueue介绍</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bjxq-cs88/p/9759571.html">https://www.cnblogs.com/bjxq-cs88/p/9759571.html</a></p>
<h1 id="九、线程安全的集合"><a href="#九、线程安全的集合" class="headerlink" title="九、线程安全的集合"></a>九、线程安全的集合</h1><p>首先要明白线程的工作原理，jvm有一个main memory，而每个线程有自己的working memory，一个线程对一个variable进行操作时，都要在自己的working memory里面建立一个copy，操作完之后再写入main memory。多个线程同时操作同一个variable，就可能会出现不可预知的结果。根据上面的解释，很容易想出相应的scenario。 </p>
<p>而用synchronized的关键是建立一个monitor，这个monitor可以是要修改的variable也可以其他你认为合适的object比如method，然后通过给这个monitor加锁来实现线程安全，每个线程在获得这个锁之后，要执行完load到workingmemory －&gt; use&amp;assign －&gt; store到mainmemory 的过程，才会释放它得到的锁。这样就实现了所谓的线程安全。</p>
<p>什么是线程安全?线程安全是怎么完成的(原理)? <strong>线程安全就是说多线程访问同一代码，不会产生不确定的结果。编写线程安全的代码是低依靠线程同步。</strong></p>
<h2 id="1、早期线程安全的集合"><a href="#1、早期线程安全的集合" class="headerlink" title="1、早期线程安全的集合"></a>1、早期线程安全的集合</h2><h3 id="1、Vector、ArrayList、LinkedList"><a href="#1、Vector、ArrayList、LinkedList" class="headerlink" title="1、Vector、ArrayList、LinkedList"></a>1、Vector、ArrayList、LinkedList</h3><p>Vector和ArrayList在使用上非常相似,都可用来表示一组数量可变的对象应用的集合,并且可以随机地访问其中的元素。  </p>
<p>　　 Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。  </p>
<blockquote>
<p>   【 <strong>ArrayList和LinkedList区别</strong>  】</p>
<p>   　　 对于处理一列数据项,Java提供了两个类ArrayList和LinkedList,ArrayList的内部实现是基于内部数组Object[],所以从概念上讲,它更象数组，但LinkedList的内部实现是基于一组连接的记录,所以,它更像一个链表结构，所以,它们在性能上有很大的差别。  </p>
<p>   　　 从上面的分析可知,在ArrayList的前面或中间插入数据时,你必须将其后的所有数据相应的后移,这样必然要花费较多时间，所以,当你的操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能  </p>
<p>   　　 而访问链表中的某个元素时,就必须从链表的一端开始沿着连接方向一个一个元素地去查找,直到找到所需的元素为止，所以,当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList了。  </p>
<p>   　　 如果在编程中,1，2两种情形交替出现,这时,你可以考虑使用List这样的通用接口,而不用关心具体的实现，在具体的情形下,它的性能由具体的实现来保证。</p>
</blockquote>
<h3 id="2、HashTable-HashMap-HashSet"><a href="#2、HashTable-HashMap-HashSet" class="headerlink" title="2、HashTable,HashMap,HashSet"></a>2、HashTable,HashMap,HashSet</h3><p>HashTable和HashMap采用相同的存储机制，二者的实现基本一致，不同的是：</p>
<p>1)、HashMap是非线程安全的，HashTable是线程安全的，内部的方法基本都是synchronized。</p>
<p>2)、HashTable不允许有null值的存在。</p>
<p>在HashTable中调用put方法时，如果key为null，直接抛出NullPointerException。其它细微的差别还有，比如初始化Entry数组的大小等等，但基本思想和HashMap一样。</p>
<p>HashSet：</p>
<p>1、HashSet基于HashMap实现，无容量限制。</p>
<p>2、HashSet是非线程安全的。 </p>
<p>3、HashSet不保证有序。 </p>
<p>HashMap：</p>
<p>1、HashMap采用数组方式存储key，value构成的Entry对象，无容量限制。</p>
<p>2、HashMap基于Key hash查找Entry对象存放到数组的位置，对于hash冲突采用链表的方式来解决。</p>
<p>3、HashMap在插入元素时可能会要扩大数组的容量，在扩大容量时须要重新计算hash，并复制对象到新的数组中。</p>
<p>4、HashMap是非线程安全的。</p>
<p>5、HashMap遍历使用的是Iterator </p>
<p>HashTable</p>
<p>1、HashTable是线程安全的。</p>
<p>2、HashTable中无论是Key，还是Value都不允许为null。</p>
<p>3、HashTable遍历使用的是Enumeration。 </p>
<p>TreeSet,TreeMap</p>
<p>TreeSet：</p>
<p>1、TreeSet基于TreeMap实现，支持排序。</p>
<p>2、TreeSet是非线程安全的。</p>
<p>   从对HashSet和TreeSet的描述来看，TreeSet和HashSet一样，也是完全基于Map来实现的，并且都不支持get(int)来获取指定位置的元素（需要遍历获取），另外TreeSet还提供了一些排序方面的支持。例如传入Comparator实现、descendingSet以及descendingIterator等。</p>
<p>TreeMap： </p>
<p>1、TreeMap是一个典型的基于红黑树的Map实现，因此它要求一定要有Key比较的方法，要么传入Comparator实现，要么key对象实现Comparable接口。</p>
<p>2、TreeMap是非线程安全的。</p>
<h2 id="2、Collections包装方法"><a href="#2、Collections包装方法" class="headerlink" title="2、Collections包装方法"></a>2、Collections包装方法</h2><p>Vector和HashTable被弃用后，它们被ArrayList和HashMap代替，但它们不是线程安全的，所以Collections工具类中提供了相应的包装方法把它们包装成线程安全的集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; synArrayList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;E&gt;());</span><br><span class="line"></span><br><span class="line">Set&lt;E&gt; synHashSet = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;E&gt;());</span><br><span class="line"></span><br><span class="line">Map&lt;K,V&gt; synHashMap = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;K,V&gt;());</span><br></pre></td></tr></table></figure>

<p>Collections针对每种集合都声明了一个线程安全的包装类，在原集合的基础上添加了锁对象，集合中的每个方法都通过这个锁对象实现同步</p>
<h2 id="3、java-util-concurrent包中的集合"><a href="#3、java-util-concurrent包中的集合" class="headerlink" title="3、java.util.concurrent包中的集合"></a>3、java.util.concurrent包中的集合</h2><p>在java.util.concurrent包中，不但包含了我们本篇要说的线程安全的集合，还涉及到了多线程、CAS、线程锁等相关内容，可以说是完整覆盖了Java并发的知识栈。</p>
<p>对于Java开发人员来说，学好java.util.concurrent包下的内容，是一个必备的功课，也是逐渐提升自己的一个重要阶段。</p>
<h3 id="1-ConcurrentHashMap"><a href="#1-ConcurrentHashMap" class="headerlink" title="1.ConcurrentHashMap"></a>1.ConcurrentHashMap</h3><p>ConcurrentHashMap和HashTable都是线程安全的集合，它们的不同主要是加锁粒度上的不同。HashTable的加锁方法是给每个方法加上synchronized关键字，这样锁住的是整个Table对象。而ConcurrentHashMap是更细粒度的加锁<br>在JDK1.8之前，ConcurrentHashMap加的是分段锁，也就是Segment锁，每个Segment含有整个table的一部分，这样不同分段之间的并发操作就互不影响<br>JDK1.8对此做了进一步的改进，它取消了Segment字段，直接在table元素上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率</p>
<h3 id="2-CopyOnWriteArrayList和CopyOnWriteArraySet"><a href="#2-CopyOnWriteArrayList和CopyOnWriteArraySet" class="headerlink" title="2.CopyOnWriteArrayList和CopyOnWriteArraySet"></a>2.CopyOnWriteArrayList和CopyOnWriteArraySet</h3><p>它们是加了写锁的ArrayList和ArraySet，锁住的是整个对象，但读操作可以并发执行</p>
<h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h3><p>除此之外还有ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue、ConcurrentLinkedDeque等，至于为什么没有ConcurrentArrayList，原因是无法设计一个通用的而且可以规避ArrayList的并发瓶颈的线程安全的集合类，只能锁住整个list，这用Collections里的包装类就能办到</p>
<p>Collection集合：</p>
<p><strong>List：</strong></p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyOnWriteArrayList</span></span><br></pre></td></tr></table></figure>

<p><strong>Set：</strong></p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyOnWriteArraySet</span></span><br><span class="line"><span class="attribute">ConcurrentSkipListSet</span></span><br></pre></td></tr></table></figure>

<p><strong>Queue：</strong></p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">BlockingQueue:</span></span><br><span class="line">    LinkedBlockingQueue</span><br><span class="line">    DelayQueue</span><br><span class="line">    PriorityBlockingQueue</span><br><span class="line">    ConcurrentLinkedQueue</span><br><span class="line"><span class="symbol">    TransferQueue:</span></span><br><span class="line">        LinkedTransferQueue</span><br><span class="line"><span class="symbol">    BlockingDeque:</span></span><br><span class="line">        LinkedBlockingDeque</span><br><span class="line">        ConcurrentLinkedDeque</span><br></pre></td></tr></table></figure>

<p>Map集合：</p>
<p><strong>Map:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ConcurrentMap:</span></span><br><span class="line">    ConcurrentHashMap</span><br><span class="line">    ConcurrentSkipListMap</span><br><span class="line">    ConcurrentNavigableMap</span><br></pre></td></tr></table></figure>

<p>通过以上可以看出，java.util.concurrent包为每一类集合都提供了线程安全的实现。</p>
<p>线程安全有以下几种实现方式：</p>
<h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p>
<p>不可变的类型：</p>
<ul>
<li>final 关键字修饰的基本数据类型</li>
<li>String</li>
<li>枚举类型</li>
<li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li>
</ul>
<p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImmutableExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);</span><br><span class="line">        unmodifiableMap.put(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</span><br><span class="line">    at java.util.Collections$UnmodifiableMap.put(Collections.java:1457)</span><br><span class="line">    at ImmutableExample.main(ImmutableExample.java:9)</span><br></pre></td></tr></table></figure>

<p>Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><p>synchronized 和 ReentrantLock。</p>
<h2 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h2><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p>
<p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<h3 id="1-CAS"><a href="#1-CAS" class="headerlink" title="1. CAS"></a>1. CAS</h3><p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p>
<h3 id="2-AtomicInteger"><a href="#2-AtomicInteger" class="headerlink" title="2. AtomicInteger"></a>2. AtomicInteger</h3><p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。</p>
<p>以下代码使用了 AtomicInteger 执行了自增的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p>
<p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-ABA"><a href="#3-ABA" class="headerlink" title="3. ABA"></a>3. ABA</h3><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p>
<p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p>
<h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p>
<h3 id="1-栈封闭"><a href="#1-栈封闭" class="headerlink" title="1. 栈封闭"></a>1. 栈封闭</h3><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackClosedExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add100</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">StackClosedExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackClosedExample</span>();</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">100</span><br></pre></td></tr></table></figure>

<h3 id="2-线程本地存储（Thread-Local-Storage）"><a href="#2-线程本地存储（Thread-Local-Storage）" class="headerlink" title="2. 线程本地存储（Thread Local Storage）"></a>2. 线程本地存储（Thread Local Storage）</h3><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
<p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p>
<p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p>
<p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p>为了理解 ThreadLocal，先看以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLocal</span> <span class="variable">threadLocal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">        <span class="type">ThreadLocal</span> <span class="variable">threadLocal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">1</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它所对应的底层结构图为：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6782674c-1bfe-4879-af39-e9d722a95d39.png" width="500px"> </div><br>

<p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get() 方法类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p>
<p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p>
<h3 id="3-可重入代码（Reentrant-Code）"><a href="#3-可重入代码（Reentrant-Code）" class="headerlink" title="3. 可重入代码（Reentrant Code）"></a>3. 可重入代码（Reentrant Code）</h3><p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p>
<p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p>
<h1 id="十、锁优化"><a href="#十、锁优化" class="headerlink" title="十、锁优化"></a>十、锁优化</h1><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p>
<p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p>
<p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p>
<p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p>
<p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p>
<p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bb6a49be-00f2-4f27-a0ce-4ed764bc605c.png" width="500"/> </div><br>

<p>下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/051e436c-0e46-4c59-8f67-52d89d656182.png" width="500"/> </div><br>

<p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p>
<p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/baaa681f-7c52-4198-a5ae-303b9386cf47.png" width="400"/> </div><br>

<p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p>
<p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p>
<p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/390c913b-5f31-444f-bbdb-2b88b688e7ce.jpg" width="600"/> </div><br>

<h1 id="十一、Java-内存模型"><a href="#十一、Java-内存模型" class="headerlink" title="十一、Java 内存模型"></a>十一、Java 内存模型</h1><p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p>
<h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h2><p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。</p>
<p>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/942ca0d2-9d5c-45a4-89cb-5fd89b61913f.png" width="600px"> </div><br>

<p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。</p>
<p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15851555-5abc-497d-ad34-efed10f43a6b.png" width="600px"> </div><br>

<h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8b7ebbad-9604-4375-84e3-f412099d170c.png" width="450px"> </div><br>

<ul>
<li>read：把一个变量的值从主内存传输到工作内存中</li>
<li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li>
<li>use：把工作内存中一个变量的值传递给执行引擎</li>
<li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>store：把工作内存的一个变量的值传送到主内存中</li>
<li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li>
<li>lock：作用于主内存的变量</li>
<li>unlock</li>
</ul>
<h2 id="内存模型三大特性"><a href="#内存模型三大特性" class="headerlink" title="内存模型三大特性"></a>内存模型三大特性</h2><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h3><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p>
<p>有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。</p>
<p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。</p>
<p>下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2797a609-68db-4d7b-8701-41ac9a34b14f.jpg" width="300px"> </div><br>

<p>AtomicInteger 能保证多个线程修改的原子性。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dd563037-fcaa-4bd8-83b6-b39d93a12c77.jpg" width="300px"> </div><br>

<p>使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        cnt.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">AtomicExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicExample</span>(); <span class="comment">// 只修改这条语句</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadSize);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000</span><br></pre></td></tr></table></figure>

<p>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicSynchronizedExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">AtomicSynchronizedExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicSynchronizedExample</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadSize);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000</span><br></pre></td></tr></table></figure>

<h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h3><p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p>
<p>主要有三种实现可见性的方式：</p>
<ul>
<li>volatile</li>
<li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li>
<li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li>
</ul>
<p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。</p>
<h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h3><p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p>
<p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p>
<h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p>
<h3 id="1-单一线程原则"><a href="#1-单一线程原则" class="headerlink" title="1. 单一线程原则"></a>1. 单一线程原则</h3><blockquote>
<p>Single Thread rule</p>
</blockquote>
<p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/874b3ff7-7c5c-4e7a-b8ab-a82a3e038d20.png" width="180px"> </div><br>

<h3 id="2-管程锁定规则"><a href="#2-管程锁定规则" class="headerlink" title="2. 管程锁定规则"></a>2. 管程锁定规则</h3><blockquote>
<p>Monitor Lock Rule</p>
</blockquote>
<p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8996a537-7c4a-4ec8-a3b7-7ef1798eae26.png" width="350px"> </div><br>

<h3 id="3-volatile-变量规则"><a href="#3-volatile-变量规则" class="headerlink" title="3. volatile 变量规则"></a>3. volatile 变量规则</h3><blockquote>
<p>Volatile Variable Rule</p>
</blockquote>
<p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/942f33c9-8ad9-4987-836f-007de4c21de0.png" width="400px"> </div><br>

<h3 id="4-线程启动规则"><a href="#4-线程启动规则" class="headerlink" title="4. 线程启动规则"></a>4. 线程启动规则</h3><blockquote>
<p>Thread Start Rule</p>
</blockquote>
<p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6270c216-7ec0-4db7-94de-0003bce37cd2.png" width="380px"> </div><br>

<h3 id="5-线程加入规则"><a href="#5-线程加入规则" class="headerlink" title="5. 线程加入规则"></a>5. 线程加入规则</h3><blockquote>
<p>Thread Join Rule</p>
</blockquote>
<p>Thread 对象的结束先行发生于 join() 方法返回。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/233f8d89-31d7-413f-9c02-042f19c46ba1.png" width="400px"> </div><br>

<h3 id="6-线程中断规则"><a href="#6-线程中断规则" class="headerlink" title="6. 线程中断规则"></a>6. 线程中断规则</h3><blockquote>
<p>Thread Interruption Rule</p>
</blockquote>
<p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p>
<h3 id="7-对象终结规则"><a href="#7-对象终结规则" class="headerlink" title="7. 对象终结规则"></a>7. 对象终结规则</h3><blockquote>
<p>Finalizer Rule</p>
</blockquote>
<p>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p>
<h3 id="8-传递性"><a href="#8-传递性" class="headerlink" title="8. 传递性"></a>8. 传递性</h3><blockquote>
<p>Transitivity</p>
</blockquote>
<p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p>
<h1 id="十二、多线程开发良好的实践"><a href="#十二、多线程开发良好的实践" class="headerlink" title="十二、多线程开发良好的实践"></a>十二、多线程开发良好的实践</h1><ul>
<li><p>给线程起个有意义的名字，这样可以方便找 Bug。</p>
</li>
<li><p>缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。</p>
</li>
<li><p>多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。</p>
</li>
<li><p>使用 BlockingQueue 实现生产者消费者问题。</p>
</li>
<li><p>多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。</p>
</li>
<li><p>使用本地变量和不可变类来保证线程安全。</p>
</li>
<li><p>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>BruceEckel. Java 编程思想: 第 4 版 [M]. 机械工业出版社, 2007.</li>
<li>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.</li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se6/html/Threads.doc.html">Threads and Locks</a></li>
<li><a target="_blank" rel="noopener" href="http://ifeve.com/thread-signaling/#missed_signal">线程通信</a></li>
<li><a target="_blank" rel="noopener" href="http://www.importnew.com/12773.html">Java 线程面试题 Top 50</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html">BlockingQueue</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/11265289/thread-state-java">thread state java</a></li>
<li><a target="_blank" rel="noopener" href="http://wiki.expertiza.ncsu.edu/index.php/CSC_456_Spring_2012/ch7_MN">CSC 456 Spring 2012&#x2F;ch7 MN</a></li>
<li><a target="_blank" rel="noopener" href="https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/happens-before.html">Java - Understanding Happens-before relationship</a></li>
<li><a target="_blank" rel="noopener" href="https://www.slideshare.net/novathinker/6-thread-synchronization">6장 Thread Synchronization</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1202444/how-is-javas-threadlocal-implemented-under-the-hood/15653015">How is Java’s ThreadLocal implemented under the hood?</a></li>
<li><a target="_blank" rel="noopener" href="https://sites.google.com/site/webdevelopart/21-compile/06-java/javase/concurrent?tmpl=/system/app/templates/print/&showPrintDialog=1">Concurrent</a></li>
<li><a target="_blank" rel="noopener" href="http://www.javacreed.com/java-fork-join-example/" title="Java Fork Join Example">JAVA FORK JOIN EXAMPLE</a></li>
<li><a target="_blank" rel="noopener" href="http://ifeve.com/talk-concurrency-forkjoin/">聊聊并发（八）——Fork&#x2F;Join 框架介绍</a></li>
<li>[Eliminating SynchronizationRelated Atomic Operations with Biased Locking and Bulk Rebiasing](</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/11/16/java-%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/16/java-%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">java-并发（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-16 15:47:12" itemprop="dateCreated datePublished" datetime="2021-11-16T15:47:12Z">2021-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="五、线程同步"><a href="#五、线程同步" class="headerlink" title="五、线程同步"></a>五、线程同步</h1><p>  java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p>
<h2 id="1、使用重入锁（Lock）实现线程同步"><a href="#1、使用重入锁（Lock）实现线程同步" class="headerlink" title="1、使用重入锁（Lock）实现线程同步"></a>1、使用重入锁（Lock）实现线程同步</h2><p>​      在<a target="_blank" rel="noopener" href="http://www.2cto.com/kf/ware/Java/">Java</a>SE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。ReenreantLock类的常用方法有：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">ReentrantLock</span><span class="params">()</span></span> : 创建一个ReentrantLock实例         </span><br><span class="line"><span class="function"><span class="title">lock</span><span class="params">()</span></span> : 获得锁        </span><br><span class="line"><span class="function"><span class="title">unlock</span><span class="params">()</span></span> : 释放锁</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只给出要修改的代码，其余代码与上同</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">account</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">            <span class="comment">//需要声明这个锁</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAccount</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> account;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里不再需要synchronized </span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">                lock.lock();<span class="comment">//</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    account += money;</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    lock.unlock();<span class="comment">//解锁线程</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        ｝ </span><br></pre></td></tr></table></figure>

<p><code>lock.lock();</code>确保只有一个线程进入临界区，一旦一个线程进入之后，会获得锁对象，其他线程无法通过lock语句。当其他线程调用lock时，它们会被阻塞，知道第一个线程释放锁对象。</p>
<p><code>lock.unlock();</code>解锁操作，一定要放到finally里，因为如果try语句里出了问题，锁必须被释放，否则其他线程将永远被阻塞</p>
<p><strong>因为系统会随机为线程分配资源，所以在线程获得锁对象之后，可能被系统剥夺运行权，这时候其他线程来访问，但是发现有锁，进不去，只能等拿到锁对象的线程把里面的代码执行完毕后，释放锁，第二个线程才能运行。</strong></p>
<h2 id="2、synchronzied关键字"><a href="#2、synchronzied关键字" class="headerlink" title="2、synchronzied关键字"></a>2、synchronzied关键字</h2><p>前面我们讲了ReentrantLock锁对象的使用，但是在系统里面我们不一定要使用ReentrantLock锁，Java中还提供了一个内部的<strong>隐式锁</strong>，关键字是<strong>synchronized</strong>.</p>
<p>举个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">Method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//do some work...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>synchronized关键字说明</strong>：</p>
<p>　　总的说来，synchronized关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果再细的分类，synchronized可作用于instance变量（成员变量）、object reference（对象实例引用）、static函数和class literals(类名称字面常量)身上。</p>
<p>在进一步阐述之前，我们需要明确几点：</p>
<ul>
<li><p><strong>无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁</strong>――而且同步方法很可能还会被其他线程的对象访问。</p>
</li>
<li><p><strong>每个对象只有一个锁（lock）与之相关联</strong>。JVM会给类的每个实例化的对象赋予一个单独的锁。</p>
</li>
<li><p>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</p>
</li>
</ul>
<p>　　注意：在同步块和同步方法中，是给类或类的对象进行加锁，而不是给方法加锁。所谓的需要获得对象的锁才能执行方法，也是针对线程而言的。</p>
<p><strong>synchronized 方法：</strong></p>
<p>通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">         <span class="built_in">this</span>.name = name;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　synchronized方法控制对类成员变量的访问：每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变量的方法均被声明为 synchronized）。</p>
<p>　　在 Java 中，不光是类实例，每一个类也对应一把锁，这样我们也可将类的静态成员函数声明为 synchronized ，以控制其对类的静态成员变量的访问。</p>
<p>　　synchronized 方法的缺陷：<strong>若将一个大的方法声明为synchronized 将会大大影响效率</strong>，典型地，若将线程类的方法 run()声明为 synchronized ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何 synchronized 方法的调用都永远不会成功。</p>
<p>synchronized 块：</p>
<p>　　synchronized 块是这样一个代码块，其中的代码必须获得对象 syncObject （如前所述，可以是类实例或类）的锁方能执行，具体机制同前所述。由于可以针对任意代码块，且可任意指定上锁的对象，故灵活性较高。</p>
<p>　　通过 synchronized关键字来声明synchronized 块。语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(syncObject)&#123;　　</span><br><span class="line">    <span class="comment">//允许访问控制的代码　　</span></span><br><span class="line">&#125;　</span><br></pre></td></tr></table></figure>

<p><strong>3. 同步一个类</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SynchronizedExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedExample</span>();</span><br><span class="line">    <span class="type">SynchronizedExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedExample</span>();</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func2());</span><br><span class="line">    executorService.execute(() -&gt; e2.func2());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>



<p><strong>synchronized (this)的理解说明</strong></p>
<ul>
<li><strong>当一个线程正在执行object的一个synchronized(this)同步代码块时，该线程就获得了这个object的对象锁。</strong></li>
<li><strong>当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</strong>　　</li>
<li><strong>当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。</strong>　　</li>
<li><strong>但是，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的除synchronized(this)同步代码块以外的部分。</strong></li>
</ul>
<p><strong>总结</strong>：</p>
<p><strong>同步块、同步方法的锁定说明：</strong></p>
<ul>
<li><strong>对于同步的方法或者代码块来说，必须获得对象锁才能够进入同步方法或者代码块进行操作；</strong></li>
<li><strong>如果采用普通方法级别的同步，则对象锁即为该方法所在的对象，如果是静态方法，对象锁即指该方法所在的类的锁（类的锁，对所有实例化对象都是唯一的）。</strong></li>
<li><strong>对于代码块，对象锁即指synchronized(obj)中的obj；</strong></li>
<li><strong>静态方法则一定会同步，非静态方法需在单例模式才生效，推荐用静态方法</strong></li>
</ul>
<h3 id="实现同步的一些技巧"><a href="#实现同步的一些技巧" class="headerlink" title="实现同步的一些技巧"></a>实现同步的一些技巧</h3><p>　　搞清楚synchronized锁定的是哪个对象，就能帮助我们设计更安全的多线程程序。 还有一些技巧可以让我们对共享资源的同步访问更加安全：</p>
<ul>
<li>定义private的instance变量(成员变量)+对应的get()方法，而不要定义public&#x2F;protected的instance变量。如果将变量定义为public，对象在外界可以绕过同步方法的控制而直接取得它，并改动它。这也是JavaBean的标准实现方式之一。</li>
<li>如果instance变量是一个对象（如数组或ArrayList），那上述方法仍然不安全，因为当外界对象通过get()方法拿到这个instance对象的引用后，又将其指向另一个对象，那么这个private变量也就变了，岂不是很危险。这个时候就需要将get()方法也加上synchronized同步，并且，只返回这个private对象的clone()，这样，调用端得到的就是对象副本的引用了。</li>
<li>还有，比较常用的就有：Collections.synchronizedMap(new HashMap())，当然这个MAP就是生命在类中的全局变量，就是一个线程安全的HashMap，web的application是全web容器公用的，所以要使用线程安全来保证数据的正确。</li>
</ul>
<p>ava中多线程锁释放的条件：</p>
<ul>
<li>执行完同步代码块，就会释放锁。（synchronized）</li>
<li>在执行同步代码块的过程中，遇到异常而导致线程终止，锁也会被释放。（exception）</li>
<li>在执行同步代码块的过程中，执行了锁所属对象的wait()方法，这个线程会释放锁，进入对象的等待池。(wait)</li>
</ul>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><strong>1. 锁的实现</strong>  </p>
<p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p>
<p><strong>2. 性能</strong>  </p>
<p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p>
<p><strong>3. 等待可中断</strong>  </p>
<p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
<p>ReentrantLock 可中断，而 synchronized 不行。</p>
<p><strong>4. 公平锁</strong>  </p>
<p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p>
<p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>
<p><strong>5. 锁绑定多个条件</strong>  </p>
<p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p>
<h2 id="3、Conditional条件对象"><a href="#3、Conditional条件对象" class="headerlink" title="3、Conditional条件对象"></a>3、Conditional条件对象</h2><p>通常，线程拿到锁对象之后，却发现需要满足某一条件才能继续向下执行。</p>
<p>拿银行程序来举例子，我们需要转账方账户有足够的资金才能转出到目标账户，这时候需要用到ReentrantLock对象，因为如果我们已经完成转账方账户有足够的资金的判断之后，线程被其他线程中断，等其他线程执行完之后，转账方的钱又没有了足够的资金，这时候因为系统已经完成了判断，所以会继续向下执行，然后银行系统就会出现问题。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Accounts[from] &gt; amount)<span class="comment">//系统在结束判断之后被剥夺运行权,然后账户通过网银转出所有钱,银行凉凉</span></span><br><span class="line">        DoTransfer(from, to, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候我们就需要使用ReentrantLock对象了，我们修改一下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    locker.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (Accounts[from] &lt; amount) &#123;</span><br><span class="line">            <span class="comment">//等待有足够的钱</span></span><br><span class="line">        &#125;</span><br><span class="line">        DoTransfer(from, to, amount);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        locker.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样又有了问题，当前线程获取了锁对象之后，开始执行代码，发现钱不够，进入等待状态，然后其他线程又因为锁的原因无法给该账户转账，就会一直进入等待状态。</p>
<p>这个问题如何解决呢？</p>
<p>条件对象登场！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">sufficientFunds</span> <span class="operator">=</span> locker.newCondition();<span class="comment">//条件对象，</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (Accounts[from] &lt; amount) &#123;</span><br><span class="line">            sufficientFunds.await();</span><br><span class="line">            <span class="comment">//等待有足够的钱</span></span><br><span class="line">        &#125;</span><br><span class="line">        DoTransfer(from, to, amount);</span><br><span class="line">        sufficientFunds.signalAll();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        locker.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>条件对象的关键字是:<strong>Condition</strong>，<strong>一个锁对象可以有一个或多个相关的条件对象</strong>。可以通过锁对象.newCondition方法获得一个条件对象.</p>
<p>在进入锁之前，我们创建一个条件，然后如果金额不足，在这里调用条件对象的<strong>await</strong>方法，通知系统当前线程进入<strong>挂起状态</strong>，让其他线程执行。这样你这次调用会被锁定，然后系统可以再次调用该方法给其他账户转账，当每一次转账完成后，执行转账操作的线程在底部调用<strong>signalAll</strong>通知所有线程可以继续运行了，因为我们有可能是转足够的钱给当前账户，这时候有可能该线程会继续执行（不一定是你，是通知所有线程，如果通知的线程还是不符合条件，会继续调用<strong>await</strong>方法，并完成转账操作，然后<strong>通知其他挂起的线程。</strong></p>
<p>你说为啥不直接通知当前线程？不行，可以调用<strong>signal</strong>方法只通知一个线程，但是如果这个线程操作的账户还是没钱（不是转账给这个账户的情况），那这个线程又进入等待了，这时候已经没有线程能通知其他线程了，程序死锁，所以还是用signal比较保险。</p>
<p>以上是使用<strong>ReentrantLock</strong>+<strong>Condition</strong>对象，那你说我要是使用<strong>synchronized</strong>隐式锁怎么办？</p>
<p>也可以，而且不需要</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">     <span class="keyword">while</span> (Accounts[from] &lt; amount) &#123;</span><br><span class="line">            wait();<span class="comment">//这个wait方法是定义在Object类里面的，可以直接用，和条件对象的await一样，挂起线程</span></span><br><span class="line">            <span class="comment">//等待有足够的钱</span></span><br><span class="line">        &#125;</span><br><span class="line">        DoTransfer(from, to, amount);</span><br><span class="line">        notifyAll();<span class="comment">//通知其他挂起的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Object类里面定义了wait、notifyAll、notify方法，对应await、signalAll和signal方法，用来操作隐式锁，<strong>synchronized只能有一个条件，而ReentrantLock显式声明的锁可以用绑定多个Condition条件.</strong></p>
<h2 id="4、同步代码块"><a href="#4、同步代码块" class="headerlink" title="4、同步代码块"></a>4、同步代码块</h2><p> 即有synchronized关键字修饰的语句块。</p>
<p>被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(SomeObject obj)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;    <span class="comment">//锁定的是对象obj的对象锁</span></span><br><span class="line">       <span class="comment">//…..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，锁就是obj这个对象，谁拿到这个锁谁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以按以上方式来写程序；当没有明确的对象作为锁时，但还想让一段代码同步时，可以创建一个特殊的instance变量（必须是一个对象）来充当锁，此时代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] lock = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>]; <span class="comment">// 特殊的instance变量；也可以用String常量作为锁</span></span><br><span class="line">        Public <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span>(lock) &#123; <span class="comment">//… &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//…..</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">synchronized</span> (locker) &#123;</span><br><span class="line">*<span class="comment">//do some work*</span></span><br><span class="line">&#125;</span><br><span class="line">*<span class="comment">//也可以直接锁当前类的对象*</span></span><br><span class="line">sychronized(<span class="built_in">this</span>)&#123;</span><br><span class="line">*<span class="comment">//do some work*</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码会获得Object类型locker对象的锁，这种锁是一个特殊的锁，在上面的代码中，创建这个Object类对象只是单纯用来使用其持有的锁.</p>
<p>这种机制叫做<strong>同步块</strong>，应用场景也很广：有的时候，我们并不是整个一个方法都需要同步，只是方法里的部分代码块需要同步，这种情况下，我们如果将这个方法声明为<strong>synchronized</strong>，尤其是方法很大的时候，会造成很大的资源浪费。所以在这种情况下我们可以使用<strong>synchronized</strong>关键字来声明同步块:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//do some work without synchronized</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">//do some synchronized operation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> &#123;  </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">0</span>;<span class="comment">//账户余额  </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存钱  </span></span><br><span class="line">    <span class="keyword">public</span>   <span class="keyword">void</span> <span class="title function_">addMoney</span><span class="params">(<span class="type">int</span> money)</span>&#123;  </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;  </span><br><span class="line">            count +=money;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(System.currentTimeMillis()+<span class="string">&quot;存进：&quot;</span>+money);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//取钱  </span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">subMoney</span><span class="params">(<span class="type">int</span> money)</span>&#123;  </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(count-money &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;余额不足&quot;</span>);  </span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            count -=money;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(+System.currentTimeMillis()+<span class="string">&quot;取出：&quot;</span>+money);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//查询  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lookMoney</span><span class="params">()</span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;账户余额：&quot;</span>+count);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。</p>
<h2 id="5、监视器的概念"><a href="#5、监视器的概念" class="headerlink" title="5、监视器的概念"></a>5、监视器的概念</h2><p>锁和条件是同步中一个很重要的工具，但是它们并不是面向对象的。多年来，Java的研究人员努力寻找一种方法，可以在不需要考虑如何加锁的情况下，就能保证多线程的安全性。最成功的的一个解决方案叫做<strong>monitor</strong>监视器，<strong>这个对象内置于每一个Object变量中，相当于一个许可证。拿到许可证就可以进行操作，没有拿到则需要阻塞等待。</strong></p>
<p>监视器具有以下特性:</p>
<p><strong>1.监视器是只包含私有域的类</strong></p>
<p><strong>2.每个监视器对象都有一个相关的锁</strong></p>
<p><strong>3.使用监视器对象的锁对所有的方法进行加锁</strong>（举个例子:如果调用<strong>obj.Method</strong>方法，<strong>obj对象的锁会在方法调用的时候自动获得</strong>，当<strong>方法结束或返回之后会自动释放该锁</strong>。<strong>因为所有的域都是私有的，这样可以确保一个线程在操作类对象的时候，没有其他线程可以访问里面的域</strong>）</p>
<p><strong>4.该锁对象可以有任意多个相关条件</strong></p>
<p>其实我们使用的<strong>synchronized</strong>关键字就是使用了<strong>monitor</strong>来实现<strong>加锁解锁</strong>，所以又被称为<strong>内部锁</strong>。<strong>因为Object类实现了监视器，所以对象又被内置于任何一个对象之中。</strong>这就是我们为什么可以使用<strong>synchronized(locker)<strong>的方式锁定一个代码块了，其实只是用到了locker对象中内置的monitor而已。</strong>每一个对象的monitor类又是唯一的，所以就是唯一的许可证，拿到许可证的线程才可以执行，执行完后释放对象的monitor才可以被其他线程获取。</strong></p>
<p>举个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">//do some synchronized operation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它在字节码文件中会被编译为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">monitorenter;<span class="comment">//get monitor，enter the synchronized block</span></span><br><span class="line">            <span class="comment">//do some synchronized operation</span></span><br><span class="line">monitorexit;<span class="comment">//leavel the synchronized block,release the monitor</span></span><br></pre></td></tr></table></figure>

<h2 id="6、死锁"><a href="#6、死锁" class="headerlink" title="6、死锁"></a>6、死锁</h2><p>产生死锁的必要条件：</p>
<p>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。<br>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。<br>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。<br>环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。</p>
<blockquote>
<p>为什么倾向于使用signalAll和notifyAll方式，如果假设使用signal和notify，随机选择的线程发现自己还是不能运行，那么它再次被阻塞。这样就又会造成死锁现象。</p>
</blockquote>
<h2 id="7、锁测试和超时"><a href="#7、锁测试和超时" class="headerlink" title="7、锁测试和超时"></a>7、锁测试和超时</h2><p>线程在调用lock方法获得另一个线程持有的锁的时候，很可能发生阻塞。<strong>应该更加谨慎的申请锁，tryLock方法试图申请一个锁，如果申请成功，返回true，否则，立刻返回false，线程就会离开去做别的事，而不是被阻塞等待锁对象。</strong></p>
<p>语法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">if</span> (locker.tryLock()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do some work</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        locker.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//do other work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以给其指定超时参数，单位有<strong>SECONDS</strong>、<strong>MILLISECONDS</strong>、<strong>MICROSEONDS</strong>和<strong>MANOSECONDS</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">if</span> (locker.tryLock(<span class="number">1000</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do some work</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        locker.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//do other work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lock方法不能被中断，如果一个线程在调用了lock方法后等待锁的时候被中断，中断线程在获得锁之前一直处于阻塞状态。</p>
<p>如果带有超时参数的<strong>tryLock</strong>方法,那么如果等待期间线程被中断，会抛出InterruptedException异常，这是一个很好的特性，允许程序打破死锁。</p>
<h2 id="8、读写锁"><a href="#8、读写锁" class="headerlink" title="8、读写锁"></a>8、读写锁</h2><p><strong>eentrantLock</strong>类属于<strong>java.util.concurrent.locks</strong>包，这个包底下还有一个<strong>ReentrantReaderWriterLock</strong>类，如果使用多线程对数据读的操作很多，但是写的操作很少的话，可以使用这个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>():</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Read</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">readLocker</span> <span class="operator">=</span> rwl.readLock();<span class="comment">//创建读取锁对象</span></span><br><span class="line">    readLocker.lock();<span class="comment">//使用读取锁对象加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do some work</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLocker.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Write</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">writeLocker</span> <span class="operator">=</span> rwl.writeLock();<span class="comment">//创建写入锁对象</span></span><br><span class="line">    writeLocker.lock();<span class="comment">//使用写入锁对象加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do some work</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        writeLocker.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9、使用特殊域变量-volatile-实现线程同步"><a href="#9、使用特殊域变量-volatile-实现线程同步" class="headerlink" title="9、使用特殊域变量(volatile)实现线程同步"></a>9、使用特殊域变量(volatile)实现线程同步</h2><p>   • volatile关键字为域变量的访问提供了一种免锁机制；</p>
<p>   • 使用volatile修饰域相当于告诉<a target="_blank" rel="noopener" href="http://www.2cto.com/os/xuniji/">虚拟机</a>该域可能会被其他线程更新；</p>
<p>   • 因此每次使用该域就要重新计算，而不是使用寄存器中的值；</p>
<p>   • volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedThread</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">account</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAccount</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> account;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 用同步方法实现</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">               account += money;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 用同步代码块实现</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save1</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                   account += money;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">class</span> <span class="title class_">NewThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">           <span class="keyword">private</span> Bank bank;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">public</span> <span class="title function_">NewThread</span><span class="params">(Bank bank)</span> &#123;</span><br><span class="line">               <span class="built_in">this</span>.bank = bank;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                   <span class="comment">// bank.save1(10);</span></span><br><span class="line">                   bank.save(<span class="number">10</span>);</span><br><span class="line">                   System.out.println(i + <span class="string">&quot;账户余额为：&quot;</span> +bank.getAccount());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 建立线程，调用内部类</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useThread</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">           <span class="type">NewThread</span> <span class="variable">new_thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewThread</span>(bank);</span><br><span class="line">           System.out.println(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">           <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(new_thread);</span><br><span class="line">           thread1.start();</span><br><span class="line">           System.out.println(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">           <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(new_thread);</span><br><span class="line">           thread2.start();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">           <span class="type">SynchronizedThread</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedThread</span>();</span><br><span class="line">           st.useThread();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用final域，有锁保护的域和volatile域可以避免非同步的问题。</p>
<h2 id="10、final变量"><a href="#10、final变量" class="headerlink" title="10、final变量"></a>10、final变量</h2><p>上一节已经了解到，除非使用锁或volatile修饰符，否则无法从多个线程安全地读取一个域。</p>
<p>还有一种情况可以安全地访问一个共享域，即这个域声明为final时。考虑以下声明：</p>
<p>finalMap&lt;String,Double〉accounts&#x3D;newHashKap&lt;&gt;0；</p>
<p>其他线程会在构造函数完成构造之后才看到这个accounts变量。</p>
<p>如果不使用final，就不能保证其他线程看到的是accounts更新后的值，它们可能都只是看到null,而不是新构造的HashMap。</p>
<p>当然，对这个映射表的操作并不是线程安全的。如果多个线程在读写这个映射表，仍然需要进行同步</p>
<h2 id="11、线程的局部变量"><a href="#11、线程的局部变量" class="headerlink" title="11、线程的局部变量"></a>11、线程的局部变量</h2><p>线程间有时要避免共享变量，使用ThreadLocal辅助类为各个线程提供各自的实例。</p>
<p>例如，SimpleDateFormat类不是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>如果两个线程都执行以下操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">dateStamp</span> <span class="operator">=</span> dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure>


<p>结果可能很混乱，因为dateFormat使用的内部数据结构可能会被并发的访问所破坏。当然可以使用同步，但开销很大；或者也可以在需要时构造一个局部SimpleDateFormat对象，不过这也太浪费了。</p>
<p>要为每个线程构造一个实例，可以使用以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormat = </span><br><span class="line">ThreadLocal.withInitial(()-&gt;<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>要访问具体的格式化方法，可以调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">dateStamp</span> <span class="operator">=</span> dateFormat.get().format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure>


<p>在一个给定线程中首次调用get时，会调用initialValue方法。在此之后，get方法会返回属于当前线程的那个实例。</p>
<p>在多个线程中生成随机数也存在类似的问题。java.util.Random类是线程安全的。但是如果多个线程需要等待一个共享的随机数生成器，这会很低效。</p>
<p>可以使用ThreadLocal辅助类为各个线程提供一个单独的生成器，不过Java SE 7还另外提供了一个便利类。只需要做以下调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(upperBound);</span><br></pre></td></tr></table></figure>


<p>ThreadLocalRandom.current()调用会返回特定于当前线程的Random类实例。</p>
<h1 id="六、线程通信"><a href="#六、线程通信" class="headerlink" title="六、线程通信"></a>六、线程通信</h1><h2 id="1、借助于Object类的wait-、notify-和notifyAll-实现通信"><a href="#1、借助于Object类的wait-、notify-和notifyAll-实现通信" class="headerlink" title="1、借助于Object类的wait()、notify()和notifyAll()实现通信"></a>1、借助于Object类的wait()、notify()和notifyAll()实现通信</h2><p>​     线程执行wait()后，就放弃了运行资格，处于冻结状态；</p>
<p>​     线程运行时，内存中会建立一个线程池，冻结状态的线程都存在于线程池中，notify()执行时唤醒的也是线程池中的线程，线程池中有多个线程时唤醒第一个被冻结的线程。<br>​      notifyall(), 唤醒线程池中所有线程。<br><strong>注：</strong> （1） wait(), notify(),notifyall()都用在同步里面，因为这3个函数是对持有锁的线程进行操作，而只有同步才有锁，所以要使用在同步中；<br>​       （2） wait(),notify(),notifyall(),  在使用时必须标识它们所操作的线程持有的锁，因为等待和唤醒必须是同一锁下的线程；而锁可以是任意对象，所以这3个方法都是Object类中的方法。</p>
<p>单个消费者生产者例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span>&#123;  <span class="comment">//生产者和消费者都要操作的资源  </span></span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> flag=<span class="literal">false</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String name)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(flag)  </span><br><span class="line">            <span class="keyword">try</span>&#123;wait();&#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;  </span><br><span class="line">        <span class="built_in">this</span>.name=name+<span class="string">&quot;---&quot;</span>+count++;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...生产者...&quot;</span>+<span class="built_in">this</span>.name);  </span><br><span class="line">        flag=<span class="literal">true</span>;  </span><br><span class="line">        <span class="built_in">this</span>.notify();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(!flag)  </span><br><span class="line">            <span class="keyword">try</span>&#123;wait();&#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...消费者...&quot;</span>+<span class="built_in">this</span>.name);  </span><br><span class="line">        flag=<span class="literal">false</span>;  </span><br><span class="line">        <span class="built_in">this</span>.notify();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Resource res;  </span><br><span class="line">    Producer(Resource res)&#123;  </span><br><span class="line">        <span class="built_in">this</span>.res=res;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;  </span><br><span class="line">            res.set(<span class="string">&quot;商品&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Resource res;  </span><br><span class="line">    Consumer(Resource res)&#123;  </span><br><span class="line">        <span class="built_in">this</span>.res=res;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;  </span><br><span class="line">            res.out();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerDemo</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;  </span><br><span class="line">        Resource r=<span class="keyword">new</span> <span class="title class_">Resource</span>();  </span><br><span class="line">        Producer pro=<span class="keyword">new</span> <span class="title class_">Producer</span>(r);  </span><br><span class="line">        Consumer con=<span class="keyword">new</span> <span class="title class_">Consumer</span>(r);  </span><br><span class="line">        Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(pro);  </span><br><span class="line">        Thread t2=<span class="keyword">new</span> <span class="title class_">Thread</span>(con);  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;<span class="comment">//运行结果正常，生产者生产一个商品，紧接着消费者消费一个商品。</span></span><br></pre></td></tr></table></figure>



<h1 id="七、同步器J-U-C-AQS"><a href="#七、同步器J-U-C-AQS" class="headerlink" title="七、同步器J.U.C-AQS"></a>七、同步器J.U.C-AQS</h1><p><strong>多线程并发的执行，之间通过某种 共享 状态来同步，只有当状态满足 xxxx 条件，才能触发线程执行 xxxx 。这个共同的语义可以称之为同步器。</strong></p>
<p>可以认为以上所有的锁机制都可以基于同步器定制来实现的。</p>
<p>而juc(java.util.concurrent)里的思想是 将这些场景抽象出来的语义通过统一的同步框架来支持。</p>
<p>juc 里所有的这些锁机制都是基于 AQS （ AbstractQueuedSynchronizer ）框架上构建的。下面简单介绍下 AQS（ AbstractQueuedSynchronizer ）。 可以参考Doug Lea的论文The java.util.concurrent Synchronizer Framework（<a target="_blank" rel="noopener" href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf%EF%BC%89">http://gee.cs.oswego.edu/dl/papers/aqs.pdf）</a></p>
<p>Java中多线程开发时，离不开线程的分工协作，常用的多线程的同步器有如下几种：</p>
<h2 id="1、CountDownLatch（倒计时门闩）"><a href="#1、CountDownLatch（倒计时门闩）" class="headerlink" title="1、CountDownLatch（倒计时门闩）"></a>1、CountDownLatch（倒计时门闩）</h2><p>应用场景：等待一组线程任务完成后在继续执行当前线程。</p>
<p>用法：定义一个CountDownLatch变量latch，在当前线程中调用latch.await()方法，在要等待的一组线程中执行完后调用latch.countDown(）方法，这样当该线程都调用过latch.countDown（）方法后就开始执行当前线程latch.await()后的方法。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ba078291-791e-4378-b6d1-ece76c2f0b14.png" width="300px"> </div><br>

<p> <strong>倒计时门闩会导致一条或多条线程在“门口”一直等待，直到另一条线程打开这扇门，线程才得以继续运行。</strong>他是由一个计数变量和两个操作组成的，这两个操作分别是“导致一条线程等待直到。</p>
<p>计数变为0”以及“递减计数变量”。</p>
<p><img src="https://i.loli.net/2021/11/22/MsL1UAKey8XDptn.png"></p>
<p>例如：</p>
<p>以下代码是用倒计时门闩实现的一个是所有线程同时执行同时结束之后，才能继续执行主线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NTHREADS</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">startSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">doneSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(NTHREADS);</span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入等待&quot;</span>);</span><br><span class="line">					startSignal.await();<span class="comment">//3个线程进入等待，直到startSignal.countDown()被调用</span></span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始执行任务&quot;</span>);</span><br><span class="line">					Thread.sleep(<span class="number">200</span>);</span><br><span class="line">					doneSignal.countDown();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(NTHREADS);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NTHREADS; i++) &#123;</span><br><span class="line">			es.execute(r);</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				startSignal.countDown();</span><br><span class="line">                <span class="comment">//3个线程全部开始执行任务，主线程进入等待</span></span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入等待&quot;</span>);</span><br><span class="line">                <span class="comment">//直到3个线程全部结束任务，doneSignal.countDown()被调用，主线程开始执行</span></span><br><span class="line">				doneSignal.await();</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">				es.shutdownNow();</span><br><span class="line">				</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、CyclicBarrier（同步屏障）"><a href="#2、CyclicBarrier（同步屏障）" class="headerlink" title="2、CyclicBarrier（同步屏障）"></a>2、CyclicBarrier（同步屏障）</h2><p>应用场景：等待一组线程到达某个点后一起执行，该组线程达到指定点后可以再次循环执行。也可用于一组线程达达某个点后再执行某个方法。</p>
<blockquote>
<p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p>
</blockquote>
<p>用法：定义一个CyclicBarrier变量barrier，线程达到某个约定点时调用barrier.await（）方法，当该组所有线程都调用了barrier.await()方法后改组线程一起向下执行。</p>
<p>CyclicBarrier和CountDownLatch的区别</p>
<ul>
<li>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。</li>
<li>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。</li>
</ul>
<p><strong>若有多条线程，他们到达屏障时将会被阻塞，只有当所有线程都到达屏障时才能打开屏障，</strong></p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f71af66b-0d54-4399-a44b-f47b58321984.png" width="300px"> </div><br>

<p>所有线程同时执行，若有这样的需求可以使用同步屏障。此外，当屏障打开的同时还能指定执行的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建同步屏障对象，并制定需要等待的线程个数 和 打开屏障时需要执行的任务</span></span><br><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>,<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//当所有线程准备完毕后触发此任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 启动三条线程</span></span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++ )&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>( <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="comment">// 等待，（每执行一次barrier.await，同步屏障数量-1，直到为0时，打开屏障）</span></span><br><span class="line">            barrier.await();</span><br><span class="line">            <span class="comment">// 任务</span></span><br><span class="line">            任务代码……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>倒计时门闩 与 同步屏障 的区别 倒计时门闩只会阻塞一条线程，目的是为了让该条任务线程满足条件后执行；</p>
<p> 而同步屏障会阻塞所有线程，目的是为了让所有线程同时执行</p>
<h2 id="3、Semaphore（信号量）"><a href="#3、Semaphore（信号量）" class="headerlink" title="3、Semaphore（信号量）"></a>3、Semaphore（信号量）</h2><p>应用场景：对于一组有限制都资源访问。比如餐厅有5个位置但同时有7个人要吃饭，则要控制7个人对餐位的并发实用。</p>
<p>用法：定义Semaphore变量semaphore包含受限的资源个数，每个人要来用餐时先调用semaphore.acquire()方法获取一个餐位（若没有餐位，则阻塞等待），用完餐后调用semaphore.release()释放餐位给其它人用。</p>
<p><strong>信号量维护了一组许可证，以约束访问被限制资源的线程数。当没有可用</strong></p>
<p><strong>的许可证时，线程的获取尝试会一直阻塞，直到其它的线程释放一个许可证。</strong></p>
<p>【信号量<br>    一个信号量管理多个许可证。<strong>为了通过信号量，线程通过调用acquire()请求许可</strong>。其实没有实际的许可对象，信号连也仅仅是维护一个计数器。<br>    <strong>许可的数目是固定的，由此限制了线程通过的数量</strong>。<strong>当一个线程执行完之后，应该调用release()释放许可证，让其他线程有机会执行</strong>。事实上，<br>    任意一个线程都有可以释放任意个数的许可证，这可能会增加许可证的个数。所以我建议，如果不是非常明确的知道为什么要释放多个许可证，就一定<br>    是让获得许可证的线程是放一个许可证。</p>
<p>【常用方法<br>    1.构造函数：<br>    　　Semaphore(int permits)：创建具有给定许可数和非公平设置的Semaphore</p>
<p>​    　　Semaphore(int permits，boolean fair)：此类的构造方法可选地接受一个公平 参数。当设置为 false 时(默认也是false)，此类不对线程获取许可的顺序做任何保证。</p>
<p>​        特别地，闯入是允许的，也就是说可以在已经等待的线程前为调用 acquire() 的线程分配一个许可，从逻辑上说，就是新线程将自己置于等待线程队列的头部。<br>​        当公平设置为 true 时，信号量保证对于任何调用获取方法的线程而言，都按照处理它们调用这些方法的顺序（即先进先出；FIFO）来选择线程、获得许可。<br>​        注意，FIFO 排序必然应用到这些方法内的指定内部执行点。所以，可能某个线程先于另一个线程调用了 acquire，但是却在该线程之后到达排序点，并且从方法返回时也类似。</p>
<p>2.Semaphore还提供一些其他方法：<br>        int availablePermits() ：返回此信号量中当前可用的许可证数。<br>        int getQueueLength()：返回正在等待获取许可证的线程数。<br>        boolean hasQueuedThreads() ：是否有线程正在等待获取许可证。<br>        void reducePermits(int reduction) ：减少reduction个许可证。是个protected方法。<br>        Collection getQueuedThreads() ：返回所有等待获取许可证的线程集合。是个protected方法。</p>
<p>【补充<br>    当许可证的个数为1时，可以充当互斥锁使用。</p>
<p>示例代码：</p>
<p>只能同时有5个线程访问的信号量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="comment">// 创建信号量对象，并给予3个资源Semaphore semaphore = new Semaphore(3);// 开启10条线程for ( int i=0; i&lt;10; i++ ) &#123;    new Thread( new Runnbale()&#123;        public void run()&#123;            // 获取资源，若此时资源被用光，则阻塞，直到有线程归还资源            semaphore.acquire();            // 任务代码            ……            // 释放资源            semaphore.release();        &#125;    &#125; ).start();&#125;`</span></span><br></pre></td></tr></table></figure>

<h2 id="4、Exchanger交换器"><a href="#4、Exchanger交换器" class="headerlink" title="4、Exchanger交换器"></a>4、Exchanger<T>交换器</h2><p><img src="https://i.loli.net/2021/11/22/kbPTMqx5AvcmYZu.png"></p>
<ul>
<li>交换值是同步的；</li>
<li>成对的线程之间交换数据；</li>
<li>可看成是双向的同步队列；</li>
<li>可应用于演算法、流水线设计；</li>
</ul>
<p>Exchanger<V>类中的主要方法就是：exchange(V x)方法，<strong>成对的两个线程之间，都调用了该方法，就能在两个线程彼此都准备好数据后，成功的交换数据给对方，然后各自返回。</strong>如果想支持成对的两个线程之间，一个没耐性，等的时间过长，或者被打断了就不交换数据了，可以使用exchange(V x, long timeout, TimeUnit unit)方法。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//球线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BallTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Exchanger&lt;String&gt; e;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BallTask</span><span class="params">(Exchanger&lt;String&gt; e)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.e = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sleepTime</span> <span class="operator">=</span> (<span class="type">long</span>)(Math.random() * <span class="number">2500</span>) ;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        System.out.println(tName+<span class="string">&quot;正在买球,用时[&quot;</span>+sleepTime+<span class="string">&quot;]才买到球,赶紧去换鱼...&quot;</span>);</span><br><span class="line">        Thread.sleep(sleepTime);</span><br><span class="line">        <span class="comment">//这里的str即为交换的东西</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> e.exchange(tName+<span class="string">&quot;:的球&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;【&quot;</span>+tName+<span class="string">&quot;:的球】换到了--&gt;【&quot;</span>+str+<span class="string">&quot;】&quot;</span>);</span><br><span class="line">		&#125;	</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鱼线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FishTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Exchanger&lt;String&gt; e;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FishTask</span><span class="params">(Exchanger&lt;String&gt; e)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.e = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sleepTime</span> <span class="operator">=</span> (<span class="type">long</span>)(Math.random() * <span class="number">2500</span>) ;</span><br><span class="line">                <span class="type">String</span> <span class="variable">tName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            System.out.println(tName+<span class="string">&quot;正在钓鱼,用时[&quot;</span>+sleepTime+<span class="string">&quot;]才钓到鱼,赶紧去换球...&quot;</span>);</span><br><span class="line">            Thread.sleep(sleepTime);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> e.exchange(tName+<span class="string">&quot;:的鱼&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;【&quot;</span>+tName+<span class="string">&quot;:的鱼】换到了--&gt;【&quot;</span>+str+<span class="string">&quot;】&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangerTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">	Exchanger&lt;String&gt; e = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="type">BallTask</span> <span class="variable">bTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BallTask</span>(e);		<span class="comment">//任务：球线程</span></span><br><span class="line">            <span class="type">FishTask</span> <span class="variable">fTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FishTask</span>(e);		<span class="comment">//任务：鱼线程</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">bThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(bTask,<span class="string">&quot;Ball&quot;</span>);</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">fThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(fTask,<span class="string">&quot;Fish&quot;</span>);</span><br><span class="line"></span><br><span class="line">            bThread.start();</span><br><span class="line">            fThread.start();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;我是主线程,准备看看你们交易情况...\n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//Thread类中的join方法的主要作用就是同步，它可以使得线程之间的并行执行变为串行执行。</span></span><br><span class="line">                bThread.join();</span><br><span class="line">                fThread.join();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception ep)&#123;&#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;\n\r我是主线程,已看到你们的交易结果...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Exchanger和Semaphore区别</strong><br>Exchanger<V>交换器和Semaphore信号量在关于生产者消费者《产1消1模式》运用的区别：</p>
<p>1·Exchanger交换器：成对的两个线程，各个线程有各个线程的自己数据V，A线程拥有V1，B线程拥有V2，V1&lt;…&gt;V2互换。<br>2·Semaphore信号量：成对的两个线程，只需一个数据池即可，生产者生产数据注入数据池，消费者从数据池取走数据消费。<br>3·Exchanger交换器：两个线程之间的通讯仅仅一个Exchanger实例即可。<br>4·Semaphore信号量：两个线程之间的通讯需要两个信号量，生产信号指示灯，消费信号指示灯。<br>5·Exchanger和Semaphore的共同点：两个线程之间需要同步通讯。生产的过快，没用，必须等消费完了，才能进行下一生产1；同理，消费的过快，也没用，必须等生产完了，才能进行下一消费1。</p>
<h2 id="5、同步队列与等待队列"><a href="#5、同步队列与等待队列" class="headerlink" title="5、同步队列与等待队列"></a>5、同步队列与等待队列</h2><p>书上：</p>
<p>【同步队列是一种将生产者与消费者线程配对的机制。当一个线程调用SynchronousQueue的put方法时，它会阻塞直到另一个线程调用take方法为止，反之亦然。与Exchanger的情况不同，数据仅仅沿一个方向传递，从生产者到消费者。即使SynchronousQueue类实现了BlockingQueue接口，概念上讲，它依然不是一个队列。它没有包含任何元素，它的size方法总是返回0。】</p>
<p><strong>简单的理解是同步队列存放着竞争同步资源的线程的引用（不是存放线程），而等待队列存放着待唤醒的线程的引用。</strong></p>
<p><strong>同步队列中存放着一个个节点，当线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点并将其加入同步队列，首节点表示的获取同步状态成功的线程节点。</strong></p>
<p><img src="https://i.loli.net/2021/11/22/gnBeVMbcx2L1a6l.png"></p>
<p><strong>Condition维护着一个等待队列与同步队列相似。主要针对await和signal的操作。</strong><br><img src="https://i.loli.net/2021/11/22/StGsfokCVRbF2Oy.png"></p>
<p>例子：</p>
<p>这里实现了三个多线程的run方法。A线程输出A然后通知B,然后B通知C。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">&quot;A进程输出&quot;</span> + <span class="string">&quot; : &quot;</span> + ++index);</span><br><span class="line">                conditionB.signal();</span><br><span class="line">                conditionA.await();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">&quot;B进程输出&quot;</span> + <span class="string">&quot; : &quot;</span> + ++index);</span><br><span class="line">                conditionC.signal();</span><br><span class="line">                conditionB.await();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadC</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">&quot;C进程输出&quot;</span> + <span class="string">&quot; : &quot;</span> + ++index);</span><br><span class="line">                conditionA.signal();</span><br><span class="line">                conditionC.await();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CondtionTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionA</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionC</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line">        <span class="type">ThreadB</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadB</span>();</span><br><span class="line">        <span class="type">ThreadC</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadC</span>();</span><br><span class="line"></span><br><span class="line">        threadA.start();<span class="comment">//（1）</span></span><br><span class="line">        threadB.start();<span class="comment">//（2）</span></span><br><span class="line">        threadC.start();<span class="comment">//（3）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当(1)(2)(3)三个线程被调用时，因为三个线程同时竞争lock，这里假设线程A拿到了lock（线程A虽然是看起来是先start()，但是正在的调用还是看调度程序的，所以这里只能假设是A线程拿到同步资源）。首节点表示的是正在操作同步资源的线程。所以现在的同步队列是：<br><img src="https://i.loli.net/2021/11/22/kay4tz3ig9UBLDP.png"></p>
<p>接着线程A输出了：“A进程输出 : 1”。然后调用conditionB.signal()，其实这一步的signal是没什么意义的，因为conditionB现在没有线程是可以被唤醒的。<br>当conditionA.await()被执行到的时候，线程A同步队列中被移除，对应操作是锁的释放； 线程A(节点A)接着被加入到ConditionA等待队列，因为线程需要singal信号。</p>
<p><strong>同步队列</strong>：<br><img src="https://i.loli.net/2021/11/22/WHLbGySihmJ4uwX.png"></p>
<p><strong>A等待队列</strong>：<br><img src="https://i.loli.net/2021/11/22/WphDRvwNO4HauMi.png"></p>
<p>现在在同步队列中的首节点是B节点，那么B线程占用了同步资源就可以开始运行了。先是输出“B进程输出 : 2”，同样的signal操作也是没有意义的，因为conditionC是没有可以被唤醒的线程。当conditionB.await()被执行到的时候，线程B同步队列中被移除，线程B(节点B)接着被加入到ConditionB等待队列</p>
<p><strong>同步队列</strong>：<br><img src="https://i.loli.net/2021/11/22/PbFxRsdYJSpUn8D.png"></p>
<p><strong>B等待队列</strong>：<br><img src="https://i.loli.net/2021/11/22/b8ISi7VOlQKcMsp.png"></p>
<p>终于轮到了C线程占用同步资源了，再输出“C进程输出：3”之后，调用conditionA.signal()，<strong>注意这个signal是有用的</strong><br>因为在conditionA的等待队列中A线程是在等待的，把它取出来加入到同步队列中去竞争，但是<strong>这个时候线程A还没唤醒。首节点还是C</strong>。</p>
<p><strong>同步队列</strong>：<br><img src="https://i.loli.net/2021/11/22/bNFwlpIDYLdrU8C.png"></p>
<p>接着conditionC.await()被执行。线程C同步队列中被移除，线程C(节点C)接着被加入到ConditionC等待队列</p>
<p><strong>同步队列</strong>：<br><img src="https://i.loli.net/2021/11/22/utyGBKSCf8aZjPo.png"></p>
<p><strong>C等待队列</strong>：<br> <img src="https://i.loli.net/2021/11/22/VvpuyIYZdQiSnRz.png">                  </p>
<p>注意到同步队列中的首节点已经变回了节点A了。所以线程A在刚刚等待的地方继续执行，最后释放了lock。但是线程B和线程C最后也没有其他线程去唤醒，状态一直为WAITING，而线程A的状态为TERMINATED。</p>
<h2 id="6、定时器"><a href="#6、定时器" class="headerlink" title="6、定时器"></a>6、定时器</h2><p>定时器是一个应用十分广泛的线程工具，可用于调度多个定时任务以后台线程的方式执行，在Java中，可以通过Timer和TimerTask类来实现定义调度的功能。</p>
<p>Timer类                  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Timer</span><span class="params">()</span>默认的构造方法</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task, <span class="type">long</span> delay)</span>	在指定的延迟后执行指定的任务</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task,<span class="type">long</span> delay,<span class="type">long</span> period)</span>	计划重复固定延迟执行指定的任务，在指定的延迟后开始</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task,  Date time)</span>	在指定的时间计划指定的任务</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task,  Date firstTime, <span class="type">long</span> period)</span>	计划重复固定延迟执行指定的任务，在指定的开始时间</span><br></pre></td></tr></table></figure>



<p>TimerTask类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>	定时器任务执行的动作</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">()</span>	取消此定时器任务</span><br></pre></td></tr></table></figure>

<p>代码演示</p>
<p>1、输出爆炸啦</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承TimerTask，需要重新rum方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Time</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;爆炸啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//new一个Timer对象，用来调方法</span></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        <span class="comment">//调用Timer对象的方法schedule，第一个参数必须是TimerTask对象，Time继承了它因此也是这个对象，第二个参数表示在2秒后运行run方法，这个参数只有在第一次使用run方法，最后一个参数是每隔1秒，运行一次run方法</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">Time</span>(),<span class="number">2000</span>,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个结果是，不停的输出爆炸啦，要想停掉的话，可以加入cancel()方法，在run方法最后加入这个话，结果会输出一个爆炸啦，因为执行第一次完后就执行到这一语句，定时器就取消了，如下。</p>
<p>2、</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">javapublic <span class="keyword">class</span> <span class="title class_">Time</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个Timer对象，到时候可以用它来调用cancel方法</span></span><br><span class="line">    Timer time;</span><br><span class="line">    <span class="comment">//通过构造器给Timer对象赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Time</span><span class="params">(Timer time)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.time=time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;爆炸啦&quot;</span>);</span><br><span class="line">        <span class="comment">//取消定时器</span></span><br><span class="line">        time.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">Time</span>(timer),<span class="number">2000</span>,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/11/16/java-maven%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/16/java-maven%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">java-maven学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-16 14:10:53 / 修改时间：06:49:04" itemprop="dateCreated datePublished" datetime="2021-11-16T14:10:53Z">2021-11-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><ul>
<li>构建工具：自动化构建，抽象构建过程</li>
<li>可跨平台——对外提供了一致的操作接口</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/11/05/%E9%94%80%E5%94%AE%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/05/%E9%94%80%E5%94%AE%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">销售模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-05 13:13:18" itemprop="dateCreated datePublished" datetime="2021-11-05T13:13:18Z">2021-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">工作笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="销售模块"><a href="#销售模块" class="headerlink" title="销售模块"></a>销售模块</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rhb</p>
  <div class="site-description" itemprop="description">纵浪大化中，不喜亦不惧</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">140</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RShawshank" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RShawshank" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rhb</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://lib.baomitu.com/canvas-nest.js/1.0.1/canvas-nest.js"></script>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
