<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rshawshank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="纵浪大化中，不喜亦不惧">
<meta property="og:type" content="website">
<meta property="og:title" content="rhb_blog">
<meta property="og:url" content="http://rshawshank.github.io/page/3/index.html">
<meta property="og:site_name" content="rhb_blog">
<meta property="og:description" content="纵浪大化中，不喜亦不惧">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rhb">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rshawshank.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>rhb_blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rhb_blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">rao的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">60</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">24</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">147</span></a>

  </li>
        <li class="menu-item menu-item-photos">

    <a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
        <li class="menu-item menu-item-readnote">

    <a href="/readnote" rel="section"><i class="fa fa-book fa-fw"></i>阅读笔记</a>

  </li>
        <li class="menu-item menu-item-somethink">

    <a href="/somethink/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>随笔闲谈</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/RShawshank" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%85%AD%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%85%AD%EF%BC%89/" class="post-title-link" itemprop="url">java-设计模式（六）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-29 09:28:21" itemprop="dateCreated datePublished" datetime="2021-12-29T09:28:21Z">2021-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="二十一、观察者模式（observer）"><a href="#二十一、观察者模式（observer）" class="headerlink" title="二十一、观察者模式（observer）"></a>二十一、观察者模式（observer）</h2><p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p>
<p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220112140918.png" alt="img"></p>
<ul>
<li><p>主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。</p>
</li>
<li><p>观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法,观察者为所有的具体观察者定义一个接口，在得到主题的通知时更新自己</p>
</li>
<li><p>ConcreteSubject类是具体主题，将有关状态存入具体观察者对象，在具体主题内部状态改变时，给所有登记过的观察者发出通知；</p>
</li>
<li><p>ConcreteObserver是具体观察者，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协同。</p>
</li>
</ul>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>主题Subject</p>
<p>　　首先定义一个观察者数组，并实现增、删及通知操作。它的职责很简单，就是定义谁能观察，谁不能观察，用Vector是线程同步的，比较安全，也可以使用ArrayList，是线程异步的，但不安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观察者数组</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; oVector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加一个观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.oVector.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除一个观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.oVector.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通知所有观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(Observer observer : <span class="built_in">this</span>.oVector) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象观察者Observer</p>
<p>　　观察者一般是一个接口，每一个实现该接口的实现类都是具体观察者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">     <span class="comment">//更新</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>具体主题</p>
<p>　　继承Subject类，在这里实现具体业务，在具体项目中，该类会有很多变种。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体业务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="built_in">super</span>.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体观察者</p>
<p>　　实现Observer接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息，进行处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client客户端</p>
<p>　　首先创建一个被观察者，然后定义一个观察者，将该被观察者添加到该观察者的观察者数组中，进行测试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个主题</span></span><br><span class="line">        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line">        <span class="comment">//定义一个观察者</span></span><br><span class="line">        <span class="type">Observer</span> <span class="variable">observer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>();</span><br><span class="line">        <span class="comment">//观察</span></span><br><span class="line">        subject.addObserver(observer);</span><br><span class="line">        <span class="comment">//开始活动</span></span><br><span class="line">        subject.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="开发中常见的场景"><a href="#开发中常见的场景" class="headerlink" title="开发中常见的场景"></a>开发中常见的场景</h3><ul>
<li><p>聊天室程序的，服务器转发给所有客户端</p>
</li>
<li><p>网络游戏(多人联机对战)场景中，服务器将客户端的状态进行分发</p>
</li>
<li><p>邮件订阅</p>
</li>
<li><p>Servlet中，监听器的实现</p>
</li>
<li><p>Android中，广播机制</p>
</li>
<li><p>JDK的AWT中事件处理模型,基于观察者模式的委派事件模型(Delegation Event Model)</p>
<ul>
<li><p>事件源—————-目标对象</p>
</li>
<li><p>事件监听器————观察者</p>
</li>
</ul>
</li>
<li><p>京东商城中，群发某商品打折信息</p>
</li>
</ul>
<h3 id="观察者模式的应用"><a href="#观察者模式的应用" class="headerlink" title="观察者模式的应用"></a>观察者模式的应用</h3><p>　　1. 何时使用</p>
<ul>
<li>一个对象状态改变，所有的依赖对象都将得到通知</li>
</ul>
<p> 　2. 方法</p>
<ul>
<li>使用面向对象技术</li>
</ul>
<p> 　3. 优点</p>
<ul>
<li>观察者和被观察者是抽象耦合的</li>
<li>建立了一套触发机制</li>
</ul>
<p> 　4. 缺点</p>
<ul>
<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间</li>
<li>如果观察者和观察目标间有循环依赖，可能导致系统崩溃</li>
<li>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的</li>
</ul>
<p> 　5. 使用场景</p>
<ul>
<li>关联行为场景</li>
<li>事件多级触发场景</li>
<li>跨系统的消息变换场景，如消息队列的处理机制</li>
</ul>
<p>　　6. 应用实例</p>
<ul>
<li>手机丢了，委托别人给其他人发消息通知</li>
<li>通知老师&#x2F;老板来了</li>
<li>拍卖，拍卖师观察最高标价，然后通知给其它竞价者竞价</li>
<li>在一个目录下建立一个文件，会同时通知目录管理器增加目录，并通知磁盘减少空间，文件是被观察者，目录管理器和磁盘管理器是观察者</li>
<li>猫叫了一声，吓着了老鼠，也惊到了主人，猫是被观察者，老鼠和人是观察者</li>
</ul>
<p>　　7. 注意事项</p>
<ul>
<li>避免循环引用</li>
<li>如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式</li>
</ul>
<h2 id="二十二、备忘录模式（Memento）"><a href="#二十二、备忘录模式（Memento）" class="headerlink" title="二十二、备忘录模式（Memento）"></a>二十二、备忘录模式（Memento）</h2><p>在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220112142720.png" alt="img"></p>
<ul>
<li>Originator：原始对象</li>
<li>Caretaker：负责保存好备忘录</li>
<li>Memento：备忘录，存储原始对象的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。</li>
</ul>
<h3 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h3><p>发起人角色</p>
<p>　　记录当前时刻的内部状态，并负责创建和恢复备忘录数据，允许访问返回到先前状态所需的所有数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">createMento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">Memento</span>(state));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemento</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;state = &quot;</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备忘录角色</p>
<p>　　负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Memento</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备忘录管理员角色</p>
<p>　　对备忘录进行管理、保存和提供备忘录，只能将备忘录传递给其他角色。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">getMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemento</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client客户端</p>
<p>　　下面编写一小段代码测试一下，即先将状态置为On，保存后再将状态置为Off，然后通过备忘录管理员角色恢复初始状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Originator</span> <span class="variable">originator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Originator</span>();</span><br><span class="line">        originator.setState(<span class="string">&quot;On&quot;</span>);    <span class="comment">//Originator初始状态</span></span><br><span class="line">        originator.show();</span><br><span class="line"></span><br><span class="line">        <span class="type">Caretaker</span> <span class="variable">caretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Caretaker</span>();</span><br><span class="line">        caretaker.setMemento(originator.createMento());</span><br><span class="line"></span><br><span class="line">        originator.setState(<span class="string">&quot;Off&quot;</span>);    <span class="comment">//Originator状态变为Off</span></span><br><span class="line">        originator.show();</span><br><span class="line"></span><br><span class="line">        originator.setMemento(caretaker.getMemento());    <span class="comment">//回复初始状态</span></span><br><span class="line">        originator.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="备忘录模式的应用"><a href="#备忘录模式的应用" class="headerlink" title="备忘录模式的应用"></a>备忘录模式的应用</h3><p>　　1. 何时使用</p>
<ul>
<li>需要记录一个对象的内部状态时，为了允许用户取消不确定或者错误的操作，能够恢复到原先的状态</li>
</ul>
<p>　　2. 方法</p>
<ul>
<li>通过一个备忘录类专门存储对象状态</li>
</ul>
<p>　　3. 优点</p>
<ul>
<li>给用户提供了一种可以恢复状态的机制，可以使用能够比较方便地回到某个历史的状态</li>
<li>实现了信息的封装，使得用户不需要关心状态的保存细节</li>
</ul>
<p>　　4. 缺点</p>
<ul>
<li>消耗资源</li>
</ul>
<p>　　5. 使用场景</p>
<ul>
<li>需要保存和恢复数据的相关场景</li>
<li>提供一个可回滚的操作，如ctrl+z、浏览器回退按钮、Backspace键等</li>
<li>需要监控的副本场景</li>
</ul>
<p>　　6. 应用实例</p>
<ul>
<li>游戏存档</li>
<li>ctrl+z键、浏览器回退键等（撤销&#x2F;还原）</li>
<li>棋盘类游戏的悔棋</li>
<li>数据库事务的回滚</li>
</ul>
<p>　　7. 注意事项</p>
<ul>
<li>为了符合迪米特法则，需要有一个管理备忘录的类</li>
<li>不要在频繁建立备份的场景中使用备忘录模式。为了节约内存，可使用原型模式+备忘录模式</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89/" class="post-title-link" itemprop="url">java-设计模式（五）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-29 09:28:10" itemprop="dateCreated datePublished" datetime="2021-12-29T09:28:10Z">2021-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="十四、中介者模式（Mediator）"><a href="#十四、中介者模式（Mediator）" class="headerlink" title="十四、中介者模式（Mediator）"></a>十四、中介者模式（Mediator）</h2><p>集中相关对象之间复杂的沟通和控制方式。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220111163216.png" alt="img"></p>
<ul>
<li>Mediator是抽象中介者，定义了同事对象到中介者对象的接口；</li>
<li>Colleague是抽象同事类；</li>
<li>ConcreteMediator是具体中介者对象，实现抽象类的方法，它需要知道所有具体同事类，并从具体同事接收消息，向具体同事对象发出命令；</li>
<li>ConcreteColleague是具体同事类，每个具体同事只知道自己的行为，而不了解其它同事类的情况，但它们却都认识中介者对象。</li>
</ul>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>抽象中介者</p>
<p>　　抽象中介者角色定义统一的接口，用于各同事角色之间的通信。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象的发送消息方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message, Colleague colleague)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象同事类</p>
<p>　　每一个同事角色都知道中介者角色，而且与其它的同事角色通信的时候，一定要通过中介者角色协作。每个同事类的行为分两种：一种是同事本身行为，比如改变对象本身的状态，处理自己的行为等，这种行为叫做自发行为，与其它同事类或者中介者没有任何依赖；第二种是必须依赖中介者才能完成的行为，叫做依赖方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Colleague</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体中介者类</p>
<p>　　具体中介者角色通过协调各同事角色实现协作行为，因此它必须依赖于各个同事角色。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcreteColleague1 colleague1;</span><br><span class="line">    <span class="keyword">private</span> ConcreteColleague2 colleague2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColleague1</span><span class="params">(ConcreteColleague1 colleague1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.colleague1 = colleague1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColleague2</span><span class="params">(ConcreteColleague2 colleague2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.colleague2 = colleague2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message, Colleague colleague)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(colleague == colleague1) &#123;</span><br><span class="line">            colleague2.notify(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            colleague1.notify(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体同事类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteColleague1</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteColleague1</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        mediator.send(message, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;同事1得到消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcreteMediator</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteMediator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ConcreteColleague1</span> <span class="variable">colleague1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteColleague1</span>(mediator);</span><br><span class="line">        <span class="type">ConcreteColleague2</span> <span class="variable">colleague2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteColleague2</span>(mediator);</span><br><span class="line"></span><br><span class="line">        mediator.setColleague1(colleague1);</span><br><span class="line">        mediator.setColleague2(colleague2);</span><br><span class="line"></span><br><span class="line">        colleague1.send(<span class="string">&quot;Nice to meet u.&quot;</span>);</span><br><span class="line">        colleague2.send(<span class="string">&quot;Nice to meet u too.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中介者模式的应用"><a href="#中介者模式的应用" class="headerlink" title="中介者模式的应用"></a>中介者模式的应用</h3><p>　　1. 何时使用</p>
<ul>
<li>多个类相互耦合，形成网状结构时</li>
</ul>
<p>　　2. 方法</p>
<ul>
<li>将网状结构分离为星型结构</li>
</ul>
<p>　　3. 优点</p>
<ul>
<li>减少类间依赖，降低了耦合</li>
<li>符合迪米特原则</li>
</ul>
<p>　　4. 缺点</p>
<ul>
<li>中介者会膨胀的很大，而且逻辑复杂</li>
</ul>
<p>　　5. 使用场景</p>
<ul>
<li>系统中对象之间存在比较复杂的引用关系</li>
<li>想通过一个中间类来封装多个类的行为，而又不想生成太多的子类</li>
</ul>
<h4 id="开发中常见的场景"><a href="#开发中常见的场景" class="headerlink" title="开发中常见的场景"></a>开发中常见的场景</h4><ul>
<li>MVC模式(其中的C，控制器就是一个中介者对象。M和V都和他打交道) </li>
<li>窗口游戏程序，窗口软件开发中窗口对象也是一个中介者对象</li>
<li>图形界面开发GUI中，多个组件之间的交互，可以通过引入一个中介者 对象来解决，可以是整体的窗口对象或者DOM对象</li>
<li>Java.lang.reflect.Method#invoke()</li>
</ul>
<h2 id="十五、命令模式（command）"><a href="#十五、命令模式（command）" class="headerlink" title="十五、命令模式（command）"></a>十五、命令模式（command）</h2><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220111165607.png" alt="img"></p>
<ul>
<li>Invoker调用者&#x2F;请求者：请求的发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联。在程序运行时，将调用命令对象的execute()，间接调用接收者的相关操作。</li>
<li>Command是命令角色，需要执行的所有命令都在这里声明，可以是接口或抽象类；</li>
<li>Receiver接收者：知道如何实施与执行一个请求相关的操作，任何类都可能作为一个接收者；</li>
<li>ConcreteCommand将一个接收者对象绑定与一个动作，调用接收者相应的操作，以实现Execute。</li>
<li>Client：在客户类中故需要创建调用者对象、具体命令类对象，在创建具体命令对象是指定对应的接收者。发送者和接收者之间没有直接的关系，都通过命令对象来调用</li>
</ul>
<h3 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h3><p>command类</p>
<p>​	用来声明执行操作的接口&#x2F;抽象类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Command</span><span class="params">(Receiver receiver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行命令的方法</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteCommand类</p>
<p>　　具体的Command类，用于构造传递接收者，根据环境需求，具体的命令类也可能有n个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造传递接收者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteCommand</span><span class="params">(Receiver receiver)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(receiver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//必须实现一个命令</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Invoker类</p>
<p>　　接收命令，并执行命令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受命令</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行命令</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Receiver类</p>
<p>　　该角色就是干活的角色， 命令传递到这里是应该被执行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行请求！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client类</p>
<p>　　首先定义一个接收者，然后定义一个命令用于发送给接收者，之后再声明一个调用者，即可把命令交给调用者执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义接收者</span></span><br><span class="line">        <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>();</span><br><span class="line">        <span class="comment">//定义一个发送给接收者的命令</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteCommand</span>(receiver);</span><br><span class="line">        <span class="comment">//声明调用者</span></span><br><span class="line">        <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Invoker</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把命令交给调用者执行</span></span><br><span class="line">        invoker.setCommand(command);</span><br><span class="line">        invoker.executeCommand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命令模式的应用"><a href="#命令模式的应用" class="headerlink" title="命令模式的应用"></a>命令模式的应用</h3><p>　　1. 何时使用</p>
<ul>
<li>在某些场合，如要对行为进行“记录、撤销&#x2F;重做、事务”等处理时</li>
</ul>
<p> 　2. 方法</p>
<ul>
<li>通过调用者调用接收者执行命令，顺序为调用者→接收者→命令</li>
</ul>
<p> 　3. 优点</p>
<ul>
<li>类间耦合，调用者角色与接收者角色之间没有任何依赖关系</li>
<li>可扩展性</li>
<li>命令模式结合职责链模式可以实现命令族解析任务；结合模板方法模式可以减少Command子类的膨胀问题</li>
</ul>
<p> 　4. 缺点</p>
<ul>
<li>可能导致某些系统有过多的具体命令类</li>
</ul>
<p> 　5. 使用场景</p>
<ul>
<li>认为是命令的地方都可以使用</li>
<li>系统需要支持命令的撤销&#x2F;恢复操作时</li>
</ul>
<p> 　6. 应用实例</p>
<ul>
<li>GUI中每一个按钮都是一条命令</li>
<li>模拟CMD（DOS命令）</li>
<li>订单的撤销&#x2F;恢复</li>
<li>触发-反馈机制的处理</li>
</ul>
<h2 id="十六、解释器模式（interpreter）——不常用"><a href="#十六、解释器模式（interpreter）——不常用" class="headerlink" title="十六、解释器模式（interpreter）——不常用"></a>十六、解释器模式（interpreter）——不常用</h2><p>为语言创建解释器，通常由语言的语法和语法分析来定义。</p>
<ul>
<li>用于描述如何构成一个简单的语言解释器，主要用于使用面向对象语言开发的 编译器和解释器设计。 </li>
<li>当我们需要开发一种新的语言时，可以考虑使用解释器模式。 </li>
<li><strong>尽量不要使用解释器模式</strong>，后期维护会有很大麻烦。在项目中，可以使用 Jruby，Groovy、java的js引擎来替代解释器的作用，弥补java语言的不足</li>
</ul>
<h2 id="十七、访问者模式（visitor）"><a href="#十七、访问者模式（visitor）" class="headerlink" title="十七、访问者模式（visitor）"></a>十七、访问者模式（visitor）</h2><p>表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变元素的类的前提下定义作用于这些元素的新操作。</p>
<h3 id="开发中的场景-应用范围非常窄，了解即可"><a href="#开发中的场景-应用范围非常窄，了解即可" class="headerlink" title="开发中的场景(应用范围非常窄，了解即可)"></a>开发中的场景(应用范围非常窄，了解即可)</h3><ul>
<li>XML文档解析器设计</li>
<li>编译器的设计</li>
<li>复杂集合对象的处理</li>
</ul>
<h2 id="十八、策略模式（strategy）"><a href="#十八、策略模式（strategy）" class="headerlink" title="十八、策略模式（strategy）"></a>十八、策略模式（strategy）</h2><p>定义一系列算法，封装每个算法，并使它们可以互换。（<strong>分离算法，选择实现</strong>）</p>
<p>策略模式可以让算法独立于使用它的客户端。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220112111007.png" alt="img"></p>
<ul>
<li>Context是上下文，用一个ConcreteStrategy来配置，维护一个对Strategy对象的引用；</li>
<li>Strategy是策略类，用于定义所有支持算法的公共接口；</li>
<li>ConcreteStrategy是具体策略类，封装了具体的算法或行为，继承于Strategy。</li>
</ul>
<h3 id="与状态模式的比较"><a href="#与状态模式的比较" class="headerlink" title="与状态模式的比较"></a>与状态模式的比较</h3><p>状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。</p>
<p>状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。</p>
<h3 id="Implementation-2"><a href="#Implementation-2" class="headerlink" title="Implementation"></a>Implementation</h3><p>Context上下文</p>
<p>　　Context上下文角色，也叫Context封装角色，起承上启下的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"></span><br><span class="line">    Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上下文接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.algorithmInterface();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>策略角色</p>
<p>　　抽象策略角色，是对策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。algorithm是“运算法则”的意思。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//算法方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体策略角色</p>
<p>　　用于实现抽象策略中的操作，即实现具体的算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">extends</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;算法A实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client客户端</p>
<p>　　下面依次更换策略，测试一下策略模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Context context;</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>());</span><br><span class="line">        context.contextInterface();</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>());</span><br><span class="line">        context.contextInterface();</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyC</span>());</span><br><span class="line">        context.contextInterface();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="策略模式的应用"><a href="#策略模式的应用" class="headerlink" title="策略模式的应用"></a>策略模式的应用</h3><p>　　1. 何时使用</p>
<ul>
<li>一个系统有许多类，而区分它们的只是他们直接的行为时</li>
</ul>
<p>　　2. 方法</p>
<ul>
<li>将这些算法封装成一个一个的类，任意的替换</li>
</ul>
<p>　　3. 优点</p>
<ul>
<li>算法可以自由切换</li>
<li>避免使用多重条件判断（如果不用策略模式我们可能会使用多重条件语句，不利于维护）</li>
<li>扩展性良好，增加一个策略只需实现接口即可</li>
</ul>
<p>　　4. 缺点</p>
<ul>
<li>策略类数量会增多，每个策略都是一个类，复用的可能性很小</li>
<li>所有的策略类都需要对外暴露</li>
</ul>
<p>　　5. 使用场景</p>
<ul>
<li>多个类只有算法或行为上稍有不同的场景</li>
<li>算法需要自由切换的场景</li>
<li>需要屏蔽算法规则的场景</li>
</ul>
<p>　　6. 应用实例</p>
<ul>
<li>出行方式，自行车、汽车等，每一种出行方式都是一个策略</li>
<li>商场促销方式，打折、满减等</li>
<li>Java AWT中的LayoutManager，即布局管理器</li>
</ul>
<p>　　7. 注意事项</p>
<ul>
<li>如果一个系统的策略多于四个，就需要考虑使用混合模式来解决策略类膨胀的问题</li>
</ul>
<h3 id="开发中常见的场景-1"><a href="#开发中常见的场景-1" class="headerlink" title="开发中常见的场景"></a>开发中常见的场景</h3><ul>
<li>JAVASE中GUI编程中，布局管理</li>
<li>Spring框架中，Resource接口，资源访问策略 </li>
<li>javax.servlet.http.HttpServlet#service()</li>
</ul>
<h2 id="十九、模板方法模式（template-method）"><a href="#十九、模板方法模式（template-method）" class="headerlink" title="十九、模板方法模式（template method）"></a>十九、模板方法模式（template method）</h2><p>定义算法框架，并将一些步骤的实现延迟到子类。</p>
<p>通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p>
<p><strong>处理步骤父类中定义好，具体实现延迟到子类中定义。</strong></p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220112111539.png" alt="img"></p>
<ul>
<li>AbstractClass实现类一个模板方法，定义了算法的骨架，具体子类将重定义PrimitiveOperation以实现一个算法的步骤；</li>
<li>ConcreteClass实现了PrimitiveOperation以完成算法中与特定子类相关的步骤。</li>
</ul>
<h3 id="Implementation-3"><a href="#Implementation-3" class="headerlink" title="Implementation"></a>Implementation</h3><p>抽象模板类</p>
<p>　　定义一个模板方法来组合PrimitiveOperation1()和PrimitiveOperation2()两个方法形成一个算法，然后让子类重定义这两个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">PrimitiveOperation1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">PrimitiveOperation2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TemplateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        PrimitiveOperation1();</span><br><span class="line">        PrimitiveOperation2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体模板类</p>
<p>　　这里定义两个具体模板类，ConcreteClassA及ConcreteClassB来进行测试，继承抽象模板类，实现具体方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClassA</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrimitiveOperation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体方法A方法1实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrimitiveOperation2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体方法A方法2实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client客户端</p>
<p>　　通过调用模板方法来分别得到不同的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AbstractClass abstractClass;</span><br><span class="line"></span><br><span class="line">        abstractClass = <span class="keyword">new</span> <span class="title class_">ConcreteClassA</span>();</span><br><span class="line">        abstractClass.TemplateMethod();</span><br><span class="line"></span><br><span class="line">        abstractClass = <span class="keyword">new</span> <span class="title class_">ConcreteClassB</span>();</span><br><span class="line">        abstractClass.TemplateMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="开发中常见的场景："><a href="#开发中常见的场景：" class="headerlink" title="开发中常见的场景："></a>开发中常见的场景：</h3><p>非常频繁，各个框架、类库都存在</p>
<ul>
<li>数据库访问的封装</li>
<li>Junit单元测试</li>
<li>servlet中关于doGet（）和doPost（）方法调用</li>
<li>Hibernate中模板程序</li>
<li>spring中JDBCTemplate、HibernateTemplate···</li>
</ul>
<h3 id="模板方法模式的应用"><a href="#模板方法模式的应用" class="headerlink" title="模板方法模式的应用"></a>模板方法模式的应用</h3><p>　　1. 何时使用</p>
<ul>
<li>有一些通用的方法时</li>
</ul>
<p>　　2. 方法</p>
<ul>
<li>将通用算法抽象出来</li>
</ul>
<p>　　3. 优点</p>
<ul>
<li>封装不变部分，扩展可变部分</li>
<li>提取公共部分代码，便于维护</li>
<li>行为由父类控制，子类实现</li>
</ul>
<p>　　4. 缺点</p>
<ul>
<li>每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大</li>
</ul>
<p>　　5. 使用场景</p>
<ul>
<li>有多个子类共有的方法，且逻辑相同</li>
<li>重要的、复杂的方法，可以考虑作为模板方法</li>
<li>重构时，模板方法模式是一个经常使用到的模式，把相同的代码抽取到父类中，通过钩子函数约束其行为</li>
</ul>
<p>　　6. 应用实例</p>
<ul>
<li>做试卷，大家题目都是一样的，只是答案不同</li>
<li>对于汽车，车从发动到停车的顺序是相同的，不同的是引擎声、鸣笛声等</li>
<li>造房时，地基、走线、水管都一样，只有在建筑后期才有差异</li>
</ul>
<p>　　7. 注意事项</p>
<ul>
<li>为防恶意操作，一般模板方法都加上final关键字</li>
</ul>
<h2 id="二十、状态模式（state）"><a href="#二十、状态模式（state）" class="headerlink" title="二十、状态模式（state）"></a>二十、状态模式（state）</h2><p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220112133737.png" alt="img"></p>
<ul>
<li>Context类为环境角色，用于维护一个ConcreteState子类的实例，这个实例定义当前的状态；</li>
<li>State为抽象状态角色，定义一个接口以封装与Context的一个特定接口状态相关的行为；</li>
<li>ConcreteState是具体状态角色，每一个子类实现一个与Context的一个状态相关的行为。</li>
</ul>
<h3 id="Implementation-4"><a href="#Implementation-4" class="headerlink" title="Implementation"></a>Implementation</h3><p>Context类</p>
<p>　　环境角色具有两个职责，即处理本状态必须完成的任务，及决定是否可以过渡到其它状态。对于环境角色，有几个不成文的约束：</p>
<ul>
<li>即把状态对象声明为静态常量，有几个状态对象就声明几个状态常量</li>
<li>环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">State</span> <span class="variable">STATE1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteState1</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">State</span> <span class="variable">STATE2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteState2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前状态</span></span><br><span class="line">    <span class="keyword">private</span> State currentState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得当前状态</span></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置当前状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCurrentState</span><span class="params">(State currentState)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentState = currentState;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;当前状态：&quot; + currentState);</span></span><br><span class="line">        <span class="comment">//切换状态</span></span><br><span class="line">        <span class="built_in">this</span>.currentState.setContext(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentState.handle1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentState.handle2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> State抽象状态类</p>
<p>　　抽象环境中声明一个环境角色，提供各个状态类自行访问，并且提供所有状态的抽象行为，由各个实现类实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Context context;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//行为1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handle1</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//行为2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handle2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 具体状态</p>
<p>　　具体状态实现，这里以定义ConcreteState1和ConcreteState2两个具体状态类为例，ConcreteState2的具体内容同ConcreteState1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteState1</span> <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteState1 的 handle1 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.context.setCurrentState(Context.STATE2);</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteState1 的 handle2 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client客户端</p>
<p>　　定义Context环境角色，初始化具体状态1，执行行为观察结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义环境角色</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        <span class="comment">//初始化状态</span></span><br><span class="line">        context.setCurrentState(<span class="keyword">new</span> <span class="title class_">ConcreteState1</span>());</span><br><span class="line">        <span class="comment">//行为执行</span></span><br><span class="line">        context.handle1();</span><br><span class="line">        context.handle2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="开发中常见的场景-2"><a href="#开发中常见的场景-2" class="headerlink" title="开发中常见的场景"></a>开发中常见的场景</h3><ul>
<li>银行系统中账号状态的管理</li>
<li>OA系统中公文状态的管理</li>
<li>酒店系统中，房间状态的管理</li>
<li>线程对象各状态之间的切换</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89/" class="post-title-link" itemprop="url">java-设计模式（四）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-29 09:28:00" itemprop="dateCreated datePublished" datetime="2021-12-29T09:28:00Z">2021-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="九、装饰模式（decorator）"><a href="#九、装饰模式（decorator）" class="headerlink" title="九、装饰模式（decorator）"></a>九、装饰模式（decorator）</h2><p>为对象动态添加功能。</p>
<p>装饰模式是一种用来代替继承的技术，无须通过继承增加子类就能拓展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时可以<strong>避免类型体系的快速膨胀</strong>。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220110143736.png" alt="img"></p>
<ul>
<li>Component：抽象构件，真实对象和装饰对象都有的接口，这样，客户端对象可以以与真实对象相同的方式同装饰对象交互</li>
<li>ConreteComponent：具体构件对象（真实对象）</li>
<li>Decorator：装饰角色。持有一个<strong>抽象构件</strong>的引用，装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象。这样，就能在真实对象调用前后增加新的功能</li>
<li>ConreteDecorator：具体装饰对象。负责给构件对象增加新的责任</li>
</ul>
<p> 要点： <strong>装饰者与被装饰者拥有共同的超类，继承的目的是继承类型，而不是行为</strong></p>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>component抽象类：</p>
<p>Component是一个接口或是抽象类，就是定义我们最核心的对象，也就是最原始的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">     </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>conretetComponent:</p>
<p>具体构件，通过继承实现Component抽象类中的抽象方法。是最核心、最原始、最基本的接口或抽象类的实现，我们要装饰的就是它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConretetComponent</span> <span class="keyword">extends</span> <span class="title class_">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体对象的操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Decorator装饰类:</p>
<p>　　一般是一个抽象类，在其属性里必然有一个private变量指向Component抽象构件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造函数传递给被修饰者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//委托给被修饰者执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(component != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.component.operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteDecorator类：</p>
<p>　　我们可以写多个具体实现类，把最核心的、最原始的、最基本的东西装饰成其它东西。</p>
<p>　　这里就写两个类，稍改一下二者的实现顺序，看看结果。</p>
<p>　　A类，它的operation()方法先执行了method1()方法，再执行了Decorator的operation()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义被修饰者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecoratorA</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义自己的修饰方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method1 修饰&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.method1();</span><br><span class="line">        <span class="built_in">super</span>.operation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B类，它的operation()方法先执行了Decorator的operation()方法，再执行了method2()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDecoratorB</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义被修饰者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecoratorB</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义自己的修饰方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2 修饰&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.operation();</span><br><span class="line">        <span class="built_in">this</span>.method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>();</span><br><span class="line">        <span class="comment">//第一次修饰</span></span><br><span class="line">        component = <span class="keyword">new</span> <span class="title class_">ConcreteDecoratorA</span>(component);</span><br><span class="line">        <span class="comment">//第二次修饰</span></span><br><span class="line">        component = <span class="keyword">new</span> <span class="title class_">ConcreteDecoratorB</span>(component);</span><br><span class="line">        <span class="comment">//修饰后运行</span></span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IO流实现细节"><a href="#IO流实现细节" class="headerlink" title="IO流实现细节"></a>IO流实现细节</h3><ul>
<li>Component抽象构件角色：<ul>
<li>io流中的InputStream、OutputStream、Reader、Writer</li>
</ul>
</li>
<li>ConcreteComponent 具体构件角色：<ul>
<li>io流中的FileInputStream、FileOutputStream</li>
</ul>
</li>
<li>Decorator装饰角色：<ul>
<li>持有一个抽象构件的引用：io流中的FilterInputStream、FilterOutputStream</li>
</ul>
</li>
<li>ConcreteDecorator具体装饰角色：<ul>
<li>负责给构件对象增加新的责任。Io流中的BufferedOutputStream、BufferedInputStream等。</li>
</ul>
</li>
</ul>
<h3 id="装饰模式的应用"><a href="#装饰模式的应用" class="headerlink" title="装饰模式的应用"></a>装饰模式的应用</h3><p>　1. 何时使用</p>
<ul>
<li>在不想增加很多子类的情况下扩展类时</li>
</ul>
<p> 　2. 方法</p>
<ul>
<li>将具体功能职责划分，同时继承装饰者模式</li>
</ul>
<p> 　3. 优点</p>
<ul>
<li>装饰类和被装饰类可以独立发展，而不会相互耦合。它有效地把类的核心职责和装饰功能分开了</li>
<li>装饰模式是继承关系的一个替代方案</li>
<li>装饰模式可以动态地扩展一个实现类的功能</li>
</ul>
<p>　　4. 缺点</p>
<ul>
<li>多层装饰比较复杂。比如我们现在有很多层装饰，出了问题，一层一层检查，最后发现是最里层的装饰出问题了，想想工作量都害怕</li>
</ul>
<p>　　5. 使用场景</p>
<ul>
<li>需要扩展一个类的功能时</li>
<li>需要动态地给一个对象增加功能，并可以动态地撤销时</li>
<li>需要为一批的兄弟类进行改装或加装功能时</li>
</ul>
<h3 id="装饰模式和桥接模式的区别"><a href="#装饰模式和桥接模式的区别" class="headerlink" title="装饰模式和桥接模式的区别"></a>装饰模式和桥接模式的区别</h3><p>两个模式都是为了解决过多子类对象问题。但他们的诱因不一样。桥接模式是对象自身现有机制沿着多个维度变化，是既有部分不稳定。装饰模式是为了增加新的功能。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/adamjwh/p/9036358.html">简说设计模式——装饰模式 - JAdam - 博客园 (cnblogs.com)</a></p>
<h2 id="十、外观模式（facade）"><a href="#十、外观模式（facade）" class="headerlink" title="十、外观模式（facade）"></a>十、外观模式（facade）</h2><p>提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。</p>
<h3 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h3><p>观看电影需要操作很多电器，使用外观模式实现一键看电影功能。</p>
<p>子系统角色：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOnTV</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;turnOnTV()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCD</span><span class="params">(String cd)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;setCD( &quot;</span> + cd + <span class="string">&quot; )&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startWatching</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;startWatching()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外观类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystem</span> <span class="variable">subSystem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystem</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watchMovie</span><span class="params">()</span> &#123;</span><br><span class="line">        subSystem.turnOnTV();</span><br><span class="line">        subSystem.setCD(<span class="string">&quot;a movie&quot;</span>);</span><br><span class="line">        subSystem.startWatching();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Facade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Facade</span>();</span><br><span class="line">        facade.watchMovie();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少。</p>
<h3 id="外观模式的应用"><a href="#外观模式的应用" class="headerlink" title="外观模式的应用"></a>外观模式的应用</h3><p>　　1. 何时使用</p>
<ul>
<li>客户端不需要知道系统内部的复杂联系，整个系统只提供一个“接待员”即可</li>
<li>定义系统的入口</li>
</ul>
<p> 　2. 方法</p>
<ul>
<li>客户端不与系统耦合，外观类与系统耦合</li>
</ul>
<p> 　3. 优点</p>
<ul>
<li>减少了系统的相互依赖</li>
<li>提高了灵活性。不管系统内部如何变化，只要不影响到外观对象，任你自由活动</li>
<li>提高了安全性。想让你访问子系统的哪些业务就开通哪些逻辑，不在外观上开通的方法，你就访问不到</li>
</ul>
<p> 　4. 缺点</p>
<ul>
<li>不符合开不原则，修改很麻烦</li>
</ul>
<p> 　5. 使用场景</p>
<ul>
<li>为一个复杂的模块或子系统提供一个外界访问的接口</li>
<li>子系统相对独立，外界对子系统的访问只要黑箱操作即可</li>
<li>预防低水平人员带来的风险扩散</li>
</ul>
<h2 id="十一、享元模式（FlyWeight）"><a href="#十一、享元模式（FlyWeight）" class="headerlink" title="十一、享元模式（FlyWeight）"></a>十一、享元模式（FlyWeight）</h2><p>运用共享技术有效地支持大量细粒度的对象。</p>
<p>池技术：String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220110153253.png" alt="img"></p>
<ul>
<li>FlyWeightFactory：享元工厂类。创建并管理享元对象，享元池一般设计成键值对。</li>
<li>FlyWeight：抽象享元类。通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，设置外部状态。</li>
<li>ConcreteFlyWeight：具体享元类。为内部状态提供成员变量进行存储</li>
<li>UnsharedConcreteFlyWeight：非共享享元类。不能被共享的子类可以设计为非共享享元类</li>
</ul>
<h3 id="Implementation-2"><a href="#Implementation-2" class="headerlink" title="Implementation"></a>Implementation</h3><p>Flyweight抽象类</p>
<p>　　所有具体享元类的超类或接口，通过这个接口，Flyweight可以接受并作用于外部状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Flyweight</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部状态</span></span><br><span class="line">    <span class="keyword">public</span> String intrinsic;</span><br><span class="line">    <span class="comment">//外部状态</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String extrinsic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要求享元角色必须接受外部状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Flyweight</span><span class="params">(String extrinsic)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.extrinsic = extrinsic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义业务操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> extrinsic)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getIntrinsic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> intrinsic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIntrinsic</span><span class="params">(String intrinsic)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.intrinsic = intrinsic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteFlyweight类</p>
<p>　　继承Flyweight超类或实现Flyweight接口，并为其内部状态增加存储空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title class_">Flyweight</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受外部状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteFlyweight</span><span class="params">(String extrinsic)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(extrinsic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据外部状态进行逻辑处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> extrinsic)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体Flyweight:&quot;</span> + extrinsic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UnsharedConcreteFlyweight类</p>
<p>　　指那些不需要共享的Flyweight子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsharedConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title class_">Flyweight</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnsharedConcreteFlyweight</span><span class="params">(String extrinsic)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(extrinsic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> extrinsic)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不共享的具体Flyweight:&quot;</span> + extrinsic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FlyweightFactory类</p>
<p>　　一个享元工厂，用来创建并管理Flyweight对象，主要是用来确保合理地共享Flyweight，当用户请求一个Flyweight时，FlyweightFactory对象提供一个已创建的实例或创建一个实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyweightFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个池容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, Flyweight&gt; pool = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//享元工厂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Flyweight <span class="title function_">getFlyweight</span><span class="params">(String extrinsic)</span> &#123;</span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">flyweight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pool.containsKey(extrinsic)) &#123;    <span class="comment">//池中有该对象</span></span><br><span class="line">            flyweight = pool.get(extrinsic);</span><br><span class="line">            System.out.print(<span class="string">&quot;已有 &quot;</span> + extrinsic + <span class="string">&quot; 直接从池中取----&gt;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//根据外部状态创建享元对象</span></span><br><span class="line">            flyweight = <span class="keyword">new</span> <span class="title class_">ConcreteFlyweight</span>(extrinsic);</span><br><span class="line">            <span class="comment">//放入池中</span></span><br><span class="line">            pool.put(extrinsic, flyweight);</span><br><span class="line">            System.out.print(<span class="string">&quot;创建 &quot;</span> + extrinsic + <span class="string">&quot; 并从池中取出----&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">extrinsic</span> <span class="operator">=</span> <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">flyweightX</span> <span class="operator">=</span> FlyweightFactory.getFlyweight(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">        flyweightX.operate(++ extrinsic);</span><br><span class="line"></span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">flyweightY</span> <span class="operator">=</span> FlyweightFactory.getFlyweight(<span class="string">&quot;Y&quot;</span>);</span><br><span class="line">        flyweightY.operate(++ extrinsic);</span><br><span class="line"></span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">flyweightZ</span> <span class="operator">=</span> FlyweightFactory.getFlyweight(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">        flyweightZ.operate(++ extrinsic);</span><br><span class="line"></span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">flyweightReX</span> <span class="operator">=</span> FlyweightFactory.getFlyweight(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">        flyweightReX.operate(++ extrinsic);</span><br><span class="line"></span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">unsharedFlyweight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnsharedConcreteFlyweight</span>(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">        unsharedFlyweight.operate(++ extrinsic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部状态和外部状态"><a href="#内部状态和外部状态" class="headerlink" title="内部状态和外部状态"></a>内部状态和外部状态</h3><p>　　上面享元模式的定义为我们提出了两个要求：细粒度和共享对象。我们知道分配太多的对象到应用程序中将有损程序的性能，同时还容易造成内存溢出，要避免这种情况，用到的就是共享技术，这里就需要提到内部状态和外部状态了。</p>
<p>　　因为要求细粒度对象，所以不可避免地会使对象数量多且性质相近，此时我们就将这些对象的信息分为两个部分：内部状态和外部状态。</p>
<p>　　<strong>内部状态</strong>指对象共享出来的信息，存储在享元对象内部并且不会随环境的改变而改变；<strong>外部状态</strong>指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。</p>
<p>　　我们举一个最简单的例子，棋牌类游戏大家都有玩过吧，比如说说围棋和跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色略多一点，但也是不太变化的，所以棋子颜色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同，我们落子嘛，落子颜色是定的，但位置是变化的，所以方位坐标就是棋子的外部状态。</p>
<p>　　那么为什么这里要用享元模式呢？可以想象一下，上面提到的棋类游戏的例子，比如围棋，理论上有361个空位可以放棋子，常规情况下每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题。</p>
<h3 id="享元模式的应用"><a href="#享元模式的应用" class="headerlink" title="享元模式的应用"></a>享元模式的应用</h3><p>　　1. 何时使用</p>
<ul>
<li>系统中有大量对象时</li>
<li>这些对象消耗大量内存时</li>
<li>这些对象的状态大部分可以外部化时</li>
</ul>
<p>　　2. 方法</p>
<ul>
<li>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap&#x2F;HashTable存储</li>
</ul>
<p>　　3. 优点</p>
<ul>
<li>大大减少了对象的创建，降低了程序内存的占用，提高效率</li>
</ul>
<p>　　4. 缺点</p>
<ul>
<li>提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变</li>
<li>为了节省内存，共享了内部状态，分离出外部状态，而读取外部状态 使运行时间变长。用时间换取了空间。</li>
</ul>
<p> 　5. 使用场景</p>
<ul>
<li>系统中存在大量相似对象</li>
<li>需要缓冲池的场景</li>
</ul>
<p> 　6. 应用实例</p>
<ul>
<li>String常量池</li>
<li>数据库连接池</li>
</ul>
<p> 　7. 注意事项</p>
<ul>
<li>注意划分内部状态和外部状态，否则可能会引起线程安全问题</li>
<li>这些类必须有一个工厂类加以控制</li>
</ul>
<h1 id="结构型模式汇总"><a href="#结构型模式汇总" class="headerlink" title="结构型模式汇总"></a>结构型模式汇总</h1><table>
<thead>
<tr>
<th align="center">代理模式</th>
<th align="center">为真实对象提供一个代理，从而控制对真实对象的访问</th>
</tr>
</thead>
<tbody><tr>
<td align="center">适配模式</td>
<td align="center">使原本由于接口不兼容不能一起工作的类可以一起工作</td>
</tr>
<tr>
<td align="center">桥接模式</td>
<td align="center">处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。</td>
</tr>
<tr>
<td align="center">组合模式</td>
<td align="center">将对象组合成树状结构以表示”部分和整体”层次结构，使得客户可以统一 的调用叶子对象和容器对象</td>
</tr>
<tr>
<td align="center">装饰模式</td>
<td align="center">动态地给一个对象添加额外的功能，比继承灵活</td>
</tr>
<tr>
<td align="center">外观模式</td>
<td align="center">为子系统提供统一的调用接口，使得子系统更加容易使用</td>
</tr>
<tr>
<td align="center">享元模式</td>
<td align="center">运用共享技术有效的实现管理大量细粒度对象，节省内存，提高效率</td>
</tr>
</tbody></table>
<h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><ul>
<li><p>行为型模式关注的是系统中对象之间的相互交互，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责。</p>
</li>
<li><p>创建型模式关注的是对象的创建过程。</p>
</li>
<li><p>结构型模式关注的是对象和类的组织。</p>
</li>
</ul>
<h2 id="十二、责任链模式（chain-of-responsibility）"><a href="#十二、责任链模式（chain-of-responsibility）" class="headerlink" title="十二、责任链模式（chain of responsibility）"></a>十二、责任链模式（chain of responsibility）</h2><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220110162827.png" alt="img"></p>
<ul>
<li>Handler：抽象处理者。定义了一个处理请求的接口。</li>
<li>ConcreteHandler：具体处理者。处理它所负责的请求，可访问它的后继者。如果可处理该请求就处理，否则就将该请求转发给它的后继者。</li>
</ul>
<h3 id="Implementation-3"><a href="#Implementation-3" class="headerlink" title="Implementation"></a>Implementation</h3><p>抽象处理者</p>
<p>　　抽象处理者实现了三个职责：</p>
<ul>
<li>定义一个请求的处理方法handlerMessage()，是唯一对外开放的方法</li>
<li>定义一个链的编排方式setNext()，用于设置下一个处理者</li>
<li>定义了具体的请求者必须实现的两个方法，即定义自己能够处理的级别的getHandlerLevel()方法及具体的处理任务echo()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;    <span class="comment">//下一个处理者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Response <span class="title function_">handlerMessage</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.getHandlerLevel().equals(request.getRequestLevel())) &#123;    <span class="comment">//判断是否是自己的处理级别</span></span><br><span class="line">            response = <span class="built_in">this</span>.echo(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.nextHandler != <span class="literal">null</span>) &#123;    <span class="comment">//下一处理者不为空</span></span><br><span class="line">                response = <span class="built_in">this</span>.nextHandler.handlerMessage(request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没有适当的处理者，业务自行处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定下一个处理者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Handler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个处理者的处理等级</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Level <span class="title function_">getHandlerLevel</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个处理者都必须实现的处理任务</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Response <span class="title function_">echo</span><span class="params">(Request request)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体处理者</p>
<p>　　这里我们定义三个具体处理者，以便能组成一条链，ConcreteHandlerB及ConcreteHandlerC就不再赘述了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandlerA</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Level <span class="title function_">getHandlerLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置自己的处理级别</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Response <span class="title function_">echo</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="comment">//完成处理逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="责任链模式的应用"><a href="#责任链模式的应用" class="headerlink" title="责任链模式的应用"></a>责任链模式的应用</h3><p>开发中常见的场景： </p>
<ul>
<li>Java中，异常机制就是一种责任链模式。一个try可以对应多个catch， 当第一个catch不匹配类型，则自动跳到第二个catch. </li>
<li>Javascript语言中，事件的冒泡和捕获机制。Java语言中，事件的处理 采用观察者模式。</li>
<li>Servlet开发中，过滤器的链式处理 </li>
<li>Struts2中，拦截器的调用也是典型的责任链模式</li>
</ul>
<p>　　1. 何时使用</p>
<ul>
<li>处理消息时</li>
</ul>
<p>　　2. 方法</p>
<ul>
<li>拦截的类都实现同一接口</li>
</ul>
<p>　　3. 优点</p>
<ul>
<li>将请求和处理分开，实现解耦，提高系统的灵活性</li>
<li>简化了对象，使对象不需要知道链的结构</li>
</ul>
<p>　　4. 缺点</p>
<ul>
<li>性能会收到影响，特别是在链比较长的时候</li>
<li>调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂</li>
<li>不能保证请求一定被接收</li>
</ul>
<p>　　5. 使用场景</p>
<ul>
<li>有多个对象可以处理同一个请求</li>
<li>在不明确指定接收者的情况下，向多个对象中的提交请求</li>
<li>可动态指定一组对象处理请求</li>
</ul>
<p>　　6. 应用实例</p>
<ul>
<li>多级请求</li>
<li>击鼓传花</li>
<li>请假&#x2F;加薪请求</li>
<li>Java Web中Tomcat对Encoding的处理、拦截器</li>
</ul>
<p>　　7. 注意事项</p>
<ul>
<li>需控制链中最大节点数量，一般通过在Handler中设置一个最大节点数量，在setNext()方法中判断是否已经超过阀值，超过则不允许该链建立，避免出现超长链无意识地破坏系统性能</li>
</ul>
<h2 id="十三、迭代器模式（iterator）"><a href="#十三、迭代器模式（iterator）" class="headerlink" title="十三、迭代器模式（iterator）"></a>十三、迭代器模式（iterator）</h2><p>提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20220111155357.png" alt="img"></p>
<ul>
<li>Aggregate：聚集抽象类。负责提供创建具体迭代器角色的接口</li>
<li>Iterator：迭代抽象类，用于定义得到开始对象、得到下一个对象、判断是否到结尾、当前对象等抽象方法，统一接口</li>
<li>ConcreteAggregate：具体聚集类，继承Aggregate</li>
<li>ConcreteIterator：具体迭代器类，继承Iterator，实现开始、下一个、是否结尾、当前对象等方法</li>
</ul>
<h3 id="Implementation-4"><a href="#Implementation-4" class="headerlink" title="Implementation"></a>Implementation</h3><p>抽象容器</p>
<p>　　负责提供接口，比如存在一个类似createIterator()这样的方法，在Java中一般是iterator()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Aggregate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object object)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Object object)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象迭代器</p>
<p>　　负责定义访问和遍历元素的接口，基本上有固定的三个方法，即first()获取第一个元素、next()访问下一个元素、hasNext()是否已经遍历到底部。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span>;    <span class="comment">//遍历到下一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;    <span class="comment">//是否已经遍历到尾部</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">()</span>;    <span class="comment">//删除当前指向的元素</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体容器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title class_">Aggregate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Vector</span> <span class="variable">vector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vector.add(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.remove(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteIterator</span>(<span class="built_in">this</span>.vector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体迭代器</p>
<p>　简单的实现就是通过一个游标，在一个容器中上下翻滚，遍历所有它需要查看的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Vector</span> <span class="variable">vector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//定义当前游标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteIterator</span><span class="params">(Vector vector)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vector = vector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.hasNext()) &#123;</span><br><span class="line">            result = <span class="built_in">this</span>.vector.get(<span class="built_in">this</span>.cursor ++);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.cursor == <span class="built_in">this</span>.vector.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vector.remove(<span class="built_in">this</span>.cursor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器模式的应用"><a href="#迭代器模式的应用" class="headerlink" title="迭代器模式的应用"></a>迭代器模式的应用</h3><p>　　1. 何时使用</p>
<ul>
<li>遍历一个聚合对象时</li>
</ul>
<p>　　2. 方法</p>
<ul>
<li>把在元素间游走的责任交给迭代器，而不是聚合对象</li>
</ul>
<p>　　3. 优点</p>
<ul>
<li>支持以不同的方式遍历一个聚合对象</li>
<li>迭代器简化了聚合类</li>
<li>在同一个聚合上可以有多个遍历</li>
<li>增加新的聚合类和迭代器类都很方便，无需修改原有代码</li>
</ul>
<p>　　4. 缺点</p>
<ul>
<li>增加了系统的复杂性。因为迭代器模式将存储数据和遍历数据的职责分离，增加了新的聚合类需要对应增加新的迭代器类，增加了系统的复杂性。</li>
</ul>
<p>　　5. 使用场景 </p>
<ul>
<li>访问一个聚合对象的内容无需暴露它的内部表示时</li>
<li>需要为聚合对象提供多种便利方式时</li>
<li>为遍历不同的聚合结构提供一个统一的接口</li>
</ul>
<p>　　6. 应用实例</p>
<ul>
<li>Java中的Iterator迭代器</li>
<li>foreach遍历</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">java-设计模式（三）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-29 09:27:50" itemprop="dateCreated datePublished" datetime="2021-12-29T09:27:50Z">2021-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>核心作用：是从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题。</p>
<p>分类：</p>
<ul>
<li>适配器模式、代理模式、桥接模式、 装饰模式、组合模式、外观模式、享元模式</li>
</ul>
<table>
<thead>
<tr>
<th>代理模式</th>
<th>为真实对象提供一个代理，从而控制对真实对象的访问</th>
</tr>
</thead>
<tbody><tr>
<td>适配模式</td>
<td>使原本由于接口不兼容不能一起工作的类可以一起工作</td>
</tr>
<tr>
<td>桥接模式</td>
<td>处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。</td>
</tr>
<tr>
<td>组合模式</td>
<td>将对象组合成树状结构以表示”部分和整体”层次结构，使得客户可以统一的调用叶子对象和容器对象</td>
</tr>
<tr>
<td>装饰模式</td>
<td>动态地给一个对象添加额外的功能，比继承灵活</td>
</tr>
<tr>
<td>外观模式</td>
<td>为子系统提供统一的调用接口，使得子系统更加容易使用</td>
</tr>
<tr>
<td>享元模式</td>
<td>运用共享技术有效的实现管理大量细粒度对象，节省内存，提高效率</td>
</tr>
</tbody></table>
<h2 id="五、代理模式（proxy）"><a href="#五、代理模式（proxy）" class="headerlink" title="五、代理模式（proxy）"></a>五、代理模式（proxy）</h2><p>控制对其它对象的访问。</p>
<p><strong>核心作用：</strong></p>
<p>控制对其他对象的访问。</p>
<p><strong>核心角色：</strong></p>
<ul>
<li><p>抽象角色：定义代理角色和真实角色的公共给对外方法</p>
</li>
<li><p>真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用</p>
<p><strong>关注真正的业务逻辑！</strong></p>
</li>
<li><p>代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。</p>
<p><strong>将统一的流程控制放到代理角色中处理!</strong></p>
</li>
</ul>
<p><strong>开发框架中应用场景：</strong></p>
<ul>
<li>struts2中拦截器的实现</li>
<li>数据库连接池关闭处理</li>
<li>Hibernate中延时加载的实现</li>
<li>mybatis中实现拦截器插件</li>
<li>AspectJ的实现</li>
<li>spring中AOP的实现<ul>
<li>日志拦截</li>
<li>声明式事务处理</li>
</ul>
</li>
<li>web service</li>
<li>RMI远程方法调用</li>
</ul>
<p>包含四类：</p>
<ul>
<li><p>远程代理（remote proxy）:控制对源程对象不同地址空间）的访问。它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。</p>
</li>
<li><p>虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。</p>
</li>
<li><p>保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。</p>
</li>
<li><p>智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。</p>
</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9b679ff5-94c6-48a7-b9b7-2ea868e828ed.png"/> </div><br>

<p>例子：</p>
<p>以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HighResolutionImage</span> <span class="keyword">implements</span> <span class="title class_">Image</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> URL imageURL;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> startTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HighResolutionImage</span><span class="params">(URL imageURL)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.imageURL = imageURL;</span><br><span class="line">        <span class="built_in">this</span>.startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="built_in">this</span>.width = <span class="number">600</span>;</span><br><span class="line">        <span class="built_in">this</span>.height = <span class="number">600</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLoad</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟图片加载，延迟 3s 加载完成</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> endTime - startTime &gt; <span class="number">3000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Real Image: &quot;</span> + imageURL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProxy</span> <span class="keyword">implements</span> <span class="title class_">Image</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HighResolutionImage highResolutionImage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImageProxy</span><span class="params">(HighResolutionImage highResolutionImage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.highResolutionImage = highResolutionImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!highResolutionImage.isLoad()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Temp Image: &quot;</span> + highResolutionImage.getWidth() + <span class="string">&quot; &quot;</span> + highResolutionImage.getHeight());</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        highResolutionImage.showImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageViewer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">image</span> <span class="operator">=</span> <span class="string">&quot;http://image.jpg&quot;</span>;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(image);</span><br><span class="line">        <span class="type">HighResolutionImage</span> <span class="variable">highResolutionImage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HighResolutionImage</span>(url);</span><br><span class="line">        <span class="type">ImageProxy</span> <span class="variable">imageProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageProxy</span>(highResolutionImage);</span><br><span class="line">        imageProxy.showImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向切面编程AOP介绍"><a href="#面向切面编程AOP介绍" class="headerlink" title="面向切面编程AOP介绍"></a>面向切面编程AOP介绍</h2><p>AOP（Aspect-Oriented Programming，面向切面的编程） </p>
<ul>
<li>它是可以通过预编译方式和运行期动态代理实现在不修改源代码的情 况下给程序动态统一添加功能的一种技术。它是一种新的方法论，它是对传统OOP编程的一种补充。</li>
</ul>
<p>常用术语：</p>
<ul>
<li><p>切面（Aspect）：其实就是共有功能的实现。 </p>
</li>
<li><p>通知（Advice）：是切面的具体实现。 </p>
</li>
<li><p>连接点（Joinpoint）：就是程序在运行过程中能够插入切面的地点。 </p>
</li>
<li><p>切入点（Pointcut）：用于定义通知应该切入到哪些连接点上。 </p>
</li>
<li><p>目标对象（Target）：就是那些即将切入切面的对象，也就是那些被通知的对象 </p>
</li>
<li><p>代理对象（Proxy）：将通知应用到目标对象之后被动态创建的对象。 </p>
</li>
<li><p>织入（Weaving）：将切面应用到目标对象从而创建一个新的代理对象的过程。</p>
</li>
</ul>
<p>开源的AOP框架：</p>
<ul>
<li>Aspect</li>
</ul>
<h2 id="六、适配器模式（Adapter）"><a href="#六、适配器模式（Adapter）" class="headerlink" title="六、适配器模式（Adapter）"></a>六、适配器模式（Adapter）</h2><p>把一个类接口转换成另一个用户需要的接口。</p>
<p><strong>使用场景</strong></p>
<ul>
<li>系统需要使用<strong>现有的类</strong>，而这些类的<strong>接口不符合</strong>系统的需要。</li>
<li>想要建立一个可以<strong>重复使用</strong>的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li>
<li>需要一个<strong>统一的输出接口</strong>，而输入端的类型不可预知。</li>
</ul>
<p><strong>工作中的场景</strong></p>
<ul>
<li><p>经常用来做旧系统改造和升级</p>
</li>
<li><p>如果我们的系统开发之后再也不需要维护，那么很多模式都是没必要的，但是不幸的是，事实却是维护一个系统的代价往往是开发一个系统的数倍。</p>
</li>
</ul>
<p><strong>我们学习中见过的场景</strong></p>
<ul>
<li>java.io.InputStreamReader(InputStream)</li>
<li>java.io.OutputStreamWriter(OutputStream)</li>
</ul>
<h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><p>一句话描述：Adapter类，通过<strong>继承</strong>需要被适配的类，<strong>实现</strong>我们想要的类<strong>接口</strong>，完成src-&gt;dst的适配。</p>
<p>我们现有的src类：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 介绍：src类: 我们有的220V电压</span></span><br><span class="line"><span class="comment"> * 作者：zhangxutong</span></span><br><span class="line"><span class="comment"> * 邮箱：zhangxutong@imcoming.com</span></span><br><span class="line"><span class="comment"> * 时间： 2016/10/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Voltage220</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">output220V</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> src = <span class="number">220</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;我是&quot;</span> + src + <span class="string">&quot;V&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想要的dst接口：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 介绍：dst接口：客户需要的5V电压</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> 作者：zhangxutong</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 邮箱：zhangxutong@imcoming.com</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> 时间： 2016/10/18.</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">*/</span></span></span></span></span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">interface</span> <span class="title">Voltage5</span> </span>&#123;</span><br><span class="line">    <span class="built_in">int</span> output5V();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适配器类：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 介绍：Adapter类：完成220V-5V的转变</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> 通过继承src类，实现 dst 类接口，完成src-&gt;dst的适配。</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 作者：zhangxutong</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span> 邮箱：zhangxutong@imcoming.com</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* 时间： 2016/10/18.</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span>/</span></span></span></span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220</span> <span class="keyword">implements</span> <span class="title">Voltage5</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="built_in">int</span> output5V() &#123;</span><br><span class="line">        <span class="built_in">int</span> src = output220V();</span><br><span class="line">        System.out.println(<span class="string">&quot;适配器工作开始适配电压&quot;</span>);</span><br><span class="line">        <span class="built_in">int</span> dst = src / <span class="number">44</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;适配完成后输出电压：&quot;</span> + dst);</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象的适配器模式（常用）"><a href="#对象的适配器模式（常用）" class="headerlink" title="对象的适配器模式（常用）"></a>对象的适配器模式（常用）</h3><p>基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承src类，而是持有src类的实例，以解决<strong>兼容性</strong>的问题。<br> 即：<strong>持有</strong> src类，<strong>实现</strong> dst 类<strong>接口</strong>，完成src-&gt;dst的适配。<br> （根据“合成复用原则”，在系统中<strong>尽量使用关联关系来替代继承关系</strong>，因此大部分结构型模式都是对象结构型模式。）</p>
<p> Adapter类如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 介绍：对象适配器模式：</span></span><br><span class="line"><span class="comment"> * 持有 src类，实现 dst 类接口，完成src-&gt;dst的适配。 。以达到解决**兼容性**的问题。</span></span><br><span class="line"><span class="comment"> * 作者：zhangxutong</span></span><br><span class="line"><span class="comment"> * 邮箱：zhangxutong@imcoming.com</span></span><br><span class="line"><span class="comment"> * 时间： 2016/10/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VoltageAdapter2</span> <span class="title">implements</span> <span class="title">Voltage5</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Voltage220 mVoltage220;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VoltageAdapter2</span>(<span class="params">Voltage220 voltage220</span>)</span> &#123;</span><br><span class="line">        mVoltage220 = voltage220;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">output5V</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> dst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != mVoltage220) &#123;</span><br><span class="line">            <span class="built_in">int</span> src = mVoltage220.output220V();</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;对象适配器工作，开始适配电压&quot;</span>);</span><br><span class="line">            dst = src / <span class="number">44</span>;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;适配完成后输出电压：&quot;</span> + dst);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。<br> 根据合成复用原则，组合大于继承，<br> 所以它解决了类适配器必须继承src的局限性问题，也不再强求dst必须是接口。<br> 同样的它使用成本更低，更灵活。</p>
<p>（和装饰者模式初学时可能会弄混，这里要搞清，装饰者是对src的装饰，使用者毫无察觉到src已经被装饰了（使用者用法不变）。 这里对象适配以后，使用者的用法还是变的。<br> <strong>即，装饰者用法： setSrc-&gt;setSrc，对象适配器用法：setSrc-&gt;setAdapter.</strong>)</p>
<h3 id="接口的适配器模式"><a href="#接口的适配器模式" class="headerlink" title="接口的适配器模式"></a>接口的适配器模式</h3><p>定义：</p>
<p>当不需要<strong>全部实现</strong>接口提供的方法时，可先设计一个<strong>抽象类</strong>实现接口，并为该接口中每个方法提供一个<strong>默认实现</strong>（空方法），那么该抽象类的子类可<strong>有选择</strong>地覆盖父类的某些方法来实现需求，它适用于<strong>一个接口不想使用其所有的方法</strong>的情况。</p>
<h2 id="七、桥接模式（Bridge）"><a href="#七、桥接模式（Bridge）" class="headerlink" title="七、桥接模式（Bridge）"></a>七、桥接模式（Bridge）</h2><p>将抽象与实现分离开来，使得它们可以独立变化。</p>
<p><strong>核心要点</strong></p>
<ul>
<li>处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。</li>
</ul>
<p><strong>效果及实现要点</strong>：</p>
<ol>
<li>桥接模式使用对象见的组合关系解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。</li>
<li>所谓抽象和实现沿着各自维度的变化，即“<strong>子类化</strong>”它们，得到各个子类之后，便可以任意它们，从而获得不同路上的不同其次。</li>
<li>桥接模式有时候类似于多继承方案，但是多继承方案往往违背了SRP原则，复用性较差。桥接模式是比继承方案更好的解决方法。</li>
<li>桥接模式的应用一般在“两个非常强的变化维度”，有时候即使有两个变化的维度，但是某个方向的变化维度并不剧烈——换而言之两个变化不会导致纵横交错的结果，并不一定要使用桥接模式。</li>
</ol>
<p><strong>使用场景</strong></p>
<ol>
<li>如果你不希望在抽象和实现部分采用固定的绑定关系，可以采用桥接模式，来把抽象和实现部分分开，然后在程序运行期间来动态的设置抽象部分需要用到的具体的实现，还可以动态切换具体的实现。</li>
<li>如果出现抽象部分和实现部分都应该可以扩展的情况，可以采用桥接模式，让抽象部分和实现部分可以独立的变化，从而可以灵活的进行单独扩展，而不是搅在一起，扩展一边会影响到另一边。</li>
<li>如果希望实现部分的修改，不会对客户产生影响，可以采用桥接模式，客户是面向抽象的接口在运行，实现部分的修改，可以独立于抽象部分，也就不会对客户产生影响了，也可以说对客户是透明的。</li>
<li>如果采用继承的实现方案，会导致产生很多子类，对于这种情况，可以考虑采用桥接模式，分析功能变化的原因，看看是否能分离成不同的纬度，然后通过桥接模式来分离它们，从而减少子类的数目。</li>
</ol>
<p><strong>实际开发中应用场景</strong></p>
<ul>
<li>JDBC驱动程序 <ul>
<li>AWT中的Peer架构</li>
</ul>
</li>
<li>银行日志管理：<ul>
<li>格式分类：操作日志、交易日志、异常日志 </li>
<li>距离分类：本地记录日志、异地记录日志</li>
</ul>
</li>
<li>人力资源系统中的奖金计算模块： <ul>
<li>奖金分类：个人奖金、团体奖金、激励奖金。 </li>
<li>部门分类：人事部门、销售部门、研发部门。</li>
</ul>
</li>
<li>OA系统中的消息处理： <ul>
<li>业务类型：普通消息、加急消息、特急消息 </li>
<li>发送消息方式：系统内消息、手机短信、邮件</li>
</ul>
</li>
</ul>
<h2 id="八、组合模式（composite）"><a href="#八、组合模式（composite）" class="headerlink" title="八、组合模式（composite）"></a>八、组合模式（composite）</h2><p>将对象组合成树形结构来表示“整体&#x2F;部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。</p>
<p><strong>组合模式核心：</strong></p>
<ul>
<li>组合部件（Component）：它是一个抽象角色，为要组合的对象提供统一的接口。</li>
<li>叶子（Leaf）：在组合中表示子节点对象，叶子节点不能有子节点。</li>
<li>合成部件（Composite）：定义有枝节点的行为，用来存储部件，实现在Component接口中的有关操作，如增加（Add）和删除（Remove）</li>
</ul>
<p>组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。</p>
<p>组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。</p>
<h3 id="透明模式"><a href="#透明模式" class="headerlink" title="透明模式"></a>透明模式</h3><p>在Component中声明所有来管理子对象的方法，其中包括Add，Remove等。这样实现Component接口的所有子类都具备了Add和Remove方法。这样做的好处是叶节点和枝节点对于外界没有区别，它们具备完全一致的接口。</p>
<p>component：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Component</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加一个叶子构件或树枝构件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component component)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除一个叶子构件或树枝构件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component component)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取分支下的所有叶子构件和树枝构件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> depth)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>composite：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Composite</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建容器</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; componentArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Component&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.componentArrayList.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.componentArrayList.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="comment">//输出树形结构</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;depth; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下级遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Component component : componentArrayList) &#123;</span><br><span class="line">            component.display(depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>leaf：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Leaf</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="comment">//空实现，抛出“不支持请求”异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="comment">//空实现，抛出“不支持请求”异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="comment">//输出树形结构的叶子节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;depth; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>弊端：客户端对叶节点和枝节点是一致的，但叶节点并不具备Add和Remove的功能，因而对它们的实现是没有意义的</p>
<h3 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h3><p>安全模式是把树枝节点和树叶节点彻底分开，树枝节点单独拥有用来组合的方法，这种方法比较安全。</p>
<p>component:</p>
<p>这里相比透明模式就少了add()和romove()抽象方法的声明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Component</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取分支下的所有叶子构件和树枝构件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> depth)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>composite：</p>
<p>这里add()和remove()方法的实现就从继承变为了自己实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Composite</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建容器</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; componentArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Component&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加一个叶子构件或树枝构件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.componentArrayList.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除一个叶子构件或树枝构件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.componentArrayList.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="comment">//输出树形结构</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;depth; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下级遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Component component : componentArrayList) &#123;</span><br><span class="line">            component.display(depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>leaf：</p>
<p>叶子节点中没有了空实现，比较安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Leaf</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="comment">//输出树形结构的叶子节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;depth; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合模式的应用"><a href="#组合模式的应用" class="headerlink" title="组合模式的应用"></a>组合模式的应用</h3><p>　　1. 何时使用</p>
<ul>
<li>想表达“部分-整体”层次结构（树形结构）时</li>
<li>希望用户忽略组合对象与单个对象的不同，用户将统一的使用组合结构中的所有对象</li>
</ul>
<p>　　2. 方法</p>
<ul>
<li>树枝和叶子实现统一接口，树枝内部组合该接口</li>
</ul>
<p>　　3. 优点</p>
<ul>
<li>高层模块调用简单。一棵树形机构中的所有节点都是Component，局部和整体对调用者来说没有任何区别，高层模块不必关心自己处理的是单个对象还是整个组合结构。</li>
<li>节点自由增加</li>
</ul>
<p>　　4. 缺点</p>
<ul>
<li>使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒转原则</li>
</ul>
<p>　　5. 使用场景</p>
<ul>
<li>维护和展示部分-整体关系的场景（如树形菜单、文件和文件夹管理）</li>
<li>从一个整体中能够独立出部分模块或功能的场景</li>
</ul>
<p>　　6. 应用实例</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/adamjwh/p/8392737.html">Swing</a>中，Button、Checkbox等组件都是树叶，而Container容器是树枝</li>
<li>文本编辑时，可以单个字编辑，也可以整段编辑，还可以全文编辑</li>
<li>文件复制时，可以一个一个文件复制，也可以整个文件夹复制</li>
</ul>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/adamjwh/p/9033547.html">简说设计模式——组合模式 - JAdam - 博客园 (cnblogs.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/29/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">java-设计模式（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-29 09:27:05" itemprop="dateCreated datePublished" datetime="2021-12-29T09:27:05Z">2021-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="三、建造者模式（Builder）"><a href="#三、建造者模式（Builder）" class="headerlink" title="三、建造者模式（Builder）"></a>三、建造者模式（Builder）</h2><p>建造者模式可以将一个类的构建和表示进行分离</p>
<p><strong>适用场景：</strong></p>
<ul>
<li>隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果</li>
<li>多个部件都可以装配到一个对象中，但产生的运行结果不相同</li>
<li>产品类非常复杂或者产品类因为调用顺序不同而产生不同作用</li>
<li>初始化一个对象时，参数过多，或者很多参数具有默认值</li>
<li>Builder模式不适合创建差异性很大的产品类<br> 产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本</li>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；</li>
</ul>
<p><strong>开发中应用场景：</strong></p>
<ul>
<li>StringBuilder类的append方法</li>
<li>SQL中的PreparedStatement</li>
<li>JDOM中，DomBuilder、SAXBuilder</li>
</ul>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3d1c9ffb0a28">一篇文章就彻底弄懂建造者模式(Builder Pattern) - 简书 (jianshu.com)</a></p>
<h2 id="四、原型模式（prototype）"><a href="#四、原型模式（prototype）" class="headerlink" title="四、原型模式（prototype）"></a>四、原型模式（prototype）</h2><p>使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。</p>
<p><strong>适用场景</strong></p>
<ul>
<li>通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式</li>
<li>就是java中的克隆技术，以某个对象为原型，复制出新的对象。显然，新的对象具备原型对象的特点。优势有：效率高(直接克隆，避免了重新执行构造过程步骤) </li>
<li>克隆类似于new，但是不同于new。new创建新的对象属性采用的是默认值。克隆出的 对象的属性值完全和原型对象相同。并且克隆出的新对象改变不会影响原型对象。然后， 再修改克隆对象的值。</li>
</ul>
<h3 id="原型模式实现"><a href="#原型模式实现" class="headerlink" title="原型模式实现"></a>原型模式实现</h3><ul>
<li>Cloneable接口和clone方法</li>
<li>Prototype模式中实现起来最困难的地方就是内存复制操作，所幸在Java中提供了 clone()方法替我们做了绝大部分事情。</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> Prototype <span class="title function_">myClone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String filed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcretePrototype</span><span class="params">(String filed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.filed = filed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Prototype <span class="title function_">myClone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(filed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> filed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">clone</span> <span class="operator">=</span> prototype.myClone();</span><br><span class="line">        System.out.println(clone.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/29/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/29/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/" class="post-title-link" itemprop="url">java-面向对象思想</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-29 09:26:25" itemprop="dateCreated datePublished" datetime="2021-12-29T09:26:25Z">2021-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h1><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="泛化关系（Generalization）"><a href="#泛化关系（Generalization）" class="headerlink" title="泛化关系（Generalization）"></a>泛化关系（Generalization）</h3><p>用来描述继承关系，在 Java 中使用 extends 关键字。</p>
<h3 id="实现关系-Realization"><a href="#实现关系-Realization" class="headerlink" title="实现关系 (Realization)"></a>实现关系 (Realization)</h3><p>用来实现一个接口，在 Java 中使用 implements 关键字。</p>
<h3 id="关联关系-Association"><a href="#关联关系-Association" class="headerlink" title="关联关系 (Association)"></a>关联关系 (Association)</h3><p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p>
<p>【代码表现】：成员变量</p>
<h3 id="聚合关系-Aggregation"><a href="#聚合关系-Aggregation" class="headerlink" title="聚合关系 (Aggregation)"></a>聚合关系 (Aggregation)</h3><p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p>
<p>聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。</p>
<p>【代码表现】：成员变量</p>
<h3 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="组合关系 (Composition)"></a>组合关系 (Composition)</h3><p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p>
<p>组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期</p>
<p>【代码表现】：成员变量</p>
<h3 id="依赖关系-Dependency"><a href="#依赖关系-Dependency" class="headerlink" title="依赖关系 (Dependency)"></a>依赖关系 (Dependency)</h3><p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：</p>
<ul>
<li>A 类是 B 类方法的局部变量；</li>
<li>A 类是 B 类方法的参数；</li>
<li>A 类向 B 类发送消息，从而影响 B 类发生变化。</li>
</ul>
<p>【代码表现】：局部变量、方法的参数或者对静态方法的调用</p>
<h3 id="各种关系的强弱顺序"><a href="#各种关系的强弱顺序" class="headerlink" title="各种关系的强弱顺序"></a>各种关系的强弱顺序</h3><p>泛化&#x3D;实现&gt;组合&gt;聚合&gt;关联&gt;依赖</p>
<h2 id="面向对象的六大原则"><a href="#面向对象的六大原则" class="headerlink" title="面向对象的六大原则"></a>面向对象的六大原则</h2><h3 id="1、单一职责原则SRP"><a href="#1、单一职责原则SRP" class="headerlink" title="1、单一职责原则SRP"></a>1、单一职责原则SRP</h3><p>面向对象的六大原则就一个类而言，应该仅有一个引起它变化的原因。</p>
<p>简单的说就是：一个类中应该是一组相关性很高的函数、数据的封装。两个不一样的功能不应该放在一个类中。</p>
<p>这个原则没有具体的划分界限，需要根据个人经验，具体业务逻辑而定。这也是优化代码的第一步。试想一下，如果所有的功能写在一个类里，那么这个类会越来越大，越来越复杂，越不易修改维护。那么根据功能，各自独立拆分出来，岂不是逻辑会清晰些。</p>
<h3 id="2、开闭原则OCP"><a href="#2、开闭原则OCP" class="headerlink" title="2、开闭原则OCP"></a>2、开闭原则OCP</h3><p>定义是：软件中的对象（类、模块、函数等）应该对于<strong>扩展是开放的，但是对于修改是封闭的</strong>。当软件需要变化时，我们<u>尽量</u>通过扩展的方式来实现变化，而不是通过修改已有的代码来实现（可能引入的代码会破坏原有系统）。</p>
<h3 id="3、里氏替换原则LSP"><a href="#3、里氏替换原则LSP" class="headerlink" title="3、里氏替换原则LSP"></a>3、里氏替换原则LSP</h3><p>定义：所有引用父类的地方，必须能使用子类的对象。简单地说就是<strong>将父类替换为他的子类是不会出现问题</strong>，反之，未必可以。</p>
<p>那么里氏替换原则就是依赖于面向对象语言的<strong>继承</strong>与<strong>多态</strong>。核心原理是<strong>抽象</strong>。</p>
<p>这里列举一下继承的优缺点：<br>优点：<br>（1）代码重用，减少创建类的成本，每个子类都拥有父类的方法与属性。<br>（2）子类与父类基本相似，但与父类又有所区别。<br>（3）提高代码的可扩展性。<br>缺点：<br>（1）继承是侵入性的，只要继承就必须拥有父类所有的属性与方法。<br>（2）可能造成子类代码冗余、灵活性降低。</p>
<p>开闭原则和里氏替换原则是生死相依的、不离不弃的。他们都强调了抽象这一重要的特性。</p>
<p>看着定义很是抽象，但是通俗的理解就是由子类实例化的父类引用，在使用这个引用时，感觉就像是使用了父类一样。一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;...&#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;...&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="comment">// 类型是A，但实际是B类型实例化的，就是依赖多态</span></span><br><span class="line">    a.method();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、依赖倒置原则DIP"><a href="#4、依赖倒置原则DIP" class="headerlink" title="4、依赖倒置原则DIP"></a>4、依赖倒置原则DIP</h3><p>定义：指代一种特定的解耦方式，使得高层次的模块不依赖于低层次的模块的实现细节的目的。他有一下几个关键点：<br>（1）高层模块不依赖于低层模块，应该都依赖其抽象。<br>（2）抽象不依赖细节。<br>（3）细节应依赖抽象。</p>
<p>解释：在Java中，<strong>抽象就是指接口或者抽象类，两者都是不能直接被实例化的</strong>；<strong>细节就是实现类，实现接口或者继承抽象类而产生的就是细节</strong>，也就是可以加上一个关键字new产生的对象。<strong>高层模块就是调用端，底层模块就是具体实现类。</strong></p>
<p>依赖倒置原则在Java中的表现就是：<strong>模块间通过抽象发生，实现类之间不发生直接依赖关系，其依赖关系是通过接口或者抽象类产生的。如果类与类直接依赖细节，那么就会直接耦合，那么当修改时，就会同时修改依赖者代码，这样限制了可扩展性。</strong></p>
<h3 id="5、接口隔离原则ISP"><a href="#5、接口隔离原则ISP" class="headerlink" title="5、接口隔离原则ISP"></a>5、接口隔离原则ISP</h3><p>定义：类间的依赖关系应该建立在最小的接口上，将庞大、臃肿的接口拆分成更小的、更具体的接口。目的是系统的解耦，从而更容易重构、更改和重新部署。</p>
<h3 id="6、迪米特原则LOD"><a href="#6、迪米特原则LOD" class="headerlink" title="6、迪米特原则LOD"></a>6、迪米特原则LOD</h3><p>定义：一个类应该对自己需要耦合或者调用的类知道的最少，类的内部如何实现与调用者或者依赖者没有关系，调用者或依赖者只需知道他需要的方法，其他可以一概不管。这样使得系统具有更低的耦合与更好的可扩展性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/23/java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/23/java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">java-类加载全过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-22 16:59:21" itemprop="dateCreated datePublished" datetime="2021-12-22T16:59:21Z">2021-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="类加载全过程"><a href="#类加载全过程" class="headerlink" title="类加载全过程"></a>类加载全过程</h1><p>一个Java文件从编码完成到最终执行，一般主要包括两个过程</p>
<ul>
<li><p>编译</p>
<p>即把java文件，通过javac命令编译成字节码，也就是.class文件。</p>
</li>
<li><p>运行</p>
<p>则是把编译生成的.class文件交给Java虚拟机(JVM)执行。</p>
</li>
</ul>
<p>类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。</p>
<p>JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且<strong>只加载一次</strong>。</p>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>类加载的过程主要分为三个部分：</p>
<ul>
<li>加载</li>
<li>链接</li>
<li>初始化</li>
</ul>
<p>而链接又可以细分为三个小部分：</p>
<ul>
<li>验证</li>
<li>准备</li>
<li>解析</li>
</ul>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20211223103209.jpeg" alt="img"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载指的是把class字节码文件从各个来源通过类加载器装载入内存中。</p>
<p>这里有两个重点：</p>
<ul>
<li><strong>字节码来源</strong>。一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译</li>
<li><strong>类加载器</strong>。一般包括<strong>启动类加载器</strong>，<strong>扩展类加载器</strong>，<strong>应用类加载器</strong>，以及用户的<strong>自定义类加载器</strong>。</li>
</ul>
<p><strong>注：为什么会有自定义类加载器？</strong></p>
<ul>
<li>一方面是由于java代码很容易被反编译，如果需要对自己的代码加密的话，可以对编译后的代码进行加密，然后再通过实现自己的自定义类加载器进行解密，最后再加载。</li>
<li>另一方面也有可能从非标准的来源加载代码，比如从网络来源，那就需要自己实现一个类加载器，从指定源进行加载。</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。</p>
<p>包括对于<strong>文件格式的验证</strong>，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？</p>
<p>对于<strong>元数据的验证</strong>，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？</p>
<p>对于<strong>字节码的验证</strong>，保证程序语义的合理性，比如要保证类型转换的合理性。</p>
<p>对于<strong>符号引用的验证</strong>，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>主要是为类变量（注意，不是实例变量）分配内存，并且赋予<strong>初值</strong>。</p>
<p>特别需要注意，<strong>初值，不是代码中具体写的初始化的值</strong>，而是Java虚拟机根据不同变量类型的默认初始值。</p>
<p>比如8种<strong>基本类型</strong>的初值，默认为0；<strong>引用类型</strong>的初值则为null；<strong>常量</strong>的初值即为代码中设置的值，final static tmp &#x3D; 456， 那么该阶段tmp的初值就是456</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将常量池内的符号引用替换为直接引用的过程。</p>
<p>两个重点：</p>
<ul>
<li><strong>符号引用</strong>。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。</li>
<li><strong>直接引用</strong>。可以理解为一个内存地址，或者一个偏移量。比如<strong>类方法，类变量</strong>的直接引用是指向方法区的<strong>指针</strong>；而<strong>实例方法，实例变量</strong>的直接引用则是从实例的头指针开始算起到这个实例变量位置的<strong>偏移量</strong></li>
</ul>
<p>举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。</p>
<p>在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>这个阶段主要是对<strong>类变量</strong>初始化，是执行类构造器的过程。类构造器<clinit>()方法是由编译器自动收集类中的所有类变量的<strong>赋值</strong>动作和**静态语句块(static块)**中的语句合并产生的。</p>
<p>换句话说，只对static修饰的变量或语句进行初始化。</p>
<p>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。</p>
<p>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</p>
<ul>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。</li>
</ul>
<p>Java程序初始化顺序：</p>
<blockquote>
<p> 1、父类的静态变量<br> 2、父类的静态代码块<br> 3、子类的静态变量<br> 4、子类的静态代码块<br> 5、父类的非静态变量<br> 6、父类的非静态代码块<br> 7、父类的构造方法<br> 8、子类的非静态变量<br> 9、子类的非静态代码块<br> 10、子类的构造方法</p>
</blockquote>
<h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><ol>
<li>创建类的实例，也就是new一个对象</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（Class.forName(“com.lyj.load”)）</li>
<li>初始化一个类的子类（会首先初始化子类的父类）</li>
<li>JVM启动时标明的启动类，即文件名和类名相同的那个类</li>
</ol>
<p>  除此之外，下面几种情形需要特别指出：</p>
<p> 对于一个final类型的静态变量，如果该变量的值在编译时就可以确定下来，那么这个变量相当于“宏变量”。Java编译器会在编译时直接把这个变量出现的地方替换成它的值，因此即使程序使用该静态变量，也不会导致该类的初始化。反之，如果final类型的静态Field的值不能在编译时确定下来，则必须等到运行时才可以确定该变量的值，如果通过该类来访问它的静态变量，则会导致该类被初始化。</p>
<h2 id="类的引用"><a href="#类的引用" class="headerlink" title="类的引用"></a>类的引用</h2><h3 id="主动引用（一定会初始化）"><a href="#主动引用（一定会初始化）" class="headerlink" title="主动引用（一定会初始化）"></a>主动引用（一定会初始化）</h3><p>当虚拟机启动，先初始化main方法所在的类<br>1.new一个类的对象<br>2.调用类的静态成员(除了final常量)和静态方法<br>3.使用java.lang.reflect包的方法对类进行反射调用<br>4.当初始化一个类的时候，如果其父类没有被初始化，则会先初始化它的父类</p>
<h3 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h3><p>1.访问一个静态域时，只有真正的声名这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类被初始化<br>2.通过数组引用定义类时，不会触发此类的初始化<br>3.引用常量不会触发此类的初始化(常量在链接阶段就存入调用类的常量池中了)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;mian方法所在类被初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  ClassNotFoundException&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          类的主动引用，一定会引起类的初始化 当虚拟机启动，先初始化main方法所在的类</span></span><br><span class="line"><span class="comment">          1.new一个类的对象</span></span><br><span class="line"><span class="comment">          2.调用类的静态成员(除了final常量)和静态方法</span></span><br><span class="line"><span class="comment">          3.使用java.lang.reflect包的方法对类进行反射调用</span></span><br><span class="line"><span class="comment">          4.当初始化一个类的时候，如果其父类没有被初始化，则会先初始化它的父类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//new一个类的对象</span></span><br><span class="line">        <span class="comment">//Animal animal = new Animal();//mian方法所在类被初始化 父类被初始化</span></span><br><span class="line">        <span class="comment">//调用类的静态成员(除了final常量)和静态方法</span></span><br><span class="line">        <span class="comment">//System.out.println(Animal.num);//mian方法所在类被初始化 3</span></span><br><span class="line">        <span class="comment">//System.out.println(Animal.name);//mian方法所在类被初始化 父类被初始化 狗</span></span><br><span class="line">        <span class="comment">//Animal.print();//mian方法所在类被初始化 父类被初始化 动物在叫</span></span><br><span class="line">        <span class="comment">//使用java.lang.reflect包的方法对类进行反射调用</span></span><br><span class="line">        <span class="comment">//Class c1 = Class.forName(&quot;exam.reflect.Cat&quot;);// mian方法所在类被初始化 父类被初始化 子类被初始化</span></span><br><span class="line">        <span class="comment">//当初始化一个类的时候，如果其父类没有被初始化，则会先初始化它的父类</span></span><br><span class="line">        <span class="comment">//Cat cat = new Cat();// mian方法所在类被初始化 父类被初始化 子类被初始化</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">           类的被动引用  不会发生类的初始化</span></span><br><span class="line"><span class="comment">           1.访问一个静态域时，只有真正的声名这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类被初始化</span></span><br><span class="line"><span class="comment">           2.通过数组引用定义类时，不会触发此类的初始化</span></span><br><span class="line"><span class="comment">           3.引用常量不会触发此类的初始化(常量在链接阶段就存入调用类的常量池中了)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//子类引用父类的静态变量，不会子类被初始化</span></span><br><span class="line">        <span class="comment">//System.out.println(Cat.name);mian方法所在类被初始化 父类被初始化 狗通过数组引用定义类时，不会触发此类的初始化</span></span><br><span class="line">        <span class="comment">//Animal[] animals = new Animal[5];//mian方法所在类被初始化</span></span><br><span class="line">        <span class="comment">//Cat[] cats = new Cat[6];//mian方法所在类被初始化</span></span><br><span class="line">        <span class="comment">//引用常量不会触发此类的初始化</span></span><br><span class="line">        <span class="comment">//System.out.println(Animal.NAME);//mian方法所在类被初始化 动物</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类被初始化&quot;</span>);</span><br><span class="line">        name = <span class="string">&quot;猫&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span>  <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类被初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">color</span>  <span class="operator">=</span> <span class="string">&quot;黄色&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="类加载器的原理"><a href="#类加载器的原理" class="headerlink" title="类加载器的原理"></a>类加载器的原理</h2><h3 id="类缓存"><a href="#类缓存" class="headerlink" title="类缓存"></a>类缓存</h3><p>标准的Java SE类加载器可以按要求查找类，一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过，JVM垃圾收集器可以回收这些Class对象。</p>
<h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20211224153606.webp" alt="img"></p>
<p><strong>A.从Java虚拟机的角度：</strong></p>
<p><strong>1.Bootstrap ClassLoader启动类加载器</strong><br><strong>2.其他类加载器</strong><br>从JVM的角度，加载器只分为两类,即JVM自身实现的Bootstrap启动类加载器，和其他JVM以外的所有类加载器。Bootstrap翻译为根，故也叫根类加载器。</p>
<p><strong>B.从开发者的角度：</strong></p>
<p><strong>1.Bootstrap ClassLoader根类加载器</strong><br><strong>2.Extension ClassLoader拓展类加载器</strong><br><strong>3.Application ClassLoader应用程序类加载器</strong><br>1.根类加载器，加载位于&#x2F;jre&#x2F;lib目录中的或者被参数-Xbootclasspath所指定的目录下的核心Java类库。此类加载器是Java虚拟机的一部分，使用native代码(C++)编写。</p>
<p>2.扩展类加载器，加载位于&#x2F;jre&#x2F;lib&#x2F;ext目录中的或者java.ext.dirs系统变量所指定的目录下的拓展类库。此加载器由sun.misc.Launcher ExtClassLoader实现。</p>
<p>3.系统类加载器，加载用户路径(ClassPath)上所指定的类库。此加载器由sun.misc.Launcher$ AppClassLoader实现。</p>
<blockquote>
<p><strong>引导类加载器（bootstrap class loader）</strong><br> （1）它用来加载 Java 的核心库(JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar,sun.boot.class.path路径下的内容)，是用原生代码（C语言）来实现的，并不继承自 java.lang.ClassLoader。<br> （2）加载扩展类和应用程序类加载器。并指定他们的父类加载器。</p>
<p><strong>扩展类加载器（extensions class loader）</strong><br> （1）用来加载 Java 的扩展库(JAVA_HOME&#x2F;jre&#x2F;ext&#x2F;*.jar，或java.ext.dirs路径下的内容) 。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java类。<br> （2）由sun.misc.Launcher$ExtClassLoader实现。</p>
<p><strong>应用程序类加载器（application class loader）</strong><br> （1）它根据 Java 应用的类路径（classpath，java.class.path 路径下的内容）来加载 Java 类。<strong>一般来说，Java 应用的类都是由它来完成加载的。</strong><br> （2）由sun.misc.Launcher$AppClassLoader实现。</p>
</blockquote>
<p>类加载器加载Class大致要经过如下8个步骤：</p>
<ol>
<li>检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。</li>
<li>如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。</li>
<li>请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。</li>
<li>请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。</li>
<li>当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。</li>
<li>从文件中载入Class，成功后跳至第8步。</li>
<li>抛出ClassNotFountException异常。</li>
<li>返回对应的java.lang.Class对象。</li>
</ol>
<h2 id="类加载器的代理模式"><a href="#类加载器的代理模式" class="headerlink" title="类加载器的代理模式"></a>类加载器的代理模式</h2><p>代理模式即是将指定类的加载交给其他的类加载器。常用双亲委托机制。</p>
<p>JVM的类加载机制主要有如下3种。</p>
<ul>
<li>全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</li>
<li>双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。</li>
<li>缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。</li>
</ul>
<h4 id="1、双亲委托机制"><a href="#1、双亲委托机制" class="headerlink" title="1、双亲委托机制"></a>1、双亲委托机制</h4><p>双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，如果都不能加载则报错——ClassNotFoundException。这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。</p>
<p>  双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</p>
<p>值得注意是，双亲委托机制是代理模式的一种，但并不是所有的类加载器都采用双亲委托机制。在tomcat服务器类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。</p>
<h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>（1）首先检查请求的类型是否已经被这个类装载器装载到命名空间中了，如果已经装载，直接返回；否则转入步骤2。</p>
<p>（2）委派类加载请求给父类加载器，如果父类加载器能够完成，则返回父类加载器加载的Class实例；否则转入步骤3。</p>
<p>（3）调用本类加载器的findClass（…）方法，试图获取对应的字节码，如果获取的到，则调用defineClass（…）导入类型到方法区；如果获取不到对应的字节码或者其他原因失败，返回异常给loadClass（…）， loadClass（…）转抛异常，终止加载过程（注意：这里的异常种类不止一种）。</p>
<p> <strong>- 注意：被两个类加载器加载的同一个类，JVM认为是不相同的类。</strong></p>
<h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><p>通常当你需要动态加载资源的时候 , 你至少有三个 ClassLoader 可以选择 :<br> 1.系统类加载器或叫作应用类加载器 (system classloader or application classloader)<br> 2.当前类加载器<br> 3.当前线程类加载器</p>
<p><strong>• 当前线程类加载器是为了抛弃双亲委派加载链模式。</strong><br> 每个线程都有一个关联的上下文类加载器。如果你使用new Thread()方式生成新的线程，新线程将继承其父线程的上下文类加载器。如果程序对线程上下文类加载器没有任何改动的话，程序中所有的线程将都使用系统类加载器作为上下文类加载器。<br> <strong>• Thread.currentThread().getContextClassLoader()</strong></p>
<h2 id="tomcat服务器的类加载器"><a href="#tomcat服务器的类加载器" class="headerlink" title="tomcat服务器的类加载器"></a>tomcat服务器的类加载器</h2><p>每个 Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式(不同于前面说的双亲委托机制)，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。但也是为了保证安全，这样核心库就不在查询范围之内。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/17/java-%E5%AD%97%E8%8A%82%E7%A0%81%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/17/java-%E5%AD%97%E8%8A%82%E7%A0%81%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">java-字节码操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-17 15:26:50" itemprop="dateCreated datePublished" datetime="2021-12-17T15:26:50Z">2021-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="字节码操作"><a href="#字节码操作" class="headerlink" title="字节码操作"></a>字节码操作</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>java的动态性的两种常见方式</p>
<ul>
<li>字节码操作</li>
<li>反射</li>
</ul>
<p>运行时操作字节码可以实现的功能如下：</p>
<ul>
<li><p>动态生成新的类</p>
</li>
<li><p>动态改变某个类的结构（添加&#x2F;删除&#x2F;修改 新的属性）</p>
</li>
</ul>
<p>优势：</p>
<ul>
<li><p>比反射开销小，性能高。</p>
</li>
<li><p>JAVAasist性能高于反射，低于ASM</p>
</li>
</ul>
<p>常见的字节码操作类库</p>
<ul>
<li><p>BCEL</p>
<p> Byte Code Engineering Library (BCEL) ，这是 Apache Software Foundation 的 Jakarta 项目的一部分。 BCEL 是 Java classworking 广泛 使用的一种 框架 , 它 可以让您深入 JVM 汇编语言进行类操作的细节。 BCEL 与 Javassist 有不同的处理字节码方法， BCEL 在实际的 JVM 指令层次上进行操作 (BCEL 拥有丰富的 JVM 指令级支持 ) 而 Javassist 所 强调 的是源代码 级别的 工作 。</p>
</li>
<li><p>ASM</p>
<p> 是一个轻量级 java 字节码操作框架，直接涉及到 JVM 底层的操作和 指令</p>
</li>
<li><p>CGLIB</p>
<p>是一个强大的，高性能，高质量的 Code</p>
</li>
<li><p>Javaassist </p>
<p>性能较ASM差，跟cglib差不多，但是用用简单，很多框架都在使用</p>
</li>
</ul>
<h2 id="javassist"><a href="#javassist" class="headerlink" title="javassist"></a>javassist</h2><p>使用Javassist需要使用javassist.jar</p>
<p>优势：</p>
<p>  比反射开销小，性能高。<br>  JAVAsist性能高于反射，低于ASM</p>
<p>局限性：</p>
<p>  JDK新语法不支持（包括泛型、枚举），不支持注解修改，但可以通过底层的javasist类来解决，具体参考：javassist.bytecode.annotaion<br>  不支持数组的初始化，如 String[]{“1”,”2”}，除非只有数组的容量为1<br>  不支持内部类和匿名类<br>  不支持 continue 和 break 表达式。<br>  对于继承关系，有些不支持 。例如：- class A{} - class B extends A{} - class C enxends B {}</p>
<p>应用场景：</p>
<p>  AOP:<br>    给一个类增加新的方法<br>    给一段语句前面和后面（before&#x2F;after&#x2F;around）动态的加代码<br>  Reflection:起到类似反射的效果</p>
<p>javassist 的最外层的 API 和 JAVA 的反射包中的 API 颇为类似 。</p>
<p>它主要由 CtClass ， CtMethod, ，以及 CtField 几个类组成。用以执行和 JDK 反射 API 中 java.lang.Class ， java.lang.reflect.Method ， java.lang.reflect.Method .Field 相同的 操作 。<br>方法操作</p>
<p>  修改已有方法的方法体体（插入代码到已有方法体）<br>  新增方法 删除方法<br>  占位符参数介绍：</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20211217164511.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtConstructor;</span><br><span class="line"><span class="keyword">import</span> javassist.CtField;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test10</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault(); <span class="comment">// 类池</span></span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">class1</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;com.gs.Emp&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建属性</span></span><br><span class="line">    <span class="type">CtField</span> <span class="variable">f1</span> <span class="operator">=</span> CtField.make(<span class="string">&quot;private int num;&quot;</span>, class1);</span><br><span class="line">    <span class="type">CtField</span> <span class="variable">f2</span> <span class="operator">=</span> CtField.make(<span class="string">&quot;private String name;&quot;</span>, class1);</span><br><span class="line">    class1.addField(f1);</span><br><span class="line">    class1.addField(f2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建方法</span></span><br><span class="line">     </span><br><span class="line">    <span class="type">CtMethod</span> <span class="variable">setName</span> <span class="operator">=</span> CtMethod.make(<span class="string">&quot;public void setName(String name)&#123;this.name = name;&#125;&quot;</span>, class1);</span><br><span class="line">    <span class="type">CtMethod</span> <span class="variable">getName</span> <span class="operator">=</span> CtMethod.make(<span class="string">&quot;public String getName()&#123;return name;&#125;&quot;</span>, class1);</span><br><span class="line">    class1.addMethod(setName);</span><br><span class="line">    class1.addMethod(getName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加构造器。  如果是带参构造器，需要传递参数类型，基本数据类型用CtClass获取，引用类型，需要用pool获取</span></span><br><span class="line">    <span class="type">CtConstructor</span> <span class="variable">constructor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtConstructor</span>(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;CtClass.intType,pool.get(<span class="string">&quot;java.lang.String&quot;</span>)&#125;, class1);</span><br><span class="line">    constructor.setBody(<span class="string">&quot;&#123;this.num = num;this.name = name;&#125;&quot;</span>); <span class="comment">//构造器的方法体</span></span><br><span class="line">    </span><br><span class="line">    class1.writeFile(<span class="string">&quot;E:/myjava&quot;</span>); <span class="comment">//将上面写好的类，写入到这个工作空间中</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;生成类成功！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903751082328072">Java 动态字节码技术 - 掘金 (juejin.cn)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/16/java-%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/16/java-%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E/" class="post-title-link" itemprop="url">java-脚本引擎</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-16 10:20:21" itemprop="dateCreated datePublished" datetime="2021-12-16T10:20:21Z">2021-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="脚本引擎"><a href="#脚本引擎" class="headerlink" title="脚本引擎"></a>脚本引擎</h1><p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20211216102211.jpg"></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>脚本引擎就是一个计算机编程语言的解释器</p>
<p>JAVA脚本引擎是从JDK6.0之后添加的新功能。 </p>
<p>脚本引擎介绍：</p>
<ul>
<li>使得Java应用程序可以通过一套固定的接口与各种脚本引擎交互，从而达到在Java平台上调用各种脚本语言的目的。</li>
<li>Java脚本API是连通Java平台和脚本语言的桥梁。 </li>
<li>可以把一些复杂异变的业务逻辑交给脚本语言处理，这又大大提高了开发效率</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在日常的Java项目中，我们免不了会遇到这样的需求：</p>
<ol>
<li>动态地获取并运行自定义脚本文件，以实现特定的功能</li>
<li>对数据流执行用户自定义的数据有效性、公式计算、数据处理ETL（如数据截取、拼接）等不同业务逻辑</li>
<li>对用户输入的代码或脚本文件进行测试、运行，确保其语法正确、功能正常</li>
<li>处理需要灵活配置且不断变更的动态业务规则</li>
<li>代码的热更新、热修复</li>
</ol>
<p>诸如此类的需求若采用硬编码实现，则迭代成本相当高，每次改动都需要进行开发、测试、部署。同时业务规则的频繁变更会导致代码的开发和维护成本大大提高</p>
<h2 id="js语言简介"><a href="#js语言简介" class="headerlink" title="js语言简介"></a>js语言简介</h2><p>js属于的是解释性语言。</p>
<ul>
<li><p>支持动态类型，弱类型，在程序运行的时候才进行编译，效率不较低。</p>
</li>
<li><p>不像编译性语言，源代码不能直接翻译成<strong>机器语言</strong>，先翻译成<strong>中间代码</strong>，再由<strong>解释器</strong>对中间代码进行解释运行。</p>
</li>
<li><p>程序不需要编译，程序运行时才翻译成机器语言，每执行一次都要翻译一次。</p>
</li>
<li><p>一般，<code>编译性语言的运行效率比解释性语言更高</code>；但是不能一概而论，部分解释性语言的解释器通过在运行时动态优化代码，甚至能使解释性语言的性能超过编译性语言；</p>
</li>
</ul>
<h2 id="简单的实现过程"><a href="#简单的实现过程" class="headerlink" title="简单的实现过程"></a>简单的实现过程</h2><h3 id="查找脚本引擎"><a href="#查找脚本引擎" class="headerlink" title="查找脚本引擎"></a>查找脚本引擎</h3><ol>
<li><p>通过脚本名称获取：</p>
<p>ScriptEngineManager:为ScriptEngine提供实例化机制。</p>
<p>　　方法：getEngineByName(String shortName);&#x2F;&#x2F;查找并创建指定名称的脚本引擎</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>().getEngineByName(<span class="string">&quot;JavaScript&quot;</span>); </span><br></pre></td></tr></table></figure>
</li>
<li><p>通过文件扩展名获取:</p>
<p>ScriptEngine:是一个接口，该接口提供了基本的脚本功能（包括执行脚本，设置和获取值的方法）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>().getEngineByExtension(<span class="string">&quot;js&quot;</span>);  </span><br><span class="line"></span><br><span class="line">方法：</span><br><span class="line">    	 get(String key);<span class="comment">//获取指定key所对应的值，这里的key看做变量名称，值看做变量名所对应的值。</span></span><br><span class="line"></span><br><span class="line">　　　　　eval(String script)；<span class="comment">//执行指定的脚本代码</span></span><br><span class="line"></span><br><span class="line">　　　　　eval(Reader reader)；<span class="comment">//执行指定的脚本文件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过MIME类型获取:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>().getEngineByMimeType(<span class="string">&quot;text/javascript&quot;</span>);  </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="语言绑定"><a href="#语言绑定" class="headerlink" title="语言绑定"></a>语言绑定</h3><p>脚本语言支持API使用语言绑定对象实现Java语言编写的程序与脚本语言间的数据传递。语言绑定对象实际上就是一个简单的<strong>哈希表</strong>，用来存放和获取需要共享的数据，其定义的接口为javax.script.Bindings，继承自java.util.Map接口。一个脚本引擎在执行过程中可能会使用多个语言绑定对象，不同语言绑定对象的作用域不同。ScriptEngine类提供out和get方法对脚本引擎中特定作用域的默认语言绑定对象进行操作。 </p>
<p>使用默认的语言绑定对象： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useDefaultBinding</span><span class="params">()</span> <span class="keyword">throws</span> ScriptException &#123;  </span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">    engine.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Alex&quot;</span>);  </span><br><span class="line">    engine.eval(<span class="string">&quot;var message = &#x27;Hello, &#x27; + name;&quot;</span>);  <span class="comment">//执行指定的脚本代码</span></span><br><span class="line">    engine.eval(<span class="string">&quot;println(message);&quot;</span>);  </span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> engine.get(<span class="string">&quot;message&quot;</span>);  </span><br><span class="line">    System.out.println(obj);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>亦可以自定义语言绑定对象（如语言绑定对象中包含程序自己独有的数据等情形……）： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useCustomBinding</span><span class="params">()</span> <span class="keyword">throws</span> ScriptException &#123;  </span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">    <span class="type">Bindings</span> <span class="variable">bindings</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleBindings</span>();  </span><br><span class="line">    bindings.put(<span class="string">&quot;hobby&quot;</span>, <span class="string">&quot;playing games&quot;</span>);  </span><br><span class="line">    engine.eval(<span class="string">&quot;println(&#x27;I like &#x27; + hobby);&quot;</span>, bindings);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="脚本引擎执行脚本方法"><a href="#脚本引擎执行脚本方法" class="headerlink" title="脚本引擎执行脚本方法"></a>脚本引擎执行脚本方法</h3><p>一、</p>
<ol>
<li>执行脚本方法，首先肯定是要在脚本中定义方法，然后执行。</li>
<li>执行时需要将engine转换为Invcable,然后调用其中的invokeFun</li>
</ol>
<p>　　Invocable:由ScriptEngines实现的可选接口，其方法允许调用先前已执行的脚本中的程序（方法）。</p>
<ol start="3">
<li>调用Object invokeFunction(String name, Object… args)；执行指定方法。</li>
</ol>
<p>　　name为方法名称，args为方法参数，返回是一个Object对象　</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.script.Invocable;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptEngine;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptEngineManager;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRhino</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ScriptException &#123;</span><br><span class="line">        <span class="type">ScriptEngineManager</span> <span class="variable">sem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>();</span><br><span class="line">        <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> sem.getEngineByName(<span class="string">&quot;javascript&quot;</span>);</span><br><span class="line">        <span class="comment">//定义方法的字符串形式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">funAdd</span> <span class="operator">=</span> <span class="string">&quot;function add(a,b)&#123;&quot;</span></span><br><span class="line">                    + <span class="string">&quot;      var sum = a + b;&quot;</span></span><br><span class="line">                    + <span class="string">&quot;     return sum;&quot;</span></span><br><span class="line">                    + <span class="string">&quot;  &#125;&quot;</span>;</span><br><span class="line">        engine.eval(funAdd);<span class="comment">//这一步可以看做将方法写入脚本</span></span><br><span class="line">        <span class="type">Invocable</span> <span class="variable">invo</span> <span class="operator">=</span> (Invocable)engine;<span class="comment">//转换成Invocable</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行脚本中方法</span></span><br><span class="line">            result = invo.invokeFunction(<span class="string">&quot;add&quot;</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">17</span>,<span class="number">23</span>&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二、</p>
<ol>
<li>执行脚本文件，首先我们要指定文件的路径。</li>
<li>通过这个路径构建一个Reader对象</li>
<li>调用eval(Reader reader)；&#x2F;&#x2F;执行指定的脚本文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptEngine;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptEngineManager;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRhino</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ScriptException &#123;</span><br><span class="line">        <span class="comment">//E:\eclipse\Rhino</span></span><br><span class="line">        <span class="type">ScriptEngineManager</span> <span class="variable">sem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>();</span><br><span class="line">        <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> sem.getEngineByName(<span class="string">&quot;javascript&quot;</span>);</span><br><span class="line">        <span class="comment">//脚本文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;E:\\eclipse\\Rhino\\test.js&quot;</span>;<span class="comment">//</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">read</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过脚本文件路径构造Reader对象</span></span><br><span class="line">            read = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(path));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行脚本文件</span></span><br><span class="line">        engine.eval(read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="脚本执行的上下文"><a href="#脚本执行的上下文" class="headerlink" title="脚本执行的上下文"></a>脚本执行的上下文</h3><p>脚本引擎通过执行过程中的上下文对象获取与脚本执行相关的信息，同时允许程序员通过此对象配置脚本引擎的行为。其上下文对象来自javax.script.ScriptContext接口，类似于J2EE中javax.servlet.ServletContext接口，该接口主要包含3类信息：</p>
<h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><p>默认情况下，脚本输入输出都是在标准控制台中，可以通过setReader和setWriter方法对输出流进行重定向，可以通过setErrorWriter方法进行错误输出重定向。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：将输出重定向到文件  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scriptToFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ScriptException &#123;  </span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">    <span class="type">ScriptContext</span> <span class="variable">context</span> <span class="operator">=</span> engine.getContext();  </span><br><span class="line">    context.setWriter(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>));  </span><br><span class="line">    engine.eval(<span class="string">&quot;println(&#x27;Hello World!&#x27;);&quot;</span>);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h4><p>上下文中通过setAttribute和getAttribute方法获取和设置属性，类似于ServletContext中设置和获取属性操作。与ServletContext中不同的是，ScriptContext中的属性是有作用域之分的，ScriptContext按不同的顺序在不同的作用域中进行属性查找（类似于JSP中EL表达式属性的作用域）。通过ScriptContext的getScopes可以得到其中所有可用的作用域，其中预定义了两个作用域：常量ScriptContext.ENGINE_SCOPE（当前的脚本引擎）和ScriptContext.GLOBAL_SCOPE（从同一引擎工厂中创建的所有脚本引擎对象）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scriptContextAttribute</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">    <span class="type">ScriptContext</span> <span class="variable">context</span> <span class="operator">=</span> engine.getContext();  </span><br><span class="line">    context.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Alex&quot;</span>, ScriptContext.GLOBAL_SCOPE);  </span><br><span class="line">    context.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Bob&quot;</span>, ScriptContext.ENGINE_SCOPE);  </span><br><span class="line">    context.getAttribute(<span class="string">&quot;name&quot;</span>); <span class="comment">//值为Bob  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="语言绑定对象"><a href="#语言绑定对象" class="headerlink" title="语言绑定对象"></a>语言绑定对象</h4><p>语言绑定对象位于ScriptContext中，同样也有作用域之分，范围越小，优先级越高。执行如下代码，输出的name值为Bob。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scriptContextBindings</span><span class="params">()</span> <span class="keyword">throws</span> ScriptException &#123;  </span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">    <span class="type">ScriptContext</span> <span class="variable">context</span> <span class="operator">=</span> engine.getContext();  </span><br><span class="line">    <span class="type">Bindings</span> <span class="variable">bindings1</span> <span class="operator">=</span> engine.createBindings();  </span><br><span class="line">    bindings1.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Alex&quot;</span>);  </span><br><span class="line">    context.setBindings(bindings1, ScriptContext.GLOBAL_SCOPE);  </span><br><span class="line">    <span class="type">Bindings</span> <span class="variable">bindings2</span> <span class="operator">=</span> engine.createBindings();  </span><br><span class="line">    bindings2.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Bob&quot;</span>);  </span><br><span class="line">    context.setBindings(bindings2, ScriptContext.ENGINE_SCOPE);  </span><br><span class="line">    engine.eval(<span class="string">&quot;println(name);&quot;</span>);    <span class="comment">//Bob  </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>也可以通过ScriptContext获取语言绑定对象： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useScriptContextValues</span><span class="params">()</span> <span class="keyword">throws</span> ScriptException &#123;  </span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">    <span class="type">ScriptContext</span> <span class="variable">context</span> <span class="operator">=</span> engine.getContext();  </span><br><span class="line">    <span class="type">Bindings</span> <span class="variable">bindings</span> <span class="operator">=</span> context.getBindings(ScriptContext.ENGINE_SCOPE);  </span><br><span class="line">    bindings.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Alex&quot;</span>);  </span><br><span class="line">    engine.eval(<span class="string">&quot;println(name);&quot;</span>);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>前面说到语言绑定对象存在于上下文环境中，故context中保存的自定义属性其实也是保存于语言绑定对象中的，如2中的语言绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeInBindings</span><span class="params">()</span> <span class="keyword">throws</span> ScriptException &#123;  </span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">    <span class="type">ScriptContext</span> <span class="variable">context</span> <span class="operator">=</span> engine.getContext();  </span><br><span class="line">    context.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Alex&quot;</span>, ScriptContext.GLOBAL_SCOPE);  </span><br><span class="line">    engine.eval(<span class="string">&quot;println(name);&quot;</span>);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="脚本编译"><a href="#脚本编译" class="headerlink" title="脚本编译"></a>脚本编译</h4><p>脚本语言一般均是解释执行的，相对于编译执行的语言，效率较低一些。当脚本语言需要多次重复执行时，可以先对煎熬本进行编译，避免重复解析，提高效率（注：脚本编译需要脚本引擎支持，实现javax.script.Compilable接口）。JavaSE中自带的JavaScript引擎是支持对脚本进行编译的，编译的脚本用javax.script.CompiledScript来表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScriptCompile</span> <span class="keyword">extends</span> <span class="title class_">JsScriptRunner</span> &#123;  </span><br><span class="line">    <span class="comment">//对脚本进行编译  </span></span><br><span class="line">    <span class="keyword">public</span> CompiledScript <span class="title function_">compile</span><span class="params">(String scriptText)</span> <span class="keyword">throws</span> ScriptException &#123;  </span><br><span class="line">        <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">        <span class="keyword">if</span> (engine <span class="keyword">instanceof</span> Compilable) &#123;  </span><br><span class="line">            <span class="type">CompiledScript</span> <span class="variable">script</span> <span class="operator">=</span> ((Compilable) engine).compile(scriptText);  </span><br><span class="line">            <span class="keyword">return</span> script;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//先编译再执行  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String scriptText)</span> <span class="keyword">throws</span> ScriptException &#123;  </span><br><span class="line">        <span class="type">CompiledScript</span> <span class="variable">script</span> <span class="operator">=</span> compile(scriptText);  </span><br><span class="line">        <span class="keyword">if</span> (script == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;  </span><br><span class="line">            script.eval();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">ScriptCompile</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptCompile</span>();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            sc.run(<span class="string">&quot;println(&#x27;Hello&#x27;);&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ScriptException ex) &#123;  </span><br><span class="line">            Logger.getLogger(ScriptCompile.class.getName()).log(Level.SEVERE, <span class="literal">null</span>, ex);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>Java虚拟机支持脚本的意义在于实现函数式的编程，即脚本中最重要的便是方法。一些脚本引擎允许使用者单独调用脚本中的某个方法，支持此操作的脚本引擎可以通过实现javax.script.Invocable接口，支持顶层方法或者某对象中成员方法的调用。使用方法调用时最好先检查脚本引擎是否实现了Invocable接口，JavaSE中的JavaScript引擎已实现了Invocable接口。</p>
<ol>
<li><p>在Java中调用脚本中的顶层方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeFunction</span><span class="params">()</span> <span class="keyword">throws</span> ScriptException, NoSuchMethodException &#123;  </span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">    <span class="type">String</span> <span class="variable">scriptText</span> <span class="operator">=</span> <span class="string">&quot;function greet(name) &#123; println(&#x27;Hello, &#x27; + name); &#125; &quot;</span>;  </span><br><span class="line">    engine.eval(scriptText);  </span><br><span class="line">    <span class="type">Invocable</span> <span class="variable">invocable</span> <span class="operator">=</span> (Invocable) engine;  </span><br><span class="line">    invocable.invokeFunction(<span class="string">&quot;greet&quot;</span>, <span class="string">&quot;Alex&quot;</span>);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>调用脚本中某对象的成员方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeMethod</span><span class="params">()</span> <span class="keyword">throws</span> ScriptException, NoSuchMethodException &#123;  </span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">    <span class="type">String</span> <span class="variable">scriptText</span> <span class="operator">=</span> <span class="string">&quot;var obj = &#123; getGreeting : function(name) &#123; return &#x27;Hello, &#x27; + name; &#125; &#125;; &quot;</span>;  </span><br><span class="line">    engine.eval(scriptText);  </span><br><span class="line">    <span class="type">Invocable</span> <span class="variable">invocable</span> <span class="operator">=</span> (Invocable) engine;  </span><br><span class="line">    <span class="type">Object</span> <span class="variable">scope</span> <span class="operator">=</span> engine.get(<span class="string">&quot;obj&quot;</span>);  </span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocable.invokeMethod(scope, <span class="string">&quot;getGreeting&quot;</span>, <span class="string">&quot;Alex&quot;</span>);   <span class="comment">//第一个参数为方法所属对象  </span></span><br><span class="line">    System.out.println(result);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>指定脚本中的方法为Java接口的实现</p>
<p> Greet是Java实现的接口，包含一个方法getGreeting，通过Invocable.getInterface()方法指定脚本中的方法为Java接口的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useInterface</span><span class="params">()</span> <span class="keyword">throws</span> ScriptException &#123;  </span><br><span class="line">    <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> getJavaScriptEngine();  </span><br><span class="line">    <span class="type">String</span> <span class="variable">scriptText</span> <span class="operator">=</span> <span class="string">&quot;function getGreeting(name) &#123; return &#x27;Hello, &#x27; + name; &#125; &quot;</span>;  </span><br><span class="line">    engine.eval(scriptText);  </span><br><span class="line">    <span class="type">Invocable</span> <span class="variable">invocable</span> <span class="operator">=</span> (Invocable) engine;  </span><br><span class="line">    <span class="type">Greet</span> <span class="variable">greet</span> <span class="operator">=</span> invocable.getInterface(Greet.class);  </span><br><span class="line">    System.out.println(greet.getGreeting(<span class="string">&quot;Alex&quot;</span>));  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Nashorn-JavaScript脚本引擎"><a href="#Nashorn-JavaScript脚本引擎" class="headerlink" title="Nashorn JavaScript脚本引擎"></a>Nashorn JavaScript脚本引擎</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2021/12/15/java-%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/15/java-%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">java-动态编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-15 13:39:32" itemprop="dateCreated datePublished" datetime="2021-12-15T13:39:32Z">2021-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h1><p>动态编译，就是在程序运行时产生java类，并编译成class文件。</p>
<h2 id="动态编译的实现方式"><a href="#动态编译的实现方式" class="headerlink" title="动态编译的实现方式"></a>动态编译的实现方式</h2><p>正常情况下先编译（明文源码到字节码），后执行（JVM加载字节码，获得类模板，实例化，方法使用）。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20211215143048.png" alt="程序流程图"></p>
<h3 id="相关类介绍"><a href="#相关类介绍" class="headerlink" title="相关类介绍"></a>相关类介绍</h3><p>JavaCompiler: 负责读取源代码，编译诊断，输出class<br>JavaFileObject: 文件抽象，代表源代码或者编译后的class<br>JavaFileManager: 管理JavaFileObject，负责JavaFileObject的创建和保存位置<br>ClassLoader: 根据字节码，生成类模板</p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>由于代码在编译的时候，类定义甚至类名称还不存在，所以没法直接声明使用的。只能定义一个接口代替之，具体实现留给后面的动态编译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用-JavaCompiler-接口来编译-java-源程序-最简单的"><a href="#使用-JavaCompiler-接口来编译-java-源程序-最简单的" class="headerlink" title="使用 JavaCompiler 接口来编译 java 源程序(最简单的)"></a>使用 JavaCompiler 接口来编译 java 源程序(最简单的)</h3><p>通过 ToolProvider 类的静态方法 getSystemJavaCompiler 来得到一个 JavaCompiler 接 口的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JavaCompiler</span> <span class="variable">compiler</span> <span class="operator">=</span> ToolProvider.getSystemJavaCompiler();</span><br></pre></td></tr></table></figure>

<p>javaCompiler 中最核心的方法是 run。通过这个方法能编译 java 源程序。这个方法有 3 个固 定参数和 1 个可变参数。前 3 个参数分别用来为 java 编译器提供参数、得到 Java 编译器的输出信息及接收编译器的 错误信息,后面的可变参数能传入一个或多个 Java 源程式文件。如果 run 编译成功,返回 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> compiler.run(<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,sourceFile);</span><br><span class="line">System.out.println(result==<span class="number">0</span>?<span class="string">&quot;编译成功&quot;</span>：<span class="string">&quot;编译失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一个参数：为java编译器提供参数</p>
</li>
<li><p>第二个参数：得到java编译器的输出信息</p>
</li>
<li><p>第三个参数：接收编译器的错误信息</p>
</li>
<li><p>第四个参数：可变参数（String数组）能传入一个或者多个java源文件</p>
</li>
<li><p>返回值：0表示编译成功，非0表示编译失败</p>
</li>
<li><p>如果前 3 个参数传入的是 null,那么 run 方法将以标准的输入、输出代替,即 System.in、 System.out 和 System.err。如果我们要编译一个 hello.java 文件,并将使用标准输入输出,run 的使用方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">results</span> <span class="operator">=</span> tool.run(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="string">&quot;Hello.java&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用-StandardJavaFileManager-编译-Java-源程序"><a href="#使用-StandardJavaFileManager-编译-Java-源程序" class="headerlink" title="使用 StandardJavaFileManager 编译 Java 源程序"></a>使用 StandardJavaFileManager 编译 Java 源程序</h3><p>StandardJavaFileManager 类能非常好地控制输入、输出,并且能通过 DiagnosticListener 得到诊断信息,而 DiagnosticCollector 类就是 listener 的实现。</p>
<p>使用 StandardJavaFileManager 需要两步。<br>首先建立一个 DiagnosticCollector 实例及通过 JavaCompiler 的 getStandardFileManager()方法得到一个 StandardFileManager 对象。<br>最后通过 CompilationTask 中的 call 方法编译源程序</p>
<h3 id="源代码的文件级动态编译"><a href="#源代码的文件级动态编译" class="headerlink" title="源代码的文件级动态编译"></a>源代码的文件级动态编译</h3><p>java源码以文件的形式存在本地，程序去指定路径加载源文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">classPath</span> <span class="operator">=</span> File2Class.class.getResource(<span class="string">&quot;/&quot;</span>).getPath();</span><br><span class="line"><span class="comment">//在这里我们是动态生成定义，然后写入文件。也可以直接读一个已经存在的文件</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;import classloader.Printer;&quot;</span> </span><br><span class="line">    + <span class="string">&quot;public class MyPrinter1 implements Printer &#123;&quot;</span> </span><br><span class="line">    + <span class="string">&quot;public void print() &#123;&quot;</span> </span><br><span class="line">    + <span class="string">&quot;System.out.println(\&quot;test1\&quot;);&quot;</span> </span><br><span class="line">    + <span class="string">&quot;&#125;&#125;&quot;</span>;</span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(classPath + <span class="string">&quot;MyPrinter1.java&quot;</span>);</span><br><span class="line">writer.write(str);;</span><br><span class="line">writer.close();</span><br><span class="line"><span class="comment">//获得系统编译器</span></span><br><span class="line"><span class="type">JavaCompiler</span> <span class="variable">compiler</span> <span class="operator">=</span> ToolProvider.getSystemJavaCompiler();</span><br><span class="line"><span class="comment">//获得java文件管理器</span></span><br><span class="line"><span class="type">StandardJavaFileManager</span> <span class="variable">fileManager</span> <span class="operator">=</span> compiler.getStandardFileManager(<span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//读入源文件</span></span><br><span class="line"><span class="type">Iterable</span> <span class="variable">fileObject</span> <span class="operator">=</span> fileManager.getJavaFileObjects(classPath + <span class="string">&quot;MyPrinter1.java&quot;</span>);</span><br><span class="line"><span class="comment">//生成编译任务</span></span><br><span class="line">JavaCompiler.<span class="type">CompilationTask</span> <span class="variable">task</span> <span class="operator">=</span> compiler.getTask(</span><br><span class="line">                <span class="literal">null</span>, fileManager, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, fileObject);</span><br><span class="line"><span class="comment">//执行编译任务</span></span><br><span class="line">task.call();</span><br><span class="line">fileManager.close();</span><br><span class="line"><span class="comment">//指定class路径，默认和源代码路径一致，加载class</span></span><br><span class="line"><span class="type">URLClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;file:&quot;</span> + classPath)&#125;);</span><br><span class="line"><span class="type">Printer</span> <span class="variable">printer</span> <span class="operator">=</span> (Printer)classLoader.loadClass(<span class="string">&quot;MyPrinter1&quot;</span>).newInstance();</span><br><span class="line">printer.print();</span><br></pre></td></tr></table></figure>

<h3 id="源代码的内存级动态编译"><a href="#源代码的内存级动态编译" class="headerlink" title="源代码的内存级动态编译"></a>源代码的内存级动态编译</h3><p>上节源代码落地了，这节让我们看下源代码和class全程在内存不落地，如何实现动态编译。思路是生成源代码对应的JavaFileObject时，从内存string读取；生成class对应的JavaFileObject时，以字节数组的形式存到内存。JavaFileObject是一个interface， SimpleJavaFileObject是JavaFileObject的一个基本实现，当自定义JavaFileObject时，继承SimpleJavaFileObject，然后改写部分函数。<br>自定义JavaSourceFromString，作为源代码的抽象文件（来自JDK API文档）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A file object used to represent source coming from a string.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaSourceFromString</span> <span class="keyword">extends</span> <span class="title class_">SimpleJavaFileObject</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The source code of this &quot;file&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> String code;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new JavaSourceFromString.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name of the compilation unit represented by this file object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> code the source code for the compilation unit represented by this file object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JavaSourceFromString(String name, String code) &#123;</span><br><span class="line">    <span class="built_in">super</span>(URI.create(<span class="string">&quot;string:///&quot;</span> + name.replace(<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;/&#x27;</span>) + Kind.SOURCE.extension), Kind.SOURCE);</span><br><span class="line">    <span class="built_in">this</span>.code = code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> CharSequence <span class="title function_">getCharContent</span><span class="params">(<span class="type">boolean</span> ignoreEncodingErrors)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaClassFileObject，代表class的文件抽象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaClassFileObject</span> <span class="keyword">extends</span> <span class="title class_">SimpleJavaFileObject</span> &#123;</span><br><span class="line">    <span class="comment">//用于存储class字节</span></span><br><span class="line">    ByteArrayOutputStream outputStream;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JavaClassFileObject</span><span class="params">(String className, Kind kind)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(URI.create(<span class="string">&quot;string:///&quot;</span> + className.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>) + kind.extension), kind);</span><br><span class="line">        outputStream = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OutputStream <span class="title function_">openOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> outputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] getClassBytes() &#123;</span><br><span class="line">        <span class="keyword">return</span> outputStream.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ClassFileManager，修改JavaFileManager生成class的JavaFileObject的行为，另外返回一个自定义ClassLoader用于返回内存中的字节码对应的类模板</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassFileManager</span> <span class="keyword">extends</span> <span class="title class_">ForwardingJavaFileManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JavaClassFileObject classFileObject;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new instance of ForwardingJavaFileManager.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileManager delegate to this file manager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">ClassFileManager</span><span class="params">(JavaFileManager fileManager)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(fileManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a JavaFileObject file object for output</span></span><br><span class="line"><span class="comment">     * representing the specified class of the specified kind in the given location.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> JavaFileObject <span class="title function_">getJavaFileForOutput</span><span class="params">(Location location, String className, JavaFileObject.Kind kind, </span></span><br><span class="line"><span class="params">    FileObject sibling)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        classFileObject = <span class="keyword">new</span> <span class="title class_">JavaClassFileObject</span>(className, kind);</span><br><span class="line">        <span class="keyword">return</span> classFileObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//获得一个定制ClassLoader，返回我们保存在内存的类</span></span><br><span class="line">    <span class="keyword">public</span> ClassLoader <span class="title function_">getClassLoader</span><span class="params">(Location location)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClassLoader</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="type">byte</span>[] classBytes = classFileObject.getClassBytes();</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用自定义的JavaFileObject&#x2F;JavaFileManager来动态编译</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;import Printer;&quot;</span> </span><br><span class="line">    + <span class="string">&quot;public class MyPrinter2 implements Printer &#123;&quot;</span> </span><br><span class="line">    + <span class="string">&quot;public void print() &#123;&quot;</span></span><br><span class="line">    + <span class="string">&quot;System.out.println(\&quot;test2\&quot;);&quot;</span></span><br><span class="line">    + <span class="string">&quot;&#125;&#125;&quot;</span>;</span><br><span class="line"><span class="comment">//生成源代码的JavaFileObject</span></span><br><span class="line"><span class="type">SimpleJavaFileObject</span> <span class="variable">fileObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaSourceFromString</span>(<span class="string">&quot;MyPrinter2&quot;</span>, str);</span><br><span class="line"><span class="type">JavaCompiler</span> <span class="variable">compiler</span> <span class="operator">=</span> ToolProvider.getSystemJavaCompiler();</span><br><span class="line"><span class="comment">//被修改后的JavaFileManager</span></span><br><span class="line"><span class="type">JavaFileManager</span> <span class="variable">fileManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassFileManager</span>(compiler.getStandardFileManager(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line"><span class="comment">//执行编译</span></span><br><span class="line">JavaCompiler.<span class="type">CompilationTask</span> <span class="variable">task</span> <span class="operator">=</span> compiler.getTask(<span class="literal">null</span>, fileManager, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, Arrays.asList(fileObject));</span><br><span class="line">task.call();</span><br><span class="line"><span class="comment">//获得ClassLoader，加载class文件</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> fileManager.getClassLoader(<span class="literal">null</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">printerClass</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;MyPrinter2&quot;</span>);</span><br><span class="line"><span class="comment">//获得实例</span></span><br><span class="line"><span class="type">Printer</span> <span class="variable">printer</span> <span class="operator">=</span> (Printer) printerClass.newInstance();</span><br><span class="line">printer.print();</span><br></pre></td></tr></table></figure>

<h2 id="慎用动态编译"><a href="#慎用动态编译" class="headerlink" title="慎用动态编译"></a>慎用动态编译</h2><ul>
<li>在框架中谨慎使用</li>
<li>不要在要求高性能的项目使用<br>动态编译毕竟需要一个编译过程，与静态编译相比多了一个执行环节，因此在高性能项目中不要使用动态编译。</li>
<li>动态编译要考虑安全问题<br>它是非常典型的注入漏洞，只要上传一个恶意Java程序就可以让你所有的安全工作毁于一旦。</li>
<li>记录动态编译过程<br>建议记录源文件、目标文件、编译过程、执行过程等日志，不仅仅是为了诊断，还是为了安全和审计，对Java项目来说，空中编译和运行是很不让人放心的，留下这些依据可以更好地优化程序</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://seanwangjs.github.io/2018/03/13/java-runtime-compile.html">Java 类运行时动态编译技术 - Fenrier Lab (seanwangjs.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904181623439368">深入理解Java的动态编译 - 掘金 (juejin.cn)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rhb</p>
  <div class="site-description" itemprop="description">纵浪大化中，不喜亦不惧</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">147</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RShawshank" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RShawshank" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rhb</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://lib.baomitu.com/canvas-nest.js/1.0.1/canvas-nest.js"></script>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
