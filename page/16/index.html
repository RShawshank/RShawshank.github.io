<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rshawshank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="纵浪大化中，不喜亦不惧">
<meta property="og:type" content="website">
<meta property="og:title" content="rhb_blog">
<meta property="og:url" content="http://rshawshank.github.io/page/16/index.html">
<meta property="og:site_name" content="rhb_blog">
<meta property="og:description" content="纵浪大化中，不喜亦不惧">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rhb">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rshawshank.github.io/page/16/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>rhb_blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rhb_blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">rao的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">63</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">27</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">155</span></a>

  </li>
        <li class="menu-item menu-item-photos">

    <a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
        <li class="menu-item menu-item-readnote">

    <a href="/readnote" rel="section"><i class="fa fa-book fa-fw"></i>阅读笔记</a>

  </li>
        <li class="menu-item menu-item-somethink">

    <a href="/somethink/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>随笔闲谈</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/RShawshank" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2019/11/28/Algorithm_%E9%80%92%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/28/Algorithm_%E9%80%92%E5%BD%92/" class="post-title-link" itemprop="url">递归</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-28 15:24:35" itemprop="dateCreated datePublished" datetime="2019-11-28T15:24:35Z">2019-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文希望总结一下递归的用法和理解。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/11/28/Algorithm_%E9%80%92%E5%BD%92/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2019/11/28/ComputerNetworking_%E5%BA%94%E7%94%A8%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/28/ComputerNetworking_%E5%BA%94%E7%94%A8%E5%B1%82/" class="post-title-link" itemprop="url">应用层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-27 23:52:45" itemprop="dateCreated datePublished" datetime="2019-11-27T23:52:45Z">2019-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-18 15:06:26" itemprop="dateModified" datetime="2020-04-18T15:06:26Z">2020-04-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>应用层直接面向用户，是OSI中的最高层。它的主要任务是为用户提供应用的接口，即提供不同计算机间的文件传送、访问与管理，电子邮件的内容处理，不同计算机通过网络交互访问的虚拟终端功能等。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/11/28/ComputerNetworking_%E5%BA%94%E7%94%A8%E5%B1%82/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2019/11/28/Algorithm_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/28/Algorithm_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">动态规划算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-27 20:52:45" itemprop="dateCreated datePublished" datetime="2019-11-27T20:52:45Z">2019-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 06:12:36" itemprop="dateModified" datetime="2021-03-08T06:12:36Z">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="url" rel="index"><span itemprop="name">动态规划</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1><p>**动态规划(dynamic programming)**是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。这个方法很类似于数学上的数学归纳法。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>动态规划实际上是一类题目的总称，并不是指某个固定的算法。动态规划的意义就是通过采用<strong>递推（或者分而治之）</strong>的策略，通过解决大问题的子问题从而解决整体的做法。</p>
<p>动态规划的<strong>核心思想</strong>是巧妙的将问题拆分成多个子问题，通过计算子问题而得到整体问题的解。而子问题又可以拆分成更多的子问题，从而用类似递推迭代的方法解决要求的问题。</p>
<p>动态规划的本质，是对问题<strong>状态的定义</strong>和<strong>状态转移方程的定义</strong></p>
<p><strong>拆分问题</strong>，靠的就是<strong>状态的定义</strong>和<strong>状态转移方程的定义</strong>。</p>
<p>参考资料：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23995189/answer/35324479">动态规划</a></p>
<p>​		 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23995189/answer/35429905">动态规划实质</a></p>
<p>动态规划算法通常基于一个递推公式及一个或多个初始状态。当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度，因此它比回溯法、暴力法等要快许多。</p>
<blockquote>
<p>每个阶段只有一个状态-&gt;递推；<br>每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心；<br>每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索；<br>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。</p>
<blockquote>
<p>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到</p>
</blockquote>
<p>这个性质叫做最优子结构；</p>
<blockquote>
<p>而不管之前这个状态是如何得到的</p>
</blockquote>
<p>这个性质叫做无后效性。</p>
</blockquote>
<h2 id="动态规划和分治的区别"><a href="#动态规划和分治的区别" class="headerlink" title="动态规划和分治的区别"></a>动态规划和分治的区别</h2><p>动态规划也是一种分治思想（比如其状态转移方程就是一种分治），但与分治算法不同的是，<strong>分治算法是把原问题分解为若干个子问题，自顶向下求解子问题，合并子问题的解，从而得到原问题的解</strong>。<strong>动态规划也是把原始问题分解为若干个子问题，然后自底向上，先求解最小的子问题，把结果存在表格中，在求解大的子问题时，直接从表格中查询小的子问题的解</strong>，避免重复计算，从而提高算法效率。（因为分治策略会反复求解公共子问题）</p>
<h2 id="可以采用动态规划求解的问题的一般要具有3个性质"><a href="#可以采用动态规划求解的问题的一般要具有3个性质" class="headerlink" title="可以采用动态规划求解的问题的一般要具有3个性质"></a>可以采用动态规划求解的问题的一般要具有3个性质</h2><h3 id="1、最优化子结构原理"><a href="#1、最优化子结构原理" class="headerlink" title="1、最优化子结构原理"></a>1、最优化子结构原理</h3><p>如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。最有子结构是使用动态规划的最基本的条件，如果不具有最优子结构性质，就不可以使用动态规划解决。<a target="_blank" rel="noopener" href="https://zhpmatrix.github.io/2016/10/08/dynamic-programming/">证明的例子</a></p>
<blockquote>
<p>如何证明问题的最优解满足最优子结构性呢？</p>
<p>即证明：作为构成原问题最优解的组成部分，对应每个子问题的部分应是该子问题的最优解。</p>
<p>“剪切-粘贴”（cut-and-paste）技术：</p>
<p>本质上是反证法证明：假定原问题最优解中对应于某个子问题的部分解不是该子问题的最优解，而存在“更优的子解”，那么我们可以从原问题的解中“剪切”掉这一部分，而将“更优的子解”粘贴进去，从而得到一个比最优解“更优”的解，这与最初的解是原问题的最优解的前提假设相矛盾。因此，不可能存在“更优的子解”。——所以，原问题的子问题的解必须是其最优解，最优子结构性成立。</p>
</blockquote>
<h3 id="2、子问题重叠"><a href="#2、子问题重叠" class="headerlink" title="2、子问题重叠"></a>2、子问题重叠</h3><p>子问题重叠不是使用动态规划的必要条件，但是问题存在子问题重叠的特性更能够充分彰显动态规划的优势。</p>
<p>举个例子：求斐波那契数列时fib(8)&#x3D;fib(7)+fib(6)，其中fib(8)的最优解就包含了子问题fib(7)的最优解和子问题fib(6)的最优解，反过来讲只要我们求解出子问题的最优解，那么就可以构造出问题的最优解，这也就是为什么最优子结构是求解动态规划的必要条件。fib(7)和fib(6)中有相同的子问题fib(5)，这就是子问题重叠。</p>
<h3 id="3、无后效性"><a href="#3、无后效性" class="headerlink" title="3、无后效性"></a>3、无后效性</h3><p>即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
<h3 id="动态规划的维数"><a href="#动态规划的维数" class="headerlink" title="动态规划的维数"></a>动态规划的维数</h3><p>斐波那契数列问题中的递归方程中只涉及一个变量i，所以是一维的动态规划，最长公共子序列问题中，递归方程中涉及两个变量，是二维的动态规划。一个很直观的理解就是，动态规划在从子问题的最优解来得到问题的最优解的过程中所填写的那张表格是几维的，就是几维的动态规划。</p>
<p>最长公共子串（Longest Common Substring）与最长公共子序列（Longest Common Subsequence）的区别： 子串要求在原字符串中是连续的，而子序列则只需保持相对顺序一致，并不要求连续。</p>
<h3 id="如何验证最优子结构特性"><a href="#如何验证最优子结构特性" class="headerlink" title="如何验证最优子结构特性"></a>如何验证最优子结构特性</h3><p>先写出问题的最优解和子问题的最优解的关系，然后假定问题的最优解成立（上面关系的左边成立），看能否得到子问题的最优解就是关系式右边的子问题最优解的形式，如果是就验证了最优子结构（一般用反证法）。</p>
<h2 id="解题核心"><a href="#解题核心" class="headerlink" title="解题核心"></a>解题核心</h2><p>动态规划的解题核心主要分为两步：</p>
<ol>
<li><strong>第一步：状态的定义</strong></li>
<li><strong>第二步：状态转移方程的定义</strong></li>
</ol>
<p>在这里，我们为了避免混淆用“状态”这个词来替代“问题”这个词。“问题”表示的含义类似：题目、要求解的内容、题干中的疑问句这样的概念。状态表示我们在求解问题之中对问题的分析转化。</p>
<h3 id="第一步：状态的定义"><a href="#第一步：状态的定义" class="headerlink" title="第一步：状态的定义"></a>第一步：状态的定义</h3><p>—————-刻画了一个最优解的结构特征（最优子结构性）</p>
<p>有的问题过于抽象，或者过于啰嗦干扰我们解题的思路，我们要做的就是将题干中的问题进行转化（换一种说法，含义不变）。转化成一系列同类问题的某个解的情况，比如说：</p>
<blockquote>
<p>题目：求一个数列中最大连续子序列的和。</p>
</blockquote>
<p>我们要将这个原问题转化为：</p>
<blockquote>
<p>状态定义：F<del>k</del>是第k项前的最大序列和，求F<del>1</del>～F<del>N</del>中最大值。</p>
</blockquote>
<p>通过换一种表述方式，我们清晰的发现了解决问题的思路，如何求出F<del>1</del>～F<del>N</del>中的最大值是解决原问题的关键部分。上述将原问题转化成另一种表述方式的过程叫做：状态的定义。这样的状态定义给出了一种类似通解的思路，把一个原来毫无头绪的问题转换成了可以求解的问题。</p>
<h3 id="第二步：状态转移方程的定义"><a href="#第二步：状态转移方程的定义" class="headerlink" title="第二步：状态转移方程的定义"></a>第二步：状态转移方程的定义</h3><p>—————-递归地定义最优解的值（一个递推关系式）</p>
<p>在进行了状态的定义后，自然而然的想到去求解F<del>1</del>～F<del>N</del>中最大值。这也是状态定义的作用，让我们<strong>把一个总体的问题转化成一系列问题</strong>，而第二步：状态转移方程的定义则告诉我们如何去求解一个问题，对于上述已经转换成一系列问题我们要关注的点就在于：<strong>如何能够用前一项或者前几项的信息得到下一项，这种从最优子状态转换为下一个最优状态的思路就是动态规划的核心。</strong><br>对于上面的例子题目来说，状态转移方程的定义应该是：</p>
<blockquote>
<p>F<del>k</del>&#x3D;max{F<del>k-1</del>+A<del>k</del>,A<del>k</del>}<br>F<del>k</del>是前k项的和，A<del>k</del>是第k项的值</p>
</blockquote>
<p>仔细思考一番，我们能够得到这样的结论，对于前k个项的最大子序列和是前k-1项的最大子序列和F<del>k</del>与第k项的和、或者第k项两者中较大的。如果大家还是不能理解这个原理建议用演算纸自己计算一番，这里就不过多赘述了。这种状态转移的思路就是DP的核心。</p>
<h3 id="第三步：计算最优解的值（目标函数的最大-x2F-小值）"><a href="#第三步：计算最优解的值（目标函数的最大-x2F-小值）" class="headerlink" title="第三步：计算最优解的值（目标函数的最大&#x2F;小值）"></a>第三步：计算最优解的值（目标函数的最大&#x2F;小值）</h3><p><strong>动态规划是一种策略，不是一个具体的算法。</strong></p>
<p>因此，动态规划求解不象搜索或数值计算，具有一个标准的数学表达式和明确清晰的解题方法。动态规划针对的最优化问题，由于问题性质的不同，确定最优解的条件的不同，动态规划的设计对不同的问题，有各具特色的解题方法。</p>
<p>改进一：若问题的决策序列由n次决策构成，而每次决策有p种选择，若采用枚举法，则可能的决策序列将有p^n^个。而利用动态规划策略的求解过程中仅保存了所有子问题的最优解，而舍去了所有不能导致问题最优解的次优决策序列，因此可能有多项式的计算复杂度。</p>
<p>改进二：重叠子问题性：动态规划与分治法也不同，分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则有些子问题被重复计算了很多次。动态规划保存了已解决的子问题的答案，在需要时找出已求得的答案，避免了大量的重复计算，节省了时间。</p>
<p>无论是采取自底向上还是自顶向下方法，动态规划分技术要点是：</p>
<ul>
<li>用一个表（备忘）来记录所有已解的子问题的答案。</li>
<li>不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。</li>
</ul>
<p>利用查表，避免对重复子问题的重复求解，动态规划可以将原来具有指数级复杂度的搜索算法改进成了具有多项式时间的算法，这是动态规划算法的根本目的。</p>
<blockquote>
<p>关于动态规划求解代价的说明</p>
<p>在动态规划方法中，我们通常自底向上地使用最优子结构，即首先求子问题的最优解，然后求原问题的最优解。在求解原问题的过程中，需要在涉及的子问题中做出选择，选出能得到原问题最优解的子问题。这样，求解原问题的代价通常就是<strong>求子问题最优解的代价加上此次选择直接产生的代价</strong>。</p>
</blockquote>
<h3 id="第四步：利用计算出的信息，构造一个最优解（求解向量）"><a href="#第四步：利用计算出的信息，构造一个最优解（求解向量）" class="headerlink" title="第四步：利用计算出的信息，构造一个最优解（求解向量）"></a>第四步：利用计算出的信息，构造一个最优解（求解向量）</h3><h2 id="动态规划的应用场景"><a href="#动态规划的应用场景" class="headerlink" title="动态规划的应用场景"></a>动态规划的应用场景</h2><p>看过了如何去使用动态规划，那么随之而来的问题就在于：既然动态规划不是某个固定的算法，而是一种策略思路，那么什么时候应该去使用什么时候不能用呢？答案很简短：</p>
<p>对于一个可拆分问题中存在可以由前若干项计算当前项的问题可以由动态规划计算。 </p>
<h3 id="例题1-数塔取数问题"><a href="#例题1-数塔取数问题" class="headerlink" title="例题1: 数塔取数问题"></a>例题1: 数塔取数问题</h3><p>一个高度为N的由正整数组成的三角形，从上走到下，求经过的数字和的最大值。<br>每次只能走到下一层相邻的数上，例如从第3层的6向下走，只能走到第4层的2或9上。</p>
<p>该三角形第n层有n个数字，例如：</p>
<p>第一层有一个数字：      5</p>
<p>第二层有两个数字：    8   4</p>
<p>第三层有三个数字：  3   6   9</p>
<p>第四层有四个数字：7   2   9   5</p>
<p>最优方案是：5 + 8 + 6 + 9 &#x3D; 28</p>
<p>状态定义:<br>$$<br>F（i，j）是第i行j列项最大取数和，求第n行F（n，m）（0 &lt; m &lt; n）中最大值。<br>$$<br>状态转移方程：<br>$$<br>F(i，j) &#x3D; max{（F(i-1,j-1),F（i-1,j)）}+A(i,jt)<br>$$<br><em>分析：</em></p>
<p><em>（1）第一步：有底层向上层算起，因为这是一个金字塔的形状，底层向上算起，就可以最终到一个值，这个值就是最大值，</em></p>
<p> <img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/606488-20180211200827966-776060807.png" alt="img"></p>
<p><em>（2）每一层相加，然后比较取最大数。即：</em></p>
<p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/606488-20180211201605654-1525469006.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dp01</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">         <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">         <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">         dp[<span class="number">0</span>][<span class="number">0</span>] = scan.nextInt();</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                 <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">                 <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                     dp[i][j] = dp[i-<span class="number">1</span>][j] + num;</span><br><span class="line">                 &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                     dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],dp[i - <span class="number">1</span>][j])+num;</span><br><span class="line">                 &#125;</span><br><span class="line">                 max = Math.max(dp[i][j],max);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(max);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题2-编辑距离"><a href="#例题2-编辑距离" class="headerlink" title="例题2:编辑距离"></a>例题2:编辑距离</h3><p>编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。<br>例如将kitten一字转成sitting：<br>sitten （k-&gt;s）<br>sittin （e-&gt;i）<br>sitting （-&gt;g）<br>所以kitten和sitting的编辑距离是3。俄罗斯科学家Vladimir Levenshtein在1965年提出这个概念。<br>给出两个字符串a,b，求a和b的编辑距离。</p>
<p>状态定义:F<del>i,j</del>表示第一个字符串的前i个字母和第二个字符串的前j个字母需要编辑的次数，求Fn,m，n和m分别是两个字符串的长度。</p>
<p>状态转移方程：<br>$$<br>当F_{i,j-1}！&#x3D;F_{i-1,j}时，F_{i,j}&#x3D;min(F_{i-1,j-1},F_{i,j-1},F_{i-1,j})+1<br>$$</p>
<p>.<br>$$<br>当F_{i,j-1}&#x3D;F_{i-1,j}时，F_{i,j}&#x3D;F_{i,j-1}；<br>$$</p>
<h3 id="例题3-矩阵取数问题"><a href="#例题3-矩阵取数问题" class="headerlink" title="例题3:矩阵取数问题"></a>例题3:矩阵取数问题</h3><p>一个N*N矩阵中有不同的正整数，经过这个格子，就能获得相应价值的奖励，从左上走到右下，只能向下向右走，求能够获得的最大价值。例如：3 * 3的方格。</p>
<p>1 3 3<br>2 1 3<br>2 2 1</p>
<p>能够获得的最大价值为：11。</p>
<p>我们必须注意到的一点是，到达一个格子的方式最多只有两种：从左边来的(除了第一列)和从上边来的(除了第一行)。因此为了求出到达当前格子的最短路径，我们就要先去考察那些能到达当前这个格子的格子，到达它们的最短路径。经过上面的分析，很容易可以得出问题的状态和状态转移方程。状态<br>$$<br>S[i][j]<br>$$<br>表示我们走到(i, j)这个格子时，最短的路径。那么，状态转移方程如下：<br>$$<br>S[i][j]&#x3D;A[i][j] + min(S[i-1][j], if      i&gt;0 ; S[i][j-1], if   j&gt;0)<br>$$<br>其中i代表行，j代表列，下标均从0开始。</p>
<p>其中i代表行，j代表列，下标均从0开始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinPath</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">(<span class="type">int</span>[][] map, <span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;   </span><br><span class="line">       <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;        <span class="comment">//初始化第一列的值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;  </span><br><span class="line">             dp[i][<span class="number">0</span>]+=map[j][<span class="number">0</span>];      </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;       <span class="comment">//初始化第一行的值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;  </span><br><span class="line">             dp[<span class="number">0</span>][i]+=map[<span class="number">0</span>][j];      </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;  </span><br><span class="line">             dp[i][j] = min(dp[i][j-<span class="number">1</span>]+map[i][j],dp[i-<span class="number">1</span>][j]+map[i][j]);     </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][m-<span class="number">1</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)&#123;  </span><br><span class="line">         <span class="keyword">return</span> b;     </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> a;     </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	    Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">	    <span class="type">int</span> m=sc.nextInt();</span><br><span class="line">	    <span class="type">int</span> n=sc.nextInt();</span><br><span class="line">	    <span class="type">int</span> map[][]=<span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">	    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">	    	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">	    		map[i][j]=sc.nextInt();</span><br><span class="line">	    	&#125;</span><br><span class="line">	    &#125;	    System.out.println(getMin(map,m,n));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题4：钢条切割问题"><a href="#例题4：钢条切割问题" class="headerlink" title="例题4：钢条切割问题"></a>例题4：钢条切割问题</h3><p>给定一段长度为n英寸的长钢条和一个价格表P，求切割为短钢条的方案，使得销售收益r<del>n</del>最大。</p>
<table>
<thead>
<tr>
<th>长度i</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>价格pi</td>
<td>1</td>
<td>5</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>17</td>
<td>17</td>
<td>20</td>
<td>24</td>
<td>30</td>
</tr>
</tbody></table>
<p>按价格从高到低分段出售，即先卖pi最大的段，然后再卖pj较小的段。是否可以获得最好的收益？（贪心策略）<br>显然是不可能获得收益最大的。详细参见上述贪心和动态规划之间的区别。</p>
<p>对最优切割，设某次切割在位置i，将钢条分成长度为i和n-i的两段，令r<del>i</del>和r<del>n-i</del>分别是这两段的最优子切割收益，则有：r<del>n</del>&#x3D;r<del>i</del>+ r<del>n-i</del></p>
<h4 id="钢条切割问题的朴素递归求解过程"><a href="#钢条切割问题的朴素递归求解过程" class="headerlink" title="钢条切割问题的朴素递归求解过程"></a>钢条切割问题的朴素递归求解过程</h4><p>基本思路:我们将钢条从左边切割下长度为i的一段，只对右边剩下的长度为n-i的一段继续进行切割(递归求解)，对左边的一段则不再进行切割。则可得公式：<br>$$<br>r_n&#x3D;\max \limits_{1&lt;&#x3D;i&lt;&#x3D;n}(P_i+r_{n-i})<br>$$<br>其中p<del>i</del>为左边长度为i的钢条的收益，r<del>n-i</del>为右边长度为n-i的钢条继续切割后得到的最优收益，r<del>n</del>为长度为n的钢条切割后得到的最优收益。</p>
<p>但是此时，原问题的最优解只包含一个相关子问题（右端剩余部分）的解，而不是两个。就是分治的策略，会有很多重复计算在里面，所以效率不高。时间复杂度为O（2^n^）。</p>
<h4 id="钢条切割问题的动态规划求解"><a href="#钢条切割问题的动态规划求解" class="headerlink" title="钢条切割问题的动态规划求解"></a>钢条切割问题的动态规划求解</h4><p><strong>带备忘录的自顶向下方法(top-down with memorization）</strong></p>
<p>此方法仍然按照自然的递归形式编写过程，但过程中会保存每个子问题的解（通常是保存在数组或者散列表中），当需要一个子问题的解时，会先判断是否保存过此解。如果是，则直接返回保存的值，从而节省了计算时间。否则，按照常规方式进行计算。</p>
<blockquote>
<p>因此，动态规划方法需要付出额外的空间保存子问题的解，是一种典型的时空权衡（time-memory trade-off）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">memorizedCutRod</span><span class="params">(<span class="type">int</span>[] p, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//保存已计算过的子问题的解的数组</span></span><br><span class="line">        <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result = memorizedCutRodAux(p, n, res);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">memorizedCutRodAux</span><span class="params">(<span class="type">int</span>[] p, <span class="type">int</span> n, <span class="type">int</span>[] r)</span>&#123;</span><br><span class="line">        <span class="comment">//如果已经计算过该子问题的解，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(r[n]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> r[n];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">             q = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//r(n)=max(p[i]+r(n-i))</span></span><br><span class="line">            <span class="comment">//p[i]表示切割成长度为i的钢条的收益</span></span><br><span class="line">            <span class="comment">//r(n-i)剩余钢条的最大收益值</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                 q = Math.max(q, p[i]+memorizedCutRodAux(p, n-i, r));</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r[n] = q;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>自底向上的方法(bottom-up method)</strong></p>
<p>这种方法一般需要恰当定义子问题的规模的概念，使得任何子问题的求解都只依赖于更小的子问题的求解。因而，我们可以将子问题按照规模排序，按照由小到大的顺序进行求解。当求解某个子问题时，它所依赖的那些更小的子问题都已经求解完毕，结果已经保存。每个子问题只需要求解一次，当我们求解它时，它的所有前提子问题都已经求解完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">extendedBottomUpCutRod</span><span class="params">(<span class="type">int</span>[] p, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">//保存已计算过的子问题的解的数组</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//用来保存最优解的切割的钢条的长度</span></span><br><span class="line">        <span class="type">int</span>[] solve = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//从规模为0的最小子问题开始依次求解</span></span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(q&lt;p[j]+res[i-j])&#123;</span><br><span class="line">                    q = p[j]+res[i-j];</span><br><span class="line">                    solve[i] = j;<span class="comment">//对于长度为i的钢条，求出其最优收益，并记录下获得最优收益时左侧第一个切割点的位置</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        print(res[n], solve, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> maxValue, <span class="type">int</span>[] solve, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        System.out.println(maxValue);</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(solve[n]+<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            n = n - solve[n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>具有相同的渐近运行时间：Θ(n^2^)</p>
<blockquote>
<p>但由于自底向上法没有频繁的递归函数调用的开销，所以自底向上法的时间复杂性函数通常具有更小的系数。</p>
<p>而在某些特殊情况下，自顶向下法可能没有递归处理所有可能的子问题（剪枝）而减少工作量。</p>
</blockquote>
<h4 id="子问题图"><a href="#子问题图" class="headerlink" title="子问题图"></a>子问题图</h4><p>在自底向上的动态规划方法中，对一个给定的子问题x，在求解它之前应先求解它所依赖的子问题。仅当它依赖的所有子问题都求解完成了，才会求解它。——这在子问题图中，对应顶点的一个逆拓扑序，可以按照深度优先原则进行处理。</p>
<p>基于子问题图“估算”算法的运行时间：</p>
<p>算法的运行时间等于所有子问题求解的时间之和。子问题图中，子问题对应顶点，子问题的数目等于顶点数。一个子问题的求解时间与子问题图中对应顶点的“出度”成正比。因此，一般情况下，动态规划算法的运行时间与顶点和边的数量至少呈线性关系。</p>
<h3 id="问题五：矩阵链乘法"><a href="#问题五：矩阵链乘法" class="headerlink" title="问题五：矩阵链乘法"></a>问题五：矩阵链乘法</h3><p>n个要连续相乘的矩阵构成一个矩阵链&lt;A1,A2,…,An&gt;,要计算这n个矩阵的连乘乘积：A1A2…An，称为矩阵链乘问题。</p>
<ul>
<li><p>矩阵链乘不满足交换律：A1A2A3 ≠ A3A2A1</p>
</li>
<li><p>矩阵链乘满足结合律，所以矩阵链乘相当于在矩阵之间加括号。不同的加括号方案导出不同的矩阵链乘计算模式。</p>
</li>
</ul>
<p>如，已知四个矩阵A1,A2,A3,A4，根据不同的加括号方式，乘积A1A2A3A4有五种不同的计算模式：(A1(A2(A3A4)))       (A1((A2A3)A4))        ((A1A2)(A3A4))       ((A1(A2A3))A4))         ((A1A2)A3)A4)</p>
<blockquote>
<p>两个矩阵A和B只有相容(compatible)，即A的列数等于B的行数时，才能相乘。如果A是p×q的矩阵，B是q×r的矩阵，那么乘积C是p×r的矩阵。计算C所需要时间由第8行的标量乘法的次数决定的，即pqr。</p>
<p>   以矩阵链&lt;A1,A2,A3&gt;为例，来说明不同的加括号方式会导致不同的计算代价。假设三个矩阵的规模分别为10×100、100×5和5×50。<br>   如果按照((A1A2)A3)的顺序计算，为计算A1A2(规模10×5)，需要做10<em>100</em>5&#x3D;5000次标量乘法，再与A3相乘又需要做10<em>5</em>50&#x3D;2500次标量乘法，共需7500次标量乘法。<br>   如果按照(A1(A2A3))的顺序计算，为计算A2A3(规模100×50)，需100<em>5</em>50&#x3D;25000次标量乘法，再与A1相乘又需10<em>100</em>50&#x3D;50000次标量乘法，共需75000次标量乘法。因此第一种顺序计算要比第二种顺序计算快10倍。</p>
</blockquote>
<p>矩阵链乘法问题(matrix-chain multiplication problem)可描述如下：给定n个矩阵的链&lt;A1,A2,…,An&gt;，矩阵Ai的规模为p(i-1)×p(i) (1&lt;&#x3D;i&lt;&#x3D;n)，求完全括号化方案，使得计算乘积A1A2…An所需标量乘法次数最少。</p>
<p>   因为括号方案的数量与n呈指数关系，所以通过暴力搜索穷尽所有可能的括号化方案来寻找最优方案是一个糟糕策略。</p>
<h4 id="步骤一：最优括号化方案的结构特征"><a href="#步骤一：最优括号化方案的结构特征" class="headerlink" title="步骤一：最优括号化方案的结构特征"></a>步骤一：最优括号化方案的结构特征</h4><p>动态规划的第一步是寻找最优子结构，然后就可以利用这种子结构从子问题的最优解构造出原问题的最优解。在矩阵链乘法问题中，我们假设A(i)A(i+1)…A(j)的最优括号方案的分割点在A(k)和A(k+1)之间。那么，继续对“前缀”子链A(i)A(i+1)..A(k)，（记为A<del>i，k</del>)进行括号化时，我们应该直接采用<strong>独立求解</strong>它时所得的最优方案。<br>    我们已经看到，一个非平凡(i≠j)的矩阵链乘法问题实例的任何解都需要划分链，而任何最优解都是由子问题实例的最优解构成的。为了构造一个矩阵链乘法问题实例的最优解，我们可以将问题划分为两个子问题(A(i)A(i+1)…A(k)和A(k+1)A(k+2)..A(j)(记为A<del>k+1，j</del>)的最优括号化问题)，<strong>求出子问题实例的最优解，然后将子问题的最优解组合起来</strong>。我们必须保证在确定分割点时，已经考察了<strong>所有可能的划分点</strong>，这样就可以保证不会遗漏最优解。</p>
<h4 id="步骤2：一个递归求解方案"><a href="#步骤2：一个递归求解方案" class="headerlink" title="步骤2：一个递归求解方案"></a>步骤2：一个递归求解方案</h4><p>对于矩阵链乘法问题，我们可以将对所有1&lt;&#x3D;i&lt;&#x3D;j&lt;&#x3D;n确定A(i)A(i+1)…A(j)的最小代价括号化方案作为子问题。令m[i,j]表示计算矩阵A(i..j)所需标量乘法次数的最小值，那么，原问题的最优解—**计算A(1..n)所需的最低代价就是m[1,n]**。</p>
<p>我们可以递归定义m[i,j]如下：<br>    对于i&#x3D;j时的平凡问题，矩阵链只包含唯一的矩阵A(i..j)&#x3D;A(i)，因此不需要做任何标量乘法运算。所以，对所有i&#x3D;1,2,…,n，m[i,i]&#x3D;0。<br>    若i&lt;j，我们利用步骤1中得到的最优子结构来计算m[i,j]。我们假设A(i)A(i+1)…A(j)的最优括号化方案的分割点在矩阵A(k)和A(k+1)之间，其中i&lt;&#x3D;k&lt;j。那么，<strong>m[i,j]就等于计算A(i..k)和A(k+1..j)的代价加上两者相乘的代价的最小值。</strong>A<del>i,k</del>是一个p<del>i-1</del>×p<del>k</del>的矩阵，A<del>k+1,j</del>是一个p<del>k</del>×p<del>j</del>的矩阵。结果矩阵A<del>i,j</del>是A<del>i,k</del>和A<del>k+1,j</del>最终相乘的结果。。因此，我们得到<br>              m[i,j]&#x3D;m[i,k]+m[k+1,j]+ p<del>(i-1)</del>p<del>(k)</del>p<del>(j)</del><br>    此递归公式假定最优分割点k是已知的，但实际上我们是不知道。不过，k只有j-i种可能的取值，即k&#x3D;i,i+1,…,j-1。由于最优分割点必在其中，我们只需检查所有可能情况，找到最优者即可。<br>    因此，A(i)A(i+1)…A(j)的最小代价括号化方案的递归求解公式变为：</p>
<p>$$<br>①如果i&#x3D;j，m[i,j]&#x3D;0<br>$$</p>
<p>$$<br>②如果i&lt;j，m[i,j]&#x3D;\min\limits_{i&lt;&#x3D;k&lt;j} (m[i,k]+m[k+1,j]+p_{i-1}p_{k}p_{j})<br>$$</p>
<p>m[i,j]的值给出了子问题最优解的代价，但它并未提供足够的信息来构造最优解。为此，我们用s[i,j]保存最优括号化方案的分割点位置k，即使得  m[i,j]&#x3D;m[i,k]+m[k+1,j]+ p<del>(i-1)</del>p<del>(k)</del>p<del>(j)</del>成立的k值。</p>
<h4 id="步骤3：计算最优代价"><a href="#步骤3：计算最优代价" class="headerlink" title="步骤3：计算最优代价"></a>步骤3：计算最优代价</h4><p>我们采用自底向上表格法代替递归算法来计算最优代价。此过程假定矩阵Ai的规模为p(i-1)×pi(i&#x3D;1,2,…,n)。它的输入是一个序列p&#x3D;&lt;p0,p1,…,pn&gt;，其长度为p.length&#x3D;n+1。过程用一个辅助表m[1..n,1..n]来保存代价m[i,j]，用另一个辅助表s[1..n-1,2..n]记录最优值m[i,j]对应的分割点k。我们就可以利用表s构造最优解。<br>   对于矩阵A(i)A(i+1)…A(j)最优括号化的子问题，我们认为其规模为链的长度j-i+1。因为j-i+1个矩阵链相乘的最优计算代价m[i,j]只依赖于那么少于j-i+1个矩阵链相乘的最优计算代价。因此，算法应该按长度递增的顺序求解矩阵链括号化问题，并按对应的顺序填写表m。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">PRINT_OPTIMAL_PARENS</span><span class="params">(<span class="type">int</span> p[],<span class="type">int</span> m[][M],<span class="type">int</span> s[][M])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> q,n=p.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)m[i][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>;l&lt;=n;l++)<span class="comment">/* 矩阵链的长度 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-l+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+l-<span class="number">1</span>;         <span class="comment">/* 等价于 l=j-i+1 */</span></span><br><span class="line">			m[i][j]=<span class="number">100000</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=j-<span class="number">1</span>;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                q=m[i][k]+m[k+<span class="number">1</span>][j]+p[i-<span class="number">1</span>]*p[k]*p[j];</span><br><span class="line">                <span class="keyword">if</span>(q&lt;m[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    m[i][j]=q;</span><br><span class="line">                    s[i][j]=k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="步骤4：构造最优解"><a href="#步骤4：构造最优解" class="headerlink" title="步骤4：构造最优解"></a>步骤4：构造最优解</h4><p>s[i,j]记录了AiAi+1…Aj的最优括号化方案中“首个”加括号的位置点k。</p>
<ul>
<li>基于s[i,j]，对A<del>i</del>A<del>i+1</del>…Aj的括号化方案是：（A<del>i</del>A<del>i+1</del>…A<del>s[i,j]</del>）（A<del>s[i,j]+1</del>…A<del>j</del>)</li>
</ul>
<p>A<del>1…n</del>的最优方案中最后一次矩阵乘运算是：（A<del>1…s[1,n]</del>）（A<del>s[1,n]+1…n</del> ）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">PRINT_OPTIMAL_PARENS</span><span class="params">(<span class="type">int</span> s[][M],<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == j) System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">		PRINT_OPTIMAL_PARENS(s,i,s[i][j]);</span><br><span class="line">		PRINT_OPTIMAL_PARENS(s,s[i][j]+<span class="number">1</span>,j);</span><br><span class="line">		System.out.println(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题六：最长公共子序列LCS"><a href="#问题六：最长公共子序列LCS" class="headerlink" title="问题六：最长公共子序列LCS"></a>问题六：最长公共子序列LCS</h3><p>两个字符串的最长公共非连续子串，称为最长公共子序列。</p>
<h4 id="步骤一：LCS问题的最优子结构性"><a href="#步骤一：LCS问题的最优子结构性" class="headerlink" title="步骤一：LCS问题的最优子结构性"></a>步骤一：LCS问题的最优子结构性</h4><p>设A&#x3D;“a0，a1，…，am”，B&#x3D;“b0，b1，…，bn”，且Z&#x3D;“z0，z1，…，zk”为它们的最长公共子序列。不难证明有以下性质：<br>       如果am&#x3D;bn，则zk&#x3D;am&#x3D;bn，且“z0，z1，…，z(k-1)”是“a0，a1，…，a(m-1)”和“b0，b1，…，b(n-1)”的一个最长公共子序列；<br>       如果am!&#x3D;bn，则若zk!&#x3D;am，蕴涵“z0，z1，…，zk”是“a0，a1，…，a(m-1)”和“b0，b1，…，bn”的一个最长公共子序列；<br>       如果am!&#x3D;bn，则若zk!&#x3D;bn，蕴涵“z0，z1，…，zk”是“a0，a1，…，am”和“b0，b1，…，b(n-1)”的一个最长公共子序列。</p>
<h4 id="步骤二：递推关系式"><a href="#步骤二：递推关系式" class="headerlink" title="步骤二：递推关系式"></a>步骤二：递推关系式</h4><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/image-20191231144749669.png"></p>
<p>涵盖了步骤一中的所有情况。</p>
<h4 id="步骤三：LCS的求解"><a href="#步骤三：LCS的求解" class="headerlink" title="步骤三：LCS的求解"></a>步骤三：LCS的求解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] longestCommonSubsequence(String str1, String str2) &#123;</span><br><span class="line">	        <span class="type">int</span>[][] c = <span class="keyword">new</span> <span class="title class_">int</span>[str1.length() + <span class="number">1</span>][str2.length() + <span class="number">1</span>];<span class="comment">//建立二维矩阵</span></span><br><span class="line">    	       </span><br><span class="line">    <span class="comment">//数组b只是为了方便理解，可以去掉</span></span><br><span class="line">    <span class="type">char</span>[][] b = <span class="keyword">new</span> <span class="title class_">char</span>[str1.length() + <span class="number">1</span>][str2.length() + <span class="number">1</span>];<span class="comment">//建立二维矩阵</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化边界条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= str1.length(); i++) &#123;</span><br><span class="line">               	c[i][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//每行第一列置零</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= str2.length(); j++) &#123;</span><br><span class="line">                c[<span class="number">0</span>][j] = <span class="number">0</span>;<span class="comment">//每列第一行置零</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 填充矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= str1.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= str2.length(); j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (str1.charAt(i - <span class="number">1</span>) == str2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                                c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                            	b[i][j]=<span class="string">&quot;↖&quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(c[i-<span class="number">1</span>,j]&gt;=c[i,j-<span class="number">1</span>])</span><br><span class="line">                        &#123;</span><br><span class="line">                        	c[i][j] = c[i - <span class="number">1</span>][j];</span><br><span class="line">                       		b[i][j]=<span class="string">&quot;↑&quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">	                <span class="keyword">else</span> <span class="keyword">if</span>(c[i-<span class="number">1</span>,j]&lt;=c[i,j-<span class="number">1</span>])</span><br><span class="line">    	                &#123;</span><br><span class="line">        	                c[i][j] = c[i][j-<span class="number">1</span>];</span><br><span class="line">                       		b[i][j]=<span class="string">&quot;←&quot;</span>;</span><br><span class="line">        	            &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>c[i] [j]的含义是：x序列的前i个元素形成的子序列和y序列的前j个元素形成的子序列的最大公共子序列的值。</p>
<p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/image-20191231145648402.png"></p>
<h4 id="步骤四：构造出该LCS"><a href="#步骤四：构造出该LCS" class="headerlink" title="步骤四：构造出该LCS"></a>步骤四：构造出该LCS</h4><p>由步骤三我们只是得出了LCS的长度，没有得出具体的LCS中的元素。</p>
<p>但是步骤三中得到了c这个二维数组，依照其元素的值：</p>
<p>反序，从b[m,n]处开始，沿箭头在表格中向上追踪。每当在表项b[i,j]中：</p>
<ul>
<li>遇到一个“↖”时，意味着xi&#x3D;yj是LCS的一个元素，下一步继续在b[i-1,j-1]中寻找上一个元素；</li>
<li>遇到“←”时，下一步到b[i,j-1]中寻找上一个元素；</li>
<li>遇到“↑”时，下一步到b[i-1,j]中寻找上一个元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据矩阵输出LCS</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[][] opt, String X, String Y, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (X.charAt(i - <span class="number">1</span>) == Y.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                print(opt, X, Y, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">                System.out.print(X.charAt(i - <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt[i - <span class="number">1</span>][j] &gt;= opt[i][j]) &#123;</span><br><span class="line">                print(opt, X, Y, i - <span class="number">1</span>, j);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                print(opt, X, Y, i, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题七：最优二叉搜索树（有点类似于树塔取数问题）"><a href="#问题七：最优二叉搜索树（有点类似于树塔取数问题）" class="headerlink" title="问题七：最优二叉搜索树（有点类似于树塔取数问题）"></a>问题七：最优二叉搜索树（有点类似于树塔取数问题）</h3><p>二叉搜索树（二分检索树）：</p>
<p>二叉搜索树Ｔ是一棵二元树，它或者为空，或者其每个结点含有一个可以比较大小的数据元素，且有：</p>
<ul>
<li>Ｔ的左子树的所有元素比根结点中的元素小；</li>
<li>T的右子树的所有元素比根结点中的元素大；</li>
<li>Ｔ的左子树和右子树也是二叉搜索树。</li>
</ul>
<p>不失一般性，这里假设所有元素互异</p>
<p>最优二叉搜索树的定义：</p>
<p>给定一个n个关键字的已排序的序列K&#x3D;&lt;k<del>1</del>,k<del>2</del>,…,k<del>n</del>&gt;（不失一般性，设k<del>1</del>&lt;k<del>2</del>&lt;…&lt;k<del>n</del>），<strong>对每个关键字k<del>i</del>，都有一个概率p<del>i</del>表示其被搜索的频率</strong>。根据k<del>i</del>和p<del>i</del>构建一个二叉搜索树T，每个k<del>i</del>对应树中的一个结点。对搜索对象x，在T中可能找到、也可能找不到：</p>
<ul>
<li>若x等于某个k<del>i</del>，则一定可以在T中找到结点k<del>i</del>，称为成功搜索。</li>
<li>成功搜索的情况一共有n种，分别是x恰好等于某个k<del>i</del>。</li>
<li>若x&lt;k<del>1</del> 、或x&gt;kn、或k<del>i</del>&lt;x&lt;k<del>i+1</del> (1≤i&lt;n), 则在T中搜索x将失败，称为失败搜索。<ul>
<li>为此引入外部结点d<del>0</del>,d<del>1</del>,…,d<del>n</del>，用来表示不在K中的值,称为伪关键字。</li>
<li>伪关键字在T中对应外部结点，共有n+1个。——扩展二叉树：内结点表示关键字k<del>i</del>，外结点(叶子结点)表示d<del>i</del>。</li>
<li>这里每个d<del>i</del>代表一个区间。（d<del>0</del>表示所有小于k<del>1</del>的值，d<del>n</del>表示所有大于k<del>n</del>的值，对于i&#x3D;1,…,n-1，d<del>i</del>表示所有在k<del>i</del>和k<del>i+1</del>之间的值。）</li>
<li>**每个d<del>i</del>也有一个概率q<del>i</del>**，表示搜索对象x恰好落入区间d<del>i</del>的频率。</li>
</ul>
</li>
</ul>
<p><strong>二叉搜索树的期望搜索代价：</strong></p>
<p>​			对于特定搜索对象，搜索过程是从根开始到某个结点的检索过程。成功搜索结束于内结点，不成功搜索结束于外部结点。</p>
<p>记depth<del>T</del>(i)为结点i在T中的深度（根到i的路径上的边数）。则从根结点开始访问结点i的数量等于depth<del>T</del>(i) +1；<br>$$<br>E（二叉搜索树T的期望代价）&#x3D; \sum_{i&#x3D;1}^n(depth_T(K_i)+1)*p_i+\sum_{i&#x3D;0}^n(depth_T(d_i)+1)*q_i<br>$$</p>
<p>$$<br>&#x3D;1+\sum_{i&#x3D;1}^ndepth_T(K_i)*p_i+\sum_{i&#x3D;0}^ndepth_T(d_i)*q_i<br>$$</p>
<p>即：加权平均代价，包括所有成功搜索的结点和失败搜索的结点。</p>
<p><strong>对于给定的关键字及其概率集合，期望搜索代价最小的二叉搜索树称为其最优二叉搜索树。</strong></p>
<p>问题：如何构造最优二叉搜索树？</p>
<h4 id="步骤一：最优子结构"><a href="#步骤一：最优子结构" class="headerlink" title="步骤一：最优子结构"></a>步骤一：最优子结构</h4><blockquote>
<p>证明最优二叉搜索树的最优子结构：</p>
<p>如果T是一棵相对于关键字k<del>1</del>,…,k<del>n</del>和伪关键字d<del>0</del>,…,d<del>n</del>的最优二叉搜索树，则T中一棵包含关键字k<del>i</del>,…,k<del>j</del>的子树T’必然是相对于关键字k<del>i</del>,…,k<del>j</del>（和伪关键字d<del>i-1</del>,…,d<del>j</del>）的最优二叉搜索子树。</p>
</blockquote>
<p>我们可以利用最优二叉搜索树的最优子结构性来构造最优二叉搜索树。</p>
<h4 id="步骤二：递归算法的构建"><a href="#步骤二：递归算法的构建" class="headerlink" title="步骤二：递归算法的构建"></a>步骤二：递归算法的构建</h4><p>对给定的关键字k<del>i</del>,…,k<del>j</del>，若其最优二叉搜索（子）树的根结点是k<del>r</del>（i≤r≤j），则kr的左子树中包含关键字k<del>i</del>,…,k<del>r-1</del>及伪关键字d<del>i-1,</del>…,d<del>r-1</del>，右子树中将含关键字k<del>i+1</del>,…,k<del>j</del>及伪关键字d<del>r</del>,…,d<del>j</del>。</p>
<p>策略：在i≤l≤j的范围内检查所有可能的结点k<del>l</del></p>
<p>(k<del>i</del>,k<del>i+1</del>,…,k<del>j</del>)的最优二叉搜索树，其中i&gt;&#x3D;1,j&lt;&#x3D;n且j&gt;&#x3D;i−1(当j&#x3D;i−1时，子树不包含实际关键字，只包含伪关键字d<del>i−1</del>).<strong>定义e[i,j]为包含关键字(k<del>i</del>,k<del>i+1</del>,…,k<del>j</del>)的二叉搜索树进行一次搜索的期望代价</strong>，最后我们希望求解得到e[1,n]。</p>
<ul>
<li>当j &#x3D; i - 1时，子树只有伪关键字d<del>i-1</del> ,所以，e[i,j]&#x3D;q<del>i-1</del> </li>
<li>当j &gt; &#x3D; i时，从(k<del>i</del>,k<del>i+1</del>,…,k<del>j</del>)中选择根节点K<del>r</del><ul>
<li>其左子树包含关键字(k<del>i</del>,k<del>i+1</del>,…,k<del>r-1</del>)且是最优二叉搜索子树</li>
<li>其右子树包含关键字(k<del>r+1</del>,k<del>r+2</del>,…,k<del>j</del>)且是最优二叉搜索子树</li>
</ul>
</li>
</ul>
<p>当一棵树成为另一个节点的子树时：</p>
<ul>
<li><p>子树的所有结点的深度+1</p>
</li>
<li><p>根据搜索代价期望值计算公式，子树对根为k<del>r</del>的树的期望搜索代价的贡献是其期望搜索代价+其所含所有结点的概率之和。</p>
<p>所以，期望搜索代价增加量为：<br>$$<br>w[i,j]&#x3D;\sum_{l&#x3D;i}^jp_l+\sum_{l&#x3D;i-1}^jq_l<br>$$</p>
</li>
</ul>
<p>原因：子树的每个结点的深度增加1。</p>
<img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/image-20200107235711478.png" style="zoom:50%;" />

<p>所以若k<del>r</del>为包含关键字k<del>i</del>,k<del>i+1</del>,…,k<del>j</del>)的最优二叉搜索树的根，则其期望搜索代价e[i,j]与左、右子树的期望搜索代价e[i,r-1]和e[r+1,j]的递推关系为：<br>$$<br>e[i,j]&#x3D;p_r+(e[i,r-1]+w[i,r-1])+(e[r+1,j]+w[r+1,j])<br>$$<br>其中，w(i,r-1)和w(r+1,j)是左右子树所有结点的概率之和。且有：<br>$$<br>w[i,j]&#x3D;w[i,r-1]+w[r+1,j]+p_r<br>$$<br>所以：<br>$$<br>e[i,j]&#x3D;\begin{cases} q_{i-1}， j&#x3D;i-1  \\min\limits_{i&lt;&#x3D;r&lt;&#x3D;j}(e[i,r-1]+e[r+1,j]+w[i,j])， i&lt;&#x3D;j   \end{cases}<br>$$</p>
<h4 id="步骤三：计算二叉搜索树的期望搜素代价"><a href="#步骤三：计算二叉搜索树的期望搜素代价" class="headerlink" title="步骤三：计算二叉搜索树的期望搜素代价"></a>步骤三：计算二叉搜索树的期望搜素代价</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p、q为概率列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] Optimal_BST(<span class="type">double</span>[] p, <span class="type">double</span>[] q, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">double</span>[][] e = <span class="keyword">new</span> <span class="title class_">double</span>[n+<span class="number">2</span>][n+<span class="number">2</span>];<span class="comment">//记录二叉搜索树的期望代价</span></span><br><span class="line">        <span class="type">double</span>[][] w = <span class="keyword">new</span> <span class="title class_">double</span>[n+<span class="number">2</span>][n+<span class="number">2</span>];<span class="comment">//记录期望搜索代价增加量</span></span><br><span class="line">        <span class="type">int</span>[][] root = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">2</span>][n+<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化叶子结点的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            e[i][i-<span class="number">1</span>]=q[i-<span class="number">1</span>];</span><br><span class="line">            w[i][i-<span class="number">1</span>]=q[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//自底向上的迭代计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span> ; l&lt;=n ; l++)&#123;<span class="comment">//最外层循环是逐渐的将关键字个数从一个扩展到n个</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-l+<span class="number">1</span>;i++)&#123;</span><br><span class="line">                <span class="type">int</span> j=i+l-<span class="number">1</span>;</span><br><span class="line">                e[i][j]=Double.MAX_VALUE;</span><br><span class="line">                w[i][j]=w[i][j-<span class="number">1</span>]+p[j]+q[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> r=i;r&lt;=j;r++)&#123;</span><br><span class="line">                    <span class="type">double</span> <span class="variable">t</span> <span class="operator">=</span> e[i][r-<span class="number">1</span>]+e[r+<span class="number">1</span>][j]+w[i][j];</span><br><span class="line">                    <span class="keyword">if</span>(t&lt;e[i][j])&#123;</span><br><span class="line">                        e[i][j]=t;</span><br><span class="line">                        root[i][j]=r;<span class="comment">///存储根节点的位置</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="步骤四：构建最优解输出"><a href="#步骤四：构建最优解输出" class="headerlink" title="步骤四：构建最优解输出"></a>步骤四：构建最优解输出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">CONSTRUCTOR-OPTIMAL-BST(root[][],i,j,r)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootChild</span> <span class="operator">=</span> root[i][j];<span class="comment">//子树根节点  </span></span><br><span class="line">    <span class="keyword">if</span> (rootChild == root[<span class="number">1</span>][n])  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//输出整棵树的根  </span></span><br><span class="line">        print(<span class="string">&quot;K&quot;</span>+rootChild+<span class="string">&quot;是根&quot;</span>);      </span><br><span class="line">        CONSTRUCTOR-OPTIMAL-BST(root,i,rootChild - <span class="number">1</span>,rootChild);  </span><br><span class="line">        CONSTRUCTOR-OPTIMAL-BST(root,rootChild + <span class="number">1</span>,j,rootChild);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (j &lt; i - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (j == i - <span class="number">1</span>)<span class="comment">//遇到虚拟键  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (j &lt; r)  </span><br><span class="line">        &#123;  </span><br><span class="line">           print( <span class="string">&quot;d&quot;</span> +  j + <span class="string">&quot;是&quot;</span> + <span class="string">&quot;k&quot;</span> + r + <span class="string">&quot;的左孩子&quot;</span> );  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            print( <span class="string">&quot;d&quot;</span> +  j + <span class="string">&quot;是&quot;</span> + <span class="string">&quot;k&quot;</span> + r + <span class="string">&quot;的右孩子&quot;</span> );  </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span><span class="comment">//遇到内部结点  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (rootChild &lt; r)  </span><br><span class="line">        &#123;  </span><br><span class="line">            print (<span class="string">&quot;k&quot;</span> + rootChild + <span class="string">&quot;是&quot;</span> + <span class="string">&quot;k&quot;</span> + r + <span class="string">&quot;的左孩子&quot;</span> );  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            print (<span class="string">&quot;k&quot;</span> + rootChild + <span class="string">&quot;是&quot;</span> + <span class="string">&quot;k&quot;</span> + r + <span class="string">&quot;的右孩子&quot;</span> );  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    CONSTRUCTOR-OPTIMAL-BST(root[],i,rootChild - <span class="number">1</span>,rootChild);  </span><br><span class="line">    CONSTRUCTOR-OPTIMAL-BST(root[],rootChild + <span class="number">1</span>,j,rootChild);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题八：01背包问题"><a href="#问题八：01背包问题" class="headerlink" title="问题八：01背包问题"></a>问题八：01背包问题</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mu399/article/details/7722810?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">https://blog.csdn.net/mu399/article/details/7722810?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p>
<h1 id="动态规划的具体实现"><a href="#动态规划的具体实现" class="headerlink" title="动态规划的具体实现"></a>动态规划的具体实现</h1><h2 id="动态规划和递归"><a href="#动态规划和递归" class="headerlink" title="动态规划和递归"></a>动态规划和递归</h2><p>一个人爬楼梯，每次只能爬 1 个或 2 个台阶，假设有 n 个台阶，那么这个人有多少种不同的爬楼梯方法？</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a> 是这道题的换皮题， GrowingIO 前端工程师岗位考察过这个题目。</p>
</blockquote>
<p>由于上第 n 级台阶一定是从 n - 1 或者 n - 2 来的，因此 上第 n 级台阶的数目就是 <code>上 (n - 1) 级台阶的数目「加」上 (n - 2) 级台阶的数目</code>。</p>
<p>递归代码：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">climbStairs</span>(n) &#123;</span><br><span class="line">  if (n === <span class="number">1</span>) return <span class="number">1</span>;</span><br><span class="line">  if (n === <span class="number">2</span>) return <span class="number">2</span>;</span><br><span class="line">  return <span class="built_in">climbStairs</span>(n - <span class="number">1</span>) + <span class="built_in">climbStairs</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们继续用一个递归树来直观感受以下：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/a2a535c91ed501ab507bdfd906a9f7b6c15b0e356389075044327c43416a1377/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303753385a496c6c793167686c756877367066326a33306d7a30623264676b2e6a7067"><img src="https://i.loli.net/2021/03/08/swDO2A1UhlXzCRB.jpg" alt="dynamic-programming-2"></a></p>
<blockquote>
<p>红色表示重复的计算</p>
</blockquote>
<p>可以看出这里面有很多重复计算，我们可以使用一个 hashtable 去缓存中间计算结果，从而省去不必要的计算。</p>
<p>那么动态规划是怎么解决这个问题呢？ 答案也是“查表”，不过区别于递归使用函数调用栈，动态规划通常使用的是 dp 数组，数组的索引通常是问题规模，值通常是递归函数的返回值。<code>递归是从问题的结果倒推，直到问题的规模缩小到寻常。 动态规划是从寻常入手， 逐步扩大规模到最优子结构。</code></p>
<p>如果上面的爬楼梯问题，使用动态规划，代码是这样的：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">climbStairs</span>(n) &#123;</span><br><span class="line">  if (n == 1) <span class="keyword">return</span> <span class="type">1</span>;</span><br><span class="line">  const dp = <span class="keyword">new</span> <span class="keyword">Array</span>(n);</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (let i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不会也没关系，我们将递归的代码稍微改造一下。其实就是将函数的名字改一下：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">dp</span>(n) &#123;</span><br><span class="line">  if (n === <span class="number">1</span>) return <span class="number">1</span>;</span><br><span class="line">  if (n === <span class="number">2</span>) return <span class="number">2</span>;</span><br><span class="line">  return <span class="built_in">dp</span>(n - <span class="number">1</span>) + <span class="built_in">dp</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>dp[n] 和 dp(n) 对比看，这样是不是有点理解了呢? 只不过递归用调用栈枚举状态， 而动态规划使用迭代枚举状态。</p>
</blockquote>
<p>动态规划的查表过程如果画成图，就是这样的：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/a86bff4cc2dd300c18d944c82ba9309a1f555a9337616905654f14753bcc4f01/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303753385a496c6c793167686c756878796c62686a33306e343063626161712e6a7067"><img src="https://i.loli.net/2021/03/08/XxeSg7NKCUvLz2D.jpg" alt="dynamic-programming-3"></a></p>
<blockquote>
<p>虚线代表的是查表过程</p>
</blockquote>
<p>这道题目是动态规划中最简单的问题了，因为只涉及到单个因素的变化，如果涉及到多个因素，就比较复杂了，比如著名的背包问题，挖金矿问题等。</p>
<p>对于单个因素的，我们最多只需要一个一维数组即可，对于如背包问题我们需要二维甚至更高维度的数组。</p>
<p>爬楼梯我们并没有必要使用一维数组，而是借助两个变量来实现的，空间复杂度是 O(1)。代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">climbStairs</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">let</span> temp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    temp = a + b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以能这么做，是因为爬楼梯问题的状态转移方程中<strong>当前状态只和前两个状态有关</strong>，因此只需要存储这两个即可。 动态规划问题有很多这种讨巧的方式，这个技巧叫做滚动数组。</p>
<p>再次强调一下：</p>
<ul>
<li>如果说递归是从问题的结果倒推，直到问题的规模缩小到寻常。 那么动态规划就是从寻常入手， 逐步扩大规模到最优子结构。</li>
<li>记忆化递归和动态规划没有本质不同。都是枚举状态，并根据状态直接的联系逐步推导求解。</li>
<li>动态规划性能通常更好。 一方面是递归的栈开销，一方面是滚动数组的技巧。</li>
</ul>
<h3 id="动态规划的三个要素"><a href="#动态规划的三个要素" class="headerlink" title="动态规划的三个要素"></a>动态规划的三个要素</h3><ol>
<li>状态转移方程</li>
<li>临界条件</li>
<li>枚举状态</li>
</ol>
<blockquote>
<p>可以看出，用递归解决也是一样的思路</p>
</blockquote>
<p>在上面讲解的爬楼梯问题中，如果我们用 f(n) 表示爬 n 级台阶有多少种方法的话，那么：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span> 与 <span class="built_in">f</span>(<span class="number">2</span>) 就是【边界】</span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(n)</span></span> = <span class="built_in">f</span>(n-<span class="number">1</span>) + <span class="built_in">f</span>(n-<span class="number">2</span>) 就是【状态转移公式】</span><br></pre></td></tr></table></figure>

<p>我用动态规划的形式表示一下：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp<span class="comment">[0]</span> 与 dp<span class="comment">[1]</span> 就是【边界】</span><br><span class="line">dp<span class="comment">[n]</span> = dp<span class="comment">[n - 1]</span> + dp<span class="comment">[n - 2]</span> 就是【状态转移方程】</span><br></pre></td></tr></table></figure>

<p>可以看出两者是多么的相似。</p>
<p>实际上临界条件相对简单，大家只有多刷几道题，里面就有感觉。困难的是找到状态转移方程和枚举状态。这两个核心点的都建立在<strong>已经抽象好了状态</strong>的基础上。比如爬楼梯的问题，如果我们用 f(n) 表示爬 n 级台阶有多少种方法的话，那么 f(1), f(2), … 就是各个<strong>独立的状态</strong>。</p>
<p>不过状态的定义都有特点的套路。 比如一个字符串的状态，通常是 dp[i] 表示字符串 s 以 i 结尾的 ….。 比如两个字符串的状态，通常是 dp[i][j] 表示字符串 s1 以 i 结尾，s2 以 j 结尾的 ….。</p>
<p>当然状态转移方程可能不止一个， 不同的转移方程对应的效率也可能大相径庭，这个就是比较玄学的话题了，需要大家在做题的过程中领悟。</p>
<p>搞定了状态的定义，那么我们来看下状态转移方程。</p>
<h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>爬楼梯问题由于上第 n 级台阶一定是从 n - 1 或者 n - 2 来的，因此 上第 n 级台阶的数目就是 <code>上 (n - 1) 级台阶的数目「加」上 (n - 2) 级台阶的数目</code>。</p>
<p>上面的这个理解是核心， 它就是我们的状态转移方程，用代码表示就是 <code>f(n) = f(n - 1) + f(n - 2)</code>。</p>
<p>实际操作的过程，有可能题目和爬楼梯一样直观，我们不难想到。也可能隐藏很深或者维度过高。 如果你实在想不到，可以尝试画图打开思路，这也是我刚学习动态规划时候的方法。当你做题量上去了，你的题感就会来，那个时候就可以不用画图了。</p>
<p>状态转移方程实在是没有什么灵丹妙药，不同的题目有不同的解法。状态转移方程同时也是解决动态规划问题中最最困难和关键的点，大家一定要多多练习，提高题感。接下来，我们来看下不那么困难，但是新手疑问比较多的问题 - <strong>如何枚举状态</strong>。</p>
<h4 id="如何枚举状态"><a href="#如何枚举状态" class="headerlink" title="如何枚举状态"></a>如何枚举状态</h4><p>前面说了如何枚举状态，才能不重不漏是枚举状态的关键所在。</p>
<ul>
<li>如果是一维状态，那么我们使用一层循环可以搞定。</li>
<li>如果是两维状态，那么我们使用两层循环可以搞定。</li>
<li>。。。</li>
</ul>
<p>这样可以保证不重不漏。</p>
<p>但是实际操作的过程有很多细节比如:</p>
<ul>
<li>一维状态我是先枚举左边的还是右边的？（从左到右遍历还是从右到左遍历）</li>
<li>二维状态我是先枚举左上边的还是右上的，还是左下的还是右下的？</li>
<li>里层循环和外层循环的位置关系（可以互换么）</li>
<li>。。。</li>
</ul>
<p>其实这个东西和很多因素有关，很难总结出一个规律，而且我认为也完全没有必要去总结规律。不过这里我还是总结了一个关键点，那就是：</p>
<ul>
<li><strong>如果你没有使用滚动数组的技巧</strong>，那么遍历顺序取决于状态转移方程。比如:</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">for</span> i in range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">  <span class="attribute">dp</span>[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>那么我们就需要从左到右遍历，原因很简单，因为 dp[i] 依赖于 dp[i - 1]，因此计算 dp[i] 的时候， dp[i - 1] 需要已经计算好了。</p>
<blockquote>
<p>二维的也是一样的，大家可以试试。</p>
</blockquote>
<ul>
<li><strong>如果你使用了滚动数组的技巧</strong>，则怎么遍历都可以，但是不同的遍历意义通常不不同的。比如我将二维的压缩到了一维：</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">for</span> i in range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">  <span class="attribute">for</span> j in range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    <span class="attribute">dp</span>[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这样是可以的。 dp[j - 1] 实际上指的是压缩前的 dp[i][j - 1]</p>
<p>而：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">for</span> i in range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">  <span class="comment">#  倒着遍历</span></span><br><span class="line">  <span class="attribute">for</span> j in range(n, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="attribute">dp</span>[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这样也是可以的。 但是 dp[j - 1] 实际上指的是压缩前的 dp[i - 1][j - 1]。因此实际中采用怎么样的遍历手段取决于题目。我特意写了一个 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/solution/wan-quan-bei-bao-wen-ti-tao-lu-ti-1449-shu-wei-che/">【完全背包问题】套路题（1449. 数位成本和为目标值的最大数字</a> 文章，通过一个具体的例子告诉大家不同的遍历有什么实际不同，强烈建议大家看看，并顺手给个三连。</p>
<ul>
<li>关于里外循环的问题，其实和上面原理类似。</li>
</ul>
<p>这个比较微妙，大家可以参考这篇文章理解一下 <a target="_blank" rel="noopener" href="https://github.com/azl397985856/leetcode/blob/master/problems/518.coin-change-2.md">0518.coin-change-2</a>。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>关于如何确定临界条件通常是比较简单的，多做几个题就可以快速掌握。</p>
<p>关于如何确定状态转移方程，这个其实比较困难。 不过所幸的是，这些套路性比较强， 比如一个字符串的状态，通常是 dp[i] 表示字符串 s 以 i 结尾的 ….。 比如两个字符串的状态，通常是 dp[i][j] 表示字符串 s1 以 i 结尾，s2 以 j 结尾的 ….。 这样遇到新的题目可以往上套， 实在套不出那就先老实画图，不断观察，提高题感。</p>
<p>关于如何枚举状态，如果没有滚动数组， 那么根据转移方程决定如何枚举即可。 如果用了滚动数组，那么要注意压缩后和压缩前的 dp 对应关系即可。</p>
<h3 id="动态规划为什么要画表格"><a href="#动态规划为什么要画表格" class="headerlink" title="动态规划为什么要画表格"></a>动态规划为什么要画表格</h3><p>动态规划问题要画表格，但是有的人不知道为什么要画，就觉得这个是必然的，必要要画表格才是动态规划。</p>
<p>其实动态规划本质上是将大问题转化为小问题，然后大问题的解是和小问题有关联的，换句话说大问题可以由小问题进行计算得到。这一点是和用递归解决一样的， 但是动态规划是一种类似查表的方法来缩短时间复杂度和空间复杂度。</p>
<p>画表格的目的就是去不断推导，完成状态转移， 表格中的每一个 cell 都是一个<code>小问题</code>， 我们填表的过程其实就是在解决问题的过程，</p>
<p>我们先解决规模为寻常的情况，然后根据这个结果逐步推导，通常情况下，表格的右下角是问题的最大的规模，也就是我们想要求解的规模。</p>
<p>比如我们用动态规划解决背包问题， 其实就是在不断根据之前的小问题<code>A[i - 1][j] A[i -1][w - wj]</code>来询问：</p>
<ul>
<li>应该选择它</li>
<li>还是不选择它</li>
</ul>
<p>至于判断的标准很简单，就是价值最大，因此我们要做的就是对于选择和不选择两种情况分别求价值，然后取最大，最后更新 cell 即可。</p>
<p>其实大部分的动态规划问题套路都是“选择”或者“不选择”，也就是说是一种“选择题”。 并且大多数动态规划题目还伴随着空间的优化（滚动数组），这是动态规划相对于传统的记忆化递归优势的地方。除了这点优势，就是上文提到的使用动态规划可以减少递归产生的函数调用栈，因此性能上更好。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">Leetcode 5.最长回文子串</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="type">char</span>[]chars = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s[i, j] 是否是回文串</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;len)dp[i][i+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">                dp[i][i]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;j;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(chars[i]!=chars[j])<span class="comment">//一头一尾不相等，所以肯定不是回文子串</span></span><br><span class="line">                        dp[i][j]=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(j-i&lt;<span class="number">3</span>)<span class="comment">//当子串只有两个或者三个元素的时候，肯定是回文子串</span></span><br><span class="line">                            dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            dp[i][j]=dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j]==<span class="literal">true</span>&amp;&amp;maxLen&lt;j-i+<span class="number">1</span>)<span class="comment">//最长子串进行迭代</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        maxLen=j-i+<span class="number">1</span>;begin=i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin,begin+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2019/11/27/ComputerNetworking_Socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/27/ComputerNetworking_Socket/" class="post-title-link" itemprop="url">socket</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-27 00:07:04" itemprop="dateCreated datePublished" datetime="2019-11-27T00:07:04Z">2019-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-03 11:45:42" itemprop="dateModified" datetime="2020-04-03T11:45:42Z">2020-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0-理解Socket"><a href="#0-理解Socket" class="headerlink" title="0 理解Socket"></a><strong>0 理解Socket</strong></h1><p>什么是Socket呢？<br>我们经常把Socket翻译为套接字，Socket是在应用层和传输层之间的一个抽象层，它把TCP&#x2F;IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。<br>socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种”打开—读&#x2F;写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。<br>套接字是通信的基石，可看作不同主机的进程进行双向通信的端点。<br>套接字有两种不同的类型：流式套接字和数据报套接字。<br>套接字可处于阻塞模式或非阻塞模式。</p>
<p><img src="/Socket.assets/1012444-20190920131745226-1003426645.png" alt="img"></p>
<p><img src="/Socket.assets/1012444-20190920131745554-104977508.png" alt="img"></p>
<h1 id="1-WinSock-API"><a href="#1-WinSock-API" class="headerlink" title="1 WinSock API"></a>1 WinSock API</h1><p>什么是WinSock呢？<br>WinSock是一套开放的、支持多种协议的Windows下网络编程的接口，是Windows网络编程实时上的标准。<br>Winsock版本：目前Winsock有两个版本，分别是WinSock1.1和WinSock2.0，使用方法如下：<br>WinSock1.1:<br>#include &lt;winsock.h&gt;<br>#pragma comment(lib, “wsock32.lib”)<br>WinSock2.0:<br>#include &lt;winsock2.h&gt;<br>#pragma comment(lib, “ws2_32.lib”)<br>WinSock服务是以动态链接库Winsock DLL形式实现的。</p>
<h2 id="通用API函数列表"><a href="#通用API函数列表" class="headerlink" title="通用API函数列表"></a>通用API函数列表</h2><p><strong>WinSock API 　　　　 描述</strong><br>WSAStartup 　　　　 Winsock启动<br>WSACleanup 　　　    Winsock停止<br>WSASetLastError　　  错误的检查和控制</p>
<p>针对WinSock1.1存在的某些局限，WinSock2提供了许多方面的扩展（如支持多个传输协议的原始套接字、重叠IO模型、服务质量控制等）以支持功能更强大的应用，考虑兼容性，WinSock1.1的API都在WinSock2中保留了下来。</p>
<h1 id="2-阻塞socket"><a href="#2-阻塞socket" class="headerlink" title="2 阻塞socket"></a><strong>2 阻塞socket</strong></h1><h2 id="基于TCP的套接字："><a href="#基于TCP的套接字：" class="headerlink" title="基于TCP的套接字："></a><strong>基于TCP的套接字</strong>：</h2><p>&#x2F;&#x2F; 创建套接字<br>SOCKET socket(int af, int type, int protocol);<br>&#x2F;&#x2F; 绑定地址端口<br>int bind(SOCKET s, const struct sockaddr *addr, socklen_t addrlen);<br>&#x2F;&#x2F; 监听客户端<br>int listen(SOCKET s, int backlog);<br>&#x2F;&#x2F; 接收客户端套接字请求<br>int accept(SOCKET s, struct sockaddr *addr, socklen_t *addrlen);<br>&#x2F;&#x2F; 连接服务端套接字<br>int connect(SOCKET s, const struct sockaddr <em>addr, socklen_t addrlen);<br>&#x2F;&#x2F; 发送数据<br>int send(SOCKET s, const char FAR * buf, int len, int flags);<br>&#x2F;&#x2F; 接收数据（阻塞）<br>int recv(SOCKET s, char</em> buf, int len, int flags);<br>&#x2F;&#x2F; 关闭套接字<br>int closesocket(SOCKET s);</p>
<p><img src="/Socket.assets/1012444-20190920131745795-533662518.png" alt="img"></p>
<h2 id="基于UDP的套接字："><a href="#基于UDP的套接字：" class="headerlink" title="基于UDP的套接字："></a><strong>基于UDP的套接字</strong>：</h2><p>&#x2F;&#x2F; 创建套接字<br>SOCKET socket(int af, int type, int protocol);<br>&#x2F;&#x2F; 绑定地址端口<br>int bind(SOCKET s, const struct sockaddr <em>addr, socklen_t addrlen);<br>&#x2F;&#x2F; 发送数据<br>int sendto (SOCKET s, const char</em> buf, int len, int flags, const struct sockaddr* to, int tolen);<br>&#x2F;&#x2F; 接收数据（阻塞）<br>int recvfrom(SOCKET s, char* buf, int len, int flags, struct sockaddr* from, int* fromlen);<br>&#x2F;&#x2F; 关闭套接字<br>int closesocket(SOCKET s);</p>
<p><img src="/Socket.assets/1012444-20190920131746090-1344730542.png" alt="img"></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结</strong>：</h2><p>在阻塞模式下，在IO操作完成之前，执行操作的WinSock函数会一直等待下去，不会立即返回，这就意味着任意一个线程在某一时刻只能进行一个IO操作，而且应用程序很难同时通过多个建好连接的套接字进行通信。<br>可见，在默认情况下套接字为阻塞模式。<br>这种情况下一般采用多线程方式，在不同的线程中进行不同的连接处理来避免阻塞，但是多线程会增加系统开销，而且线程同步会增加复杂度。</p>
<h1 id="3-非阻塞Socket"><a href="#3-非阻塞Socket" class="headerlink" title="3 非阻塞Socket"></a><strong>3 非阻塞Socket</strong></h1><p>WinSock API默认为阻塞模式，但是其提供了非阻塞模式套接字，非阻塞模式套接字使用上不如阻塞模式套接字简单，存在一点的难度，但是只要排除了这些困难，它在功能上还是很强大的。<br>可以使用ioctlsocket将套接字设置为非阻塞模式套接字：<br>int PASCAL FAR ioctlsocket (<br>　　IN SOCKET s,<br>　　IN long cmd,<br>　　IN OUT u_long FAR *argp);<br>　　&#x2F;&#x2F; If *argp &#x3D; 0, blocking is enabled;<br>　　&#x2F;&#x2F; If *argp !&#x3D; 0, non-blocking mode is enabled.</p>
<p> 代码片段(基于TCP)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SOCKET sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == sock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">AfxMessageBox</span>(_T(<span class="string">&quot;Create socket failed&quot;</span>));</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> lMode = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> retMode = <span class="built_in">ioctlsocket</span>(sock, FIONBIO, (<span class="type">unsigned</span> <span class="type">long</span> *)&amp; lMode);</span><br><span class="line"><span class="keyword">if</span> (retMode == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将一个套接字设置为非阻塞模式后，WinSock API调用会立即返回。大多数情况下，这些调用都会”失败”，并返回一个WSAEWOULDBLOCK错误表示请求的操作在调用期间没有时间完成。由于会不断地返回这个错误，所以程序员需要通过不断地检查函数返回码以判断一个套接字何时可供读写。</p>
<p> C++ Code </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">While</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    nRec = <span class="built_in">recv</span>(sock, (<span class="type">char</span> *)pbuf, <span class="number">1000</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nRec == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">if</span> (r == WSAEWOULDBLOCK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nRec == WSAETIMEDOUT || nRec == WSAENETDOWN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv failed!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">closesocket</span>(sServer);</span><br><span class="line">            <span class="built_in">closesocket</span>(sClient);</span><br><span class="line">            <span class="built_in">WSACleanup</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-套接字IO模型"><a href="#4-套接字IO模型" class="headerlink" title="4 套接字IO模型"></a><strong>4 套接字IO模型</strong></h1><p>套接字的阻塞模式和非阻塞模式都存在一定的缺点，会给编程带来一定的麻烦。为了免去这样的麻烦，WinSock提供了集中不同的套接字IO模型对IO进行管理，它们包括：</p>
<ul>
<li>select（选择）</li>
<li>WSAAsyncSelect（异步选择）</li>
<li>WSAEventSelect（事件选择）</li>
<li>Overlaped（重叠）</li>
<li>Completion port（完成端口）</li>
</ul>
<h2 id="4-1-套接字IO模型：select（选择）"><a href="#4-1-套接字IO模型：select（选择）" class="headerlink" title="4.1 套接字IO模型：select（选择）"></a><strong>4.1 套接字IO模型：select（选择）</strong></h2><p>select模式是WinSock中最常见的IO模型。通过调用select函数可以确定一个或多个套接字的状态，判断套接字上是否存在数据，或者能否向一个套接字写入数据。有如下好处：<br>1）、防止应用程序在套接字处于阻塞模式时，在一次IO操作后被阻塞；<br>2）、防止在套接字处于非阻塞模式中时产生WSAEWOULDBLOCK错误。</p>
<p>函数原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">The **select** function determines the status of one <span class="keyword">or</span> more sockets, waiting <span class="keyword">if</span> necessary, to perform synchronous I/O.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> PASCAL FAR <span class="title">select</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">IN <span class="type">int</span> nfds,</span></span></span><br><span class="line"><span class="params"><span class="function">IN OUT fd_set FAR *readfds,</span></span></span><br><span class="line"><span class="params"><span class="function">IN OUT fd_set FAR *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">IN OUT fd_set FAR *exceptfds,</span></span></span><br><span class="line"><span class="params"><span class="function">IN <span class="type">const</span> <span class="keyword">struct</span> timeval FAR *timeout)</span></span>;</span><br><span class="line">nfds - Ignored. The nfds parameter is included only <span class="keyword">for</span> compatibility with Berkeley sockets.</span><br><span class="line">readfds -Optional pointer to a set of sockets to be checked <span class="keyword">for</span> readability.</span><br><span class="line">writefds -Optional pointer to a set of sockets to be checked <span class="keyword">for</span> writability.</span><br><span class="line">exceptfds -Optional pointer to a set of sockets to be checked <span class="keyword">for</span> errors.</span><br><span class="line">timeout -Maximum time <span class="keyword">for</span> select to wait, provided in the form of a TIMEVAL structure. Set the timeout parameter to null <span class="keyword">for</span> blocking operations.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用该模型时，在服务端（select主要用在服务端处理多个客户请求上）我们可以开辟两个线程，一个线程用来监听客户端的连接请求，另一个用来处理客户端的请求。就这样不需要一个一个客户请求对应一个服务器处理线程，减少了线程的开销。<br>select允许进程指示内核等待多个事件中的任何一个发生，并仅在有一个或多个时间发生或经历一段指定时间后才唤醒它。select告诉内核对哪些描述子感兴趣以及等待多长时间。这就是所谓的非阻塞模型，就是进程或线程执行此函数时不必非要等待事件的发生，一旦执行肯定返回，以返回值的不同来反映函数的执行情况，如果事件发生则与阻塞方式相同，若事件没有发生则返回一个代码来告知事件未发生，而进程或线程继续执行，所以效率较高。<br>select本身是会阻塞的，我们可以使用select实现阻塞式套接字（如上），也可以实现异步套接字。我个人对实现异步套接字的理解是：你可以单独使用一个线程来进行你select，也就是说select阻塞你单独的线程，说白了就是让线程来完成异步。<br>该模型有个最大的缺点就是，它需要一个死循环不停的去遍历所有的客户端套接字集合，询问是否有数据到来，这样，如果连接的客户端很多，势必会影响处理客户端请求的效率，但它的优点就是解决了每一个客户端都去开辟新的线程与其通信的问题。</p>
<h2 id="4-2-套接字IO模型：WSAAsyncSelect（异步选择）"><a href="#4-2-套接字IO模型：WSAAsyncSelect（异步选择）" class="headerlink" title="4.2 套接字IO模型：WSAAsyncSelect（异步选择）"></a><strong>4.2 套接字IO模型：WSAAsyncSelect（异步选择）</strong></h2><p>如果有一个模型，可以不用去轮询客户端套接字集合，而是等待系统通知，当有客户端数据到来时，系统自动的通知我们的程序，这就解决了select模型带来的问题了。<br>于是WSAAsyncSelect模型登场了，WSAAsyncSelect模型就是这样一个解决了普通select模型问题的socket编程模型。它是在有客户端数据到来时，系统发送消息给我们的程序，我们的程序只要定义好消息的处理方法就可以了，用到的函数只要是WSAAsyncSelect。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">The WSAAsyncSelect function requests Windows message-based notification of network events <span class="keyword">for</span> a socket.</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSAAsyncSelect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">__in SOCKET s,</span></span></span><br><span class="line"><span class="params"><span class="function">__in HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">__in <span class="type">unsigned</span> <span class="type">int</span> wMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">__in <span class="type">long</span> lEvent</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line">s -A descriptor that identifies the socket <span class="keyword">for</span> which event notification is required.</span><br><span class="line">hWnd -A handle that identifies the window that will receive a message when a network event occurs.</span><br><span class="line">wMsg -A message to be received when a network event occurs.</span><br><span class="line">lEvent -A bitmask that specifies a combination of network events in which the application is interested.</span><br></pre></td></tr></table></figure>

<p>WSAAsyncSelect模型将套接字和Windows消息机制很好地粘合在一起，为用户异步SOCKET应用提供了一种较优雅的解决方案。<br>WSAAsyncSelect模型是非常简单的模型，它解决了普通select模型的问题，但是它最大的缺点就是它只能用在Windows程序上，因为它需要一个接收系统消息的窗口句柄，那么有没有一个模型既可以解决select模型的问题，又不限定只能是Windows程序才能用呢？请看下节。</p>
<h2 id="4-3-套接字IO模型：WSAEventSelect（事件选择）"><a href="#4-3-套接字IO模型：WSAEventSelect（事件选择）" class="headerlink" title="4.3 套接字IO模型：WSAEventSelect（事件选择）"></a><strong>4.3 套接字IO模型：WSAEventSelect（事件选择）</strong></h2><p>WSAEventSelect模型是一个不用主动去轮询所有客户端套接字是否有数据到来的模型，它也是在客户端有数据到来时，系统发送通知给我们的程序，但是，它不是发送消息，而是通过事件的方式来通知我们的程序，这就解决了WSAEventSelect模型只能用在Windows程序的问题。<br>该模型的实现，我们也可以开辟两个线程来进行处理，一个用来接收客户端的连接请求，一个用来与客户端进行通信，用到的主要函数有：WSAEventSelect，WSAWaitForMultipleEvents，WSAEnumNetworkEvents。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">The WSACreateEvent function creates a <span class="keyword">new</span> event object.</span><br><span class="line">WSAEVENT <span class="built_in">WSACreateEvent</span>(<span class="type">void</span>);</span><br><span class="line">The WSAEventSelect function specifies an event object to be associated with the specified set of FD_XXX network events.</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSAEventSelect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">__in SOCKET s,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">__in WSAEVENT hEventObject,</span></span></span><br><span class="line"><span class="params"><span class="function">__in <span class="type">long</span> lNetworkEvents</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line">The WSAWaitForMultipleEvents function returns when one <span class="keyword">or</span> all of the specified event objects are in the signaled state, when the time-out interval expires, <span class="keyword">or</span> when an I/O completion routine has executed.</span><br><span class="line"><span class="function">DWORD <span class="title">WSAWaitForMultipleEvents</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">__in DWORD cEvents,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">__in <span class="type">const</span> WSAEVENT* lphEvents,</span></span></span><br><span class="line"><span class="params"><span class="function">__in BOOL fWaitAll,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">__in DWORD dwTimeout,</span></span></span><br><span class="line"><span class="params"><span class="function">__in BOOL fAlertable</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line">The WSAEnumNetworkEvents function discovers occurrences of network events <span class="keyword">for</span> the indicated socket, clear internal network event records, <span class="function"><span class="keyword">and</span> reset event <span class="title">objects</span> <span class="params">(optional)</span>.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSAEnumNetworkEvents</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">__in SOCKET s,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">__in WSAEVENT hEventObject,</span></span></span><br><span class="line"><span class="params"><span class="function">__out LPWSANETWORKEVENTS lpNetworkEvents</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The WSACloseEvent function closes an open event object handle.</span><br><span class="line"><span class="function">BOOL <span class="title">WSACloseEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">__in WSAEVENT hEvent</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>代码片段（接受客户端请求并注册事件）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span>        g_nTotalConn    = <span class="number">0</span>;</span><br><span class="line">SOCKET    g_ClientSocket[MAXIMUM_WAIT_OBJECTS];</span><br><span class="line">WSAEVENT    g_ClientEvent[MAXIMUM_WAIT_OBJECTS];</span><br><span class="line"><span class="comment">//……</span></span><br><span class="line"><span class="keyword">while</span> (TRUE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Accept a connection</span></span><br><span class="line">    sClient = <span class="built_in">accept</span>(sListen, (<span class="keyword">struct</span> sockaddr *)&amp;client, &amp;nAddrSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Accepted client:%s:%d\n&quot;</span>, <span class="built_in">inet_ntoa</span>(client.sin_addr), <span class="built_in">ntohs</span>(client.sin_port));</span><br><span class="line">    <span class="comment">// Associate socket with network event</span></span><br><span class="line">    g_ClientSocket[g_nTotalConn] = sClient;</span><br><span class="line">    g_ClientEvent[g_nTotalConn] = <span class="built_in">WSACreateEvent</span>();</span><br><span class="line">    <span class="built_in">WSAEventSelect</span>(g_ClientSocket[g_nTotalConn],</span><br><span class="line">                   g_ClientEvent[g_nTotalConn],</span><br><span class="line">                   FD_READ | FD_CLOSE);</span><br><span class="line">    g_nTotalConn++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码片段（接受到事件并处理） </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThread</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nRet       = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> nIndex     = <span class="number">0</span>;</span><br><span class="line">    WSANETWORKEVENTS NetworkEvents;</span><br><span class="line">    <span class="type">char</span> szMessage[MSG_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        nRet = <span class="built_in">WSAWaitForMultipleEvents</span>(g_nTotalConn, g_ClientEvent, FALSE, <span class="number">1000</span>, FALSE);</span><br><span class="line">        <span class="comment">//注意这里应该有相应的修正的地方，WSAWaitForMultipleEvents函数在fWaitAll设置成FALSE</span></span><br><span class="line">        <span class="comment">//的时候只能指定一个事件对象受信，解决方法使用for循环进行循环检测</span></span><br><span class="line">        <span class="keyword">if</span> (nRet == WSA_WAIT_FAILED || nRet == WSA_WAIT_TIMEOUT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nIndex = nRet - WSA_WAIT_EVENT_0;</span><br><span class="line">        <span class="comment">//查看发生了什么网络事件</span></span><br><span class="line">        <span class="built_in">WSAEnumNetworkEvents</span>(g_ClientSocket[nIndex],</span><br><span class="line">                             g_ClientEvent[nIndex],</span><br><span class="line">                             &amp;NetworkEvents);</span><br><span class="line">        <span class="keyword">if</span> (NetworkEvents.lNetworkEvents &amp; FD_READ)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Receive message from client</span></span><br><span class="line">            nRet = <span class="built_in">recv</span>(g_ClientSocket[nIndex], szMessage, MSG_SIZE, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (nRet == <span class="number">0</span> || (nRet == SOCKET_ERROR &amp;&amp; <span class="built_in">WSAGetLastError</span>() == WSAECONNRESET))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Cleanup</span>(nIndex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                szMessage[nRet] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="built_in">send</span>(g_ClientSocket[nIndex], szMessage, <span class="built_in">strlen</span>(szMessage), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (NetworkEvents.lNetworkEvents &amp; FD_CLOSE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Cleanup</span>(nIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该模型通过一个死循环里面调用WSAWaitForMultipleEvents函数来等待客户端套接字对应的Event的到来，一旦事件通知到达，就通过该套接字去接收数据。虽然WsaEventSelect模型的实现较前两种方法复杂，但它在效率和兼容性方面是最好的。</p>
<h2 id="4-4-套接字IO模型：Overlaped（重叠）"><a href="#4-4-套接字IO模型：Overlaped（重叠）" class="headerlink" title="4.4 套接字IO模型：Overlaped（重叠）"></a><strong>4.4 套接字IO模型：Overlaped（重叠）</strong></h2><p>以上三种模型虽然在效率方面有了不少的提升，但它们都存在一个问题，就是都预设了只能接收64个客户端连接，虽然我们在实现时可以不受这个限制，但是那样，它们所带来的效率提升又将打折扣，那又有没有什么模型可以解决这个问题呢？<br>当然有，它就是Overlaped模型。<br>优点：<br>1、可以运行在支持Winsock2的所有Windows平台 ,而不像完成端口只是支持NT系统。<br>2、比起阻塞、非阻塞、select、WSAAsyncSelect以及WSAEventSelect等模型，Overlapped I&#x2F;O模型使应用程序能达到更佳的系统性能。<br>因为它和这5种模型不同的是：使用重叠模型的应用程序通知缓冲区收发系统直接使用数据，也就是说，如果应用程序投递了一个10KB大小的缓冲区来接收数据，且数据已经到达套接字，则该数据将直接被拷贝到投递的缓冲区。<br>而这5种模型种，数据到达并拷贝到单套接字接收缓冲区中，此时应用程序会被告知可以读入的容量。当应用程序调用接收函数之后，数据才从单套接字缓冲区拷贝到应用程序的缓冲区，差别就体现出来了。<br>3、从《Windows网络编程》中提供的试验结果中可以看到，在使用了P4 1.7G Xero处理器(CPU很强啊)以及768MB的回应服务器中，最大可以处理4万多个SOCKET连接，在处理1万2千个连接的时候CPU占用率才40% 左右(非常好的性能，已经直逼完成端口了^_^)，再也不被限制在64个客户端连接数了，而且性能杠杠的！<br>原理：<br>概括一点说，重叠模型是让应用程序使用重叠数据结构(WSAOVERLAPPED)，一次投递一个或多个Winsock I&#x2F;O请求。针对这些提交的请求，在它们完成之后，应用程序会收到通知，于是就可以通过自己另外的代码来处理这些数据了。<br>需要注意的是，有两个方法可以用来管理重叠IO请求的完成情况（就是说接到重叠操作完成的通知）：<br>1、事件对象通知(event object notification)<br>2、完成例程(completion routines)，注意，这里并不是完成端口<br>我们知道WinSock2扩展中支持重叠IO模型，既然要使用重叠结构，我们常用的send、sendto、recv、recvfrom也都要被WSASend、WSASendto、WSARecv、WSARecvFrom替换掉了，这里只需要注意一点，它们的参数中都有一个Overlapped参数，我们可以假设是把我们的WSARecv这样的操作操作”绑定”到这个重叠结构上，提交一个请求，其他的事情就交给重叠结构去操心，而其中重叠结构又要与Windows的事件对象”绑定”在一起，这样我们调用完WSARecv以后就可以”坐享其成”，等到重叠操作完成以后，自然会有与之对应的事件来通知我们操作完成，然后我们就可以来根据重叠操作的结果取得我们想要德数据了。<br>WinSock重叠IO的基础是Windows的重叠IO机制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">ReadFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">__in HANDLE hFile,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">__out LPVOID lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">__in DWORD nNumberOfBytesToRead,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">__out LPDWORD lpNumberOfBytesRead,</span></span></span><br><span class="line"><span class="params"><span class="function">__in LPOVERLAPPED lpOverlapped</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果我们在CreateFile的时候没有使用FILE_FLAG_OVERLAPPED标志，同时在调用ReadFile的时候把lpOverlapped这个参数设置的是null，那么ReadFile这个函数的调用一直要到读取完数据指定的数据后才会返回，如果没读取完，就会阻塞在这里。同样 ,writefile和ReadFile都是这样的。这样在读写大文件的时候，我们很多时间都浪费在等待ReadFile和writefile的返回上面。如果ReadFile和WriteFile是往管道里读写数据，那么有可能阻塞得更久，导致程序性能下降。为了解决这个问题，windows引进了重叠io的概念，同样是上面的ReadFile和WriteFile，如果在CreateFile的时候设置了file_flag_overlapped ，那么在调用ReadFile和WriteFile的时候就可以给他们最后一个参数传递一个overlapped结构。这样ReadFile或者WriteFile的调用马上就会返回，这时候你可以去做你要做的事，系统会自动替你完成ReadFile或者WriteFile,在你调用了ReadFile或者WriteFile后，你继续做你的事，系统同时也帮你完成ReadFile或WriteFile的操作，这就是所谓的重叠。使用重叠io还有一个好处，就是你可以同时发出几个ReadFile或者WriteFile的调用，然后用WaitForSingleObject或者WaitForMultipleObjects来等待操作系统的操作完成通知，在得到通知信号后，就可以用GetOverlappedResult来查询IO调用的结果。</p>
<p>如果我们在CreateFile的时候没有使用FILE_FLAG_OVERLAPPED标志，同时在调用ReadFile的时候把lpOverlapped这个参数设置的是null，那么ReadFile这个函数的调用一直要到读取完数据指定的数据后才会返回，如果没读取完，就会阻塞在这里。同样 ,writefile和ReadFile都是这样的。这样在读写大文件的时候，我们很多时间都浪费在等待ReadFile和writefile的返回上面。如果ReadFile和WriteFile是往管道里读写数据，那么有可能阻塞得更久，导致程序性能下降。为了解决这个问题，windows引进了重叠io的概念，同样是上面的ReadFile和WriteFile，如果在CreateFile的时候设置了file_flag_overlapped ，那么在调用ReadFile和WriteFile的时候就可以给他们最后一个参数传递一个overlapped结构。这样ReadFile或者WriteFile的调用马上就会返回，这时候你可以去做你要做的事，系统会自动替你完成ReadFile或者WriteFile,在你调用了ReadFile或者WriteFile后，你继续做你的事，系统同时也帮你完成ReadFile或WriteFile的操作，这就是所谓的重叠。使用重叠io还有一个好处，就是你可以同时发出几个ReadFile或者WriteFile的调用，然后用WaitForSingleObject或者WaitForMultipleObjects来等待操作系统的操作完成通知，在得到通知信号后，就可以用GetOverlappedResult来查询IO调用的结果。</p>
<p>举个例子：<br>你想当你有这样一个请求，就是<br>readfile(…) &#x2F;&#x2F;1<br>writefile(…) &#x2F;&#x2F;2<br>readfile(…) &#x2F;&#x2F;3<br>你在程序中如果使用同步的话，那只有当你完成1以后2才会继续执行，2执行完以后3才会继续执行，这就是同步。<br>当如果使用异步的话，当系统遇到1时，ok，开一线程给它去完成该io请求，然后系统继续运行2，3，分别开两线程。 1-2-3如果是比较耗时的操作，尤其是运用在网络上，那么1-2-3这三个io请求是并行的，也就是重叠的。</p>
<h3 id="4-4-1-基于事件通知的重叠I-x2F-O模型"><a href="#4-4-1-基于事件通知的重叠I-x2F-O模型" class="headerlink" title="4.4.1 基于事件通知的重叠I&#x2F;O模型"></a><strong>4.4.1 基于事件通知的重叠I&#x2F;O模型</strong></h3><p>The WSARecv function receives data from a connected socket.<br>int WSARecv(<br>__in SOCKET s,<br>__in_out LPWSABUF lpBuffers,<br>__in DWORD dwBufferCount,<br>__out LPDWORD lpNumberOfBytesRecvd,<br>__in_out LPDWORD lpFlags,<br>__in LPWSAOVERLAPPED lpOverlapped,<br>__in LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine<br>);</p>
<p> C++ Code </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Flags = <span class="number">0</span>;</span><br><span class="line">    rc = <span class="built_in">WSARecv</span>(ConnSocket, &amp;DataBuf, <span class="number">1</span>, &amp;RecvBytes, &amp;Flags, &amp;RecvOverlapped, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (rc == SOCKET_ERROR) &amp;&amp; (WSA_IO_PENDING != (err = <span class="built_in">WSAGetLastError</span>())))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;WSARecv failed: %d\n&quot;</span>, err);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = <span class="built_in">WSAWaitForMultipleEvents</span>(<span class="number">1</span>, &amp;RecvOverlapped.hEvent, TRUE, INFINITE, TRUE);</span><br><span class="line">    <span class="keyword">if</span> (rc == WSA_WAIT_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;WSAWaitForMultipleEvents failed: %d\n&quot;</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = <span class="built_in">WSAGetOverlappedResult</span>(ConnSocket, &amp;RecvOverlapped, &amp;RecvBytes, FALSE, &amp;Flags);</span><br><span class="line">    <span class="keyword">if</span> (rc == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;WSARecv operation failed: %d\n&quot;</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read %d bytes\n&quot;</span>, RecvBytes);</span><br><span class="line">    <span class="built_in">WSAResetEvent</span>(RecvOverlapped.hEvent);</span><br><span class="line">    <span class="comment">// If 0 bytes are received, the connection was closed</span></span><br><span class="line">    <span class="keyword">if</span> (RecvBytes == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-2-基于完成例程的重叠I-x2F-O模型"><a href="#4-4-2-基于完成例程的重叠I-x2F-O模型" class="headerlink" title="4.4.2 基于完成例程的重叠I&#x2F;O模型"></a><strong>4.4.2 基于完成例程的重叠I&#x2F;O模型</strong></h3><p>完成例程(Completion Routine)并非是大家所常听到的”完成端口”(Completion Port)，而是另外一种管理重叠I&#x2F;O请求的方式。<br>如果你想要使用重叠I&#x2F;O机制带来的高性能模型，又懊恼于基于事件通知的重叠模型要收到64个等待事件的限制，还有点畏惧完成端口稍显复杂的初始化过程，那么”完成例程”无疑是你最好的选择！^_^因为完成例程摆脱了事件通知的限制，可以连入任意数量客户端而不用另开线程，也就是说只用很简单的一些代码就可以利用Windows内部的I&#x2F;O机制来获得网络服务器的高性能。<br>而且个人感觉”完成例程”的方式比重叠I&#x2F;O更好理解，因为就和我们传统的”回调函数”是一样的，也更容易使用一些，推荐！<br>基于事件通知的重叠I&#x2F;O模型，在你投递了一个请求以后(比如WSARecv)，系统在完成以后是用事件来通知你的，而在完成例程中，系统在网络操作完成以后会自动调用你提供的回调函数，区别仅此而已，是不是很简单呢？<br>采用完成例程的服务端，通信流程是这样的：</p>
<p><img src="/Socket.assets/1012444-20190920131746383-1434771728.png" alt="img"></p>
<p>从图中可以看到，服务器端存在一个明显的异步过程，也就是说我们把客户端连入的SOCKET与一个重叠结构绑定之后，便可以将通讯过程全权交给系统内部自己去帮我们调度处理了（该过程见途中灰色部分），我们在主线程中就可以去做其他的事情，边等候系统完成的通知（调用事前注册的完成例程回调函数）就OK，这也就是完成例程高性能的原因所在。<br>有趣的比方：完成例程的处理过程，也就像我们告诉系统，说”我想要在网络上接收网络数据，你去帮我办一下”（投递WSARecv操作），”不过我并不知道网络数据合适到达，总之在接收到网络数据之后，你直接就调用我给你的这个函数(比如_CompletionProess)，把他们保存到内存中或是显示到界面中等等，全权交给你处理了”，于是乎，系统在接收到网络数据之后，一方面系统会给我们一个通知，另外同时系统也会自动调用我们事先准备好的回调函数，就不需要我们自己操心了。<br>完成例程回调函数原型及传递方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Void CALLBACK _CompletionRoutineFunc(</span><br><span class="line">DWORD dwError, 　　　　 　　　　　　 <span class="comment">// 标志咱们投递的重叠操作，比如WSARecv，完成的状态是什么</span></span><br><span class="line">DWORD cbTransferred, 　 　　　　　　<span class="comment">// 指明了在重叠操作期间，实际传输的字节量是多大</span></span><br><span class="line">LPWSAOVERLAPPED lpOverlapped, 　 <span class="comment">// 参数指明传递到最初的IO调用内的一个重叠结构</span></span><br><span class="line">DWORD dwFlags 　　　　　　　　　　 <span class="comment">// 返回操作结束时可能用的标志(一般没用)</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>因为我们需要给系统提供一个如上面定义的那样的回调函数，以便系统在完成了网络操作后自动调用，这里就需要提一下究竟是如何把这个函数与系统内部绑定的呢？如下所示，在WSARecv函数中是这样绑定的：最后一个参数</p>
<p>因为我们需要给系统提供一个如上面定义的那样的回调函数，以便系统在完成了网络操作后自动调用，这里就需要提一下究竟是如何把这个函数与系统内部绑定的呢？如下所示，在WSARecv函数中是这样绑定的：最后一个参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">The WSARecv function receives data from a connected socket.</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSARecv</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">__in SOCKET s,</span></span></span><br><span class="line"><span class="params"><span class="function">__in_out LPWSABUF lpBuffers,</span></span></span><br><span class="line"><span class="params"><span class="function">__in DWORD dwBufferCount,</span></span></span><br><span class="line"><span class="params"><span class="function">__out LPDWORD lpNumberOfBytesRecvd,</span></span></span><br><span class="line"><span class="params"><span class="function">__in_out LPDWORD lpFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">__in LPWSAOVERLAPPED lpOverlapped,</span></span></span><br><span class="line"><span class="params"><span class="function">__in LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a><strong>小结</strong>：</h3><p>重叠模型的缺点：它为每一个IO请求都开了一个线程，当同时有1000个请求发生，那么系统处理线程上下文[context]切换也是非常耗时的，所以这也就引发了完成端口模型iocp，用<strong>线程池</strong>来解决这个问题，这是下节要学习的内容。</p>
<h2 id="4-5-套接字IO模型：Completion-port（完成端口）"><a href="#4-5-套接字IO模型：Completion-port（完成端口）" class="headerlink" title="4.5 套接字IO模型：Completion port（完成端口）"></a><strong>4.5 套接字IO模型：Completion port（完成端口）</strong></h2><p>IOCP（I&#x2F;O Completion Port，I&#x2F;O完成端口）是性能最好的一种I&#x2F;O模型。<br>它是应用程序使用线程池处理异步I&#x2F;O请求的一种机制。在处理多个并发的异步I&#x2F;O请求时，以往的模型都是在接收请求是创建一个线程来应答请求。这样就有很多的线程并行地运行在系统中。而这些线程都是可运行的，Windows内核花费大量的时间在进行线程的上下文切换，并没有多少时间花在线程运行上。再加上创建新线程的开销比较大，所以造成了效率的低下。<br>Windows Sockets应用程序在调用WSARecv()函数后立即返回,线程继续运行。当系统接收数据完成后，向完成端口发送通知包（这个过程对应用程序不可见）。<br>应用程序在发起接收数据操作后，在完成端口上等待操作结果。当接收到I&#x2F;O操作完成的通知后，应用程序对数据进行处理。<br>完成端口其实就是上面两项的联合使用基础上进行了一定的改进。<br>一个完成端口其实就是一个通知队列，由操作系统把已经完成的重叠I&#x2F;O请求的通知放入其中。当某项I&#x2F;O操作一旦完成，某个可以对该操作结果进行处理的工作者线程就会收到一则通知。而套接字在被创建后，可以在任何时候与某个完成端口进行关联。<br>众所皆知，完成端口是在Windows平台下效率最高，扩展性最好的IO模型，特别针对于WinSock的海量连接时，更能显示出其威力。其实建立一个完成端口的服务器也很简单，只要注意几个函数，了解一下关键的步骤也就行了。<br>从本质上说，完成端口模型要求我们创建一个Win32完成端口对象（内核对象），通过指定数量的线程对重叠I&#x2F;O请求进行管理，以便为已经完成的重叠I&#x2F;O请求提供服务。要注意的是，所谓”完成端口”，实际是Win32、Windows NT以及Windows 2000采用的一种I&#x2F;O构造机制，除套接字句柄之外，实际上还可接受其他东西。然而，本文只打算讲述如何使用套接字句柄，来发挥完成端口模型的巨大威力。使用这种模型之前，首先要创建一个I&#x2F;O完成端口对象，用它面向任意数量的套接字句柄。管理多个I&#x2F;O请求。要做到这—点,需要调用CreateIoCompletionPort函数。该函数定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateIoCompletionPort</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE FileHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE ExistingCompletionPort,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD CompletionKey,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD NumberOfConcurrentThreads</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="5-原始套接字"><a href="#5-原始套接字" class="headerlink" title="5 原始套接字"></a><strong>5 原始套接字</strong></h1><p>一般情况下程序设计人员主要接触以下两类套接字：<br>流式套接字（SOCK_STREAM）: 面向连接的套接字，对应于 TCP 应用程序。<br>数据包套接字（SOCK_DGRAM）: 无连接的套接字，对应于UDP 应用程序。<br>这一类套接字为标准套接字。此外，还有一类原始套接字，它是一种对原始网络报文进行处理的套接字。原始套接字的用途主要有：<br>发送自定义的IP 数据报<br>发送ICMP 数据报<br>网卡的侦听模式，监听网络上的数据包。<br>伪装IP地址。<br>自定义协议的实现。<br>原始套接字主要应用在底层网络编程上，同时也是网络黑客的必备手段。eg：sniffer、拒绝服务（DoS）、IP 地址欺骗等都需要在原始套接字的基础上实现。<br>原始套接字与标准套接字之间的关系如下图所示。标准套接字与网络协议栈的TCP、UDP 层打交道，而原始套接字则与IP层级网络协议栈核心打交道。<br>网络监听技术很大程度上依赖于SOCKET_RAW。</p>
<p><img src="/Socket.assets/1012444-20190920134448947-1182732511.png" alt="img"></p>
<p>要使用原始套接字，必须经过创建原始套接字、设置套接字选项和创建并填充相应协议头这三个步骤，然后用send、WSASend函数将组装好的数据发送出去。接收的过程也很相似，只是需要用recv或WSARecv函数接收数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SOCKET sock；</span><br><span class="line">Sock＝<span class="built_in">socket</span> (AF_INET, SOCK_RAW, IPPROTO_UDP)；</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsocketopt</span> <span class="params">(SOCKET s, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">char</span> FAR *optval, <span class="type">int</span> optlen)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TCP</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> tcp_sport；</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> tcp_dport；</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tcp_seq；</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tcp_ack；</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> tcp_lenres；</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> tcp_flag；</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> tcp_win；</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> tcp_sum；</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> tcp_urp；</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>raw socket（原始套接字）工作原理与规则<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/bcbobo21cn/article/details/51330174">https://blog.csdn.net/bcbobo21cn/article/details/51330174</a></p>
<p>raw socket（原始套接字）工作原理与规则<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/bcbobo21cn/article/details/51330174">https://blog.csdn.net/bcbobo21cn/article/details/51330174</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2019/11/27/ComputerNetworking_%E8%AE%A1%E7%BD%91%E5%92%8C%E8%8B%B1%E7%89%B9%E7%BD%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/27/ComputerNetworking_%E8%AE%A1%E7%BD%91%E5%92%8C%E8%8B%B1%E7%89%B9%E7%BD%91/" class="post-title-link" itemprop="url">计网和英特网</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-27 00:07:04" itemprop="dateCreated datePublished" datetime="2019-11-27T00:07:04Z">2019-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文是学习自顶向下计算机网络的学习笔记。内容浅显，或有缺漏，还请多多指点。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/11/27/ComputerNetworking_%E8%AE%A1%E7%BD%91%E5%92%8C%E8%8B%B1%E7%89%B9%E7%BD%91/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rhb</p>
  <div class="site-description" itemprop="description">纵浪大化中，不喜亦不惧</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">155</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RShawshank" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RShawshank" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rhb</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://lib.baomitu.com/canvas-nest.js/1.0.1/canvas-nest.js"></script>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
