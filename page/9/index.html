<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rshawshank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="纵浪大化中，不喜亦不惧">
<meta property="og:type" content="website">
<meta property="og:title" content="rhb_blog">
<meta property="og:url" content="http://rshawshank.github.io/page/9/index.html">
<meta property="og:site_name" content="rhb_blog">
<meta property="og:description" content="纵浪大化中，不喜亦不惧">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rhb">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rshawshank.github.io/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>rhb_blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rhb_blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">rao的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">57</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">23</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">142</span></a>

  </li>
        <li class="menu-item menu-item-photos">

    <a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
        <li class="menu-item menu-item-readnote">

    <a href="/readnote" rel="section"><i class="fa fa-book fa-fw"></i>阅读笔记</a>

  </li>
        <li class="menu-item menu-item-somethink">

    <a href="/somethink/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>随笔闲谈</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/RShawshank" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-I-O%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-I-O%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">计算机系统结构-I/O系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 12:49:40" itemprop="dateCreated datePublished" datetime="2020-04-15T12:49:40Z">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机系统结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="IO系统的基本概念"><a href="#IO系统的基本概念" class="headerlink" title="IO系统的基本概念"></a>IO系统的基本概念</h1><p>通常包含IO设备和IO设备与处理机的连接接口两个主要部分。</p>
<h1 id="系统评价"><a href="#系统评价" class="headerlink" title="系统评价"></a>系统评价</h1><p>参数指标：连接特性、IO系统的容量、响应时间和吞吐率</p>
<p>吞吐率反映单位时间内完成的I&#x2F;O数量，响应时间则反映了完成一次I&#x2F;O所花费的时间</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">计算机系统结构-存储系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 12:49:31" itemprop="dateCreated datePublished" datetime="2020-04-15T12:49:31Z">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机系统结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="存储系统性能量化分析"><a href="#存储系统性能量化分析" class="headerlink" title="存储系统性能量化分析"></a>存储系统性能量化分析</h1><p>存储器越靠近CPU，则CPU对它的访问频度越高，但是容量也越低，单位存储容量价格越高。</p>
<p>存储容量S：一般来说，整个存储系统的容量即是第二级存储器M<del>2</del> ，即S&#x3D;S<del>2</del></p>
<p>命中率H：CPU访问存储系统时，在M<del>1</del> 中找到所需信息的概率$H&#x3D;\frac{N_1}{N_1+N_2}$</p>
<p>平均访问时间T<del>A</del> ：</p>
<ul>
<li><p>当命中时，访问时间即是T<del>1</del> （命中时间）</p>
</li>
<li><p>当没命中时，$T_2+T_1+T_B&#x3D;T_1+T_M\T_m&#x3D;T_2+T_B\传递一个信息块所需的时间为T_B\不命中开销T_M:从向M_2发出访问请求到整个数据块调入M_1中所需的时间$</p>
</li>
</ul>
<h1 id="Cache基本知识"><a href="#Cache基本知识" class="headerlink" title="Cache基本知识"></a>Cache基本知识</h1><p>Cache-利用局部性原理，加快经常性事件原理，将程序和数据放到与CPU速度匹配的高速存储器中。</p>
<p>cache关注的四个问题：</p>
<ul>
<li><p>如何放</p>
<ul>
<li>全相联映象</li>
<li>直接映象</li>
<li>组相联映象</li>
</ul>
</li>
<li><p>如何找</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200416191002374.png" style="zoom:80%;" />
</li>
<li><p>如何写</p>
<ul>
<li>写穿：写cache的同时也在写内存</li>
<li>写回：只写cache，只有被替换时才写回内存</li>
</ul>
</li>
<li><p>如何换</p>
<ul>
<li>轮换法</li>
<li>LRU算法</li>
</ul>
</li>
</ul>
<p>具体见《组原原理》</p>
<h1 id="映象规则及其变换"><a href="#映象规则及其变换" class="headerlink" title="映象规则及其变换"></a>映象规则及其变换</h1><p>见《组成原理》</p>
<h1 id="降低cache不命中率"><a href="#降低cache不命中率" class="headerlink" title="降低cache不命中率"></a>降低cache不命中率</h1><h2 id="三种类型的不命中"><a href="#三种类型的不命中" class="headerlink" title="三种类型的不命中"></a>三种类型的不命中</h2><ul>
<li>强制性不命中：当第一次访问一个块时，该块不在cache中，需从下一级存储器中调入cache。（冷启动不命中，首次访问不命中。）</li>
<li>容量不命中：如果程序执行时所需的块不能全部调入cache中，则当某些块被替换后，若重新被访问，就会发生不命中。</li>
<li>冲突不命中：在组相联或者直接映象cache中，如果太多的块映象到同一组（块）中，则该组中某个块被别的块替换（即使别的组或块有空闲位置），然后又被重新访问的情况。（碰撞不命中，干扰不命中）</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>相联度越高，冲突不命中就越少；</li>
<li>强制性不命中和容量不命中不受相联度的影响</li>
<li>强制性不命中不受cache容量的影响，但是容量不命中却随着容量的增加而减少</li>
</ol>
<h2 id="减少三种不命中的方法"><a href="#减少三种不命中的方法" class="headerlink" title="减少三种不命中的方法"></a>减少三种不命中的方法</h2><ul>
<li>强制性不命中：增加块大小，预取</li>
<li>容量不命中：增加容量</li>
<li>冲突不命中：提高相关度</li>
</ul>
<p><strong>许多降低不命中率的方法会增加命中时间或不命中开销</strong></p>
<h3 id="增加cache块的大小"><a href="#增加cache块的大小" class="headerlink" title="增加cache块的大小"></a>增加cache块的大小</h3><p>对于给定的cache容量，当块大小增加时，不命中率开始是下降的，但是后来就上升了。</p>
<ul>
<li>一方面它减少了强制性不命中；</li>
<li>另一方面，由于增加块大小会减少Cache中块的数目，可能会增加冲突不命中</li>
</ul>
<p><strong>增加块的大小会增加不命中开销</strong></p>
<h3 id="增加cache的容量"><a href="#增加cache的容量" class="headerlink" title="增加cache的容量"></a>增加cache的容量</h3><p>缺点：</p>
<ul>
<li>增加成本</li>
<li>增加命中时间</li>
</ul>
<h3 id="提高相联度"><a href="#提高相联度" class="headerlink" title="提高相联度"></a>提高相联度</h3><p>采取相联度超过8的方案实际意义不大</p>
<p><strong>容量为N的直接映象cache的不命中率和容量为N&#x2F;2的两路组相联cache的不命率差不多相同</strong></p>
<p>提高相联度是以增加命中时间为代价的</p>
<h2 id="伪相联cache和列相联cache"><a href="#伪相联cache和列相联cache" class="headerlink" title="伪相联cache和列相联cache"></a>伪相联cache和列相联cache</h2><p>基本思想：在逻辑上把直接映象cache分为上下两个区。对于任何一次访问，伪相联cache先按直接映象cache的方式去处理：如果命中，则其访问过程和直接映象cache的情况一样；如果不命中，则再对另一区相应的位置去查找。如果找到了，则发生了伪命中，否则只好访问下一级存储器。</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200417152901445.png" style="zoom:50%;" />

<h2 id="硬件预取"><a href="#硬件预取" class="headerlink" title="硬件预取"></a>硬件预取</h2><ol>
<li>指令和数据都可以预取</li>
<li>预取内容即可放入cache中，也可放在外缓冲器中</li>
<li>指令预取通常由cache之外的硬件完成</li>
</ol>
<p>预取应利用存储器的空闲带宽，不能影响对正常不命中的处理，否则会降低性能。</p>
<h2 id="编译器控制的预取"><a href="#编译器控制的预取" class="headerlink" title="编译器控制的预取"></a>编译器控制的预取</h2><p>在编译的时候加入预取指令，在数据被用到之前发出预取请求。</p>
<ol>
<li>按照预取数据所放的位置，可把预取分为两种类型：<ul>
<li>寄存器预取：把数据放在寄存器中</li>
<li>cache预取：只将数据放在cache中</li>
</ul>
</li>
<li>按照预取的处理方式不同，分为：<ul>
<li>故障性预取：在预取时，如果出现虚地址故障或违反保护权限，就会发生异常</li>
<li>非故障性预取：不会发生异常，编译器会放弃预取，转为空操作</li>
</ul>
</li>
<li>在预取数据的同时，处理器应能继续执行</li>
<li>编译器控制预取的目的：使得执行指令和读取数据能重叠执行</li>
<li>每次预取需要花费一条指令的开销<ul>
<li>保证开销低于收益</li>
<li>编译器可以通过把重点放在那些可能会导致不命中的访问上，使得程序避免不必要的预取</li>
</ul>
</li>
</ol>
<h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><p>通过对软件进行优化来降低不命中率</p>
<ol>
<li>程序代码和数据重组<ul>
<li>重新组织程序而不影响程序的正确性<ul>
<li>把一个程序的过程重新排序，减少冲突不命中，降低指令不命中率</li>
<li>把基本块对齐，提高大cache块的效率</li>
</ul>
</li>
<li>假设编译器知道分支指令会成功转移：<ul>
<li>将转移目标处的基本块和紧跟着该分支指令后的基本块进行对调</li>
<li>把该分支指令转为操作语义相反的分支指令（？）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="牺牲cache"><a href="#牺牲cache" class="headerlink" title="牺牲cache"></a>牺牲cache</h2><p>在cache和它的下一级存储器之间设置一个全相联的小cache；用来存放被替换出去的块（牺牲者），以备重新使用</p>
<p>对于减小冲突不命中很有效，特别是对于小容量的直接映象数据cache，作用尤其明显。</p>
<h2 id="采取两级cache"><a href="#采取两级cache" class="headerlink" title="采取两级cache"></a>采取两级cache</h2><p>第一级cache小且快；第二级cache容量大。</p>
<p>全部不命中率和局部不命中率：$全局不命中率&#x3D;不命中率_{L1} X 不命中率_{L2}$</p>
<ul>
<li><p>评价第二级Cache需要使用全局不命中率；</p>
</li>
<li><p>第二级cache不会影响CPU的时钟频率；</p>
</li>
</ul>
<p>$平均访存时间&#x3D;命中时间L_1+不命中率L_1X()$</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ol>
<li>容量：第二级cache的容量一般比第一级cache的大很多</li>
<li>相联度：第二级cache可以采用较高的相联度或伪相联方法</li>
<li>块大小：第二级cache可以采用较大的块</li>
</ol>
<h2 id="让读不命中优先于写"><a href="#让读不命中优先于写" class="headerlink" title="让读不命中优先于写"></a>让读不命中优先于写</h2><ol>
<li>cache中的写缓冲器导致对存储器访问的复杂化：在读不命中时，所读单元的最新值可能还在写缓冲器中，还没有进入主存。</li>
<li>读不命中的处理：<ul>
<li>推迟对读不命中的处理，直到写缓冲器清空</li>
<li>检查写缓冲器的内容</li>
</ul>
</li>
<li>在写回法cache中，可采取写缓冲器</li>
</ol>
<h2 id="写缓冲合并"><a href="#写缓冲合并" class="headerlink" title="写缓冲合并"></a>写缓冲合并</h2><p>写直达cache：</p>
<p>依靠写缓冲来减少对下一级存储器写操作的时间。</p>
<p>如果写缓冲器为空，就把数据和相应地址写入该缓冲器【从CPU的角度来看，该写操作就算完成了】</p>
<p>如果写缓冲器中已经有了待写入数据，就要把这次写入地址与写缓冲器中已有的所有地址进行比较，看看是否有匹配的项。如果有地址匹配而对应的位置又空闲，就把这次要写入的数据与该项合并。【这就是写缓冲合并】</p>
<p>如果写缓冲器满并且没有能进行写合并的项，就等待。</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200417163741394.png" style="zoom:67%;" />

<h2 id="请求字处理技术"><a href="#请求字处理技术" class="headerlink" title="请求字处理技术"></a>请求字处理技术</h2><p>请求字：从下一级存储器调入cache块中，只有一个字是立即需要的，该字就是请求字。</p>
<p>应尽早把请求字发送给CPU</p>
<ul>
<li>尽早重启动：调块时，从块的起始位置开始读起。一旦请求字到达了，就立即发送给CPU，让CPU继续执行。【请求字优先】</li>
</ul>
<h2 id="非阻塞cache技术"><a href="#非阻塞cache技术" class="headerlink" title="非阻塞cache技术"></a>非阻塞cache技术</h2><p>cache不命中时依旧允许CPU进行其他的命中访问。</p>
<h1 id="减少命中时间"><a href="#减少命中时间" class="headerlink" title="减少命中时间"></a>减少命中时间</h1><p>命中时间直接影响处理器的时钟频率。</p>
<p>Cache的访问时间限制了处理器的时钟频率。</p>
<h2 id="容量小、结构简单的Cache"><a href="#容量小、结构简单的Cache" class="headerlink" title="容量小、结构简单的Cache"></a>容量小、结构简单的Cache</h2><p>硬件越简单，速度就越快。</p>
<h2 id="虚拟cache"><a href="#虚拟cache" class="headerlink" title="虚拟cache"></a>虚拟cache</h2><h3 id="物理cache"><a href="#物理cache" class="headerlink" title="物理cache"></a>物理cache</h3><p>使用物理地址进行访问的传统cache。</p>
<p>标识存储器中存放的是物理地址，进行地址检测越是用物理地址。</p>
<p>缺点就是：地址转换和访问cache串行进行，访问速度慢。</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200417185513804.png" style="zoom:67%;" />

<h3 id="虚拟cache-1"><a href="#虚拟cache-1" class="headerlink" title="虚拟cache"></a>虚拟cache</h3><p>直接使用虚拟地址进行访问的cache。标识存储器存放的是虚拟地址，进行地址检测用的也是虚拟地址</p>
<p>优点：在命中时不需要进行地址转换，省去了地址转换的时间。就算是不命中，地址转换和访问cache也是并行进行的，速度比物理cache快。</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200417185536512.png" style="zoom:50%;" />

<p>虚拟地址和进程相关。</p>
<p>虚拟地址&#x3D;虚拟索引+物理标识<br>用虚地址中页内位移作为cache的索引，标识用物理地址；</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200417190140461.png" style="zoom:67%;" />

<h2 id="Cache访问流水化"><a href="#Cache访问流水化" class="headerlink" title="Cache访问流水化"></a>Cache访问流水化</h2><p>对第一级cache访问按流水线方式组织</p>
<p>访问cache需要多个时钟周期才能完成</p>
<p>不能够真正减少cache命中时间，但是可以提高时钟频率，提高cache的带宽。</p>
<h2 id="踪迹Cache"><a href="#踪迹Cache" class="headerlink" title="踪迹Cache"></a>踪迹Cache</h2><p>存放CPU所执行的动态指令序列：包含了由分支预测展开的指令，该分支预测是否需要在取到该指令时进行确认。</p>
<ul>
<li>地址映象机制复杂</li>
<li>相同的指令序列有可能被当作条件分支的不同选择而重复存放</li>
<li>能够提高指令cache的空间利用率</li>
</ul>
<h1 id="并行主存系统"><a href="#并行主存系统" class="headerlink" title="并行主存系统"></a>并行主存系统</h1><p>主存的主要性能指标：<strong>延迟</strong>和<strong>带宽</strong></p>
<p>定义：是在一个访存周期内能并行访问多个存储字的存储器</p>
<p>在单体单字宽的存储器中：存储器的访问周期为T<del>M</del> ,字长为W位，则<br>带宽为$B_M&#x3D;\frac{W}{T_M}$</p>
<h2 id="单体多字存储器"><a href="#单体多字存储器" class="headerlink" title="单体多字存储器"></a>单体多字存储器</h2><p>存储器能够每个存储周期读出m个CPU字</p>
<p>$B_M&#x3D;\frac{mW}{T_M}$</p>
<p>单体多字存储器的实际带宽比最大带宽小</p>
<p>缺点：访存效率不高</p>
<ul>
<li>如果一次去读的m个指令字中有分支指令，而且分支成功，则该分支指令之后的指令是无用的。</li>
<li>一次取出的m个数据不一定都是有用的。此外，当前执行指令所需要的多个操作数也不一定正好都存放在同一个长存储字中</li>
<li>写入可能变得复杂</li>
<li>当要读出的数据字和要写入的数据字处于同一个长存储字内时，读和写的操作就无法在同一个存储周期内完成</li>
</ul>
<h2 id="多体交叉存储器"><a href="#多体交叉存储器" class="headerlink" title="多体交叉存储器"></a>多体交叉存储器</h2><p>由多个单字存储体构成，每个体都有自己的地址寄存器以及地址译码和读&#x2F;写驱动等电路。</p>
<p>编址方式：</p>
<ul>
<li>高位交叉编址</li>
<li>低位交叉编址</li>
</ul>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200417195600835.png" style="zoom:67%;" />

<h3 id="高位交叉编址"><a href="#高位交叉编址" class="headerlink" title="高位交叉编址"></a>高位交叉编址</h3><p>对存储单元矩阵按列优先的方式进行编址</p>
<h3 id="低位交叉编址"><a href="#低位交叉编址" class="headerlink" title="低位交叉编址"></a>低位交叉编址</h3><p>对存储单元矩阵按行优先进行编址</p>
<h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><blockquote>
<p>进程保护：</p>
<ol>
<li>界地址寄存器：基地址、上界地址；检测条件：（基地址+地址）&lt;&#x3D;上界地址</li>
<li>虚拟存储器：给每个页面增加访问权限标识</li>
<li>环形保护</li>
<li>加锁和解锁</li>
</ol>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C/" class="post-title-link" itemprop="url">计算机系统结构-指令级并行</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 12:49:03" itemprop="dateCreated datePublished" datetime="2020-04-15T12:49:03Z">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机系统结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="指令级并行的概念"><a href="#指令级并行的概念" class="headerlink" title="指令级并行的概念"></a>指令级并行的概念</h1><p>提高处理速度：</p>
<ul>
<li>提高主频【高到一定程序，发热能耗都会升高】</li>
<li>并行工作：多个部件同时工作</li>
</ul>
<p>理想流水线的CPI加上各类停顿的时钟周期数：<br>$$<br>CPI_{流水线}&#x3D;CPI_{理想}+停顿_{结构冲突}+停顿_{数据冲突}+停顿_{控制冲突}<br>$$</p>
<h2 id="需要解决的具体问题"><a href="#需要解决的具体问题" class="headerlink" title="需要解决的具体问题"></a>需要解决的具体问题</h2><p><strong>相关和流水线冲突</strong>：</p>
<p>相关是程序固有的一种属性，它反映了程序中指令之间的相互依赖关系。相关是引起冲突的主要原因（并非唯一？结构冲突无对应相关）。因此消除相关是减少冲突停顿的一种有效方法。</p>
<p><strong>相关是引发冲突的主要原因，其中数据相关与名相关可能导致数据冲突，而控制相关可能导致控制冲突。</strong></p>
<h3 id="相关的两类解决方案"><a href="#相关的两类解决方案" class="headerlink" title="相关的两类解决方案"></a>相关的两类解决方案</h3><ul>
<li><p>保持相关，但避免发生冲突</p>
<ul>
<li>指令调度</li>
</ul>
</li>
<li><p>通过代码变换，消除相关</p>
<ul>
<li>寄存器重命名</li>
</ul>
</li>
</ul>
<h1 id="指令调度分类"><a href="#指令调度分类" class="headerlink" title="指令调度分类"></a>指令调度分类</h1><ul>
<li><p>静态调度</p>
<ul>
<li>依靠编译器对代码进行静态调度，以减少相关和冲突。</li>
<li>它不是在程序执行的过程中、而是在编译期间进行代码调度和优化。</li>
<li>通过把相关的指令拉开距离来减少可能产生的停顿。</li>
</ul>
</li>
<li><p>动态调度</p>
<ul>
<li>在程序的执行过程中，依靠专门硬件对代码进行调度，减少数据相关导致的停顿。</li>
<li>优点：<ul>
<li>能够处理一些在编译时情况不明的相关（比如涉及到存储器访问的相关），并简化了编译器；</li>
<li>能够使本来是面向某一流水线优化编译的代码在其它的流水线（动态调度）上也能高效地执行。</li>
<li>以硬件复杂性的显著增加为代价</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="经典（顺序）流水线的局限性"><a href="#经典（顺序）流水线的局限性" class="headerlink" title="经典（顺序）流水线的局限性"></a>经典（顺序）流水线的局限性</h2><p>由于指令是按序流出和按序执行的。</p>
<p>例如：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">DIV.D</span>	<span class="built_in">F4</span>，<span class="built_in">F0</span>，<span class="built_in">F2</span></span><br><span class="line"><span class="symbol">ADD.D</span>	F10，<span class="built_in">F4</span>，<span class="built_in">F6</span> </span><br><span class="line"><span class="symbol">SUB.D</span>	F12，<span class="built_in">F6</span>，F14</span><br></pre></td></tr></table></figure>

<p>假设DIV（除法）指令执行时间（EX）是10个时钟周期，ADD（加法）与SUB（减法）分别为1个，（由于除法与加法之间的数据相关）那么ADD必须等待9个时钟周期才能进入EX阶段。在我们学过的顺序流水线中，由于ID部件被ADD指令占据，SUB指令只有在ADD指令流入EX（执行）阶段后才能进入ID阶段，即其也需要等待9个时钟周期。然而，如果这些指令不用按顺序执行，则SUB（减法）无需等待。</p>
<p>SUB指令需要等待的原因：在ID阶段会检测结构冲突与数据冲突，当发现冲突后，导致冲突的指令中较晚进入流水线的那条（ADD指令），将冻结在流水寄存器中，不在向前流动。由于流水寄存器只能存放一条指令，一旦这条指令受阻，其后的指令（SUB指令）都将停顿。</p>
<p>解决方法：<strong>允许指令乱序执行</strong></p>
<h3 id="指令乱序执行"><a href="#指令乱序执行" class="headerlink" title="指令乱序执行"></a>指令乱序执行</h3><p>将ID段分为两个阶段：流出（IS）和读操作数(RO)。IS阶段执行指令译码，检查是否存在结构冲突；RO阶段等待数据冲突消失，再进行读操作数的操作。</p>
<p>两个方法：</p>
<ul>
<li>引入指令缓冲区：不能流出的指令就在缓冲区里排队等待，直到冲突消除</li>
<li>部署更多的执行部件（这里的执行部件是广义的执行，包括：运算器、访存设备等），使得多条指令能都同时执行或访存</li>
</ul>
<h3 id="乱序执行的问题"><a href="#乱序执行的问题" class="headerlink" title="乱序执行的问题"></a>乱序执行的问题</h3><h4 id="WAR冲突和WAW冲突"><a href="#WAR冲突和WAW冲突" class="headerlink" title="WAR冲突和WAW冲突"></a>WAR冲突和WAW冲突</h4><p>乱序执行可能会导致WAR冲突和WAW冲突。</p>
<p>可以使用寄存器重命名来消除冲突。值得注意的是，寄存器的数量是有限的，更多的寄存器会导致编译器变慢。</p>
<h4 id="多条指令同时处于执行或访存中"><a href="#多条指令同时处于执行或访存中" class="headerlink" title="多条指令同时处于执行或访存中"></a>多条指令同时处于执行或访存中</h4><p>乱序执行将使得多条指令处于执行当中，因此要求，具有<strong>多个功能部件</strong>、或者功能部件流水化、或者兼而有之。</p>
<h4 id="复杂的异常处理"><a href="#复杂的异常处理" class="headerlink" title="复杂的异常处理"></a>复杂的异常处理</h4><p>乱序指令引入的最大问题在于，异常处理比较复杂。异常可以分为精确异常与不精确异常。</p>
<ul>
<li><p>精确异常：如果发生异常时，处理机的现场跟严格按程序顺序执行时指令i的现场相同。</p>
</li>
<li><p>不精确异常：当执行指令i导致发生异常时，处理机的现场（状态）与严格按程序顺序执行时指令i的现场不同。</p>
<ul>
<li><p>发生不精确异常的原因：因为当发生异常（设为指令i）时</p>
<ul>
<li>流水线可能已经执行完按程序顺序是位于指令i之后的指令；</li>
<li>流水线可能还没完成按程序顺序是指令i之前的指令。</li>
</ul>
</li>
<li><p>不精确异常使得在异常处理后难以接着继续执行程序。</p>
</li>
</ul>
</li>
</ul>
<p>显然，动态调度的处理机要保持正确的异常行为。具体而言，对于一条会产生异常的指令来说，只有当处理机确切地知道该指令将被执行时，才允许它产生异常。举个例子，指令i，j顺序流入流水线。j位于条件语句中（选择执行），会引起异常但不会被执行。j被调度到i之前执行，执行过程中发生了异常（实际不会被执行，所以也不会引起异常）。这样是不允许的。</p>
<p>然而，即使保持了正确的异常行为，动态调度处理机仍可能发生不精确异常。 举个例子：指令i，j顺序流入流水线，指令i会导致异常，但其被调度到j之后执行，假设j执行完后直接改变了上下文，那么i产生异常时，上下文与顺序执行的上下文已经不同了。</p>
<h1 id="动态分支预测"><a href="#动态分支预测" class="headerlink" title="动态分支预测"></a>动态分支预测</h1><p>ILP（指令级并行）越多，控制相关的制约就越大，分支预测就要有更高的准确度。解决方法就是：动态分支预测。</p>
<h2 id="动态分支预测-1"><a href="#动态分支预测-1" class="headerlink" title="动态分支预测"></a>动态分支预测</h2><ul>
<li>在程序运行时，根据分支指令过去的表现来预测其将来的行为。</li>
<li>如果分支行为发生了变化，预测结果也跟着改变。</li>
<li>有更好的预测准确度和适应性。</li>
</ul>
<p>分支预测的有效性取决于</p>
<ul>
<li>预测的准确性</li>
<li>预测正确和不正确两种情况下的分支开销</li>
<li>决定分支开销的因素：<ul>
<li>流水线的结构</li>
<li>预测的方法</li>
<li>预测错误时的恢复策略等</li>
</ul>
</li>
</ul>
<h2 id="目标与关键问题"><a href="#目标与关键问题" class="headerlink" title="目标与关键问题"></a>目标与关键问题</h2><ul>
<li><p>采用动态分支预测技术的目标【只有尽快做到下面两点，才能避免控制相关造成流水线停顿】</p>
<ul>
<li>预测分支是否成功</li>
<li>尽快找到分支目标地址（或指令）（避免控制相关造成流水线停顿）</li>
</ul>
</li>
<li><p>需要解决的关键问题</p>
<ul>
<li>如何记录分支的历史信息，要记录哪些信息？ </li>
<li>如何根据这些信息来预测分支的去向，甚至提前取出分支目标处的指令</li>
</ul>
</li>
</ul>
<h2 id="预测错误时的处理方法"><a href="#预测错误时的处理方法" class="headerlink" title="预测错误时的处理方法"></a>预测错误时的处理方法</h2><p>在预测错误时，要作废已经预取和分析的指令，恢复现场，并从另一条分支路径重新取指令。</p>
<h2 id="分支历史表BHT"><a href="#分支历史表BHT" class="headerlink" title="分支历史表BHT"></a>分支历史表BHT</h2><p>基本思想是使用一张表（BHT）来记录分支指令最近一次或几次的执行情况（成功还是失败），并据此进行预测。</p>
<h3 id="最简单的分支历史表"><a href="#最简单的分支历史表" class="headerlink" title="最简单的分支历史表"></a>最简单的分支历史表</h3><p>只有1个预测位的分支预测表</p>
<p>仅记录分支指令最近一次的历史，只需要1位二进制位。其规则也很简单，一句话，上次是分支成功就认为下次分支成功，上次失败就认为下次失败。</p>
<h3 id="两位预测位的分支历史表"><a href="#两位预测位的分支历史表" class="headerlink" title="两位预测位的分支历史表"></a>两位预测位的分支历史表</h3><p>两个位记录分支最近两次的执行情况（成功1或失败0）</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C/image-20200416150630044.png"></p>
<p>研究结果表明：两位分支预测的性能与n位（n&gt;2）分支预测的性能差不多。</p>
<h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h4><ul>
<li><p>分支预测</p>
<ul>
<li>当分支指令到达译码段（ID）时，根据从BHT读出的信息进行分支预测 。</li>
<li>若预测正确，就继续处理后续的指令，流水线没有断流。否则，就要作废已经预取和分析的指令，恢复现场，并从另一条分支路径重新取指令。</li>
</ul>
</li>
<li><p>状态修改。【根据状态变迁图修改状态】</p>
</li>
</ul>
<h3 id="BHT的作用范围"><a href="#BHT的作用范围" class="headerlink" title="BHT的作用范围"></a>BHT的作用范围</h3><p>关键在于比较判定分支是否成功所需的时间和确定分支目标地址所需的时间哪个更大。</p>
<p>【在5段经典流水线中，判断分支是否成功和计算分支目标地址都是在ID段完成的，故BHT方法不会给该流水线带去什么好处。】</p>
<p>BHT技术只管了预测部份，没管预测后的处理部分。</p>
<h3 id="BHT的实现"><a href="#BHT的实现" class="headerlink" title="BHT的实现"></a>BHT的实现</h3><p>BHT可以跟分支指令一起存放在指令Cache中，也可以用一块专门的硬件来实现。 </p>
<h2 id="分支目标缓冲器BTB"><a href="#分支目标缓冲器BTB" class="headerlink" title="分支目标缓冲器BTB"></a>分支目标缓冲器BTB</h2><p>BTB的目标是将分支的开销降为 0。具体方法是分支目标缓冲，即，将分支成功的分支指令的地址和它的分支目标地址都放到一个缓冲区中保存起来，缓冲区以分支指令的地址作为标识。</p>
<p>BTB可以看成是用专门的硬件实现的一张表格。表格中的<strong>每一项至少有两个字段。一是，执行过的成功分支指令的地址，用作该表的匹配标识。二是预测的分支目标地址。</strong>只有这两项的就是最简单的BTB。</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C/image-20200416160452576.png"></p>
<p>注：在预测失败的情况下，会承受2个周期的延迟。</p>
<p>与BHT相比，BTB的优点在于IF周期就能找到分支地址，能够将分支成功且预测准确时的分支开销降到0。</p>
<h3 id="改进BTB"><a href="#改进BTB" class="headerlink" title="改进BTB"></a>改进BTB</h3><p>1、在分支目标缓冲器中增设一个至少是两位的“分支历史表”字段 </p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C/image-20200416160749450.png" style="zoom:67%;" />

<p>2、在表中对于每条分支指令都存放若干条分支目标处的指令，就形成了分支目标指令缓冲器。</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C/image-20200416160711828.png" style="zoom:67%;" />

<p>这里，BTB中不在保存分支目标地址，而是保存分支目标指令。</p>
<p>为什么存指令，而非指令地址呢？因为IF是通过指令地址取指令，分支成功，程序的空间局部性spatial locality被破坏，取指令的时延很可能会增加</p>
<h1 id="多指令流出技术"><a href="#多指令流出技术" class="headerlink" title="多指令流出技术"></a>多指令流出技术</h1><p>多指令流出技术通过降低理想CPI，以改善实际CPI。</p>
<h2 id="多流出处理机的两种基本风格"><a href="#多流出处理机的两种基本风格" class="headerlink" title="多流出处理机的两种基本风格"></a>多流出处理机的两种基本风格</h2><h3 id="超标量"><a href="#超标量" class="headerlink" title="超标量"></a>超标量</h3><ul>
<li>在每个时钟周期流出的指令条数不固定，依代码的具体情况而定。（有个上限）</li>
<li>设这个上限为n，就称该处理机为n-流出。</li>
<li>可以通过编译器进行静态调度，也可以基于Tomasulo算法进行动态调度。</li>
</ul>
<p>超标量结构对程序员是透明的，处理机能自己检测下一条指令能否流出，不需要由编译器或专门的变换程序对程序中的指令进行重新排列</p>
<p>即使是没有经过编译器针对超标量结构进行调度优化的代码或是旧的编译器生成的代码也可以运行，当然运行的效果不会很好【若要想达到很好的效果，方法之一是：使用动态超标量调度技术。】</p>
<h3 id="超长指令字VLIW"><a href="#超长指令字VLIW" class="headerlink" title="超长指令字VLIW"></a>超长指令字VLIW</h3><ul>
<li>在每个时钟周期流出的指令条数是固定的，这些指令构成一条长指令或者一个指令包。</li>
<li>指令包中，指令之间的并行性是通过指令显式地表示出来的。</li>
<li>指令调度是由编译器静态完成的。</li>
</ul>
<h2 id="基于静态调度的超标量流水线技术"><a href="#基于静态调度的超标量流水线技术" class="headerlink" title="基于静态调度的超标量流水线技术"></a>基于静态调度的超标量流水线技术</h2><p>指令按序流出，在流出时进行冲突检测。由硬件检测当前流出的指令之间是否存在冲突以及当前流出的指令与正在执行的指令是否有冲突。</p>
<h2 id="超长指令字技术"><a href="#超长指令字技术" class="headerlink" title="超长指令字技术"></a>超长指令字技术</h2><p>超长指令字技术把能并行执行的多条指令组装成一条很长的指令，成为一个指令字。这条指令通常为100多位到几百位。为了支持多条指令的同时执行，需要设置多个功能部件。指令字被分割成一些字段，每个字段称为一个操作槽，直接独立地控制一个功能部件。在超长指令字处理机中，<strong>在指令流出时不需要进行复杂的冲突检测，而是依靠编译器全部安排好了。</strong></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p>程序代码长度增加了。原因在于，为提高并行性而进行的大量的循环展开；此外，指令字中的操作槽也并非总能填满。 对于这个问题，可以通过采用指令共享立即数字段的方法，或者采用指令压缩存储、调入Cache或译码时展开的方法予以解决。</p>
</li>
<li><p>采用了锁步机制。任何一个操作部件出现停顿时，整个处理机都要停顿。</p>
</li>
<li><p>机器代码的不兼容性，一旦体系结构发生了变化，代码就必须重新编译。</p>
</li>
</ul>
<h2 id="超流水线处理机"><a href="#超流水线处理机" class="headerlink" title="超流水线处理机"></a>超流水线处理机</h2><p>超流水线处理机的基本概念：将每个流水段进一步细分，这样在一个时钟周期内能够分时流出多条指令。这种处理机称为超流水线处理机。</p>
<p>对于一台每个时钟周期能流出n条指令的超流水线计算机来说，这n条指令不是同时流出的，而是每隔1&#x2F;n个时钟周期流出一条指令。实际上该超流水线计算机的流水线周期为1&#x2F;n个时钟周期。</p>
<h1 id="指令调度和循环展开"><a href="#指令调度和循环展开" class="headerlink" title="指令调度和循环展开"></a>指令调度和循环展开</h1><h2 id="指令调度的基本方法"><a href="#指令调度的基本方法" class="headerlink" title="指令调度的基本方法"></a>指令调度的基本方法</h2><p>指令调度一般由编译器完成。通过找出不相关的指令序列，让它们在流水线上重叠并行执行。</p>
<p>编译器做指令调度时，通常会收两个方面的制约。一是程序固有的指令级并行，二是流水线功能部件的延迟。</p>
<h2 id="循环展开的基本概念和方法"><a href="#循环展开的基本概念和方法" class="headerlink" title="循环展开的基本概念和方法"></a>循环展开的基本概念和方法</h2><p>循环展开是把循环体的代码复制多次并按顺序排放， 然后相应调整循环的结束条件。它是开发循环级并行的有效方法。</p>
<h2 id="循环展开和指令调度的注意事项"><a href="#循环展开和指令调度的注意事项" class="headerlink" title="循环展开和指令调度的注意事项"></a>循环展开和指令调度的注意事项</h2><p>（1）保证正确性</p>
<p>（2）注意有效性</p>
<p>（3）使用不同的寄存器</p>
<p>（4）删除多余的测试指令和分支指令，并对循环结束代码和新的循环体代码进行相应的修正。</p>
<p>（5）注意对存储器数据的相关性分析</p>
<p>（6）注意新的相关性</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">计算机系统结构-流水线技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 12:48:37" itemprop="dateCreated datePublished" datetime="2020-04-15T12:48:37Z">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机系统结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="流水线的基本概念"><a href="#流水线的基本概念" class="headerlink" title="流水线的基本概念"></a>流水线的基本概念</h1><ul>
<li>流水线的段（级）：流水线中的<strong>每个子过程及其功能部件</strong>称为流水线的级或段，段与段相互连接形成流水线</li>
<li>流水线的瓶颈：执行时间最长的段</li>
<li>流水线的深度：流水线的段数称为流水线的深度</li>
<li>流水线的通过时间：第一个任务从进入流水线到流出结果所需的时间。</li>
<li>排空时间：最后一个任务从进入流水线到流出结果所需的时间。</li>
</ul>
<p><strong>流水线不适用的场景：</strong></p>
<ul>
<li><p>只有一个任务需要执行。【任务并没有在更短的时间内完成，反而有可能会使得单个任务的执行时间变长】</p>
</li>
<li><p>多个稀疏任务（来的不够密集）。【使用流水线并不能提升工作效率（执行这些任务的有效时间并没有缩短）】</p>
</li>
<li><p>多个不同任务。【多个密集任务，但各任务的子过程完全无重合（不能使用同一部件处理）】</p>
<blockquote>
<p>但是可以通过其它并行技术加速（增加更多的不同部件，使得不同任务的不同子过程能并行执行）</p>
</blockquote>
</li>
</ul>
<p><strong>流水线适用的场景：</strong></p>
<ul>
<li>多个密集且相同或类似的任务。【流水技术适合于大量重复的时序过程，只有在输入端不断地提供任务，才能充分发挥流水线的效率。】</li>
</ul>
<h2 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h2><p>按用于计算机系统的等级划分，流水线可分为：部件级、处理机级及处理机间流水线</p>
<ul>
<li><p>部件级流水线（运算操作流水线）</p>
<blockquote>
<p>把处理机中的<strong>部件分段</strong>，再把这些分段相互连接起来，使得各种类型的运算操作能够按流水方式进行。</p>
<p>eg：浮点加法流水线，包含4个段：求阶差，对阶，尾数相加，规格化</p>
</blockquote>
</li>
<li><p>处理机流水线（指令流水线）</p>
<blockquote>
<p>把指令的执行过程按照流水方式处理。把一条指令的执行过程分解为若干个子过程，每个子过程在独立的功能部件中执行。</p>
<p> eg：经典5段MIPS指令流水线，包含5个段：取址，译码，执行，访存，写回。</p>
</blockquote>
</li>
<li><p>处理机间流水线（宏流水线）</p>
<blockquote>
<p>把多台处理机串行连接起来，对同一数据流进行处理，每个处理机完成整个任务中的一部分。</p>
<p>eg：map reduce</p>
</blockquote>
</li>
</ul>
<p>按流水线所完成的功能可划分为：单功能流水线与多功能流水线</p>
<ul>
<li>单功能流水线：只能完成一种固定功能的流水线</li>
<li>多功能流水线：流水线的各段可以进行不同的连接，以实现不同的功能【某些段可以不执行，直接跳过】。<ul>
<li>静态流水线：在同一时间内，多功能流水线中的各段只能按同一种功能的连接方式工作。</li>
<li>动态流水线：在同一时间内，多功能流水线中的各段可以按照不同的方式连接，同时执行多种功能</li>
</ul>
</li>
</ul>
<p>按流水线中是否有反馈回路，流水线技术可分为线性流水线与非线性流水线</p>
<ul>
<li>线性流水线：若流水线的各段串行连接，没有反馈回路，则其为线性流水线。再线性流水线中，数据通过流水线中的各段时，每一个段最多只流过一次。</li>
<li>非线性流水线：若流水线中除了有串行的连接外，还有反馈回路，则其为非线性流水线。</li>
</ul>
<p>按任务流入和流出的顺序是否相同划分：顺序流水线与乱序流水线</p>
<ul>
<li><p>顺序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序完全相同。每一个任务在流水线的各段中是一个跟着一个顺序流动的。</p>
</li>
<li><p>乱序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序可以不同，允许后进入流水线的任务先完成（从输出端流出）。</p>
</li>
</ul>
<h1 id="流水线的性能指标"><a href="#流水线的性能指标" class="headerlink" title="流水线的性能指标"></a>流水线的性能指标</h1><h2 id="吞吐率TP"><a href="#吞吐率TP" class="headerlink" title="吞吐率TP"></a>吞吐率TP</h2><p>吞吐率通常使用缩写TP表示，是指在单位时间内流水线所完成的任务数量或输出结果的数量。<br>$$<br>TP&#x3D;\frac{n}{T_k}\<br>n:任务数\<br>T_k:处理完成n个任务所用的时间<br>$$</p>
<blockquote>
<p>CPU的吞吐率是指CPU每秒执行的指令数。</p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>假设各段时间均等：</p>
<p>（k段线性）流水线完成n个连续任务所需要的总时间<br>$$<br>T_k&#x3D;(k+n-1)\Delta t\<br>k\Delta t:流水线通过时间\<br>(n-1)\Delta t:流水线排出时间\<br>实际吞吐率：TP&#x3D;\frac{n}{(k+n-1)\Delta t}\<br>最大吞吐率：TP_{max}&#x3D;\lim_{n\to\infty}{\frac{n}{(k+n-1)\Delta t}}&#x3D;\frac{1}{\Delta t}\<br>当n趋近于无穷大时，流水线吞吐率趋近于最大值（又称流水线的最大吞吐率）\<br>TP&#x3D;\frac{n}{(k+n-1)}TP_{max}<br>$$<br>假设各段时间不全相等：</p>
<p>（k段线性）流水线完成n个连续任务所需要的总时间<br>$$<br>T_k&#x3D;\sum\Delta t_i+(n-1)max(\Delta t_i)\quad (i&#x3D;1,2,3···k)\<br>\sum\Delta t_i:单个任务的执行时间(通过时间)\<br>(n-1)max(\Delta t_i):n-1个瓶颈段的执行时间\<br>实际吞吐率：TP&#x3D;\frac{n}{\sum\Delta t_i+(n-1)max(\Delta t_1,\Delta t_2,···\Delta t_k)}\<br>最大吞吐率：TP_{max}&#x3D;\frac{1}{(n-1)max(\Delta t_1,\Delta t_2,···\Delta t_k)}\<br>$$</p>
<h2 id="流水线瓶颈问题"><a href="#流水线瓶颈问题" class="headerlink" title="流水线瓶颈问题"></a>流水线瓶颈问题</h2><blockquote>
<p>流水线中执行时间最长的段称为流水线的瓶颈段</p>
</blockquote>
<p>瓶颈段使得流水线性能下降</p>
<p>解决流水线瓶颈的方法</p>
<ul>
<li>细分瓶颈段（细分流水线）</li>
<li>重复设置瓶颈段</li>
</ul>
<h3 id="细分瓶颈段"><a href="#细分瓶颈段" class="headerlink" title="细分瓶颈段"></a>细分瓶颈段</h3><p>就是降低：$(n-1)max(\Delta t_i)$的值。将数值大的$\Delta t_i$值进行细分，差分成数值更小的$\Delta t_i$</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20200415174416181.png"></p>
<h3 id="重复设置瓶颈段"><a href="#重复设置瓶颈段" class="headerlink" title="重复设置瓶颈段"></a>重复设置瓶颈段</h3><p>就是在采取同时多次进行瓶颈段的操作来降低$\Delta t_i$</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20200415174622869.png"></p>
<h2 id="加速比S"><a href="#加速比S" class="headerlink" title="加速比S"></a>加速比S</h2><p>完成<strong>同样一批任务</strong>，不使用流水线所用的时间与使用流水线所用的时间之比。<br>$$<br>S&#x3D;\frac{T_s}{T_k}\<br>T_s：不使用流水线（即顺序执行）所用的时间\<br>T_k：使用流水线后所用的时间<br>$$</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>假设各段时间均等</p>
<p>$$<br>一条k段流水线完成n个连续任务所需要的时间:T_k&#x3D;(k+n-1)\Delta t\<br>顺序执行n个任务所需要的时间：T_s&#x3D;nk\Delta t\<br>实际加速比：S&#x3D;\frac{nk}{n+k-1}\<br>最大加速比：S_{max}&#x3D;\lim_{n\to\infty}\frac{nk}{k+n-1}&#x3D;k<br>$$<br>假设各段时间不全相等<br>$$<br>实际加速比：S&#x3D;\frac{n\sum_{i&#x3D;1}^{k}\Delta t_i}{\sum_{i&#x3D;1}^{k}\Delta t_i+(n-1)max(\Delta t_1,\Delta t_2,···\Delta t_k)}\<br>$$<br>每段执行时间并不完全相等，那么流水线完成n个连续任务所需要的总时间T<del>k</del>等于单个任务的执行时间（通过时间），加上n-1个瓶颈段的执行时间。而顺序执行这n个任务，所需要的时间为n倍的单个任务的执行时间。</p>
<h2 id="效率E"><a href="#效率E" class="headerlink" title="效率E"></a>效率E</h2><p>流水线中的设备实际使用时间与整个运行时间的比值。</p>
<p>【由于流水线有通过时间和排空时间，所以在连续完成n个任务的时间内，各段并不是满负荷地工作】</p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>各段时间均等：</p>
<p>假设各段的效率e<del>i</del> 相等<br>$$<br>e_1&#x3D;e_2&#x3D;e_3&#x3D;···&#x3D;e_k&#x3D;\frac{n\Delta t}{T_k}&#x3D;\frac{n}{k+n-1}\<br>整条流水线的效率：E&#x3D;\frac{e_1+e_2+e_3+···+e_k}{k}&#x3D;\frac{ke_1}{k}&#x3D;\frac{n}{k+n-1}\<br>$$</p>
<blockquote>
<p>效率和其他指标的关系</p>
<p>当流水线各段时间相等时，流水线的效率与吞吐率成正比$E&#x3D;TP·\Delta t$</p>
<p>流水线的效率是流水线的实际加速比S与它的最大加速比k的比值$E&#x3D;\frac{S}{K}$</p>
</blockquote>
<p>直观的描述：<br>$$<br>E&#x3D;\frac{n个任务实际占用的时空区}{k个段总的时空区}<br>$$<br>各段时间不全相等：<br>$$<br>E&#x3D;\frac{n\sum_{i&#x3D;1}^{k}\Delta t_i}{K[\sum_{i&#x3D;1}^{k}\Delta t_i+(n-1)max(\Delta t_1,\Delta t_2,···\Delta t_k)]}\<br>$$</p>
<h2 id="多功能流水线性能指标"><a href="#多功能流水线性能指标" class="headerlink" title="多功能流水线性能指标"></a>多功能流水线性能指标</h2><p>影响（多功能）流水线性能的原因</p>
<p>–多功能流水线在做某一种运算时，总有一些段是空闲的；</p>
<p>–静态流水线在进行功能切换时，要等前一种运算全部流出流水线后才能进行后面的运算；</p>
<p>–运算之间存在关联，后面有些运算要用到前面运算的结果；</p>
<p>流水线的工作过程有建立与排空部分。</p>
<p>eg：设在下图所示的静态流水线上计算<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20200415193432445.png">的吞吐率、效率和加速比</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20200415193419542.png"></p>
<p><strong>选择适合于流水线工作的算法</strong></p>
<p>先计算A<del>1</del>+B<del>1</del>、A<del>2</del>+B<del>2</del>、A<del>3</del>+B<del>3</del>和A<del>4</del>+B<del>4</del>；再计算(A<del>1</del>+B<del>1</del>)×(A<del>2</del>+B<del>2</del>)和(A<del>3</del>+B<del>3</del>)×(A<del>4</del>+B<del>4</del>)；然后求总的乘积结果。</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20200415193617077.png"></p>
<h1 id="流水线设计中的重要问题"><a href="#流水线设计中的重要问题" class="headerlink" title="流水线设计中的重要问题"></a>流水线设计中的重要问题</h1><h2 id="瓶颈问题"><a href="#瓶颈问题" class="headerlink" title="瓶颈问题"></a>瓶颈问题</h2><ul>
<li>理想情况下，流水线在工作时，其中的任务是同步地每一个时钟周期往前流动一段。</li>
<li>当流水线各段不均匀时，机器的时钟周期取决于瓶颈段的延迟时间。</li>
<li>在设计流水线时，要尽可能使各段时间相等。</li>
</ul>
<h2 id="流水线的额外开销"><a href="#流水线的额外开销" class="headerlink" title="流水线的额外开销"></a>流水线的额外开销</h2><ul>
<li><p>流水寄存器需要建立时间和传输延迟</p>
<ul>
<li>建立时间：在触发写操作的时钟信号到达之前，寄存器输入必须保持稳定的时间。</li>
<li>传输延迟：时钟信号到达后到寄存器输出可用的时间。</li>
</ul>
</li>
<li><p>时钟偏移开销</p>
<ul>
<li>流水线中，时钟到达各流水寄存器的最大差值时间。（时钟到达各流水寄存器的时间不是完全相同）</li>
</ul>
</li>
</ul>
<h2 id="由流水线性能与开销得到的重要结论"><a href="#由流水线性能与开销得到的重要结论" class="headerlink" title="由流水线性能与开销得到的重要结论"></a>由流水线性能与开销得到的重要结论</h2><ul>
<li>流水线并不能减少（而且一般是增加）单条指令的执行时间，但却能提高吞吐率。</li>
<li>增加流水线的深度（段数）可以提高流水线的性能。</li>
<li>流水线的深度受限于流水线的额外开销。</li>
<li>当时钟周期小到与额外开销相同时，流水已没意义。因为这时在每一个时钟周期中已没有时间来做有用的工作。【所以，流水段的段数越多不一定就越好】</li>
</ul>
<h1 id="单功能非线性流水线的调度"><a href="#单功能非线性流水线的调度" class="headerlink" title="单功能非线性流水线的调度"></a>单功能非线性流水线的调度</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><p>启动距离：向一条非线性流水线的输入端连续输入两个任务之间的时间间隔称为非线性流水线的启动距离。</p>
</li>
<li><p>禁用启动距离：会引起非线性流水线功能段使用冲突的启动距离则称为禁用启动距离。</p>
</li>
</ul>
<p>启动距离和禁用启动距离一般都用时钟周期数来表示，是一个正整数。</p>
<p>除去禁用启动距离外，其它的启动距离都是可用的，这也意味着，<strong>若两个任务进入非线性流水线的时间间隔不是禁用启动距离，那么这两个任务之间不会产生冲突</strong>。</p>
<ul>
<li><p>预约表：时间和执行的功能段之间的二维表</p>
</li>
<li><p>禁止表F：一个由禁用启动距离构成的集合</p>
<blockquote>
<p>对于预约表的每一行的任何一对√，用它们所在的列号相减（大的减小的），列出各种可能的差值，然后删除相同的，剩下的就是禁止表的元素。</p>
</blockquote>
</li>
</ul>
<h3 id="冲突向量"><a href="#冲突向量" class="headerlink" title="冲突向量"></a>冲突向量</h3><p>冲突向量：一个N位的二进制位串：</p>
<p>初始冲突向量C<del>0</del> 决定了下一个任务需间隔多少个时钟周期才可以流入</p>
<p>设C<del>0</del>&#x3D;（c<del>N</del>c<del>N-1</del>…c<del>i</del>…c<del>2</del>c<del>1</del>）;$C_i&#x3D;\begin{cases}1,&amp;i\in F\0,&amp;i\notin F\end{cases}$<br>c<del>i</del>&#x3D;0 ：允许间隔i个时钟周期后送入后续任务<br>c<del>i</del>&#x3D;1 ：不允许间隔i个时钟周期后送入后续任务</p>
<p>假设第二个任务是在与第一个任务间隔j个时钟周期流入，这时，由于第一个任务已经在流水线中前进了j个时钟周期，其相应的禁止表中各元素的值都应该减去j，并丢弃小于等于0的值。对原始冲突向量C<del>0</del>来说，就是<strong>逻辑右移j位（左边补0）</strong>。</p>
<p>第二个任务也会有着自己的冲突向量C。</p>
<p>由于后续任务既不能与第一个任务冲突，又不能与第二个任务冲突，所以<strong>当前（第二个任务进入流水线后的那个时钟周期）冲突向量（禁止表）是第一个任务与第二个任务的当前冲突向量的按位或（并集）</strong>。</p>
<p>假设: C<del>k</del>为当前的冲突向量，j: 允许的时间间隔，则，新的冲突向量为：SHR(j)（C<del>k</del>）∨C<del>0</del>（将当前冲突向量逻辑右移j位，再与新任务的冲突向量C<del>0</del>做按位或），得到，任意一个任务进入后的新冲突向量。</p>
<p>（通过遍历）获得所有可能的冲突向量，构成流水线状态集合：</p>
<p>从初始冲突向量C<del>0</del>出发，对于所有允许的时间间隔（所有i，满足C<del>i</del>&#x3D;0）都按上述步骤求出其新的冲突向量，并且把新的冲突向量作为当前冲突向量，反复使用上述步骤，直到不再产生新的冲突向量为止。</p>
<h2 id="流水线状态转移图"><a href="#流水线状态转移图" class="headerlink" title="流水线状态转移图"></a>流水线状态转移图</h2><p>得到所有可能的冲突向量后，可以画出其状态转移图。</p>
<p>三要素</p>
<ul>
<li>流水线状态集合（所有可能的冲突向量）</li>
<li>有向弧：表示状态转移的方向</li>
<li>弧上的数字：表示引入后续任务（从而产生新的冲突向量）所用的时间间隔（时钟周期数）</li>
</ul>
<h2 id="调度方案与最优调度方案"><a href="#调度方案与最优调度方案" class="headerlink" title="调度方案与最优调度方案"></a>调度方案与最优调度方案</h2><ul>
<li><p>调度方案：根据流水线状态图，由初始状态出发，<strong>任何一个闭合回路</strong>即为一种调度方案。 </p>
</li>
<li><p>最优调度方案：（任务进入流水线的）平均时间间隔最小的调度方案</p>
</li>
</ul>
<p>列出所有可能的调度方案，计算出每种方案的平均时间间隔，从中找出其最小者即为最优调度方案。</p>
<h2 id="等时间间隔调度方案"><a href="#等时间间隔调度方案" class="headerlink" title="等时间间隔调度方案"></a>等时间间隔调度方案</h2><p>不等时间间隔的调度方案，与等间隔的调度方案相比，在控制上要复杂得多。</p>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><p>流水线冲突（例如：在第二条指令需要第一条指令在第五周期的结果，那么第二条指令必须等到第一条指令产生相关结果才能进入流水线）会导致流水线停顿，使其性能下降。</p>
<p>相关是导致流水线冲突的主要原因。</p>
<p><strong>相关是指两条指令之间存在某种依赖关系，如果两条指令相关，则它们就有可能不能在流水线中重叠执行或者只能部分重叠执行。</strong></p>
<p>需要注意的是：相关是程序属性而非流水线属性。</p>
<p>相关可分为三类：数据相关（也称真数据相关），名相关，以及控制相关。</p>
<h2 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h2><p>定义：对于两条指令i（在前，下同）和j（在后，下同），如果下述条件之一成立，则称指令j与指令i数据相关。</p>
<p>（1）指令j使用指令i产生的结果；</p>
<p>（2）指令j与指令k数据相关，而指令k又与指令i数据相关。【传递性】</p>
<h3 id="数据相关检测"><a href="#数据相关检测" class="headerlink" title="数据相关检测"></a>数据相关检测</h3><p>当数据的流动是经过寄存器时，相关的检测比较直观和容易。</p>
<p>当数据的流动是经过存储器时，检测比较复杂。【有可能两条相关指令之间对相关数据进行过修改导致两条指令之间没有相关性】</p>
<h2 id="名相关"><a href="#名相关" class="headerlink" title="名相关"></a>名相关</h2><p>名：指令所访问的寄存器或存储器单元的名称</p>
<p>名相关：如果两条指令使用相同的名，但是它们之间并<strong>没有数据流动</strong>，则称这两条指令存在名相关</p>
<h3 id="反相关"><a href="#反相关" class="headerlink" title="反相关"></a>反相关</h3><p>如果指令j写的名与指令i读的名相同，则称指令i和j发生了反相关。</p>
<p>指令j写的名＝指令i读的名</p>
<p>这里“反”是指与数据相关的顺序（先写后读）相反（反相关是先读后写）。</p>
<h3 id="输出相关"><a href="#输出相关" class="headerlink" title="输出相关"></a>输出相关</h3><p>如果指令j和指令i写相同的名，则称指令i和j发生了输出相关</p>
<p>指令j写的名＝指令i写的名</p>
<h3 id="名相关解决方案"><a href="#名相关解决方案" class="headerlink" title="名相关解决方案"></a>名相关解决方案</h3><p>名相关特点</p>
<ul>
<li>名相关的两条指令之间并没有数据的传送。</li>
<li>如果一条指令中的名改变了，并不影响另外一条指令的执行。</li>
</ul>
<p>消除名相关的方法：换名技术</p>
<p>换名技术：通过改变指令中操作数的名来消除名相关。</p>
<ul>
<li>对于寄存器操作数进行换名称为寄存器换名<ul>
<li>既可以用编译器静态实现，也可以用硬件动态完成。</li>
</ul>
</li>
</ul>
<h2 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h2><p>控制相关是指由分支指令引起的相关。传统情况下，为了保证程序应有的执行顺序，必须严格按控制相关确定的顺序执行。</p>
<p>与一条分支指令控制相关的指令不能被移到该分支之前。</p>
<h1 id="流水线冲突"><a href="#流水线冲突" class="headerlink" title="流水线冲突"></a>流水线冲突</h1><p>流水线冲突是指对于具体的流水线来说，由于相关等原因的存在使得指令流中的下一条指令不能在指定的时钟周期执行。</p>
<p>流水线冲突分类</p>
<ul>
<li>结构冲突：因硬件资源满足不了指令重叠执行的要求而发生的冲突。</li>
<li>数据冲突：当指令在流水线中重叠执行时，因需要用到前面指令的执行结果而发生的冲突。</li>
<li>控制冲突：流水线遇到分支指令和其它会改变PC值的指令所引起的冲突。</li>
</ul>
<h2 id="问题与基本解决方法"><a href="#问题与基本解决方法" class="headerlink" title="问题与基本解决方法"></a>问题与基本解决方法</h2><p>问题</p>
<ul>
<li>导致错误的执行结果。</li>
<li>流水线可能会出现停顿，从而降低流水线的效率和实际的加速比。</li>
</ul>
<p>基本解决方法</p>
<ul>
<li>暂停部分指令执行：当一条指令被暂停时，在该暂停指令之后流出的所有指令都要被暂停，而在该暂停指令之前流出的指令则继续进行（否则就永远无法消除冲突）。</li>
</ul>
<h2 id="结构冲突"><a href="#结构冲突" class="headerlink" title="结构冲突"></a>结构冲突</h2><p>常见的导致结构冲突的原因有两个。一是功能部件不是完全流水，二是资源份数不够。</p>
<p> 解决方法：</p>
<ul>
<li><p>插入暂停周期【通过拉开两条冲突指令在流水线之间的距离来避免冲突发生的】</p>
<ul>
<li>为消除结构冲突而插入的流水线气泡</li>
</ul>
</li>
<li><p>设置相互独立的存储器，使之分别存储指令与数据【通过增加资源数量，来避免访问同一资源导致的冲突】</p>
<ul>
<li>通过让读取指令与读写数据的访存请求落到不同的存储器中，从而避免访问同一存储器引起的冲突。对应的就是组成原理课程中讲过的哈弗结构。在现代通用处理器中，这种技术被普遍用于一级cache中。</li>
</ul>
</li>
</ul>
<p><strong>不一定需要消除所有的结构冲突：</strong></p>
<p>主要是为了考虑减少硬件成本。</p>
<h2 id="数据冲突"><a href="#数据冲突" class="headerlink" title="数据冲突"></a>数据冲突</h2><h3 id="写后读冲突（RAW）"><a href="#写后读冲突（RAW）" class="headerlink" title="写后读冲突（RAW）"></a>写后读冲突（RAW）</h3><p>对应的相关：最常见的一种数据冲突，对应于真数据相关。 </p>
<p>发生条件</p>
<ul>
<li>有两条指令i和j，i在j之前进入流水线</li>
<li>在 i 写入之前，j 先去读</li>
</ul>
<p>结果</p>
<ul>
<li>j 读出的内容是错误的</li>
</ul>
<h3 id="写后写冲突（WAW）"><a href="#写后写冲突（WAW）" class="headerlink" title="写后写冲突（WAW）"></a>写后写冲突（WAW）</h3><p>对应相关：对应于输出相关。</p>
<p>发生条件：</p>
<ul>
<li>流水线中不只一个段可以进行写操作，且指令被重新排序了</li>
<li>有两条指令i和j，i在j之前进入流水线</li>
<li>在 i 写入之前，j 先写。</li>
</ul>
<p>结果</p>
<ul>
<li>最后写入的结果是 i 的。错误！</li>
</ul>
<h3 id="读后写冲突（WAR）"><a href="#读后写冲突（WAR）" class="headerlink" title="读后写冲突（WAR）"></a>读后写冲突（WAR）</h3><p>对应相关：反相关</p>
<p>发生条件</p>
<ul>
<li>有些指令的写结果操作提前了，而且有些指令的读操作滞后了；或是指令被重新排序了。 </li>
<li>有两条指令i和j，i在j之前进入流水线。在 i 读取之前，j 先写入。</li>
</ul>
<p>结果</p>
<ul>
<li>i读到的结果是错误的。</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>定向（短路、旁路）：（减少冲突引起的停顿时间）<ul>
<li>在计算结果尚未出来之前，后面等待使用该结果的指令并不真正立即需要该计算结果，如果能够将该计算结果从其产生的地方直接送到其它指令需要它的地方，那么就可以避免停顿。</li>
</ul>
</li>
</ul>
<p>定向技术实际上是在原有的寄存器传递数据的基础上，增加了新的指令间传递数据的路径。</p>
<ul>
<li>指令调度（流水线调度）：让编译器重新组织指令顺序来消除冲突</li>
</ul>
<blockquote>
<p>定向技术是基于硬件的运行时解决方案；指令调度是基于软件的的预处理方案</p>
</blockquote>
<h2 id="控制冲突"><a href="#控制冲突" class="headerlink" title="控制冲突"></a>控制冲突</h2><p>起因：执行分支指令的结果有两种</p>
<ul>
<li><p>分支成功：PC值改变为分支转移的目标地址。在条件判定和转移地址计算都完成后，才改变PC值。</p>
</li>
<li><p>不成功或者失败：PC的值保持正常递增，指向顺序的下一条指令。</p>
</li>
</ul>
<p>控制冲突</p>
<ul>
<li>分支延迟：分支指令引起的延迟</li>
</ul>
<p>最简单的处理方法</p>
<ul>
<li>“冻结”或者“排空”流水线 <ul>
<li>前述5段流水线中，改变PC值是在MEM段进行的。给流水线带来了3个时钟周期的延迟</li>
</ul>
</li>
</ul>
<h3 id="基本解决方案"><a href="#基本解决方案" class="headerlink" title="基本解决方案"></a>基本解决方案</h3><p><strong>通过设置专用的处理单元，在流水线中尽早判断出分支转移是否成功，以及分支目标地址。</strong>【硬件】</p>
<p>进一步：基于编译器的软件方法</p>
<h4 id="预测分支失败"><a href="#预测分支失败" class="headerlink" title="预测分支失败"></a>预测分支失败</h4><p>允许分支指令后的指令继续在流水线中流动，就好象什么都没发生似的；若确定分支失败，将分支指令看作是一条普通指令，流水线正常流动；若确定分支成功，流水线就把在分支指令之后取出的所有指令转化为空操作，并按分支目地重新取指令执行。</p>
<h4 id="预测分支成功"><a href="#预测分支成功" class="headerlink" title="预测分支成功"></a>预测分支成功</h4><p>假设分支转移成功，并从分支目标地址处取指令执行。这种方法起作用的前题是，需要先知道分支目标地址，后知道分支是否成功。显然，前述5段流水线中，这种方法没有任何好处。原因在于，分支目标地址与分支是否成功是同时计算出来的。</p>
<h4 id="延迟分支"><a href="#延迟分支" class="headerlink" title="延迟分支"></a>延迟分支</h4><p>从逻辑上“延长”分支指令的执行时间。把延迟分支看成是由原来的分支指令和若干个延迟槽构成，不管分支是否成功，都要按顺序执行延迟槽中的指令。<br>延迟分支的优点在于无论分支成功还是失败都能够减少（掩盖）一个时钟周期的延迟。</p>
<blockquote>
<p>通过在分支指令后增加延迟槽，并将有用的指令从别处调度到延迟槽执行，当分支是否成功与分支目标地址被算出时，恰好能够进行对应的取指操作，从而有效的消除了分支延迟。</p>
</blockquote>
<p>–要点：在延迟槽中放入有用的指令，由编译器完成。能否带来好处取决于编译器能否把有用的指令调度到延迟槽中。</p>
<p>从调度的角度，延迟分支又可分为三类：从前调度，从目标处调度，从失败处调度。</p>
<ul>
<li>从前调度：从分支指令之前调度一条与该分支无关的指令到分支延迟槽中。</li>
<li>从目标处调度：将分支目标地址对应的指令调度到延迟槽中。</li>
<li>从失败处调度：将分支失败处的指令（下一条顺序地址）调入延迟槽。</li>
</ul>
<blockquote>
<p>由于只有当调入到延迟槽的指令实际上会被执行时，分支延迟技术才会真正起效，因此，可以认为：无论分支是否成功，从前调度均能消除控制冲突；只有当分支成功时，从目标处调度才能消除控制冲突；只有当分支失败时，从失败处调度才能消除控制冲突。</p>
<p> 既然从前调度的效果远胜于后两种调度，为什么还要有后两种方法呢？原因在于，前面提到的从前调度需要找到一条与该分支无关的指令，这样的指令通常是极少的。</p>
</blockquote>
<p>分支延迟的改善受到两个方面的限制：一是需要在延迟槽中放入有用的指令（由编译器完成）；二是能否带来好处取决于编译器能否把有用的指令调度到延迟槽中。</p>
<p>此外，对于预测错误的情况，需要进一步的改进。引入分支取消机制，当分支的实际执行方向和事先所预测的一样时，执行分支延迟槽中的指令，否则就将分支延迟槽中的指令转化成一个空操作。</p>
<h1 id="流水线的实现"><a href="#流水线的实现" class="headerlink" title="流水线的实现"></a>流水线的实现</h1><p>MIPS的流水化：每一个时钟周期完成的工作看作是流水线的一段，每个时钟周期启动一条新的指令。</p>
<p>流水寄存器的位置和作用：</p>
<ul>
<li><p>位置：段与段之间设置流水寄存器</p>
</li>
<li><p>作用</p>
<ul>
<li>将各段的工作隔开，使得它们不会互相干扰。</li>
<li>保存相应段的处理结果。</li>
<li>向后传递后面将要用到的数据或者控制信息<br>所有有用的数据和控制信息每个时钟周期会随着指令在流水线中的流动往后流动一段</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/08/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">java-设计模式（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-07 21:58:36" itemprop="dateCreated datePublished" datetime="2020-04-07T21:58:36Z">2020-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GOF23种设计模式"><a href="#GOF23种设计模式" class="headerlink" title="GOF23种设计模式"></a>GOF23种设计模式</h1><p>设计模式主要分三个类型:创建型、结构型和行为型。 </p>
<p><strong>创建型</strong></p>
<ol>
<li>Singleton，单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点 </li>
<li>Abstract Factory，抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。 </li>
<li>Factory Method，工厂方法：定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。 </li>
<li>Builder，建造模式：将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。 </li>
<li>Prototype，原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。</li>
</ol>
<p><strong>行为型</strong></p>
<ol>
<li>Iterator，迭代器模式：提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。 </li>
<li>Observer，观察者模式：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。 </li>
<li>Template Method，模板方法：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该算法得某些特定步骤。 </li>
<li>Command，命令模式：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。 </li>
<li>State，状态模式：允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。 </li>
<li>Strategy，策略模式：定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。 </li>
<li>China of Responsibility，职责链模式：使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系 </li>
<li>Mediator，中介者模式：用一个中介对象封装一些列的对象交互。 </li>
<li>Visitor，访问者模式：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。 </li>
<li>Interpreter，解释器模式：给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子</li>
<li>Memento，备忘录模式：在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</li>
</ol>
<p><strong>结构型</strong> </p>
<ol>
<li>Composite，组合模式：将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使用具有一致性。 </li>
<li>Facade，外观模式：为子系统中的一组接口提供一致的界面，fa?ade提供了一高层接口，这个接口使得子系统更容易使用。</li>
<li>Proxy，代理模式：为其他对象提供一种代理以控制对这个对象的访问 </li>
<li>Adapter,适配器模式：将一类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作那些类可以一起工作。 </li>
<li>Decrator，装饰模式：动态地给一个对象增加一些额外的职责，就增加的功能来说，Decorator模式相比生成子类更加灵活。 </li>
<li>Bridge，桥模式：将抽象部分与它的实现部分相分离，使他们可以独立的变化。 </li>
<li>Flyweight，享元模式</li>
</ol>
<h2 id="一、工厂模式"><a href="#一、工厂模式" class="headerlink" title="一、工厂模式"></a>一、工厂模式</h2><h3 id="1-1、简单工厂模式（静态工厂模式）"><a href="#1-1、简单工厂模式（静态工厂模式）" class="headerlink" title="1.1、简单工厂模式（静态工厂模式）"></a>1.1、简单工厂模式（静态工厂模式）</h3><p>“<strong>当你需要某个对象的时候，通常你是new出来的，但是这样代码耦合度太高，因此我们通过一个工厂来生产出来这个对象</strong>”</p>
<ul>
<li>工厂：负责实现创建所有实例的内部逻辑，并且提供一个外界调用的方法，创建所需产品对象</li>
<li>抽象产品：用来描述产品的公共接口</li>
<li>具体产品：描述生产的具体产品</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @ Product.java</span></span><br><span class="line"><span class="comment"> *  抽象产品</span></span><br><span class="line"><span class="comment"> *  描述产品的公共接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span>  <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="comment">//产品介绍</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ AProduct.java</span></span><br><span class="line"><span class="comment"> * 具体产品A</span></span><br><span class="line"><span class="comment"> * （可以看成是一种饮料：可乐）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;可乐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ BProduct.java</span></span><br><span class="line"><span class="comment"> * @具体产品B</span></span><br><span class="line"><span class="comment"> * @（可以看成是一种饮料：奶茶）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奶茶&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ CProduct.java</span></span><br><span class="line"><span class="comment"> * 具体产品C</span></span><br><span class="line"><span class="comment"> * （可以看成是一种饮料：咖啡）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;咖啡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Factory.java*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂</span></span><br><span class="line"><span class="comment"> * 负责实现创建所有实例的内部逻辑，并提供一个外界调用的方法，创建所需的产品对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供外界调用的方法</span></span><br><span class="line"><span class="comment">     * （可以看成是对外提供的三种按钮）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 产品实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">getProduct</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AProduct</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BProduct</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;C&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CProduct</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*test.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建具体的工厂</span></span><br><span class="line">        <span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factory</span>();</span><br><span class="line">        <span class="comment">//根据传入的参数生产不同的产品实例</span></span><br><span class="line">        <span class="comment">//(按下不同的按钮，获取饮料)</span></span><br><span class="line">        <span class="type">Product</span> <span class="variable">A</span> <span class="operator">=</span> Factory.getProduct(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        A.intro();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">B</span> <span class="operator">=</span> Factory.getProduct(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        B.intro();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">C</span> <span class="operator">=</span> Factory.getProduct(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        C.intro();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：将创建使用工作分开，不必关心类对象如何创建，实现了解耦；<br>缺点：违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。</p>
<h3 id="1-2、工厂方法模式（工厂模式）"><a href="#1-2、工厂方法模式（工厂模式）" class="headerlink" title="1.2、工厂方法模式（工厂模式）"></a>1.2、工厂方法模式（工厂模式）</h3><p>可以理解成将上述的静态工厂模式中的工厂进行拆分，让对应的实例产品都有一个单独的工厂对其进行生产。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ Product.java </span></span><br><span class="line"><span class="comment"> *   抽象产品</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="comment">//产品介绍</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ ProductA.java </span></span><br><span class="line"><span class="comment"> * 具体产品A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductA</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;饮料A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ ProductB.java </span></span><br><span class="line"><span class="comment"> * 具体产品B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductB</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;饮料B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂：Factory.java、FactoryA.java 、FactoryB.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @ Factory.java</span></span><br><span class="line"><span class="comment"> *    抽象工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">//生产产品</span></span><br><span class="line">    <span class="keyword">abstract</span> Product <span class="title function_">getProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ FactoryA.java</span></span><br><span class="line"><span class="comment"> * 具体工厂A</span></span><br><span class="line"><span class="comment"> * 负责具体的产品A生产</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryA</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Product <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ FactoryB.java</span></span><br><span class="line"><span class="comment"> * @具体工厂B</span></span><br><span class="line"><span class="comment"> * 负责具体的产品B生产</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryB</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Product <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：Test.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建具体的工厂</span></span><br><span class="line">        <span class="type">FactoryA</span> <span class="variable">factoryA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FactoryA</span>();</span><br><span class="line">        <span class="comment">//生产相对应的产品</span></span><br><span class="line">        factoryA.getProduct().intro();</span><br><span class="line">        <span class="type">FactoryB</span> <span class="variable">factoryB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FactoryB</span>();</span><br><span class="line">        factoryB.getProduct().intro();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一个抽象产品类，可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类只能创建一个具体产品类的实例</strong>。</p>
<p>优点：</p>
<ol>
<li>符合开-闭原则：新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可</li>
<li>符合单一职责原则：每个具体工厂类只负责创建对应的产品</li>
</ol>
<p>缺点：</p>
<ol>
<li>增加了系统的复杂度：类的个数将成对增加</li>
<li>增加了系统的抽象性和理解难度</li>
<li>一个具体工厂只能创建一种具体产品</li>
</ol>
<h3 id="1-3、抽象工厂模式"><a href="#1-3、抽象工厂模式" class="headerlink" title="1.3、抽象工厂模式"></a>1.3、抽象工厂模式</h3><p>为了解决工厂模式中一个工厂只能生产一个具体产品的问题。抽象工厂模式使用抽象类添加了抽象工厂，然后让具体工厂继承该抽象工厂达到一个具体工厂可以生产多种具体产品的效果。</p>
<p><strong>抽象工厂</strong>：描述具体工厂的公共接口<br><strong>具体工厂</strong>：描述具体工厂，创建产品的实例，供外界调用<br><strong>抽象产品族</strong>：描述抽象产品的公共接口<br><strong>抽象产品</strong>：描述具体产品的公共接口<br><strong>具体产品</strong>：具体产品</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ Product.java</span></span><br><span class="line"><span class="comment"> * 抽象产品族 (食品)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="comment">//产品介绍</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ ProductA.java</span></span><br><span class="line"><span class="comment"> * 抽象产品  (饮料)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ProductA</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ ProductB.java</span></span><br><span class="line"><span class="comment"> * 抽象产品  (零食)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ProductB</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ ProductAa.java</span></span><br><span class="line"><span class="comment"> * 具体产品  (矿泉水)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">ProductAa</span> <span class="keyword">extends</span> <span class="title class_">ProductA</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;矿泉水&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ ProductBb.java</span></span><br><span class="line"><span class="comment"> * 具体产品  (面包)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductBb</span> <span class="keyword">extends</span> <span class="title class_">ProductB</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">intro</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;面包&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂：Factory.java、FactoryA.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ Factory.java</span></span><br><span class="line"><span class="comment"> * 抽象工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">//生产饮料</span></span><br><span class="line">    <span class="keyword">abstract</span> Product <span class="title function_">getProductA</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//生产零食</span></span><br><span class="line">    <span class="keyword">abstract</span> Product <span class="title function_">getProductB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ FactoryA.java</span></span><br><span class="line"><span class="comment"> * 具体工厂A</span></span><br><span class="line"><span class="comment"> * 负责具体的A类产品生产</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryA</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Product <span class="title function_">getProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//生产矿泉水</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductAa</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Product <span class="title function_">getProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//生产面包</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductBb</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：Test.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建零食售卖机（具体工厂），</span></span><br><span class="line">        <span class="type">FactoryA</span> <span class="variable">factoryA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FactoryA</span>();</span><br><span class="line">        <span class="comment">//获取矿泉水与面包（具体产品）</span></span><br><span class="line">        factoryA.getProductA().intro();</span><br><span class="line">        factoryA.getProductB().intro();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类可以创建多个具体产品类的实例</strong>。.</p>
<p>优点：</p>
<ol>
<li>降低耦合</li>
<li>符合开-闭原则</li>
<li>符合单一职责原则</li>
<li>不使用静态工厂方法，可以形成基于继承的等级结构。</li>
</ol>
<p>缺点：难以扩展新种类产品</p>
<h2 id="二、单例模式（singleton）"><a href="#二、单例模式（singleton）" class="headerlink" title="二、单例模式（singleton）"></a>二、单例模式（singleton）</h2><p>确保一个类只有一个实例，并提供该实例的全局访问点。</p>
<p><strong>单例的实现主要是通过以下两个步骤</strong>：</p>
<ol>
<li><strong>将该类的构造方法定义为私有方法</strong>，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，<strong>只有通过该类提供的静态方法来得到该类的唯一实例</strong>；</li>
<li>在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</li>
</ol>
<h3 id="1、单例模式的应用场景和优缺点"><a href="#1、单例模式的应用场景和优缺点" class="headerlink" title="1、单例模式的应用场景和优缺点"></a>1、单例模式的应用场景和优缺点</h3><p>举一个小例子，在我们的windows桌面上，我们打开了一个回收站，当我们试图再次打开一个新的回收站时，Windows系统并不会为你弹出一个新的回收站窗口。，也就是说在整个系统运行的过程中，系统只维护一个回收站的实例。这就是一个典型的单例模式运用。</p>
<p> 继续说回收站，我们在实际使用中并不存在需要同时打开两个回收站窗口的必要性。假如我每次创建回收站时都需要消耗大量的资源，而每个回收站之间资源是共享的，那么在没有必要多次重复创建该实例的情况下，创建了多个实例，这样做就会给系统造成不必要的负担，造成资源浪费。</p>
<p> <strong>适用场景：</strong></p>
<ul>
<li><strong>1.需要生成唯一序列的环境</strong></li>
<li><strong>2.需要频繁实例化然后销毁的对象。</strong></li>
<li><strong>3.创建对象时耗时过多或者耗资源过多，但又经常用到的对象。</strong> </li>
<li><strong>4.方便资源相互通信的环境</strong></li>
</ul>
<p><strong>常见应用场景：</strong></p>
<ul>
<li>Windows的Task Manager（任务管理器）</li>
<li>windows的Recycle Bin（回收站）也是典型的单例应用</li>
<li>应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作 ，否则内容不好追加。</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源</li>
<li>操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统</li>
<li>Application 也是单例的典型应用（Servlet编程中会涉及到）</li>
<li>在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理</li>
<li>在servlet编程中，每个Servlet也是单例</li>
<li>在spring MVC框架&#x2F;struts1框架中，控制器对象也是单例</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>在内存中只有一个对象，节省内存空间；</li>
<li>避免频繁的创建销毁对象，可以提高性能；</li>
<li>避免对共享资源的多重占用，简化访问；</li>
<li>为整个系统提供一个全局访问点。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>不适用于变化频繁的对象；</li>
<li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；</li>
<li>如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失；</li>
</ul>
<p>单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p>
<p> <img src="/images/android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/1475571-20190112110023891-1922874460.png"></p>
<p>单例模式的实现代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="literal">null</span>;  <span class="comment">//静态私有成员变量</span></span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span></span><br><span class="line">    &#123;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">//静态公有工厂方法，返回唯一实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)</span><br><span class="line">            instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();    </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在单例模式的实现过程中，需要注意如下三点：</p>
<p>  • 单例类的构造函数为私有；</p>
<p>  • 提供一个自身的静态私有成员变量；</p>
<p>  • 提供一个公有的静态工厂方法。</p>
<h3 id="2、饿汉式——线程安全、调用效率高、无法延时加载"><a href="#2、饿汉式——线程安全、调用效率高、无法延时加载" class="headerlink" title="2、饿汉式——线程安全、调用效率高、无法延时加载"></a>2、饿汉式——线程安全、调用效率高、无法延时加载</h3><p><strong>类加载的方式是按需加载，且加载一次</strong>。。因此，在上述单例类被加载时，就会实例化一个对象并交给自己的引用，供系统使用；而且，由于这个类在整个生命周期中只会被加载一次，因此只会创建一个实例，即能够充分保证单例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 指向自己实例的私有静态引用，主动创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton1</span> <span class="variable">singleton1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 私有的构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 以自己实例为返回值的静态的公有方法，静态工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getSingleton1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p>
<p>缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</p>
<h3 id="3、懒汉式——线程安全、调用效率低、延时加载"><a href="#3、懒汉式——线程安全、调用效率低、延时加载" class="headerlink" title="3、懒汉式——线程安全、调用效率低、延时加载"></a>3、懒汉式——线程安全、调用效率低、延时加载</h3><p>单例实例被<strong>延迟加载</strong>，即只有在真正使用的时候才会实例化一个对象并交给自己的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 指向自己实例的私有静态引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 singleton2;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 私有的构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 以自己实例为返回值的静态的公有方法，静态工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton2 <span class="title function_">getSingleton2</span><span class="params">()</span>&#123;<span class="comment">//synchronized保证getSingleton2是一个同步方法，可以保证在多线程情况下单例对象唯一性</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//没有synchronized，只能在单线程下使用。如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 被动创建，在真正需要使用时才去创建</span></span><br><span class="line">        <span class="keyword">if</span> (singleton2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            singleton2 = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：单例只有在使用时才会被实例化，在一定程度上节约了资源</p>
<p>缺点：第一次加载时需要及时进行实例化，反应稍慢，最大的问题是每次调用getInstance都进行同步，造成不必要的同步开销。这种模式一般不建议使用。</p>
<h3 id="4、双重加锁机制（Double-Check-Lock）——线程安全"><a href="#4、双重加锁机制（Double-Check-Lock）——线程安全" class="headerlink" title="4、双重加锁机制（Double Check Lock）——线程安全"></a>4、双重加锁机制（Double Check Lock）——线程安全</h3><p>Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次if (singleton &#x3D;&#x3D; null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton &#x3D;&#x3D; null)，直接return实例化对象。</p>
<p>使用双重检测同步延迟加载去创建单例的做法是一个非常优秀的做法，<strong>其不但保证了单例，而且切实提高了程序运行效率</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">        <span class="comment">//程序运行时创建一个静态只读的进程辅助对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> readonly <span class="type">object</span> <span class="variable">syncRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">object</span>();</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dosomething</span><span class="params">()</span></span><br><span class="line">    	&#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;do sth.&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">GetInstance</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//先判断是否存在，不存在再加锁处理</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//在同一个时刻加了锁的那部分程序只有一个线程可以进入</span></span><br><span class="line">                <span class="comment">//lock(syncRoot) 获取对象syncRoot的互斥锁，可以简单理解为，当多个线程同时执行到lock的时候，大家排队，一个一个地进行。</span></span><br><span class="line">                lock (syncRoot)<span class="comment">//可以使用synchronized (Singleton.class)</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//当声明对象的引用为volatile后，“问题的根源”的三行伪代码中的2和3之间的重排序，在多线程环境中将会被禁止，类在实例化过程中会严格按照1、2、3顺序执行下去。</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">        <span class="comment">//程序运行时创建一个静态只读的进程辅助对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dosomething</span><span class="params">()</span></span><br><span class="line">    	&#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;do sth.&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">GetInstance</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//先判断是否存在，不存在再加锁处理</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//在同一个时刻加了锁的那部分程序只有一个线程可以进入</span></span><br><span class="line">                <span class="keyword">synchronized</span> (Singleton.class)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一次 if (instance &#x3D;&#x3D; null)主要是为了避免不必要的同步，第二次的判断是为了在null的情况下创建实例。</p>
<p><img src="https://gitee.com/luffyrao/picture/raw/master/img/20211229102745.png"></p>
<p>优点：既能够在需要时才初始化单例，又能够保证线程安全，且单例对象初始化后调用getInstance不进行同步锁。<br>资源利用率高，第一次执行getInstance时单例对象才会被实例化，效率高。</p>
<p>缺点：第一次加载慢</p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/double-checked-locking-with-delay-initialization/">参考文章</a></p>
<h3 id="5、静态初始化"><a href="#5、静态初始化" class="headerlink" title="5、静态初始化"></a>5、静态初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻止发生派生，而派生可能会增加实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在第一次引用类的任何成员时创建实例，公共语言运行库负责处理变量初始化</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> readonly Singleton instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">GetInstance</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、静态内部类"><a href="#6、静态内部类" class="headerlink" title="6、静态内部类"></a>6、静态内部类</h3><p>解决DCL在某些情况下出现失效的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Slingleton</span><span class="params">()</span></span><br><span class="line">    &#123;   &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> SingleHolder.sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">sInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当第一次加载singleton类时并不会初始化sInstance，只有在第一次调用Singleton的getInstance方法时才会导致sInstance被初始化。</p>
<p>第一次调用getInstance方法会导致虚拟机加载SingletonHolder类，这种方式不仅能够确保线程安全，也可以确保单例对象的唯一性，同时也延迟了单例的实例化。推荐。</p>
<h3 id="7、枚举单例"><a href="#7、枚举单例" class="headerlink" title="7、枚举单例"></a>7、枚举单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SingletonEnum</span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dosomething</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、使用容器实现"><a href="#8、使用容器实现" class="headerlink" title="8、使用容器实现"></a>8、使用容器实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonManager</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; objMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonManager</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerService</span><span class="params">(String key,Object instance)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!objMap.containsKey(key))</span><br><span class="line">        &#123;</span><br><span class="line">            objMap.put(key,instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getService</span><span class="params">(String key)</span></span><br><span class="line">        <span class="keyword">return</span> objMap.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程序的初始时，可以将多种单例类型注入到一个统一的管理类中，在使用时根据key获取对象对应类型的对象。</p>
<p>优点：可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低用户的使用成本，降低耦合度。</p>
<p>要想实现效率高的线程安全的单例，我们必须注意以下两点：</p>
<ul>
<li><strong>尽量减少同步块的作用域；</strong></li>
<li><strong>尽量使用细粒度的锁。</strong></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/" class="post-title-link" itemprop="url">数据库_数据库完整性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-01 11:12:38" itemprop="dateCreated datePublished" datetime="2020-04-01T11:12:38Z">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h1><ul>
<li><p>数据库的完整性</p>
<ul>
<li>数据的正确性和相容性</li>
</ul>
</li>
<li><p>数据的完整性和安全性是两个不同概念：</p>
<ul>
<li>数据的完整性：防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据</li>
<li>数据的安全性：保护数据库防止恶意的破坏和非法的存取</li>
</ul>
</li>
<li><p>为维护数据库的完整性，DBMS必须：</p>
<ul>
<li>提供定义完整性约束条件的机制</li>
<li>提供完整性检查的方法</li>
<li>违约处理</li>
</ul>
</li>
</ul>
<p>DBMS完整性控制机制应具有的功能：</p>
<ul>
<li>违约反应</li>
<li>定义功能</li>
<li>检查功能</li>
</ul>
<h2 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h2><p>实体完整性的定义机制：<br>–CREATE  TABLE中用PRIMARY KEY定义<br>–列级约束条件 或表级约束条件</p>
<p>实体完整性的检查和违约处理：</p>
<p>在插入或对主码列进行更新操作时，RDBMS按照实体完整性规则自动进行检查。包括：<br>–检查主码值是否唯一，如果不唯一则拒绝插入或修改<br>–检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改</p>
<h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2><p>参照完整性，指多表之间的设计，主要使用外键约束【多表设计有：一对多，多对多，一对一】</p>
<p>主要是定义外码，将一个关系的主码放在另一个关系中，作为该关系的属性，就称其为外码。外码的取值有两种情况，一种为空，另外一种就是被参照表的主码的域。</p>
<p>子表的删除更新策略一共有4种：</p>
<ul>
<li><p>CASCADE 级联策略。<br>主表的修改会被同步到子表中。</p>
</li>
<li><p>NO ACTION 无动作策略。<br>要删改主表，必须要先删改子表对应数据。</p>
</li>
<li><p>RSTRICT 主表约束策略。<br>此策略，对主表的约束跟NO ACTION一样。即删、更新主表前的主键，必须要先删、更新子表中对应的。</p>
</li>
<li><p>SET NO 置空策略。<br>使用此策略时，当主表主键删改，则子表中的外键 设置为NULL。<br>但如果子表的外键是主键，或者子表外键设置NOT NULL，则此时就相当于NO ACTION策略。</p>
</li>
</ul>
<p>参照完整性的定义机制：<br>–在CREATE  TABLE中用FOREIGN KEY短语定义哪些列为外码，<br>–用REFERENCES短语指明这些外码参照哪些表的主码</p>
<table>
<thead>
<tr>
<th>被参照表</th>
<th>参照表</th>
<th>违约处理</th>
</tr>
</thead>
<tbody><tr>
<td>可能破坏参照完整性</td>
<td>插入元组</td>
<td>拒绝</td>
</tr>
<tr>
<td>可能破坏参照完整性</td>
<td>修改外码值</td>
<td>拒绝&#x2F;级联修改&#x2F;设置为空值</td>
</tr>
<tr>
<td>修改主码值</td>
<td>可能破坏参照完整性</td>
<td>拒绝&#x2F;级联修改&#x2F;设置为空值</td>
</tr>
<tr>
<td>删除元组</td>
<td>可能破坏参照完整性</td>
<td>拒绝&#x2F;级联修改&#x2F;设置为空值</td>
</tr>
</tbody></table>
<p>若要在参照完整性中采用级联更新的修改方式，则应该在<strong>外码定义</strong>中说明。</p>
<h1 id="用户定义完整性"><a href="#用户定义完整性" class="headerlink" title="用户定义完整性"></a>用户定义完整性</h1><p>用户定义的完整性就是针对某一具体应用的数据必须满足的语义要求</p>
<p>分为：属性上的约束和元组上的约束。</p>
<p>属性上的约束：在CREATE TABLE中定义属性时定义<br>–列值非空（NOT NULL），列值唯一（UNIQUE），检查列值是否满足一个布尔表达式（CHECK）<br>–插入元组或修改属性值时检查，不满足则拒绝执行。</p>
<p>元组上的约束<br>–在CREATE TABLE时可以用CHECK短语定义元组上的约束条件，即元组级的限制<br>–同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件<br>–插入元组或修改属性值时检查，不满足则拒绝执行</p>
<p>在一张表上可以定义多个完整性约束，为方便起见，在CREATE TABLE中可用CONSTRAINT语句对所定义的约束条件命名</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONSTRAINT</span>&lt;完整性约束条件名&gt;&lt;完整性约束条件&gt;</span><br><span class="line">其中，&lt;完整性约束条件&gt;包括：<span class="keyword">NOT</span>  <span class="keyword">NULL</span>、<span class="keyword">UNIQUE</span>、PRIMARYKEY、<span class="keyword">FOREIGN KEY</span>、<span class="keyword">CHECK</span>短语等。</span><br></pre></td></tr></table></figure>

<p>语义: 对定义的约束条件命名</p>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>是用户定义在关系表上的一类由事件驱动的特殊过程。亦称为：事件-条件-动作规则。</p>
<ul>
<li>一旦定义，触发器将被保存在数据库服务器中。</li>
<li><strong>任何用户对表的增、删、改操作均由服务器自动激活相应的触发器</strong>，在DBMS核心层进行集中的完整性控制。</li>
<li>比约束更为灵活，规则中的动作可以很复杂，可以包含 if&#x2F; while&#x2F;case 等程序控制指令，可以涉及其他表和其他数据库对象，实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力。</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> &lt;触发器名&gt;  </span><br><span class="line">&#123; <span class="keyword">BEFORE</span>| <span class="keyword">AFTER</span>&#125; &lt;触发事件&gt;</span><br><span class="line"><span class="keyword">ON</span>&lt;表名&gt;</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span>  &#123; <span class="keyword">ROW</span> | <span class="keyword">STATEMENT</span> &#125;</span><br><span class="line">［<span class="keyword">WHEN</span>&lt;触发条件&gt;］</span><br><span class="line">&lt;触发动作体&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>触发时机：AFTER 表示 执行条件，有 BEFORE（之前 ） AFTER（之后）</p>
</li>
<li><p>触发事件：INSERT ON 表示在执行了 插入操作 ,有INSERT&#x2F;UPDATE&#x2F;DELETE 三种 </p>
</li>
<li><p>触发者类型：FOR EACH ROW BEGIN 固定语法</p>
<ul>
<li>行级触发器（FOR EACH ROW）</li>
<li>语句级触发器（FOR EACH STATEMENT）【那么执行完该语句后，触发动作只发生一次】</li>
</ul>
</li>
<li><p>触发动作体：是一段程序。如果触发器是行级触发器，则这段程序中还可以使用NEW和OLD分别引用触发事件发生前后的元组值。</p>
</li>
</ul>
<h2 id="激活触发器"><a href="#激活触发器" class="headerlink" title="激活触发器"></a>激活触发器</h2><ul>
<li><p>触发器的执行，由触发事件激活，并由数据库服务器自动执行。</p>
</li>
<li><p>一个数据表上可能定义了多个触发器，同一个表上的多个触发器激活时遵循如下的执行顺序：</p>
<p>​	 （1） 执行该表上的BEFORE触发器；<br>​    （2） 执行激活触发器的SQL语句；<br>​    （3） 执行该表上的AFTER触发器。</p>
</li>
<li><p>有多个触发器时，按创建时间顺序依次执行。</p>
</li>
<li><p>任一触发器的执行失败都将中止整个操作。</p>
</li>
</ul>
<h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><p>删除触发器的SQL语法：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> &lt;触发器名&gt; <span class="keyword">ON</span>&lt;表名&gt;;</span><br></pre></td></tr></table></figure>

<p>触发器必须是一个已经创建的触发器，并且只能由具有相应权限的用户删除。</p>
<p><strong>注意：不同的DBMS对于触发器的支持方式和语法是有所区别的！</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/" class="post-title-link" itemprop="url">数据库_数据库安全性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-01 11:12:26" itemprop="dateCreated datePublished" datetime="2020-04-01T11:12:26Z">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库安全性概述"><a href="#数据库安全性概述" class="headerlink" title="数据库安全性概述"></a>数据库安全性概述</h1><p>1.数据库安全性定义数据库的安全性是指保护数据库以防止不合法的使用所造成的数据泄露、更改或破坏。</p>
<p>2.重要性</p>
<ul>
<li><p>数据库的一大特点是数据可以共享</p>
</li>
<li><p>数据共享必然带来数据库的安全性问题</p>
</li>
<li><p>数据库系统中的数据共享不能是无条件的共享</p>
</li>
</ul>
<p>系统的安全保护措施是否有效是数据库系统的主要性能指标之一。</p>
<h2 id="数据库的不安全因素"><a href="#数据库的不安全因素" class="headerlink" title="数据库的不安全因素"></a>数据库的不安全因素</h2><p>1）非授权用户对数据库的恶意存取和破坏</p>
<ul>
<li>安全措施：用户身份鉴别、存取控制、和视图等</li>
</ul>
<p>2）数据库中重要或敏感数据被泄露</p>
<ul>
<li>安全措施：审计、日志、入侵检测、数据加密等</li>
</ul>
<p>3）安全环境的脆弱性，包括：硬件、OS、网络等。</p>
<ul>
<li>可信计算机系统</li>
</ul>
<h2 id="数据库安全技术"><a href="#数据库安全技术" class="headerlink" title="数据库安全技术"></a>数据库安全技术</h2><ul>
<li>用户身份验证</li>
<li>多层存取控制</li>
<li>审计</li>
<li>视图</li>
<li>数据加密等</li>
</ul>
<h3 id="用户身份鉴别"><a href="#用户身份鉴别" class="headerlink" title="用户身份鉴别"></a>用户身份鉴别</h3><ul>
<li>用户标识与鉴别（Identification &amp;  Authentication）：<ul>
<li>系统提供的最外层安全保护措施；</li>
<li>系统提供一定的方式让用户标识自己的名字和身份，系统进行核实，通过鉴定后才提供系统使用权。</li>
</ul>
</li>
<li>常用鉴别方法：<ul>
<li>口令：静态（易被窃取）、动态（一次一密）</li>
<li>生物特征识别：指纹、声音、照片等</li>
<li>智能卡</li>
<li>回答问题</li>
</ul>
</li>
</ul>
<h3 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h3><p>1.什么是存取控制？对于获得上机权的用户还要根据系统预先定义好的外模式（视图）或用户权限进行存取控制，保证用户只能存取他有权存取的数据。</p>
<p>2.方法</p>
<ul>
<li>定义用户权限</li>
<li>合法权限检查</li>
</ul>
<p>3.常用存取控制方法</p>
<ul>
<li>自主存取控制（Discretionary Access Control，DAC），C2级，灵活</li>
<li>强制存取控制（Mandatory Access Control，MAC），B1级，严格</li>
</ul>
<h3 id="视图机制"><a href="#视图机制" class="headerlink" title="视图机制"></a>视图机制</h3><ul>
<li>视图能够把要保密的数据对无权存取这些数据的用户隐藏起来，因此对数据提供一定程度的安全保护。</li>
<li>视图机制间接实现了支持存取谓词的用户权限定义。<br>[例]  建立计算机系学生的视图，把对该视图的SELECT权限授于王平，把该视图上的所有操作权限授于张明。<br>-先建立计算机系学生的视图CS_Student<br>CREATE VIEW CS_Student AS SELECT  *    FROM   Student    WHERE  Sdept&#x3D;’CS’；<br>-在视图上进一步定义存取权限：<br>GRANT  SELECT   ON   CS_Student TO 王平；<br>GRANT ALL PRIVILIGES     ON  CS_Student TO  张明</li>
</ul>
<h3 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h3><ul>
<li><p>审计</p>
<ul>
<li>系统自动建立审计日志，将用户对数据库的所有操作记录在上面。</li>
<li>DBA利用审计日志找出非法存取数据的人、时间和内容。</li>
<li>C2以上安全级别的DBMS必须具有。</li>
</ul>
</li>
<li><p>审计分类</p>
<p>–用户级审计：针对自己创建的数据库表或视图进行审计。<br>记录所有用户对这些表或视图的一切成功和（或）不成功的访问要求以及各种类型的SQL操作 。</p>
<p>–系统级审计：由DBA设置</p>
<ul>
<li><p>监测成功或失败的登录要求；</p>
</li>
<li><p>监测GRANT和REVOKE操作以及其他数据库级权限下的操作。</p>
</li>
</ul>
</li>
</ul>
<h4 id="审计AUDIT语句"><a href="#审计AUDIT语句" class="headerlink" title="审计AUDIT语句"></a>审计AUDIT语句</h4><ul>
<li><p>AUDIT语句：设置审计功能</p>
</li>
<li><p>NOAUDIT语句：取消审计功能</p>
</li>
</ul>
<h3 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h3><ol>
<li>思想<br>数据库中的数据以密码形式存放，使用时由用户设计的解码程序将其转换成用户可读的数据。这样，数据库中的数据即使被窃取，也只能是一些无法辨认的代码。</li>
<li>数据库加密：存储加密、传输加密</li>
<li>数据库加密在哪个层次实现？<ol>
<li>OS层</li>
<li>DBMS内核层</li>
<li>DBMS外层</li>
</ol>
</li>
</ol>
<h2 id="自主存取控制技术"><a href="#自主存取控制技术" class="headerlink" title="自主存取控制技术"></a>自主存取控制技术</h2><h3 id="自主存取控制"><a href="#自主存取控制" class="headerlink" title="自主存取控制"></a>自主存取控制</h3><p><strong>用户“自主”决定将数据的存取权限授予何人、决定是否将“授权”的权限授予别人，称为“自主存取控制”。</strong></p>
<ul>
<li>定义：用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可将其拥有的存取权限转授给其他用户。</li>
<li>用户权限组成要素 ：数据对象、操作类型</li>
<li>授权：定义用户可以在哪些数据库对象上进行哪些类型的操作。</li>
</ul>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/image-20200602200358779.png" style="zoom:67%;" />

<h3 id="授权与回收"><a href="#授权与回收" class="headerlink" title="授权与回收"></a>授权与回收</h3><p>SQL中使用GRANT语句和REVOKE语句来实现自主存取控制。</p>
<h4 id="GRANT语句"><a href="#GRANT语句" class="headerlink" title="GRANT语句"></a>GRANT语句</h4><ul>
<li><p>GRANT语句的一般格式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GRANT<span class="tag">&lt;<span class="name">权限</span>&gt;</span>[,<span class="tag">&lt;<span class="name">权限</span>&gt;</span>]...</span><br><span class="line">[ON<span class="tag">&lt;<span class="name">对象类型</span>&gt;</span> <span class="tag">&lt;<span class="name">对象名</span>&gt;</span>]</span><br><span class="line">TO<span class="tag">&lt;<span class="name">用户</span>&gt;</span>[,<span class="tag">&lt;<span class="name">用户</span>&gt;</span>]...</span><br><span class="line">[WITH GRANT OPTION];</span><br></pre></td></tr></table></figure>


</li>
<li><p>语义：将对指定操作对象的指定操作权限授予指定的用户</p>
<ul>
<li>授权人：DBA、数据库对象创建者、拥有该权限的用户</li>
<li>被授权限的用户： 一个或多个具体用户、PUBLIC（全体用户）</li>
<li>WITH GRANT OPTION子句：指定：可以再授予，没有指定：不能传播</li>
<li>不允许循环授权</li>
</ul>
</li>
</ul>
<h4 id="REVOKE语句"><a href="#REVOKE语句" class="headerlink" title="REVOKE语句"></a>REVOKE语句</h4><ul>
<li><p>授予的权限可以由DBA或其他授权者用REVOKE语句收回。</p>
</li>
<li><p>REVOKE语句的一般格式为：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REVOKE<span class="variable">&lt;权限&gt;</span>[,<span class="variable">&lt;权限&gt;</span>]...</span><br><span class="line">[ON<span class="variable">&lt;对象类型&gt;</span> <span class="variable">&lt;对象名&gt;</span>]</span><br><span class="line">FROM<span class="variable">&lt;用户&gt;</span>[,<span class="variable">&lt;用户&gt;</span>]...[CASCADE |<span class="string"> RESTRICT];</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="创建数据库模式的权限"><a href="#创建数据库模式的权限" class="headerlink" title="创建数据库模式的权限"></a>创建数据库模式的权限</h3><p>DBA在创建用户时，可以创建数据库模式的权限。</p>
<p>CREATE USER语句格式：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">USER</span>  &lt;username&gt; </span><br><span class="line">［<span class="keyword">WITH</span>］［DBA| RESOURCE| <span class="keyword">CONNECT</span>］</span><br></pre></td></tr></table></figure>

<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/image-20200602200936024.png" style="zoom:67%;" />

<h4 id="数据库角色"><a href="#数据库角色" class="headerlink" title="数据库角色"></a>数据库角色</h4><p>被命名的一组与数据库操作相关的权限</p>
<ul>
<li>角色是权限的集合</li>
<li>可以为一组具有相同权限的用户创建一个角色</li>
<li>简化授权的过程</li>
</ul>
<p>1、角色的创建</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE  <span class="keyword">ROLE</span>  <span class="title">&lt;角色名&gt; </span></span><br></pre></td></tr></table></figure>

<p>2、给角色授权</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT<span class="tag">&lt;<span class="name">权限</span>&gt;</span>［，<span class="tag">&lt;<span class="name">权限</span>&gt;</span>］... </span><br><span class="line">ON<span class="tag">&lt;<span class="name">对象类型</span>&gt;</span>对象名</span><br><span class="line">TO<span class="tag">&lt;<span class="name">角色</span>&gt;</span>［，<span class="tag">&lt;<span class="name">角色</span>&gt;</span>］...</span><br></pre></td></tr></table></figure>

<p>3、将一个角色授予其他的角色或用户</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT<span class="tag">&lt;<span class="name">角色1</span>&gt;</span>［，<span class="tag">&lt;<span class="name">角色2</span>&gt;</span>］...</span><br><span class="line">TO<span class="tag">&lt;<span class="name">角色3</span>&gt;</span>［，<span class="tag">&lt;<span class="name">用户1</span>&gt;</span>］... </span><br><span class="line">［WITH ADMIN OPTION］</span><br></pre></td></tr></table></figure>

<p>4、角色权限收回</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REVOKE<span class="tag">&lt;<span class="name">权限</span>&gt;</span>［，<span class="tag">&lt;<span class="name">权限</span>&gt;</span>］...</span><br><span class="line">ON<span class="tag">&lt;<span class="name">对象类型</span>&gt;</span> <span class="tag">&lt;<span class="name">对象名</span>&gt;</span></span><br><span class="line">FROM<span class="tag">&lt;<span class="name">角色</span>&gt;</span>［，<span class="tag">&lt;<span class="name">角色</span>&gt;</span>］...</span><br></pre></td></tr></table></figure>

<p>示例如下：</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/image-20200602201218195.png" style="zoom:67%;" />

<h3 id="自主存取控制缺点"><a href="#自主存取控制缺点" class="headerlink" title="自主存取控制缺点"></a>自主存取控制缺点</h3><ul>
<li>可能存在数据的“无意泄露”</li>
<li>原因：这种机制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记</li>
</ul>
<h2 id="强制存取控制机制"><a href="#强制存取控制机制" class="headerlink" title="强制存取控制机制"></a>强制存取控制机制</h2><p>对系统控制下的所有主客体赋予安全性标记，系统根据标记安全策略，实施强制存取控制</p>
<p>强制存取控制（MAC)</p>
<ul>
<li>保证更高程度的安全性</li>
<li>用户不能直接感知或进行控制</li>
<li>适用于对数据有严格而固定密级分类的部门<ul>
<li>军事部门</li>
<li>政府部门</li>
</ul>
</li>
</ul>
<h3 id="强制存取控制方法"><a href="#强制存取控制方法" class="headerlink" title="强制存取控制方法"></a>强制存取控制方法</h3><ul>
<li>主体是系统中的活动实体<ul>
<li>DBMS所管理的实际用户</li>
<li>代表用户的各进程</li>
</ul>
</li>
<li>客体是系统中的被动实体，是受主体操纵的<ul>
<li>文件、基表、索引、视图</li>
</ul>
</li>
<li>敏感度标记（Label）<ul>
<li>绝密（Top Secret）&gt;  机密（Secret）&gt;  可信（Confidential）&gt; 公开（Public）</li>
</ul>
</li>
<li>主体的敏感度标记称为许可证级别（Clearance Level）</li>
<li>客体的敏感度标记称为密级（Classification Level）</li>
<li>强制存取控制就是通过对比主体的许可证级别和客体的密级，最终确定主体能否存取客体。</li>
</ul>
<p><strong>主体可更新密级高于他的客体</strong></p>
<h3 id="强制存取控制规则"><a href="#强制存取控制规则" class="headerlink" title="强制存取控制规则"></a>强制存取控制规则</h3><ul>
<li>强制存取控制规则：<ol>
<li>仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体</li>
<li>仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体</li>
</ol>
</li>
<li>规则的关键点：<br><strong>禁止拥有高许可证级别的主体更新低密级的数据对象</strong></li>
</ul>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/image-20200602201608002.png" style="zoom:80%;" />

<h3 id="强制存取控制的优点"><a href="#强制存取控制的优点" class="headerlink" title="强制存取控制的优点"></a>强制存取控制的优点</h3><ul>
<li>禁止拥有高许可证级别的主体更新低密级的数据对象，从而保证了敏感数据的可靠性；</li>
<li>禁止低许可证级别的主体浏览高密级的数据，避免了敏感数据的泄漏；</li>
<li>MAC对数据本身进行密级标记，无论数据如何复制，标记与数据是不可分割的整体。只有符合密级标记要求的用户才可以操作相应数据，提高了安全性级别。</li>
</ul>
<h3 id="强制存取控制方法-1"><a href="#强制存取控制方法-1" class="headerlink" title="强制存取控制方法"></a>强制存取控制方法</h3><ul>
<li>DAC与MAC共同构成DBMS的安全机制</li>
<li>实现MAC时要首先实现DAC<ul>
<li>原因：较高安全性级别提供的安全保护要包含较低级别的所有保护</li>
</ul>
</li>
<li>先进行DAC检查，通过DAC检查的数据对象再由系统进行MAC检查，只有通过MAC检查的数据对象方可存取。</li>
</ul>
<p>数据库安全机制的设计目标：试图破坏安全的人所花费的代价 &gt;&gt; 得到的利益</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">数据库_关系数据库SQL语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-01 11:12:12" itemprop="dateCreated datePublished" datetime="2020-04-01T11:12:12Z">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SQL语言概述"><a href="#SQL语言概述" class="headerlink" title="SQL语言概述"></a>SQL语言概述</h1><p>SQL语言是面向集合的非过程化的语言。是介于关系代数和关系演算之间的标准查询语言。</p>
<p>集数据定义语言DDL、数据操纵语言DML、数据控制语言DCL功能于一体。</p>
<p>核心功能：9个动词</p>
<ul>
<li><p>数据查询：SELECT（最为复杂的操作）</p>
</li>
<li><p>数据定义：CREATE（创建）、DROP（删除）、ALTER（更新）</p>
</li>
<li><p>数据操纵DML：INSERT、UPDATE、DELETE</p>
</li>
<li><p>数据控制DCL：GRANT（授权）、REVOKE（撤销，回收权限）</p>
</li>
<li><p>基本概念：</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/20220421104803.png"></p>
</li>
</ul>
<h1 id="数据定义概述"><a href="#数据定义概述" class="headerlink" title="数据定义概述"></a>数据定义概述</h1><p>数据定于语言DDL：是SQL中提供给用户定义DBMS支持的抽象对象的SQL语句。</p>
<p>DBMS支持4种抽象对象：模式、表、视图、索引</p>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/20220421104825.png"></p>
<p>一个RDBMS的实例中，可建立多个数据库；</p>
<p>一个数据库中可以建立多个外模式，只有一个内模式；</p>
<p>一个模式下可以建立多个表、视图和索引等数据库对象</p>
<h2 id="基本表的定义、修改和删除"><a href="#基本表的定义、修改和删除" class="headerlink" title="基本表的定义、修改和删除"></a>基本表的定义、修改和删除</h2><h3 id="定义基本表"><a href="#定义基本表" class="headerlink" title="定义基本表"></a>定义基本表</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE<span class="tag">&lt;<span class="name">表名</span>&gt;</span>（<span class="tag">&lt;<span class="name">列名</span>&gt;</span> <span class="tag">&lt;<span class="name">数据类型</span>&gt;</span>[ <span class="tag">&lt;<span class="name">列级完整性约束条件</span>&gt;</span> ][，<span class="tag">&lt;<span class="name">列名</span>&gt;</span> <span class="tag">&lt;<span class="name">数据类型</span>&gt;</span>[ <span class="tag">&lt;<span class="name">列级完整性约束条件</span>&gt;</span>]]...[，<span class="tag">&lt;<span class="name">表级完整性约束条件</span>&gt;</span> ]）；</span><br></pre></td></tr></table></figure>

<p>可以加多个列级完整性约束条件。</p>
<p><strong>根据已有的表创建新表：</strong><br><strong>A：create table tab_new like tab_old (使用旧表创建新表)</strong><br><strong>B：create table tab_new as select col1,col2… from tab_old definition only</strong></p>
<h4 id="模式和表"><a href="#模式和表" class="headerlink" title="模式和表"></a>模式和表</h4><ul>
<li>每一个基本表都属于某一个模式，一个模式包含多个基本表</li>
<li>定义基本表所属模式：<ul>
<li>方法一：在表名中明显地给出模式名<br>CREATE TABLE S-T.Student（……）; &#x2F;<em>模式名为S-T</em>&#x2F;</li>
<li>方法二：在创建模式语句中同时创建表<br>CREATE SCHEMA S-T AUTHORIZATION WANG<br>CREATE TABLE  Student（……）;</li>
</ul>
</li>
</ul>
<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>&lt;表名&gt;</span><br><span class="line">[ <span class="keyword">ADD</span>&lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ]  ]</span><br><span class="line">[ <span class="keyword">DROP</span>[<span class="keyword">COLUMN</span>]&lt;列名&gt; [<span class="keyword">CASCADE</span>|<span class="keyword">RESTRICT</span>]]</span><br><span class="line">[<span class="keyword">ADD</span>&lt;表级完整性约束名&gt; ] </span><br><span class="line">[<span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span>&lt;完整性约束名&gt; [<span class="keyword">CASCADE</span>|<span class="keyword">RESTRICT</span>]] </span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span>&lt;列名&gt; &lt;数据类型&gt; ]；</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;新增加的列一律为空值。</p>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> &lt;表名&gt;［<span class="keyword">RESTRICT</span>| <span class="keyword">CASCADE</span>］;</span><br></pre></td></tr></table></figure>

<p>RESTRICT：删除表是有限制的。欲删除的基本表不能被其他表的约束所引用，如果存在依赖该表的对象，则此表不能被删除</p>
<p>CASCADE：删除该表没有限制。在删除基本表的同时，相关的依赖对象一起删除</p>
<h1 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h1><p>基本语法：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">SELECT</span> <span class="built_in">A1</span>,<span class="built_in">A2</span>··· FROM <span class="built_in">R1</span>,<span class="built_in">R2</span>··· WHERE F</span><br></pre></td></tr></table></figure>

<p>这里R1,…,Rm为关系，F是公式，A1,…,An为属性。</p>
<p>完整语法：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>[<span class="keyword">ALL</span>|<span class="keyword">DISTINCT</span>]&lt;目标列表达式&gt;[，&lt;目标列表达式&gt;]...</span><br><span class="line"><span class="keyword">FROM</span> &lt;表名或视图名&gt;[，&lt;表名或视图名&gt; ] ...</span><br><span class="line">[<span class="keyword">WHERE</span>&lt;条件表达式&gt;]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span>&lt;列名<span class="number">1</span>&gt;[<span class="keyword">HAVING</span>&lt;条件表达式&gt;] ]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span>&lt;列名<span class="number">2</span>&gt;[ <span class="keyword">ASC</span>|<span class="keyword">DESC</span> ] ]；</span><br></pre></td></tr></table></figure>

<ul>
<li>SELECT子句，投影运算，选择表中的若干列；</li>
<li>WHERE子句，行筛选条件，选择表中的若干行；</li>
<li>GROUP子句，分组运算；</li>
<li>HAVING子句，分组条件；</li>
<li>ORDER子句，排序计算。</li>
</ul>
<p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/20220421104843.png"></p>
<h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><ul>
<li><p>消除重复元组Distinct</p>
</li>
<li><p>where子句：如何从表中选择指定元组？</p>
<ul>
<li><p>对应于关系代数运算σ<del>P</del>，SQL提供WHERE子句解决表元组的选择。</p>
</li>
<li><p>格式：WHERE &lt;条件表达式&gt;【&lt;条件表达式&gt;是包含属性名的逻辑表达式P】</p>
</li>
<li><p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/20220421104857.png"></p>
</li>
<li><p>范围查询：</p>
<ul>
<li>比较运算符：&#x3D;、&lt;、&gt;、&gt;&#x3D;、&lt;&#x3D;、!&#x3D;、&lt;&gt;、!&gt;、!</li>
<li>&lt;确定范围：BETWEEN …  AND  …NOT BETWEEN  …  AND  …</li>
</ul>
</li>
<li><p>集合查询：</p>
<ul>
<li>x IN &lt;值表&gt;,  x NOT IN &lt;值表&gt;</li>
</ul>
</li>
<li><p>字符匹配查询：</p>
<ul>
<li><p>[NOT]LIKE‘&lt;匹配串&gt;’[ESCAPE‘ &lt;换码字符&gt;’]</p>
<p>查找指定的属性列值与&lt;匹配串&gt;相匹配的元组。&lt;匹配串&gt;可以是一个完整的字符串，也可以含有通配符。<br>通配符：SQL规定符号百分号%及下划线__ 具有其他含义:<br>百分号%：代表任意长度的字符串<br>下划线__ ：代表任意一个字符<br>ESCAPE：是将百分号% 或下划线__转回其本意</p>
</li>
</ul>
</li>
<li><p>涉及空值查询：</p>
<ul>
<li>IS NULL 或IS NOT NULL</li>
</ul>
</li>
<li><p>多重条件查询：</p>
<ul>
<li>逻辑运算符：AND和OR可以用来将多个简单查询条件复合成更加复杂的条件</li>
<li>优先级：NOT&gt;AND&gt;OR</li>
</ul>
</li>
</ul>
</li>
<li><p>Order By子句：将查询结果的元组按照一个或多个属性列的排列次序显示</p>
<ul>
<li>格式：SELECT 块 ORDER BY 子句；<br>其中，ORDER BY子句可以按一个或多个属性列排序；<br>每列可选择：升序：ASC；降序：DESC；缺省值为升序</li>
</ul>
</li>
</ul>
<h3 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h3><p>函数只是将取出的数据进行处理，不会改变数据库中的值。</p>
<h4 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h4><p>1、字符函数</p>
<table>
<thead>
<tr>
<th align="center">函 数</th>
<th>功 能</th>
<th>示 例</th>
<th>结 果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">INITCAP  (char)</td>
<td>首字母大写</td>
<td>initcap  (‘hello’)</td>
<td>Hello</td>
</tr>
<tr>
<td align="center">LOWER  (char)</td>
<td>转换为小写</td>
<td>lower (‘FUN’)</td>
<td>fun</td>
</tr>
<tr>
<td align="center">UPPER  (char)</td>
<td>转换为大写</td>
<td>upper (‘sun’)</td>
<td>SUN</td>
</tr>
<tr>
<td align="center">LTRIM  (char, set)</td>
<td>左剪裁</td>
<td>ltrim (‘xyzadams’,  ‘xyz’)</td>
<td>adams</td>
</tr>
<tr>
<td align="center">RTRIM  (char, set)</td>
<td>右剪裁</td>
<td>rtrim (‘xyzadams’,  ‘ams’)</td>
<td>xyzad</td>
</tr>
<tr>
<td align="center">TRANSLATE  (char, from, to)</td>
<td>按字符翻译</td>
<td>translate (‘jack’, ‘abcd’,  ‘1234’)</td>
<td>j13k</td>
</tr>
<tr>
<td align="center">REPLACE  (char, search_str, replace_str)</td>
<td>字符串替换</td>
<td>replace (‘jack andjue’,  ‘j’, ‘bl’)</td>
<td>black and blue</td>
</tr>
<tr>
<td align="center">INSTR  (char, substr[, pos])</td>
<td>查找子串位置</td>
<td>instr  (‘worldwide’, ‘d’)</td>
<td>5</td>
</tr>
<tr>
<td align="center">SUBSTR  (char, pos, len)</td>
<td>取子字符串</td>
<td>substr  (‘abcdefg’,3,2)</td>
<td>cd</td>
</tr>
<tr>
<td align="center">CONCAT  (char1, char2)</td>
<td>连接字符串</td>
<td>concat  (‘Hello’, ‘world’)</td>
<td>Helloworld</td>
</tr>
</tbody></table>
<h4 id="多行函数"><a href="#多行函数" class="headerlink" title="多行函数"></a>多行函数</h4><p>1、SQL支持聚集函数来解决求集合特征值问题：如该集合的个数、最小值等</p>
<p><strong>集函数只能用于SELECT子句和HAVING子句中</strong></p>
<p>2、GROUP BY子句：将一个查询结果集合进行分组</p>
<ul>
<li>GROUP BY A1，A2，…,An（其中：Ai为属性名）【按指定的一列或多列，对一个SELECT块按值分组，值相等的为一组】</li>
</ul>
<p>3、HAVING子句：使用限定条件选择部分分组，则可以使用HAVING子句</p>
<p><strong>注意：HAVING短语与WHERE子句的区别：</strong><br><strong>– WHERE子句作用于基表或视图，从中选择满足条件的元组</strong><br><strong>– HAVING短语作用于组，从中选择满足条件的组。</strong></p>
<h2 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a>多表连接查询</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SQL1999规范中规定的连接查询语法</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 字段列表</span><br><span class="line"><span class="keyword">from</span> table1</span><br><span class="line">[<span class="keyword">cross</span> <span class="keyword">join</span> table2] |                                    //<span class="number">1</span>：交叉连接</span><br><span class="line">[<span class="keyword">natural</span> <span class="keyword">join</span> table2] |                                  //<span class="number">2</span>：自然连接</span><br><span class="line">[<span class="keyword">join</span> table2 <span class="keyword">using</span> (字段名)] |                      //<span class="number">3</span>：<span class="keyword">using</span>子句</span><br><span class="line">[<span class="keyword">join</span> table2 <span class="keyword">on</span> (table1.<span class="built_in">column_name</span> </span><br><span class="line">	= table2.<span class="built_in">column_name</span>)] |      //<span class="number">4</span>：<span class="keyword">on</span>子句</span><br><span class="line">[(left | right | <span class="keyword">full</span> <span class="keyword">outer</span>) <span class="keyword">join</span> table2</span><br><span class="line"><span class="keyword">on</span> (table1.<span class="built_in">column_name</span> = table2.<span class="built_in">column_name</span>)]; //<span class="number">5</span>：左/右/满外连接</span><br></pre></td></tr></table></figure>

<ul>
<li>合并：FROM</li>
<li>选择：WHERE</li>
<li>投影：SELECT</li>
</ul>
<h2 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h2><p>两种连接表示方法：</p>
<p>1、在FROM子句中指明进行连接的表名，在WHERE子句中指明连接的列名及其连接条件</p>
<p>2、利用关键字JOIN进行连接，通过关键词ON与JOIN相对应，指明连接条件。具体分为以下几种：</p>
<h3 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h3><ul>
<li>Cross join产生了一个笛卡尔集，其效果等同于在两个表进行连接时未使用WHERE子句限定连接条件;</li>
<li>可以使用where条件从笛卡尔集中选出满足条件的记录。</li>
</ul>
<p>用法举例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="operator">!</span><span class="comment">--两张表连接--&gt;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp,dept </span><br><span class="line">	<span class="keyword">where</span> emp.deptno<span class="operator">=</span>dept.deptno</span><br><span class="line"><span class="comment">--等价于</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">cross</span> <span class="keyword">join</span> dept</span><br><span class="line">	<span class="keyword">where</span> emp.deptno<span class="operator">=</span>dept.deptno</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">!</span><span class="comment">--三张表连接--&gt;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp,dept,salgrade </span><br><span class="line">	<span class="keyword">where</span> emp.deptno<span class="operator">=</span>dept.deptno <span class="keyword">and</span></span><br><span class="line">	(emp.sal<span class="operator">&gt;</span>salgrade.lostl <span class="keyword">and</span> emp.sal<span class="operator">&lt;</span>salgrade.hisal)</span><br><span class="line"><span class="comment">--等价于</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp &quot;E&quot; </span><br><span class="line">	<span class="keyword">cross</span> <span class="keyword">join</span> dept &quot;D&quot; </span><br><span class="line">	<span class="keyword">cross</span> <span class="keyword">join</span> salgrade &quot;S&quot;</span><br><span class="line">	<span class="keyword">where</span> &quot;E&quot;.deptno<span class="operator">=</span>&quot;D&quot;.deptno <span class="keyword">and</span></span><br><span class="line">	(&quot;E&quot;.sal<span class="operator">&gt;</span>&quot;S&quot;.lostl <span class="keyword">and</span> &quot;E&quot;.sal<span class="operator">&lt;</span>&quot;S&quot;.hisal)</span><br></pre></td></tr></table></figure>

<h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><ul>
<li>Natural join基于两个表中的全部同名列建立连接（连接两个table之后，两个table共用的属性就会合并在一起）</li>
<li>如果连个table没有共有的属性，则进行笛卡尔乘积，也就是进行两两相乘，如果table 1有3行，table 2有4行，自然连接后就有12行。<ul>
<li>从两个表中选出同名列的值均对应相等的所有行</li>
<li>如果两个表中同名列的数据类型不同，则出错</li>
<li>不允许在参照列上使用表名或者别名作为前缀</li>
<li>自然连接的结果不保留重复的属性</li>
</ul>
</li>
</ul>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> empno, ename, sal, deptno, dname</span><br><span class="line"><span class="keyword">from</span> emp <span class="keyword">natural</span> <span class="keyword">join</span> dept</span><br><span class="line"><span class="keyword">where</span> deptno <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Using子句"><a href="#Using子句" class="headerlink" title="Using子句"></a>Using子句</h3><blockquote>
<p>using等价于join操作中的on</p>
</blockquote>
<ul>
<li><p>使用using必须满足如下两个条件：</p>
<ol>
<li><p>查询必须是等值连接。</p>
</li>
<li><p>等值连接中的列必须具有相同的名称和数据类型。</p>
</li>
</ol>
</li>
<li><p>using子句引用的列在sql任何地方不能使用表名或者别名做前缀。</p>
</li>
<li><p>可以在using子句中指定多个列名</p>
</li>
</ul>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> my_test_user a , my_test_teacher b <span class="keyword">where</span> a.userid <span class="operator">=</span> b.userid;</span><br><span class="line"><span class="operator">=</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> my_test_user <span class="keyword">inner</span> <span class="keyword">join</span> my_test_teacher <span class="keyword">using</span>(userid);</span><br></pre></td></tr></table></figure>

<h3 id="join连接"><a href="#join连接" class="headerlink" title="join连接"></a>join连接</h3><p><img src="https://picture11111111.oss-cn-hangzhou.aliyuncs.com/img/20220421161942.png" alt="img"></p>
<ul>
<li>INNER JOIN：返回符合连接条件的记录；</li>
<li>LEFT [OUTER] JOIN：返回符合连接条件的数据行以及左边表中不符合条件的数据行，此时右边数据行以NULL来显示，称为左连接；</li>
<li>RIGHT  [OUTER]  JOIN：返回符合连接条件的数据行以及右边表中不符合条件的数据行，此时左边数据行以NULL来显示，称为右连接；</li>
<li>FULL  [OUTER]  JOIN：返回符合连接条件的数据行以及左边表和右边表中不符合条件的数据行，此时缺乏数据的数据行会以NULL来显示</li>
</ul>
<h3 id="on子句"><a href="#on子句" class="headerlink" title="on子句"></a>on子句</h3><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><p>LEFT  JOIN、RIGHT  JOIN与  FULL  JOIN统称为外连接。可用来显示不满足连接条件的元组。某些查询要求只能用外连接来表达</p>
<h2 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h2><p>一个SELECT-FROM-WHERE语句称为一个查询块；将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询，相当于在SELECT中调用另一段SELECT。</p>
<ul>
<li><strong>子查询不能使用ORDER BY子句；</strong></li>
<li><strong>层层嵌套方式反映了SQL语言的结构化；</strong></li>
<li><strong>有些嵌套查询可以用连接运算替代</strong></li>
<li>AS的作用是起别名</li>
</ul>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><ul>
<li>特点<ul>
<li>子查询在主查询前执行一次</li>
<li>主查询使用子查询的结果</li>
</ul>
</li>
<li><strong>使用子查询注意事项</strong><ul>
<li>在查询是基于未知值时应考虑使用子查询</li>
<li>子查询必须包含在括号内 </li>
<li>建议将子查询放在比较运算符的右侧，以增强可读性。</li>
<li>除非进行Top-N 分析，否则不要在子查询中使用ORDER BY 子句。</li>
<li>如果子查询返回单行结果，则为单行子查询，可以在主查询中对其使用相应的单行记录比较运算符</li>
<li>如果子查询返回多行结果，则为多行子查询，此时不允许对其使用单行记录比较运算符</li>
</ul>
</li>
</ul>
<h4 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a>单行子查询</h4><ul>
<li>单行子查询只返回一行记录</li>
<li>对单行子查询可使用单行记录比较运算符</li>
<li>&lt; 、 &gt; 、 &#x3D; 、 &gt;&#x3D;、 &lt;&#x3D; 、 &lt;&gt;</li>
</ul>
<h4 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a>多行子查询</h4><ul>
<li><p>多行子查询返回多行记录</p>
</li>
<li><p>对多行子查询只能使用多行记录比较运算符</p>
<ul>
<li>ALL 和子查询返回的所有值比较</li>
<li>ANY 和子查询返回的任意一个值比较</li>
<li>IN 等于列表中的任何一个</li>
</ul>
</li>
</ul>
<h4 id="带EXISTS谓词的子查询"><a href="#带EXISTS谓词的子查询" class="headerlink" title="带EXISTS谓词的子查询"></a>带EXISTS谓词的子查询</h4><p>EXISTS：本质上是一个返回值为“真”&#x2F;“假”的集函数，用于判断一个集合是否为空。<br>EXISTS（R），R为非空则返回真。</p>
<p>NOT EXISTS：语义与EXISTS函数相反的逻辑函数。</p>
<p>带EXISTS的子查询的用法：</p>
<p>1.不同形式的查询间的替换:带IN谓词、比较运算符、ANY和ALL谓词的子查询 与 带EXISTS谓词的子查询 等价替换</p>
<p>2.用EXISTS&#x2F;NOT EXISTS实现全称量词(难点)</p>
<p>3.用EXISTS&#x2F;NOT EXISTS实现逻辑蕴函(难点)</p>
<p>作用：<strong>把带有全称量词的谓词转换为等价的带有存在量词的谓词</strong></p>
<h1 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO <span class="variable">&lt;表名&gt;</span> [(<span class="variable">&lt;属性列1&gt;</span>[,<span class="variable">&lt;属性列2&gt;</span>]...)]</span><br><span class="line">VALUES （<span class="variable">&lt;常量1&gt;</span>[,<span class="variable">&lt;常量2&gt;</span>]....）</span><br><span class="line">|<span class="string"> SELECT子查询；</span></span><br></pre></td></tr></table></figure>

<p>INTO子句 属性列的顺序可与表定义中的顺序不一致，可以不指定或指定部分属性列</p>
<p>VALUES子句 提供的值必须与INTO子句匹配</p>
<h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE<span class="tag">&lt;<span class="name">表名</span>&gt;</span> </span><br><span class="line">SET<span class="tag">&lt;<span class="name">列名</span>&gt;</span>=<span class="tag">&lt;<span class="name">表达式</span>&gt;</span>[, <span class="tag">&lt;<span class="name">列名</span>&gt;</span>=<span class="tag">&lt;<span class="name">表达式</span>&gt;</span>]...</span><br><span class="line">[WHERE<span class="tag">&lt;<span class="name">条件</span>&gt;</span>]；</span><br></pre></td></tr></table></figure>

<p>SET子句给出&lt;表达式&gt;的值用于取代相应的属性列值。</p>
<p>省略WHERE子句，则表示要修改表中的所有元组。</p>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> </span><br><span class="line"><span class="keyword">FROM</span>&lt;表名&gt;</span><br><span class="line">[<span class="keyword">WHERE</span>&lt;条件&gt;]；</span><br></pre></td></tr></table></figure>

<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><ul>
<li>视图的特点：<ul>
<li>是从一个或几个基本表（或视图）导出的表，是虚表</li>
<li>数据库只存放视图的定义，不存放视图对应的数据</li>
<li>基表中的数据发生变化，从视图中查询出的数据也随之改变</li>
</ul>
</li>
<li>基于视图的操作：<ul>
<li>查询</li>
<li>删除</li>
<li>定义基于该视图的新视图</li>
<li>受限更新</li>
</ul>
</li>
</ul>
<h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><p>创建视图语句格式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE  VIEW <span class="tag">&lt;<span class="name">视图名</span>&gt;</span>  [(<span class="tag">&lt;<span class="name">列名</span>&gt;</span>  [，<span class="tag">&lt;<span class="name">列名</span>&gt;</span>]...)]</span><br><span class="line">AS<span class="tag">&lt;<span class="name">子查询</span>&gt;</span></span><br><span class="line">[WITH  CHECKOPTION]；</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li>组成视图的属性列名：全部省略或全部指定</li>
<li>子查询是否可含有ORDER BY子句和DISTINCT短语，取决于具体系统的实现。</li>
<li>WITH CHECK OPTION表示对视图进行增删改时要保证删除、插入、更新的行满足视图定义中的谓词条件（即子查询中的条件表达式）。</li>
</ul>
<h2 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h2><p>删除视图语句格式：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span>  <span class="keyword">VIEW</span>  &lt;视图名&gt; [<span class="keyword">CASCADE</span>]；</span><br></pre></td></tr></table></figure>

<p>从数据字典中删除指定的视图定义。</p>
<ul>
<li>如果该视图上还导出了其他视图，使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除</li>
<li>删除基表时，由该基表导出的所有视图定义都必须显式删除</li>
</ul>
<h2 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h2><p>RDBMS采用视图消解法实现视图查询。</p>
<h2 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h2><p>视图不实际存储数据，因此，对视图的更新最终要转换为对基本表的更新。为防止用户通过视图更新，对不属于视图范围内的基本表数据进行更新操作，在定义视图时加上WITH   CHECK   OPTION操作。</p>
<ul>
<li>一般RDBMS允许对行列子集视图进行更新</li>
<li>对其他类型视图的更新不同系统有不同限制</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>视图能够简化用户的操作</li>
<li>视图使用户能以多种角度看待同一数据</li>
<li>视图对重构数据库提供了一定程度的逻辑独立性</li>
<li>视图能够对机密数据提供安全保护</li>
<li>适当的利用视图可以更清晰的表达查询</li>
</ul>
<h1 id="key、index、primary-key和unique-key"><a href="#key、index、primary-key和unique-key" class="headerlink" title="key、index、primary key和unique key"></a>key、index、primary key和unique key</h1><p>[参考文章](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zjfjava/p/6922494.html">https://www.cnblogs.com/zjfjava/p/6922494.html</a></p>
<h1 id="SQL-约束（Constraints）"><a href="#SQL-约束（Constraints）" class="headerlink" title="SQL 约束（Constraints）"></a>SQL 约束（Constraints）</h1><p>SQL 约束用于规定表中的数据规则。</p>
<p>如果存在违反约束的数据行为，行为会被约束终止。</p>
<p>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</p>
<h1 id="SQL-CREATE-TABLE-CONSTRAINT-语法"><a href="#SQL-CREATE-TABLE-CONSTRAINT-语法" class="headerlink" title="SQL CREATE TABLE + CONSTRAINT 语法"></a>SQL CREATE TABLE + CONSTRAINT 语法</h1><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name</span><br><span class="line">(</span><br><span class="line">column_name1 data<span class="constructor">_type(<span class="params">size</span>)</span> constraint_name,</span><br><span class="line">column_name2 data<span class="constructor">_type(<span class="params">size</span>)</span> constraint_name,</span><br><span class="line">column_name3 data<span class="constructor">_type(<span class="params">size</span>)</span> constraint_name,</span><br><span class="line">....</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在 SQL 中，我们有如下约束：</p>
<ul>
<li><strong>NOT NULL</strong> - 指示某列不能存储 NULL 值。</li>
<li><strong>UNIQUE</strong> - 保证某列的每行必须有唯一的值。</li>
<li><strong>PRIMARY KEY</strong> - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>
<li><strong>FOREIGN KEY</strong> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li>
<li><strong>CHECK</strong> - 保证列中的值符合指定的条件。</li>
<li><strong>DEFAULT</strong> - 规定没有给列赋值时的默认值。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">数据库_关系数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-01 11:11:23" itemprop="dateCreated datePublished" datetime="2020-04-01T11:11:23Z">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="关系模型概述"><a href="#关系模型概述" class="headerlink" title="关系模型概述"></a>关系模型概述</h1><p>关系数据理论是建立在<strong>集合代数理论基础上</strong>的，有着坚实的数学基础</p>
<ul>
<li>数据结构：二维表</li>
<li>关系操作：<ul>
<li>增加(insert)、删除(delete)、修改(updated)</li>
<li>查询(Query):•选择(select)、投影(project)、连接(join)<ul>
<li>除(divide)、并(union)、交(intersection)</li>
<li>差(difference)</li>
</ul>
</li>
<li>关系代数，关系演算，SQL</li>
</ul>
</li>
<li>关系的三类完整性约束：<ul>
<li>实体完整性、参照完整性、用户自定义的完整性</li>
</ul>
</li>
</ul>
<blockquote>
<p>关系代数是用对关系的运算来表达查询要求的方式。</p>
<p>关系演算是用谓词表达查询要求的方式。</p>
<ul>
<li>按谓词变元的基本对象是元组变量还是域变量分为元组关系演算和域关系演算</li>
</ul>
</blockquote>
<h2 id="关系数据结构"><a href="#关系数据结构" class="headerlink" title="关系数据结构"></a>关系数据结构</h2><ul>
<li><p>域</p>
<ul>
<li>域是一组具有相同数据类型的值的集合</li>
</ul>
</li>
<li><p>笛卡儿积</p>
<ul>
<li><p>一组域D<del>1</del> , D<del>2</del> ,…, D<del>n</del>的笛卡尔积为：D<del>1</del>×D<del>2</del>×…×D<del>n</del>&#x3D; {(d<del>1</del> , d<del>2</del> , … , d<del>n</del>) | d<del>i</del>∈D<del>i</del>, i&#x3D;1,…,n}</p>
</li>
<li><p>笛卡尔积的每个元素(d<del>1</del> , d<del>2</del> , … , d<del>n</del>)称作一个n-元组（n-tuple）</p>
</li>
<li><p>元组的每一个值d<del>i</del>叫做一个分量（Component）</p>
</li>
<li><p>若D<del>i</del>的基数（元组个数）为m<del>i</del>，则笛卡尔积的基数为<br>$$<br>\prod^n_{i&#x3D;1}m_i<br>$$</p>
<blockquote>
<p>一个域允许的不同取值个数称为这个域的基数</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>笛卡儿积可以表示成一张二维表。表中的每行对应一个元组，表中的每一列的值来自一个域。</p>
<ul>
<li><p>关系</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200401153303890.png" style="zoom:50%;" />

<ul>
<li><p>笛卡尔积D<del>1</del>×D<del>2</del>×…×D<del>n</del>的子集叫做在域D<del>1</del> , D<del>2</del> ,…, D<del>n</del>上的关系，用R(D<del>1</del> , D<del>2</del> ,…, D<del>n</del>)表示</p>
</li>
<li><p>R是关系的名字，n是关系的度或目</p>
<blockquote>
<p>当n&#x3D;1时，称该关系为单元关系</p>
</blockquote>
</li>
<li><p>关系是笛卡尔积中有意义的子集，关系中的每个元素是关系中的元组</p>
<blockquote>
<p>一般来说，笛卡儿积是没有实际语义的，只有它的某个真子集才有实际含义</p>
</blockquote>
</li>
<li><p>关系也可以表示为二维表</p>
</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li>关系中不同列可以对应相同的域，为了加以区分，必须对每列起一个名字，称为属性</li>
<li>n目关系必有n个属性</li>
</ul>
</li>
</ul>
<h3 id="关系数据结构-1"><a href="#关系数据结构-1" class="headerlink" title="关系数据结构"></a>关系数据结构</h3><p>关系的性质</p>
<ul>
<li>列是同质的；即每一列中的分量是同一类型的数据，来自同一个域。</li>
<li>行列的顺序无关紧要；行列的次序是可以任意交换的</li>
<li>任意两个元组不能完全相同</li>
<li>每一分量必须是不可再分的数据</li>
<li>不同的属性，属性名不能相同</li>
</ul>
<p>候选码（Candidate Key）</p>
<ul>
<li><strong>关系中的一个属性组，其值能唯一标识一个元组</strong>。若从属性组中去掉任何一个属性，它就不具有这一性质了，这样的属性组称作候选码如DEPT中的D#，DN都可作为候选码</li>
<li>任何一个候选码中的属性称作主属性如SC中的S#，C#</li>
</ul>
<p>主码（Primary Key）</p>
<ul>
<li>若一个关系有多个候选码，则选定其中一个作为主码如可选定D#作为DEPT的主码</li>
</ul>
<p>外码（Foreign Key）</p>
<ul>
<li>关系R中的一个属性组，它不是R的码，但它与另一个关系S的码相对应，则称这个属性组为R的外码<br>如S关系中的D#属性</li>
</ul>
<h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><p>形式化的表示为R(U,D,DOM,F)</p>
<blockquote>
<p>R为关系名，U为组成该关系的属性名集合；D为U中属性所来自的域；DOM为属性向域的映象集合；F为属性间数据的依赖关系集合。</p>
</blockquote>
<ul>
<li>关系的描述称作关系模式，包括关系名、关系中的属性名、属性向域的映象、属性间的数据依赖关系等，记作R(A<del>1</del> , A<del>2</del> ,…, A<del>n</del> ) </li>
<li>属性向域的映象一般直接说明为属性的类型、长度等</li>
<li>某一时刻对应某个关系模式的内容(元组的集合)称作关系</li>
<li>关系模式是型，是稳定的<br>关系是某一时刻的值，是随时间不断变化的</li>
</ul>
<h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><ul>
<li><p>其型是关系模式的集合，即数据库描述，称作数据库的内涵(Intension)，或关系数据库模式</p>
</li>
<li><p>其值是某一时刻关系的集合，称作数据库的外延(Extension)，或关系数据库</p>
</li>
</ul>
<h2 id="关系的完整性约束"><a href="#关系的完整性约束" class="headerlink" title="关系的完整性约束"></a>关系的完整性约束</h2><h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><ul>
<li>关系的主码中的属性值不能为空值</li>
<li>空值：不知道或无意义</li>
<li>意义：关系对应到现实世界中的实体集，元组对应到实体，实体是相互可区分的，通过主码来唯一标识，若主码为空，则出现不可标识的实体，这是不容许的</li>
</ul>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><ul>
<li>如果关系R<del>2</del>的外码F<del>k</del>与关系R<del>1</del>的主码P<del>k</del>相对应，则R<del>2</del>中的每一个元组的F<del>k</del>值或者等于R<del>1</del> 中某个元组的P<del>k</del>值，或者为空值【即属性Fk本身不是主属性，则可以取空值，否则不能取空值。】</li>
<li>意义：如果关系R<del>2</del>的某个元组t<del>2</del>参照了关系R<del>1</del>的某个元组t<del>1</del>，则t<del>1</del>必须存在</li>
<li>例如：关系S在D#上的取值有两种可能<ul>
<li>空值，表示该学生尚未分到任何系中</li>
<li>若非空值，则必须是DEPT关系中某个元组的D#值，表示该学生不可能分到一个不存在的系中<br>DEPT(D#, DN , DEAN)S(S#, SN , SEX , AGE , D#)</li>
</ul>
</li>
</ul>
<h3 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h3><ul>
<li><p>用户定义的完整性</p>
<ul>
<li><p>用户针对具体的应用环境定义的完整性约束条件</p>
</li>
<li><p>如S#要求是8位整数，SEX要求取值为“男”或“女”</p>
</li>
</ul>
</li>
<li><p>系统支持</p>
<ul>
<li>实体完整性和参照完整性由系统自动支持</li>
<li>系统应提供定义和检验用户定义的完整性的机制</li>
</ul>
</li>
</ul>
<h1 id="关系代数概述"><a href="#关系代数概述" class="headerlink" title="关系代数概述"></a>关系代数概述</h1><ul>
<li>属于关系操作的一种</li>
<li>关系代数是一种抽象的查询语言</li>
<li>通过对关系的运算来表达查询操作</li>
<li>运算对象、结果均为关系</li>
<li>运算包括四类：<ul>
<li>集合运算、关系运算、比较运算、逻辑运算</li>
</ul>
</li>
</ul>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><h3 id="并运算"><a href="#并运算" class="headerlink" title="并运算"></a>并运算</h3><ul>
<li><p>所有至少出现在两个关系中之一的元组集合</p>
</li>
<li><p>两个关系R和S若进行并运算，则它们必须是相容的:</p>
<ul>
<li>关系R和S必须是同元的，即它们的属性数目必须相同</li>
<li>对i，R的第i个属性的域必须和S的第i个属性的域相同</li>
</ul>
</li>
</ul>
<h3 id="差运算"><a href="#差运算" class="headerlink" title="差运算"></a>差运算</h3><p>所有出现在一个关系而不在另一关系中的元组集合</p>
<p>R和S必须是相容的</p>
<h3 id="交运算"><a href="#交运算" class="headerlink" title="交运算"></a>交运算</h3><ul>
<li>所有同时出现在两个关系中的元组集合</li>
<li>交运算可以通过差运算来重写</li>
</ul>
<h2 id="基本关系运算"><a href="#基本关系运算" class="headerlink" title="基本关系运算"></a>基本关系运算</h2><h3 id="选择运算"><a href="#选择运算" class="headerlink" title="选择运算"></a>选择运算</h3><p>在关系R中选择满足给定条件的元组（从行的角度）</p>
<h3 id="投影运算"><a href="#投影运算" class="headerlink" title="投影运算"></a>投影运算</h3><p>投影的结果中要去掉相同的行</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200401174458046.png" style="zoom:67%;" />

<h3 id="广义笛卡儿积"><a href="#广义笛卡儿积" class="headerlink" title="广义笛卡儿积"></a>广义笛卡儿积</h3><ul>
<li><p>元组的连串（Concatenation）</p>
<ul>
<li>若r &#x3D; (r<del>1</del>，…，r<del>n</del>)，s &#x3D; (s<del>1</del> ，… ，s<del>m</del>)，则定义r与s的连串为：rs &#x3D; (r<del>1</del>，…，r<del>n</del>，s<del>1</del> ，…，s<del>m</del>)</li>
</ul>
</li>
<li><p>广义笛卡尔积两个关系R，S，其度分别为n，m，则它们的笛卡尔积是所有这样的元组集合：元组的前n个分量是R中的一个元组，后m个分量是S中的一个元组<br>RxS&#x3D;{rs|r属于R并且s属于S}</p>
</li>
<li><p>RxS的度为R与S的度之和，RxS的元组个数为R和S的元组个数的乘积</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601164930592.png"></p>
</li>
</ul>
<h2 id="其它关系运算"><a href="#其它关系运算" class="headerlink" title="其它关系运算"></a>其它关系运算</h2><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601165011840.png"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601165118331.png"></p>
<p>0连接就是有附加条件的自然连接。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601165210237.png"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601165223860.png"></p>
<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>把上述中舍弃的元组也保存在结果关系中，在其他属性上填上NULL。</p>
<p>左外连接：只把左边关系R中要舍弃的元组保留。同理：右外连接。</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601165444957.png" style="zoom:50%;" />

<h3 id="除运算"><a href="#除运算" class="headerlink" title="除运算"></a>除运算</h3><p>把S和R中相同的属性组拿出来，然后取R中独有的属性</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601165522272.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/03/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">编译原理-LR分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-27 15:18:39" itemprop="dateCreated datePublished" datetime="2020-03-27T15:18:39Z">2020-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="句柄和规范归约"><a href="#句柄和规范归约" class="headerlink" title="句柄和规范归约"></a>句柄和规范归约</h1><p>归约：根据文法的产生式规则，把串中出现的产生式的右部替换成左部符号</p>
<p>从语法树的角度看，是从叶子出发逐步向上进行构造</p>
<p>句柄：最左两代子树末端就是句柄</p>
<p>规范归约的关键是寻找句柄：</p>
<p>1、根据语法树找句柄</p>
<p>2、在栈中根据三类信息：</p>
<ul>
<li>历史：已经移入符号栈的内容</li>
<li>展望：根据产生式推迟未来可能遇到的输入符号</li>
<li>现实：当前的输入符号</li>
</ul>
<h1 id="LR分析"><a href="#LR分析" class="headerlink" title="LR分析"></a>LR分析</h1><p>LR分析法也是一种“移进—归约”的自底向上语法分析方法，<strong>其本质是规范归约【句柄作为可归约串】</strong>。</p>
<p>其思想为一方面记住已移进和归约出的整个符号串，另一方面根据所用产生式推测未来可能碰到的输入符号。</p>
<p><strong>LR分析方法：把“历史”以及“展望”综合抽象成状态；由栈顶的状态和现行的输入符号唯一确定每一步工作。</strong></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/image-20200427132237942.png"></p>
<p>解释：每一个符号对应一个状态，分析栈每次弹出一个符号，就要把对应的状态也弹出。然后LR分析程序会根据输入串在LR分析表中进行查找：是进行归约、移进还是报错操作。</p>
<p>LR分析器实质上是一个带先进后出存储器（栈）的确定有限自动机，其核心部分是一张分析表，包括两部分：</p>
<p>（1）ACTION[s，a]动作表，规定当状态s面临输入符号a时，应采取什么动作（移进、归约、接受、 报错）【<strong>也就是告诉我们当栈顶状态为s时，输入的符号是a时，我们应该采取什么操作：归约、移进还是报错</strong>】</p>
<p>（2）GOTO[s，X]状态转换表规定了状态s面对文法符号X时，下一状态是什么。【<strong>当归约完了后，要把规约后的非终结符压到栈里面的时候，跟新压入栈的这个非终结符所对应的状态是什么</strong>】</p>
<h2 id="LR文法"><a href="#LR文法" class="headerlink" title="LR文法"></a>LR文法</h2><p>对于一个文法，如果能够构造一张分析表，使得它的每个入口均是唯一确定的，则这个文法就是LR文法</p>
<p>一个文法，如果能用一个每步顶多向前检查k个输入符号的LR分析器分析，则这个文法就称为LR(K)文法</p>
<p>LR文法不是二义的</p>
<h2 id="LR-0-分析"><a href="#LR-0-分析" class="headerlink" title="LR(0)分析"></a>LR(0)分析</h2><h3 id="拓广文法"><a href="#拓广文法" class="headerlink" title="拓广文法"></a>拓广文法</h3><p>对于文法 G &#x3D; (V<del>N</del>, V<del>T</del>, P , S ) , 增加如下产生式：S’-&gt;S ，其中， S’ ∈ V<del>N</del>∪ V<del>T</del> ， 得到 G 的拓广文法，G’ &#x3D; (V<del>N</del> ’, V<del>T</del>, P ’ , S’ )</p>
<p><strong>其实就是增加了一条右部为开始符号的产生式，就变成了拓广文法</strong></p>
<h3 id="可归前缀"><a href="#可归前缀" class="headerlink" title="可归前缀"></a>可归前缀</h3><p>将符号串的任意含有头符号的子串称为前缀。特别地，空串ε为任意串的前缀。</p>
<p>采取归约过程前符号栈中的内容，称做可归前缀。<br>这种前缀包含句柄且不包含句柄之后的任何符号；</p>
<h3 id="活前缀"><a href="#活前缀" class="headerlink" title="活前缀"></a>活前缀</h3><p>就是在LR分析中为了描述栈内符号的特点给出的概念</p>
<p>对于文法 G &#x3D; (V<del>N</del>, V<del>T</del>, P , S ) , 设 S’ 是其拓广文法的开始符号（即有产生式 S’-&gt; S）， 且α,β∈(V<del>N</del>∪V<del>T</del>)* , ω∈V<del>T</del><em>。<br>若 S’ &#x3D;^</em>^&#x3D;&gt;α A ω 且 A -&gt;β， 即 β 为句柄，则 αβ 的任何前缀 γ 都是文法 G 的活前缀。【<strong>活前缀就是不含句柄之后任何符号的前缀</strong>】<br>注：由于 S’ &#x3D;^*^&#x3D;&gt;S’ 且 S’ -&gt; S， 故 S 是 G 的活前缀 。</p>
<p><strong>也就是说可归前缀的所有前缀（包括可归前缀）都是活前缀。</strong></p>
<blockquote>
<p>例：文法 G[S] :<br>（1） S -&gt; AB<br>（2） A -&gt; aA<br>（3） A -&gt; ε<br>（4） B -&gt; b<br>（5） B -&gt; bB<br>句子 aaab 是一个句型，其唯一的句柄为：ε （aaaεb）； 活前缀有：ε，a，aa，aaa。</p>
</blockquote>
<p>规范归约过程中，保证分析栈中总是活前缀，就说明分析采取的移进&#x2F;归约动作是正确的</p>
<h3 id="LR-0-项目"><a href="#LR-0-项目" class="headerlink" title="LR(0)项目"></a>LR(0)项目</h3><p>对于文法G，其产生式右部添加一个特殊的符号“.”，就构成文法的一个LR(0)项目，简称项目</p>
<p><strong>每个项目的含义是：欲用改产生式归约时，圆点前面的部分为已经识别了的句柄部分，圆点后面的部分为期望的后缀部分。</strong></p>
<p>分类：</p>
<p>移进项目: 形如 A -&gt; α • aβ（a∈V<del>T</del>），对应移进状态，把a移进符号栈。<br>待约项目: 形如 A -&gt; α • Bβ，对应待约状态，需要等待分析完非终结符B的串再继续分析A的右部。<br>归约项目: 形如 A -&gt; α •，句柄已形成，可以归约。<br>接受项目: 形如 S’ -&gt; S •。【也是一个归约项目，表示整个句子已经识别完毕】<br>初始项目: 形如 S’ -&gt; • S。<br>其中a∈V<del>T</del> , α,β∈(V<del>N</del>∪V<del>T</del>)*， A,B∈V<del>T</del><br>后继项目: 表示同属于一个产生式的项目，但是圆点的位置仅相差一个文法符号，则称后者为前者的后继项目。</p>
<p> • 的左边是已经归约，右边是没有归约的</p>
<blockquote>
<p>例：对于产生式S -&gt; aAcBe，它有6个项目：<br>S -&gt; ·aAcBe<br>S -&gt; a·AcBe<br>S -&gt; aA·cBe<br>S -&gt; aAc·Be<br>S -&gt; aAcB·e<br>S -&gt; aAcBe·</p>
</blockquote>
<h2 id="LR-0-有限状态机的构造方法"><a href="#LR-0-有限状态机的构造方法" class="headerlink" title="LR(0)有限状态机的构造方法"></a>LR(0)有限状态机的构造方法</h2><h3 id="构造识别活前缀的NFA"><a href="#构造识别活前缀的NFA" class="headerlink" title="构造识别活前缀的NFA"></a>构造识别活前缀的NFA</h3><h4 id="NFA的构造方法"><a href="#NFA的构造方法" class="headerlink" title="NFA的构造方法"></a>NFA的构造方法</h4><p>(1)状态集：由每个项目所对应的状态组成的集合；</p>
<p>(2)输入字符集合：由文法符号组成，包括：终结符、非终结符和e；</p>
<p>(3)初态：对于文法G[S]的拓广文法G[S’],有项目S’® . S ,由于S’ 仅在第一个产生式的左部出现，所以规定它为初态；</p>
<p>(4)终态：每个状态均为NFA的终态（活前缀的识别态）。</p>
 <img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203220121070.png" style="zoom:75%;" />

<ul>
<li><p>若状态i为X-&gt;X<del>1</del>····X<del>i-1</del>•X<del>i</del>····X<del>n</del>；状态j为X-&gt;X<del>1</del>····X<del>i-1</del>X<del>i</del>•X<del>i+1</del>····X<del>n</del></p>
<p>则从状态i画一条标志为X<del>i</del>的有向边到状态j</p>
</li>
<li><p>若状态i为X-&gt;α• Aβ，A为非终结符，<br>则从状态i画一条ε边到所有状态A-&gt;• y【可以理解成X想要把A进行归约，然后画一条ε边，交给A需要归约的符号】</p>
</li>
</ul>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203220250887.png" style="zoom:75%;" />

<h3 id="NFA转换成DFA"><a href="#NFA转换成DFA" class="headerlink" title="NFA转换成DFA"></a>NFA转换成DFA</h3><p>DFA是用子集法得到的</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203220947527.png" style="zoom:75%;" />

<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203221052145.png" style="zoom:75%;" />

<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203221104587.png" style="zoom:75%;" />

<h3 id="求项目集规范族"><a href="#求项目集规范族" class="headerlink" title="求项目集规范族"></a>求项目集规范族</h3><p>每个项目集对应一个DFA状态，它们的全体称为这个文法的项目集规范族</p>
<h4 id="有效项目"><a href="#有效项目" class="headerlink" title="有效项目"></a>有效项目</h4><p>项目A-&gt;β<del>1</del>• β<del>2</del>对活前缀αβ<del>1</del>是有效的，其条件就是存在规范推导</p>
<h4 id="1-用闭包函数（CLOSURE）来求DFA一个状态的项目集"><a href="#1-用闭包函数（CLOSURE）来求DFA一个状态的项目集" class="headerlink" title="1.用闭包函数（CLOSURE）来求DFA一个状态的项目集"></a>1.用闭包函数（CLOSURE）来求DFA一个状态的项目集</h4><p>I是拓广文法G的任意项目集：<br>CLOSURE(I)是这样定义的：<br>首先I的项目都属于CLOSURE(I)；<br>如果A-&gt;α• Bβ,则左部为B的每个产生式中的形如B-&gt;·γ项目，也属于CLOSURE(I)；</p>
<blockquote>
<p>例子：已知文法G[E]如下:<br>(1) E -&gt; E+T<br>(2) E -&gt; T<br>(3) T -&gt;( E )<br>(4) T -&gt; d</p>
<p>可以直到它的拓广文法G’ [E’]为 ：<br>(0) E’ -&gt; E<br>(1) E -&gt; E+T<br>(2) E -&gt; T<br>(3) T -&gt; ( E )<br>(4) T -&gt; d</p>
<p>令I<del>0</del> &#x3D; CLOSURE({E’-&gt;.E})</p>
<p>则I<del>0</del> &#x3D; {<br>E’ -&gt; • E，<br>E -&gt; • E+T，<br>E -&gt; • T，<br>T -&gt; •( E ),<br>T -&gt; • d<br>}</p>
</blockquote>
<h4 id="2-LR-0-FSM-的状态转移函数"><a href="#2-LR-0-FSM-的状态转移函数" class="headerlink" title="2.LR(0) FSM 的状态转移函数"></a>2.LR(0) FSM 的状态转移函数</h4><p>从一个状态出发，到达下一个状态的转换函数：<br>GO (I,X) &#x3D; CLOSURE(J)<br>其中，I为LR(0) FSM 的状态（闭包的项目集），X为文法符号， J&#x3D;{ A -&gt; αX•β | A -&gt; α• Xβ∈I} ；【J是非终结符包进去后的集合】<br>表示对于一个状态项目集中的一个项目A -&gt; α• Xβ，在下一个输入字符是X的情况下，一定到另一个新状态 A -&gt; αX•β。</p>
<h4 id="3-LR-0-有限状态机的构造"><a href="#3-LR-0-有限状态机的构造" class="headerlink" title="3.LR(0) 有限状态机的构造"></a>3.LR(0) 有限状态机的构造</h4><p>从 LR(0) FSM 的初态出发 ，先求出初态项目集的闭包（CLOSURE({S’-&gt;.S})），然后应用上述转移函数，通过项目分析每种输入字符下的状态转移，若为新状态，则就求出新状态下的项目集的闭包，级可逐步构造出完整的 LR(0) FSM。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">构造项目集规范族的算法：</span><br><span class="line"><span class="function"><span class="keyword">PROCEDURE</span> <span class="title">ITEMSET</span><span class="params">(G<span class="string">&#x27;)；</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">BEGIN</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">C:&#123;CLOSURE&#123;S&#x27;</span>-&gt;.S&#125;&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">REPEAT</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">FOR</span> C中的每一个项目集I和G<span class="string">&#x27;的每一个符号X DO</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		IF GO(I,X)非空且不属于C THEN</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		把GO(I,X)放入C族中</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">	UNTIL C不再增大</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">End</span></span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>LR(0) FSM 的构造举例<br>给定文法G[E]：<br>(1) E -&gt; E+T<br>(2) E -&gt; T<br>(3) T -&gt; ( E )<br>(4) T -&gt; d</p>
<p>构造LR(0) FSM<br>① G[E]的拓广文法，得到G’ [E’]：<br>(0) E’ -&gt; E<br>(1) E -&gt; E+T<br>(2) E -&gt; T<br>(3) T -&gt; ( E )<br>(4) T -&gt; d</p>
<p>②构造G’[E’] 的 LR(0) FSM</p>
<p><img src="https://img-blog.csdnimg.cn/20181229131739897"></p>
</blockquote>
<p>两种构造识别活前缀的DFA的方法：</p>
<ul>
<li>项目-&gt;NFA-&gt;DFA</li>
<li>Closure-&gt;GO-&gt;DFA</li>
</ul>
<h2 id="LR-0-分析法"><a href="#LR-0-分析法" class="headerlink" title="LR(0) 分析法"></a>LR(0) 分析法</h2><h3 id="1-LR-0-文法定义"><a href="#1-LR-0-文法定义" class="headerlink" title="1.LR(0) 文法定义"></a>1.LR(0) 文法定义</h3><p>文法 G 是 LR(0) 文法，当且仅当它的LR(0)FSM中的每个状态都满足：<br><strong>①不同时含有移进项目和归约项目，即不存在移进-归约冲突。</strong><br><strong>②不含有两个以上归约项目，即不存在归约-归约冲突。</strong></p>
<h3 id="2-LR-0-分析表的构造"><a href="#2-LR-0-分析表的构造" class="headerlink" title="2.LR(0)分析表的构造"></a>2.LR(0)分析表的构造</h3><p>令每个项目集I<del>k</del>的下标k作为分析器的状态</p>
<p>ACTION 表项和 GOTO表项可按如下方法构造：</p>
<ul>
<li><p>若项目A -&gt;α • aβ属于 I<del>k</del> 且 GO (I<del>k</del>, a)&#x3D; I<del>j</del>, 期望字符a 为终结符，则置ACTION[k, a] &#x3D;s<del>j</del> (j表示新状态I<del>j</del>);</p>
</li>
<li><p>若项目A -&gt;α •属于I<del>k</del>, 那么对任何终结符a, 置ACTION[k, a]&#x3D;r<del>j</del>；其中，假定A-&gt;α为文法G 的第j个产生式；【对k到a进行归约】</p>
</li>
<li><p>若项目S’ -&gt;S • 属于I<del>k</del>, 则置ACTION[k, #]为“acc”;【单词处理完毕】</p>
</li>
<li><p>若项目A -&gt;α • Aβ属于 I<del>k</del>，且GO (I<del>k</del>, A)&#x3D; I<del>j</del>,期望字符 A为非终结符，则置GOTO(k, A)&#x3D;j (j表示文法中第j个产生式);</p>
</li>
<li><p>分析表中凡不能用上述规则填入信息的空白格均置上“出错标志”</p>
<p><strong>翻译一下：</strong></p>
<ol>
<li><strong>如果圆点不在项目k最后且圆点后的期待字符a为终结符，则ACTION[k, a] &#x3D;s<del>j</del> (j表示新状态I<del>j</del>)；</strong></li>
<li><strong>如果圆点不在项目k最后且圆点后的期待字符A为非终结符，则GOTO(k, A)&#x3D;j (j表示文法中第j个产生式)；</strong></li>
<li><strong>如果圆点在项目k最后且k不是S’ -&gt;S，那么对所有终结符a，ACTION[k, a]&#x3D;r<del>j</del> (j表示文法中第j个产生式)；</strong></li>
<li><strong>如果圆点在项目k最后且k是S’ -&gt;S，则ACTION[k, #]为“acc”;</strong></li>
</ol>
</li>
</ul>
<blockquote>
<p>例子：</p>
<p>考虑文法G[S] :<br>S → （S） | a<br>相应的LR(0) FSM如下，构造其LR(0)分析表。</p>
<p><img src="https://img-blog.csdnimg.cn/20181229131739956"></p>
<p>LR(0) FSM</p>
<p>从I<del>0</del>看，S‘-&gt;·S,期望字符是非终结符S，根据上面的规则2，得到GOTO(0,S)&#x3D;1；<br>S‘-&gt;·(S),期望字符是终结符(，根据上面的规则1，得到ACTION(0,()&#x3D;S<del>2</del>；<br>从I<del>3</del>看，S-&gt;a·，根据规则3，置ACTION[3, a]为r<del>2</del>;<br>从I<del>1</del>看，S‘-&gt;S·，根据规则4，置ACTION[1, #]为“acc”;</p>
<p><img src="https://img-blog.csdnimg.cn/201812291317408"></p>
<p>LR(0)分析表</p>
</blockquote>
<h3 id="3-LR-0-分析流程"><a href="#3-LR-0-分析流程" class="headerlink" title="3.LR(0) 分析流程"></a>3.LR(0) 分析流程</h3><p>设输入串为w，ip指向输入串w的首符号a，i指向符号栈顶；状态栈的初始栈顶为0，符号栈初始栈顶为#。</p>
<p>算法流程图为：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/image-20200427170434108.png"></p>
<h2 id="SLR-1-分析法"><a href="#SLR-1-分析法" class="headerlink" title="SLR(1)分析法"></a>SLR(1)分析法</h2><h3 id="1-SLR-1-解决的问题"><a href="#1-SLR-1-解决的问题" class="headerlink" title="1.SLR(1)解决的问题"></a>1.SLR(1)解决的问题</h3><p>LR(0)文法的要求是①不同时含有移进项目和归约项目，即不存在移进-归约冲突。②不含有两个以上归约项目，即不存在归约-归约冲突。</p>
<p>例如项目集I<del>i</del>中存在： I<del>i</del> ＝{A-&gt;α•bγ ， B→ γ•，C→β• }，此时就同时存在移进-归约冲突和归约-归约；因为你不知道下一步是选择归约还是移进，选择归约的话选择哪个产生式归约。</p>
<p>而事实上一般文法满足这种要求有一定难度，但是假如在归约时出现了移进-归约冲突或者归约-归约冲突，我们可以通过在待分析的字符串中向后再看一位，大多数情况下通过这一位字符就可以确定，选择哪一个表达式归约，或是移进操作。</p>
<p>这种方法就叫做SLR(1)分析法，即简单的LR(1)分析法。</p>
<h3 id="2-SLR-1-冲突解决方法"><a href="#2-SLR-1-冲突解决方法" class="headerlink" title="2.SLR(1)冲突解决方法"></a>2.SLR(1)冲突解决方法</h3><p>如上面所述，我们需要知道下一位待分析的字符，然后和现有项目进行比较。</p>
<p>分析过程与LR(0)一样，但是需要解决分析表上的冲突问题。</p>
<p>假如LR(0) 项目集规范族中有项目集 I<del>i</del> 含有移进-归约冲突和归约-归约冲突：<br> I<del>i</del> ＝{A<del>1</del>-&gt;α<del>1</del>•b<del>1</del>γ<del>1</del>，… ， A<del>m</del>-&gt;m•b<del>m</del> γ<del>m</del>， B<del>1</del>-&gt;β<del>1</del>• ，…， B<del>n</del>-&gt; β<del>n</del>• }，若集合{b<del>1</del> ，b<del>2</del>，… ，b<del>m</del> }、FOLLOW(B<del>1</del>) 、 FOLLOW(B<del>2</del>) ，…，FOLLOW(Bn)均两两不相交，则可用SLR(1)解决方法解决分析表上第i行上的冲突问题。</p>
<p>假设下一个移进的字符为b:</p>
<p>1、若b∈ {b<del>1</del> ，b<del>2</del>，… ，b<del>m</del> }，则移进输入符；</p>
<p>2、若b∈FOLLOW(B<del>j</del>) ，j＝1 ，… ，n，则用B<del>j</del>-&gt; β<del>j</del> 归约；</p>
<p>3、此外，报错</p>
<p>通过这个方法，就可以在知道下一位待分析的字符的情况下，解决冲突。</p>
<p>继续采用SLR(1)分析的方法，我们可以对出错情况进行优化：</p>
<p>在LR(0)和SLR(1)分析中，我们在可以归约且没有冲突时（假如归约成A），是不关心下一位待分析的字符a和follow(A)的关系的，假如a!∈follow(A)则当前字符串是不被接受的，当然这会在之后的继续移进字符过程中发现错误，但是如果不管是否有冲突看，将SLR(1)分析方法应用到所有分析表的构建过程中，可以提前发现字符串的错误。</p>
<h3 id="3-构造SLR-1-分析表的方法"><a href="#3-构造SLR-1-分析表的方法" class="headerlink" title="3.构造SLR(1)分析表的方法"></a>3.构造SLR(1)分析表的方法</h3><p>1、把G扩广成G’</p>
<p>2、对G’构造：得到LR(0)项目集规范族C；活前缀识别自动机的状态转换函数GO</p>
<p>3、使用C和GO，构造SLR分析表：构造action和goto子表：</p>
<ul>
<li>若项目A -&gt;α • aβ属于 I<del>k</del> 且 GO (I<del>k</del>, a)&#x3D; I<del>j</del>,期望字符a为终结符，则置ACTION[k, a] &#x3D;s<del>j</del> (j表示新状态I<del>j</del>);</li>
<li>若项目A -&gt;α • Aβ属于 I<del>k</del>，且GO (I<del>k</del>, A)&#x3D; I<del>j</del>,期望字符 A为非终结符，则置GOTO(k, A)&#x3D;j (j表示文法中第j个产生式);</li>
<li>若项目A -&gt;α •属于I<del>k</del>, 那么对任何终结符a，<strong>当满足a属于follow(A)时</strong>， 置ACTION[k, a]&#x3D;r<del>j</del>；其中，假定A-&gt;α为文法G 的第j个产生式；</li>
<li>若项目S’ -&gt;S • 属于I<del>k</del>, 则置ACTION[k, #]&#x3D;“acc”;</li>
<li>分析表中凡不能用上述规则填入信息的空白格均置上“出错标志”</li>
</ul>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/image-20200427182955125.png"></p>
<p>SLR分析是有选择的放置的</p>
<h3 id="4-SLR（1）文法"><a href="#4-SLR（1）文法" class="headerlink" title="4.SLR（1）文法"></a>4.SLR（1）文法</h3><p>按上述方法构造出的ACTION和GOTO表如果不含多重入口，则称该文法是SLR(1)文法。</p>
<p>使用SLR表的分析器叫做一个SLR分析器</p>
<p>每个SLR(1)文法都是无二义的。<br>$$<br>LR(0)\subset SLR(1)\subset 无二义文法<br>$$</p>
<h3 id="5-SLR-1-分析的例子"><a href="#5-SLR-1-分析的例子" class="headerlink" title="5.SLR(1)分析的例子"></a>5.SLR(1)分析的例子</h3><blockquote>
<p>算术表达式文法G[E]：<br>E→E +T | T<br>T→T * F | F<br>F→ （E）| i<br>求此文法的识别规范句型活前缀的DFA，分析句子i+i *i。</p>
</blockquote>
<ol>
<li>将文法拓广为G’[E’]：<br>(0) E’ -&gt;E<br>(1) E-&gt; E +T<br>(2) E -&gt;T<br>(3) T -&gt;T * F<br>(4) T -&gt;F<br>(5) F -&gt;(E)<br>(6) F -&gt;i</li>
<li>构造识别规范句型活前缀的DFA</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20181229131728485"></p>
<ol>
<li><p>判断有无冲突：</p>
<p>I<del>1</del> ，I<del>2</del> ，I<del>9</del>有移进_归约冲突。<br>I<del>1</del>:E´ -&gt;E· E -&gt;E·+T<br>I<del>2</del>: E -&gt;T · T -&gt;T · *F<br>I<del>9</del>: E -&gt;E+T· T -&gt;T · *F</p>
</li>
<li><p>考虑能否用SLR(1)方法解决冲突：</p>
<p>对于I<del>1</del>: <code>&#123; E´ -&gt;E· E -&gt;E·+T&#125;</code> 因为：<code>&#123;+&#125; ∈FOLLOW(E´)= &#123;+&#125; ∩ &#123;＃&#125; ＝∅</code>, 所以可用SLR(1)方法 解决I<del>1</del>的冲突。</p>
<p>对于I<del>2</del>: <code>&#123;E -&gt;T· T -&gt;T·*F&#125;</code> 因为：<code>&#123;*&#125; ∈ FOLLOW(E)= &#123;*&#125; ∩ &#123;＃，）,+&#125; ＝ ∅</code> 所以可用SLR(1)方法解决I<del>2</del>的冲突。</p>
<p>对于I<del>9</del>: <code>&#123;E -&gt;E+T· T -&gt;T ·*F&#125;</code> 因为：<code>&#123;*&#125; FOLLOW(E)= ∅</code>, 所以可用SLR(1)方法解决I<del>9</del>的冲突。</p>
</li>
<li><p>构建分析表：</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20181229131728536"></p>
<p>6.句子i+i *i的分析过程：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>状态栈</th>
<th>符号栈</th>
<th>输入符</th>
<th>剩余输   入串</th>
<th align="left">查表</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
<td>#</td>
<td>i</td>
<td>i+i*i#</td>
<td align="left">Action[0,i]&#x3D;S5</td>
<td>移进i</td>
</tr>
<tr>
<td>2</td>
<td>0 5</td>
<td># i</td>
<td>+</td>
<td>+i*i#</td>
<td align="left">Action[5,+]&#x3D;r6,GOTO(0,F)&#x3D;3</td>
<td>用F -&gt; i 归约</td>
</tr>
<tr>
<td>3</td>
<td>0 3</td>
<td># F</td>
<td>+</td>
<td>+i*i#</td>
<td align="left">Action[3,+]&#x3D;r4,GOTO(0,T)&#x3D;2</td>
<td>用F -&gt; T归约</td>
</tr>
<tr>
<td>4</td>
<td>0 2</td>
<td># T</td>
<td>+</td>
<td>+i*i#</td>
<td align="left">Action[2,+]&#x3D;r4,GOTO(0,E)&#x3D;1</td>
<td>用F -&gt; E归约</td>
</tr>
<tr>
<td>5</td>
<td>0 1</td>
<td># E</td>
<td>+</td>
<td>+i*i#</td>
<td align="left">Action[1,+]&#x3D;S6</td>
<td>移进+</td>
</tr>
<tr>
<td>6</td>
<td>0 1 6</td>
<td># E +</td>
<td>i</td>
<td>i*i#</td>
<td align="left">Action[6,i]&#x3D;S6</td>
<td>移进+</td>
</tr>
<tr>
<td>7</td>
<td>0 1 6 5</td>
<td># E + i</td>
<td>*</td>
<td>*i#</td>
<td align="left">Action[5,*]&#x3D;r6,GOTO(6,F)&#x3D;3</td>
<td>用F -&gt; i 归约</td>
</tr>
<tr>
<td>8</td>
<td>0 1 6 3</td>
<td># E + F</td>
<td>*</td>
<td>*i#</td>
<td align="left">Action[3,*]&#x3D;r6,GOTO(6,T)&#x3D;9</td>
<td>用F -&gt; F 归约</td>
</tr>
<tr>
<td>9</td>
<td>0 1 6 9</td>
<td># E + T</td>
<td>*</td>
<td>*i#</td>
<td align="left">Action[9,*]&#x3D;S7</td>
<td>移进*</td>
</tr>
<tr>
<td>10</td>
<td>0 1 6 9 7</td>
<td># E + T *</td>
<td>i</td>
<td>i#</td>
<td align="left">Action[7,i]&#x3D;S5</td>
<td>移进i</td>
</tr>
<tr>
<td>11</td>
<td>0 1 6 9 7 5</td>
<td># E + T * i</td>
<td>#</td>
<td>#</td>
<td align="left">Action[5,#]&#x3D;r6,GOTO(7,F)&#x3D;10</td>
<td>用F -&gt; i 归约</td>
</tr>
<tr>
<td>12</td>
<td>0 1 6 9 7 10</td>
<td># E + T * F</td>
<td>#</td>
<td>#</td>
<td align="left">Action[10,#]&#x3D;r3,GOTO(6,T)&#x3D;9</td>
<td>用T -&gt; T+F归约</td>
</tr>
<tr>
<td>13</td>
<td>0 1 6 9</td>
<td># E + T</td>
<td>#</td>
<td>#</td>
<td align="left">Action[9,#]&#x3D;r1,GOTO(0,E)&#x3D;1</td>
<td>用E -&gt; E+T归约</td>
</tr>
<tr>
<td>14</td>
<td>0 1</td>
<td># E</td>
<td>#</td>
<td>#</td>
<td align="left">Action[1,#]&#x3D;acc</td>
<td>接受</td>
</tr>
</tbody></table>
<h2 id="LR-1-分析法"><a href="#LR-1-分析法" class="headerlink" title="LR(1)分析法"></a>LR(1)分析法</h2><h3 id="SLR冲突消解存在的问题"><a href="#SLR冲突消解存在的问题" class="headerlink" title="SLR冲突消解存在的问题"></a>SLR冲突消解存在的问题</h3><p>在SLR方法中，如果项目集I<del>i</del>含项目A -&gt;α •而且下一输入符号α∈FOLLOW(A)，则状态i面临α时，可选用“用A -&gt;α归约”动作。</p>
<p>但是在某些情况下，当状态i显现于栈顶时，当前单词是α，栈里的活前缀βα未必允许把α归约为A，因为可能根本不存在一个形如“βAα”的规范句型。在这种情况下，用“A -&gt;α”归约不一定合适</p>
<p>【因为FOLLOW（A）集合提供的信息太泛】</p>
<h3 id="构造LR-1-分析表的方法"><a href="#构造LR-1-分析表的方法" class="headerlink" title="构造LR(1)分析表的方法"></a>构造LR(1)分析表的方法</h3><p>1、把G扩广成G’</p>
<p>2、对G’构造：得到LR(1)项目集规范族C；活前缀识别自动机的状态转换函数GO</p>
<p>3、使用C和GO，构造LR（1）分析表：</p>
<p>LR(K)项目：扩展LR(0)项目，附带有k个终结符[A-&gt;α •β,α<del>1</del>α<del>2</del>····α<del>k</del>]<br>α<del>1</del>α<del>2</del>····α<del>k</del>称为向前搜索符串（或展望串）</p>
<p>归约项目[A-&gt;α •,α<del>1</del>α<del>2</del>····α<del>k</del>]的意义：当它所属的状态呈现现在栈顶且后续的k个输入符号为α<del>1</del>α<del>2</del>····α<del>k</del>时，才可以把栈顶上的α归约为A</p>
<p> 对于任何移进或待约项目[A-&gt;α •β,α<del>1</del>α<del>2</del>····α<del>k</del>]，β不等于α，搜索符串α<del>1</del>α<del>2</del>····α<del>k</del>没有直接作用 </p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">构造项目集规范族的算法：</span><br><span class="line"><span class="function"><span class="keyword">PROCEDURE</span> <span class="title">ITEMSET</span><span class="params">(G<span class="string">&#x27;)；</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">BEGIN</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">C:&#123;CLOSURE&#123;S&#x27;</span>-&gt;.S,#&#125;&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">REPEAT</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">FOR</span> C中的每一个项目集I和G<span class="string">&#x27;的每一个符号X DO</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		IF GO(I,X)非空且不属于C THEN</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		把GO(I,X)放入C族中</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">	UNTIL C不再增大</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">End</span></span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>若项目[A -&gt;α • aβ，b]属于 I<del>k</del> 且 GO (I<del>k</del>, a)&#x3D; I<del>j</del>,期望字符a为终结符，则置ACTION[k, a] &#x3D;s<del>j</del> (j表示新状态I<del>j</del>);</li>
<li>若项目[A -&gt;α •，a]属于I<del>k</del>, 那么对任何终结符a，<strong>当满足a属于follow(A)时</strong>， 置ACTION[k, a]&#x3D;r<del>j</del>；其中，假定A-&gt;α为文法G 的第j个产生式；</li>
<li>若项目[S’ -&gt;S • ，#]属于I<del>k</del>, 则置ACTION[k, #]&#x3D;“acc”;</li>
<li>若GO[I<del>k</del>，A]&#x3D;I<del>j</del>，则置GOTO[K,A]&#x3D;j</li>
<li>分析表中凡不能用上述规则填入信息的空白格均置上“出错标志”</li>
</ul>
<p>$$<br>LR(0)\subset SLR(1)\subset LR(1)\subset 无二义文法<br>$$</p>
<p><strong>（SLR(1)和LR(1)的区别在于LR(1)多使用了一个预判信息，即项目后面的符号如A →·e,c中的c，这个预判信息是用first集而非follow集得出的）</strong></p>
<h1 id="LR-0-、SLR-1-、LL-1-等的区别"><a href="#LR-0-、SLR-1-、LL-1-等的区别" class="headerlink" title="LR(0)、SLR(1)、LL(1)等的区别"></a>LR(0)、SLR(1)、LL(1)等的区别</h1><p>LL(1)定义：一个文法G是LL（1）的，当且仅当对于G的每一个非终结符A的任何两个不同产生式 A→α|β，下面的条件成立：SELECT( A→α)∩SELECT( A→β)&#x3D;,其中，</p>
<p>α|β不能同时ε。</p>
<p>解释：LL(1)的意思是，第一个L,指的是从左往右处理输入，第二个L,指的是它为输入生成一个最左推导。1指的是向前展望1个符号。LL(1)文法是上下文无关文法的一个子集。它用的方法是自顶向下的(递归式的处理)。它要求生成的预测分析表的每一个项目至多只能有一个生成式。上面的定义说的是，任何两个不同的产生式 A→α和 A→β,选择A→α或者 A→β是不能有冲突的，即SELECT( A→α)∩SELECT( A→β)&#x3D;，具体来说，就是，第一:First( A→α) ∩ First( A→β)&#x3D;,首符集不能有交集，否则当交集中的元素出现时，选择哪个产生式进行推导是不确定的，（这其中也包含了α|β不能同时ε，否则交集就是{ε}不为空），第二：若任何一个产生式β，有ε属于First(β),应有First(A)∩Follow( A)为空（当ε属于First(β)，则A有可能被空串代替，那么就要看A的下一个字符，即Follow集，即要求Follow集和First集不能相交，否则可能发生冲突）。</p>
<p>LR文法：定义：如果某一文法能够构造一张分析表，使得表中每一个元素至多只有一种明确动作，则该文法称为LR文法。</p>
<p>拓展：由上面的定义可以看到，LL(1)和LR文法都是无二义性的：LL(1)要求生成的预测分析表的每一个项目至多只能有一个生成式，即对于读头下的每一个字符，都可以明确地选择哪个产生式来推导，LR文法要求每一步都有明确的动作，移进和归约都是可确定的，没有二义性。</p>
<p>比较两大类型（自顶向下　vs 自底向上）的文法的特点：</p>
<p>1.首先LL(1)分析法是自上而下的分析法。LR(0),LR(1),SLR(1),LALR(1)是自下而上的分析法。<br>   2.自上而下:从开始符号出发，根据产生式规则推导给定的句子。用的是推导<br>   3.自下而上:从给定的句子规约到文法的开始符号。用的是归约<br>   4.自上而下就是一种试探过程，怎么试探？需要你写出它的FIRST()集与FOLLOW()集。写出这两个集合后根据LL(1)分析表构造规则画出LL(1)分析表。现在基本完成了大半，当计算机输入句子时，分析程序便会根据输入去和分析表进行匹配，如果每步都能够匹配成功则说明符合该语法规则，分析成功。<br>   FIRST()集：其实是终结符的集合，看该非终结符A能不能产生以它里面的某个符号开头的句子。（这也是自上而下分析法的思想）<br>   5.自下而上就是把句子变成非终结符，在把非终结符变成非终结符，这样不断的进行如果能到根节点则成功。</p>
<p> LL(1)就是向前只搜索1个符号，即与FIRST()匹配，如果FIRST为空则还要考虑Follow。<br>　 LR需要构造一张LR分析表，此表用于当面临输入字符时，将它移进，规约（即自下而上分析思想），接受还是出错。<br>   LR(0)找出句柄前缀，构造分析表，然后根据输入符号进行规约。不考虑先行，只要出现终结符就移进，只要出现归约状态，就无条件归约,这样子可能出现归约－移进，归约－归约冲突。<br>   SLR(1)使用LR(0)时若有归约－归约冲突，归约－移进冲突，所以需要看先行，则只把有问题的地方向前搜索一次。</p>
<p>SLR(1)定义：满足下面两个条件的文法是SLR(1)文法</p>
<p>a.对于在s中的任何项目 A→α.Xβ,当X是一个终结符，且X在Follow(B)中时，s中没有完整的项目B→r.</p>
<p>b.对于在s中的任何两个完整项目A→α.和 B→β.,Follow(A)∩Follow(B)为空。</p>
<p>解释：a.当X是一个终结符且X出现在读头上，对于项目 A→α.Xβ应该采用移进，若有完整的项目B→r.且Follow(B)中有X，当X出现在读头上时，此时应该归约，于是，就产生了移进和归约冲突</p>
<p>b.假设Follow(A)∩Follow(B)为{ X },对于A→α.，若Follow(A)[A后面的元素]出现时，应该归约，同理B也一样，于是，会产生归约－归约冲突，SLR(1)是为了消除LR(0)的两个冲突。<br>   LR(1)1.在每个项目中增加搜索符。2.举个列子如有A-&gt;α.Bβ，则还需将B的规则也加入。<br>   LALR(1)就是假如两个产生式集相同则将它们合并为一个，几合并同心集</p>
<p><strong>总结：</strong></p>
<p><strong>见到First集就移进，见到Follow集就归约。</strong></p>
<p><strong>LR(0):见到First集就移进，见到终态就归约</strong></p>
<p><strong>SLR(1)见到First集就移进，见到终态先看Follow集，与Follow集对应的项目归约，其它报错。</strong></p>
<p><strong>SLR分析法包含的展望信息是体现在利用了Follow(A)信息，可以解决“归约－归约”冲突</strong></p>
<p><strong>SLR分析法没有包含足够的展望信息，不能完成解决“移进－归约”冲突，需要改进。</strong></p>
<p><strong>下面是LR(0),SLR(1),LALR(1),LR(1)文法处理能力的比较，圆圈越大说明能力越强。</strong></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20130703204706828"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rhb</p>
  <div class="site-description" itemprop="description">纵浪大化中，不喜亦不惧</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">142</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RShawshank" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RShawshank" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rhb</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://lib.baomitu.com/canvas-nest.js/1.0.1/canvas-nest.js"></script>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
