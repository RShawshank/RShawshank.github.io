<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rshawshank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="纵浪大化中，不喜亦不惧">
<meta property="og:type" content="website">
<meta property="og:title" content="rhb_blog">
<meta property="og:url" content="http://rshawshank.github.io/page/11/index.html">
<meta property="og:site_name" content="rhb_blog">
<meta property="og:description" content="纵浪大化中，不喜亦不惧">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rhb">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rshawshank.github.io/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>rhb_blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rhb_blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">rao的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">63</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">27</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">154</span></a>

  </li>
        <li class="menu-item menu-item-photos">

    <a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
        <li class="menu-item menu-item-readnote">

    <a href="/readnote" rel="section"><i class="fa fa-book fa-fw"></i>阅读笔记</a>

  </li>
        <li class="menu-item menu-item-somethink">

    <a href="/somethink/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>随笔闲谈</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/RShawshank" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">数据库_关系数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-01 11:11:23" itemprop="dateCreated datePublished" datetime="2020-04-01T11:11:23Z">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="关系模型概述"><a href="#关系模型概述" class="headerlink" title="关系模型概述"></a>关系模型概述</h1><p>关系数据理论是建立在<strong>集合代数理论基础上</strong>的，有着坚实的数学基础</p>
<ul>
<li>数据结构：二维表</li>
<li>关系操作：<ul>
<li>增加(insert)、删除(delete)、修改(updated)</li>
<li>查询(Query):•选择(select)、投影(project)、连接(join)<ul>
<li>除(divide)、并(union)、交(intersection)</li>
<li>差(difference)</li>
</ul>
</li>
<li>关系代数，关系演算，SQL</li>
</ul>
</li>
<li>关系的三类完整性约束：<ul>
<li>实体完整性、参照完整性、用户自定义的完整性</li>
</ul>
</li>
</ul>
<blockquote>
<p>关系代数是用对关系的运算来表达查询要求的方式。</p>
<p>关系演算是用谓词表达查询要求的方式。</p>
<ul>
<li>按谓词变元的基本对象是元组变量还是域变量分为元组关系演算和域关系演算</li>
</ul>
</blockquote>
<h2 id="关系数据结构"><a href="#关系数据结构" class="headerlink" title="关系数据结构"></a>关系数据结构</h2><ul>
<li><p>域</p>
<ul>
<li>域是一组具有相同数据类型的值的集合</li>
</ul>
</li>
<li><p>笛卡儿积</p>
<ul>
<li><p>一组域D<del>1</del> , D<del>2</del> ,…, D<del>n</del>的笛卡尔积为：D<del>1</del>×D<del>2</del>×…×D<del>n</del>&#x3D; {(d<del>1</del> , d<del>2</del> , … , d<del>n</del>) | d<del>i</del>∈D<del>i</del>, i&#x3D;1,…,n}</p>
</li>
<li><p>笛卡尔积的每个元素(d<del>1</del> , d<del>2</del> , … , d<del>n</del>)称作一个n-元组（n-tuple）</p>
</li>
<li><p>元组的每一个值d<del>i</del>叫做一个分量（Component）</p>
</li>
<li><p>若D<del>i</del>的基数（元组个数）为m<del>i</del>，则笛卡尔积的基数为<br>$$<br>\prod^n_{i&#x3D;1}m_i<br>$$</p>
<blockquote>
<p>一个域允许的不同取值个数称为这个域的基数</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>笛卡儿积可以表示成一张二维表。表中的每行对应一个元组，表中的每一列的值来自一个域。</p>
<ul>
<li><p>关系</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200401153303890.png" style="zoom:50%;" />

<ul>
<li><p>笛卡尔积D<del>1</del>×D<del>2</del>×…×D<del>n</del>的子集叫做在域D<del>1</del> , D<del>2</del> ,…, D<del>n</del>上的关系，用R(D<del>1</del> , D<del>2</del> ,…, D<del>n</del>)表示</p>
</li>
<li><p>R是关系的名字，n是关系的度或目</p>
<blockquote>
<p>当n&#x3D;1时，称该关系为单元关系</p>
</blockquote>
</li>
<li><p>关系是笛卡尔积中有意义的子集，关系中的每个元素是关系中的元组</p>
<blockquote>
<p>一般来说，笛卡儿积是没有实际语义的，只有它的某个真子集才有实际含义</p>
</blockquote>
</li>
<li><p>关系也可以表示为二维表</p>
</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li>关系中不同列可以对应相同的域，为了加以区分，必须对每列起一个名字，称为属性</li>
<li>n目关系必有n个属性</li>
</ul>
</li>
</ul>
<h3 id="关系数据结构-1"><a href="#关系数据结构-1" class="headerlink" title="关系数据结构"></a>关系数据结构</h3><p>关系的性质</p>
<ul>
<li>列是同质的；即每一列中的分量是同一类型的数据，来自同一个域。</li>
<li>行列的顺序无关紧要；行列的次序是可以任意交换的</li>
<li>任意两个元组不能完全相同</li>
<li>每一分量必须是不可再分的数据</li>
<li>不同的属性，属性名不能相同</li>
</ul>
<p>候选码（Candidate Key）</p>
<ul>
<li><strong>关系中的一个属性组，其值能唯一标识一个元组</strong>。若从属性组中去掉任何一个属性，它就不具有这一性质了，这样的属性组称作候选码如DEPT中的D#，DN都可作为候选码</li>
<li>任何一个候选码中的属性称作主属性如SC中的S#，C#</li>
</ul>
<p>主码（Primary Key）</p>
<ul>
<li>若一个关系有多个候选码，则选定其中一个作为主码如可选定D#作为DEPT的主码</li>
</ul>
<p>外码（Foreign Key）</p>
<ul>
<li>关系R中的一个属性组，它不是R的码，但它与另一个关系S的码相对应，则称这个属性组为R的外码<br>如S关系中的D#属性</li>
</ul>
<h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><p>形式化的表示为R(U,D,DOM,F)</p>
<blockquote>
<p>R为关系名，U为组成该关系的属性名集合；D为U中属性所来自的域；DOM为属性向域的映象集合；F为属性间数据的依赖关系集合。</p>
</blockquote>
<ul>
<li>关系的描述称作关系模式，包括关系名、关系中的属性名、属性向域的映象、属性间的数据依赖关系等，记作R(A<del>1</del> , A<del>2</del> ,…, A<del>n</del> ) </li>
<li>属性向域的映象一般直接说明为属性的类型、长度等</li>
<li>某一时刻对应某个关系模式的内容(元组的集合)称作关系</li>
<li>关系模式是型，是稳定的<br>关系是某一时刻的值，是随时间不断变化的</li>
</ul>
<h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><ul>
<li><p>其型是关系模式的集合，即数据库描述，称作数据库的内涵(Intension)，或关系数据库模式</p>
</li>
<li><p>其值是某一时刻关系的集合，称作数据库的外延(Extension)，或关系数据库</p>
</li>
</ul>
<h2 id="关系的完整性约束"><a href="#关系的完整性约束" class="headerlink" title="关系的完整性约束"></a>关系的完整性约束</h2><h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><ul>
<li>关系的主码中的属性值不能为空值</li>
<li>空值：不知道或无意义</li>
<li>意义：关系对应到现实世界中的实体集，元组对应到实体，实体是相互可区分的，通过主码来唯一标识，若主码为空，则出现不可标识的实体，这是不容许的</li>
</ul>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><ul>
<li>如果关系R<del>2</del>的外码F<del>k</del>与关系R<del>1</del>的主码P<del>k</del>相对应，则R<del>2</del>中的每一个元组的F<del>k</del>值或者等于R<del>1</del> 中某个元组的P<del>k</del>值，或者为空值【即属性Fk本身不是主属性，则可以取空值，否则不能取空值。】</li>
<li>意义：如果关系R<del>2</del>的某个元组t<del>2</del>参照了关系R<del>1</del>的某个元组t<del>1</del>，则t<del>1</del>必须存在</li>
<li>例如：关系S在D#上的取值有两种可能<ul>
<li>空值，表示该学生尚未分到任何系中</li>
<li>若非空值，则必须是DEPT关系中某个元组的D#值，表示该学生不可能分到一个不存在的系中<br>DEPT(D#, DN , DEAN)S(S#, SN , SEX , AGE , D#)</li>
</ul>
</li>
</ul>
<h3 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h3><ul>
<li><p>用户定义的完整性</p>
<ul>
<li><p>用户针对具体的应用环境定义的完整性约束条件</p>
</li>
<li><p>如S#要求是8位整数，SEX要求取值为“男”或“女”</p>
</li>
</ul>
</li>
<li><p>系统支持</p>
<ul>
<li>实体完整性和参照完整性由系统自动支持</li>
<li>系统应提供定义和检验用户定义的完整性的机制</li>
</ul>
</li>
</ul>
<h1 id="关系代数概述"><a href="#关系代数概述" class="headerlink" title="关系代数概述"></a>关系代数概述</h1><ul>
<li>属于关系操作的一种</li>
<li>关系代数是一种抽象的查询语言</li>
<li>通过对关系的运算来表达查询操作</li>
<li>运算对象、结果均为关系</li>
<li>运算包括四类：<ul>
<li>集合运算、关系运算、比较运算、逻辑运算</li>
</ul>
</li>
</ul>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><h3 id="并运算"><a href="#并运算" class="headerlink" title="并运算"></a>并运算</h3><ul>
<li><p>所有至少出现在两个关系中之一的元组集合</p>
</li>
<li><p>两个关系R和S若进行并运算，则它们必须是相容的:</p>
<ul>
<li>关系R和S必须是同元的，即它们的属性数目必须相同</li>
<li>对i，R的第i个属性的域必须和S的第i个属性的域相同</li>
</ul>
</li>
</ul>
<h3 id="差运算"><a href="#差运算" class="headerlink" title="差运算"></a>差运算</h3><p>所有出现在一个关系而不在另一关系中的元组集合</p>
<p>R和S必须是相容的</p>
<h3 id="交运算"><a href="#交运算" class="headerlink" title="交运算"></a>交运算</h3><ul>
<li>所有同时出现在两个关系中的元组集合</li>
<li>交运算可以通过差运算来重写</li>
</ul>
<h2 id="基本关系运算"><a href="#基本关系运算" class="headerlink" title="基本关系运算"></a>基本关系运算</h2><h3 id="选择运算"><a href="#选择运算" class="headerlink" title="选择运算"></a>选择运算</h3><p>在关系R中选择满足给定条件的元组（从行的角度）</p>
<h3 id="投影运算"><a href="#投影运算" class="headerlink" title="投影运算"></a>投影运算</h3><p>投影的结果中要去掉相同的行</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200401174458046.png" style="zoom:67%;" />

<h3 id="广义笛卡儿积"><a href="#广义笛卡儿积" class="headerlink" title="广义笛卡儿积"></a>广义笛卡儿积</h3><ul>
<li><p>元组的连串（Concatenation）</p>
<ul>
<li>若r &#x3D; (r<del>1</del>，…，r<del>n</del>)，s &#x3D; (s<del>1</del> ，… ，s<del>m</del>)，则定义r与s的连串为：rs &#x3D; (r<del>1</del>，…，r<del>n</del>，s<del>1</del> ，…，s<del>m</del>)</li>
</ul>
</li>
<li><p>广义笛卡尔积两个关系R，S，其度分别为n，m，则它们的笛卡尔积是所有这样的元组集合：元组的前n个分量是R中的一个元组，后m个分量是S中的一个元组<br>RxS&#x3D;{rs|r属于R并且s属于S}</p>
</li>
<li><p>RxS的度为R与S的度之和，RxS的元组个数为R和S的元组个数的乘积</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601164930592.png"></p>
</li>
</ul>
<h2 id="其它关系运算"><a href="#其它关系运算" class="headerlink" title="其它关系运算"></a>其它关系运算</h2><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601165011840.png"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601165118331.png"></p>
<p>0连接就是有附加条件的自然连接。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601165210237.png"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601165223860.png"></p>
<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>把上述中舍弃的元组也保存在结果关系中，在其他属性上填上NULL。</p>
<p>左外连接：只把左边关系R中要舍弃的元组保留。同理：右外连接。</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601165444957.png" style="zoom:50%;" />

<h3 id="除运算"><a href="#除运算" class="headerlink" title="除运算"></a>除运算</h3><p>把S和R中相同的属性组拿出来，然后取R中独有的属性</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200601165522272.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/03/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">编译原理-LR分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-27 15:18:39" itemprop="dateCreated datePublished" datetime="2020-03-27T15:18:39Z">2020-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="句柄和规范归约"><a href="#句柄和规范归约" class="headerlink" title="句柄和规范归约"></a>句柄和规范归约</h1><p>归约：根据文法的产生式规则，把串中出现的产生式的右部替换成左部符号</p>
<p>从语法树的角度看，是从叶子出发逐步向上进行构造</p>
<p>句柄：最左两代子树末端就是句柄</p>
<p>规范归约的关键是寻找句柄：</p>
<p>1、根据语法树找句柄</p>
<p>2、在栈中根据三类信息：</p>
<ul>
<li>历史：已经移入符号栈的内容</li>
<li>展望：根据产生式推迟未来可能遇到的输入符号</li>
<li>现实：当前的输入符号</li>
</ul>
<h1 id="LR分析"><a href="#LR分析" class="headerlink" title="LR分析"></a>LR分析</h1><p>LR分析法也是一种“移进—归约”的自底向上语法分析方法，<strong>其本质是规范归约【句柄作为可归约串】</strong>。</p>
<p>其思想为一方面记住已移进和归约出的整个符号串，另一方面根据所用产生式推测未来可能碰到的输入符号。</p>
<p><strong>LR分析方法：把“历史”以及“展望”综合抽象成状态；由栈顶的状态和现行的输入符号唯一确定每一步工作。</strong></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/image-20200427132237942.png"></p>
<p>解释：每一个符号对应一个状态，分析栈每次弹出一个符号，就要把对应的状态也弹出。然后LR分析程序会根据输入串在LR分析表中进行查找：是进行归约、移进还是报错操作。</p>
<p>LR分析器实质上是一个带先进后出存储器（栈）的确定有限自动机，其核心部分是一张分析表，包括两部分：</p>
<p>（1）ACTION[s，a]动作表，规定当状态s面临输入符号a时，应采取什么动作（移进、归约、接受、 报错）【<strong>也就是告诉我们当栈顶状态为s时，输入的符号是a时，我们应该采取什么操作：归约、移进还是报错</strong>】</p>
<p>（2）GOTO[s，X]状态转换表规定了状态s面对文法符号X时，下一状态是什么。【<strong>当归约完了后，要把规约后的非终结符压到栈里面的时候，跟新压入栈的这个非终结符所对应的状态是什么</strong>】</p>
<h2 id="LR文法"><a href="#LR文法" class="headerlink" title="LR文法"></a>LR文法</h2><p>对于一个文法，如果能够构造一张分析表，使得它的每个入口均是唯一确定的，则这个文法就是LR文法</p>
<p>一个文法，如果能用一个每步顶多向前检查k个输入符号的LR分析器分析，则这个文法就称为LR(K)文法</p>
<p>LR文法不是二义的</p>
<h2 id="LR-0-分析"><a href="#LR-0-分析" class="headerlink" title="LR(0)分析"></a>LR(0)分析</h2><h3 id="拓广文法"><a href="#拓广文法" class="headerlink" title="拓广文法"></a>拓广文法</h3><p>对于文法 G &#x3D; (V<del>N</del>, V<del>T</del>, P , S ) , 增加如下产生式：S’-&gt;S ，其中， S’ ∈ V<del>N</del>∪ V<del>T</del> ， 得到 G 的拓广文法，G’ &#x3D; (V<del>N</del> ’, V<del>T</del>, P ’ , S’ )</p>
<p><strong>其实就是增加了一条右部为开始符号的产生式，就变成了拓广文法</strong></p>
<h3 id="可归前缀"><a href="#可归前缀" class="headerlink" title="可归前缀"></a>可归前缀</h3><p>将符号串的任意含有头符号的子串称为前缀。特别地，空串ε为任意串的前缀。</p>
<p>采取归约过程前符号栈中的内容，称做可归前缀。<br>这种前缀包含句柄且不包含句柄之后的任何符号；</p>
<h3 id="活前缀"><a href="#活前缀" class="headerlink" title="活前缀"></a>活前缀</h3><p>就是在LR分析中为了描述栈内符号的特点给出的概念</p>
<p>对于文法 G &#x3D; (V<del>N</del>, V<del>T</del>, P , S ) , 设 S’ 是其拓广文法的开始符号（即有产生式 S’-&gt; S）， 且α,β∈(V<del>N</del>∪V<del>T</del>)* , ω∈V<del>T</del><em>。<br>若 S’ &#x3D;^</em>^&#x3D;&gt;α A ω 且 A -&gt;β， 即 β 为句柄，则 αβ 的任何前缀 γ 都是文法 G 的活前缀。【<strong>活前缀就是不含句柄之后任何符号的前缀</strong>】<br>注：由于 S’ &#x3D;^*^&#x3D;&gt;S’ 且 S’ -&gt; S， 故 S 是 G 的活前缀 。</p>
<p><strong>也就是说可归前缀的所有前缀（包括可归前缀）都是活前缀。</strong></p>
<blockquote>
<p>例：文法 G[S] :<br>（1） S -&gt; AB<br>（2） A -&gt; aA<br>（3） A -&gt; ε<br>（4） B -&gt; b<br>（5） B -&gt; bB<br>句子 aaab 是一个句型，其唯一的句柄为：ε （aaaεb）； 活前缀有：ε，a，aa，aaa。</p>
</blockquote>
<p>规范归约过程中，保证分析栈中总是活前缀，就说明分析采取的移进&#x2F;归约动作是正确的</p>
<h3 id="LR-0-项目"><a href="#LR-0-项目" class="headerlink" title="LR(0)项目"></a>LR(0)项目</h3><p>对于文法G，其产生式右部添加一个特殊的符号“.”，就构成文法的一个LR(0)项目，简称项目</p>
<p><strong>每个项目的含义是：欲用改产生式归约时，圆点前面的部分为已经识别了的句柄部分，圆点后面的部分为期望的后缀部分。</strong></p>
<p>分类：</p>
<p>移进项目: 形如 A -&gt; α • aβ（a∈V<del>T</del>），对应移进状态，把a移进符号栈。<br>待约项目: 形如 A -&gt; α • Bβ，对应待约状态，需要等待分析完非终结符B的串再继续分析A的右部。<br>归约项目: 形如 A -&gt; α •，句柄已形成，可以归约。<br>接受项目: 形如 S’ -&gt; S •。【也是一个归约项目，表示整个句子已经识别完毕】<br>初始项目: 形如 S’ -&gt; • S。<br>其中a∈V<del>T</del> , α,β∈(V<del>N</del>∪V<del>T</del>)*， A,B∈V<del>T</del><br>后继项目: 表示同属于一个产生式的项目，但是圆点的位置仅相差一个文法符号，则称后者为前者的后继项目。</p>
<p> • 的左边是已经归约，右边是没有归约的</p>
<blockquote>
<p>例：对于产生式S -&gt; aAcBe，它有6个项目：<br>S -&gt; ·aAcBe<br>S -&gt; a·AcBe<br>S -&gt; aA·cBe<br>S -&gt; aAc·Be<br>S -&gt; aAcB·e<br>S -&gt; aAcBe·</p>
</blockquote>
<h2 id="LR-0-有限状态机的构造方法"><a href="#LR-0-有限状态机的构造方法" class="headerlink" title="LR(0)有限状态机的构造方法"></a>LR(0)有限状态机的构造方法</h2><h3 id="构造识别活前缀的NFA"><a href="#构造识别活前缀的NFA" class="headerlink" title="构造识别活前缀的NFA"></a>构造识别活前缀的NFA</h3><h4 id="NFA的构造方法"><a href="#NFA的构造方法" class="headerlink" title="NFA的构造方法"></a>NFA的构造方法</h4><p>(1)状态集：由每个项目所对应的状态组成的集合；</p>
<p>(2)输入字符集合：由文法符号组成，包括：终结符、非终结符和e；</p>
<p>(3)初态：对于文法G[S]的拓广文法G[S’],有项目S’® . S ,由于S’ 仅在第一个产生式的左部出现，所以规定它为初态；</p>
<p>(4)终态：每个状态均为NFA的终态（活前缀的识别态）。</p>
 <img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203220121070.png" style="zoom:75%;" />

<ul>
<li><p>若状态i为X-&gt;X<del>1</del>····X<del>i-1</del>•X<del>i</del>····X<del>n</del>；状态j为X-&gt;X<del>1</del>····X<del>i-1</del>X<del>i</del>•X<del>i+1</del>····X<del>n</del></p>
<p>则从状态i画一条标志为X<del>i</del>的有向边到状态j</p>
</li>
<li><p>若状态i为X-&gt;α• Aβ，A为非终结符，<br>则从状态i画一条ε边到所有状态A-&gt;• y【可以理解成X想要把A进行归约，然后画一条ε边，交给A需要归约的符号】</p>
</li>
</ul>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203220250887.png" style="zoom:75%;" />

<h3 id="NFA转换成DFA"><a href="#NFA转换成DFA" class="headerlink" title="NFA转换成DFA"></a>NFA转换成DFA</h3><p>DFA是用子集法得到的</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203220947527.png" style="zoom:75%;" />

<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203221052145.png" style="zoom:75%;" />

<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20171203221104587.png" style="zoom:75%;" />

<h3 id="求项目集规范族"><a href="#求项目集规范族" class="headerlink" title="求项目集规范族"></a>求项目集规范族</h3><p>每个项目集对应一个DFA状态，它们的全体称为这个文法的项目集规范族</p>
<h4 id="有效项目"><a href="#有效项目" class="headerlink" title="有效项目"></a>有效项目</h4><p>项目A-&gt;β<del>1</del>• β<del>2</del>对活前缀αβ<del>1</del>是有效的，其条件就是存在规范推导</p>
<h4 id="1-用闭包函数（CLOSURE）来求DFA一个状态的项目集"><a href="#1-用闭包函数（CLOSURE）来求DFA一个状态的项目集" class="headerlink" title="1.用闭包函数（CLOSURE）来求DFA一个状态的项目集"></a>1.用闭包函数（CLOSURE）来求DFA一个状态的项目集</h4><p>I是拓广文法G的任意项目集：<br>CLOSURE(I)是这样定义的：<br>首先I的项目都属于CLOSURE(I)；<br>如果A-&gt;α• Bβ,则左部为B的每个产生式中的形如B-&gt;·γ项目，也属于CLOSURE(I)；</p>
<blockquote>
<p>例子：已知文法G[E]如下:<br>(1) E -&gt; E+T<br>(2) E -&gt; T<br>(3) T -&gt;( E )<br>(4) T -&gt; d</p>
<p>可以直到它的拓广文法G’ [E’]为 ：<br>(0) E’ -&gt; E<br>(1) E -&gt; E+T<br>(2) E -&gt; T<br>(3) T -&gt; ( E )<br>(4) T -&gt; d</p>
<p>令I<del>0</del> &#x3D; CLOSURE({E’-&gt;.E})</p>
<p>则I<del>0</del> &#x3D; {<br>E’ -&gt; • E，<br>E -&gt; • E+T，<br>E -&gt; • T，<br>T -&gt; •( E ),<br>T -&gt; • d<br>}</p>
</blockquote>
<h4 id="2-LR-0-FSM-的状态转移函数"><a href="#2-LR-0-FSM-的状态转移函数" class="headerlink" title="2.LR(0) FSM 的状态转移函数"></a>2.LR(0) FSM 的状态转移函数</h4><p>从一个状态出发，到达下一个状态的转换函数：<br>GO (I,X) &#x3D; CLOSURE(J)<br>其中，I为LR(0) FSM 的状态（闭包的项目集），X为文法符号， J&#x3D;{ A -&gt; αX•β | A -&gt; α• Xβ∈I} ；【J是非终结符包进去后的集合】<br>表示对于一个状态项目集中的一个项目A -&gt; α• Xβ，在下一个输入字符是X的情况下，一定到另一个新状态 A -&gt; αX•β。</p>
<h4 id="3-LR-0-有限状态机的构造"><a href="#3-LR-0-有限状态机的构造" class="headerlink" title="3.LR(0) 有限状态机的构造"></a>3.LR(0) 有限状态机的构造</h4><p>从 LR(0) FSM 的初态出发 ，先求出初态项目集的闭包（CLOSURE({S’-&gt;.S})），然后应用上述转移函数，通过项目分析每种输入字符下的状态转移，若为新状态，则就求出新状态下的项目集的闭包，级可逐步构造出完整的 LR(0) FSM。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">构造项目集规范族的算法：</span><br><span class="line"><span class="function"><span class="keyword">PROCEDURE</span> <span class="title">ITEMSET</span><span class="params">(G<span class="string">&#x27;)；</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">BEGIN</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">C:&#123;CLOSURE&#123;S&#x27;</span>-&gt;.S&#125;&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">REPEAT</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">FOR</span> C中的每一个项目集I和G<span class="string">&#x27;的每一个符号X DO</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		IF GO(I,X)非空且不属于C THEN</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		把GO(I,X)放入C族中</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">	UNTIL C不再增大</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">End</span></span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>LR(0) FSM 的构造举例<br>给定文法G[E]：<br>(1) E -&gt; E+T<br>(2) E -&gt; T<br>(3) T -&gt; ( E )<br>(4) T -&gt; d</p>
<p>构造LR(0) FSM<br>① G[E]的拓广文法，得到G’ [E’]：<br>(0) E’ -&gt; E<br>(1) E -&gt; E+T<br>(2) E -&gt; T<br>(3) T -&gt; ( E )<br>(4) T -&gt; d</p>
<p>②构造G’[E’] 的 LR(0) FSM</p>
<p><img src="https://img-blog.csdnimg.cn/20181229131739897"></p>
</blockquote>
<p>两种构造识别活前缀的DFA的方法：</p>
<ul>
<li>项目-&gt;NFA-&gt;DFA</li>
<li>Closure-&gt;GO-&gt;DFA</li>
</ul>
<h2 id="LR-0-分析法"><a href="#LR-0-分析法" class="headerlink" title="LR(0) 分析法"></a>LR(0) 分析法</h2><h3 id="1-LR-0-文法定义"><a href="#1-LR-0-文法定义" class="headerlink" title="1.LR(0) 文法定义"></a>1.LR(0) 文法定义</h3><p>文法 G 是 LR(0) 文法，当且仅当它的LR(0)FSM中的每个状态都满足：<br><strong>①不同时含有移进项目和归约项目，即不存在移进-归约冲突。</strong><br><strong>②不含有两个以上归约项目，即不存在归约-归约冲突。</strong></p>
<h3 id="2-LR-0-分析表的构造"><a href="#2-LR-0-分析表的构造" class="headerlink" title="2.LR(0)分析表的构造"></a>2.LR(0)分析表的构造</h3><p>令每个项目集I<del>k</del>的下标k作为分析器的状态</p>
<p>ACTION 表项和 GOTO表项可按如下方法构造：</p>
<ul>
<li><p>若项目A -&gt;α • aβ属于 I<del>k</del> 且 GO (I<del>k</del>, a)&#x3D; I<del>j</del>, 期望字符a 为终结符，则置ACTION[k, a] &#x3D;s<del>j</del> (j表示新状态I<del>j</del>);</p>
</li>
<li><p>若项目A -&gt;α •属于I<del>k</del>, 那么对任何终结符a, 置ACTION[k, a]&#x3D;r<del>j</del>；其中，假定A-&gt;α为文法G 的第j个产生式；【对k到a进行归约】</p>
</li>
<li><p>若项目S’ -&gt;S • 属于I<del>k</del>, 则置ACTION[k, #]为“acc”;【单词处理完毕】</p>
</li>
<li><p>若项目A -&gt;α • Aβ属于 I<del>k</del>，且GO (I<del>k</del>, A)&#x3D; I<del>j</del>,期望字符 A为非终结符，则置GOTO(k, A)&#x3D;j (j表示文法中第j个产生式);</p>
</li>
<li><p>分析表中凡不能用上述规则填入信息的空白格均置上“出错标志”</p>
<p><strong>翻译一下：</strong></p>
<ol>
<li><strong>如果圆点不在项目k最后且圆点后的期待字符a为终结符，则ACTION[k, a] &#x3D;s<del>j</del> (j表示新状态I<del>j</del>)；</strong></li>
<li><strong>如果圆点不在项目k最后且圆点后的期待字符A为非终结符，则GOTO(k, A)&#x3D;j (j表示文法中第j个产生式)；</strong></li>
<li><strong>如果圆点在项目k最后且k不是S’ -&gt;S，那么对所有终结符a，ACTION[k, a]&#x3D;r<del>j</del> (j表示文法中第j个产生式)；</strong></li>
<li><strong>如果圆点在项目k最后且k是S’ -&gt;S，则ACTION[k, #]为“acc”;</strong></li>
</ol>
</li>
</ul>
<blockquote>
<p>例子：</p>
<p>考虑文法G[S] :<br>S → （S） | a<br>相应的LR(0) FSM如下，构造其LR(0)分析表。</p>
<p><img src="https://img-blog.csdnimg.cn/20181229131739956"></p>
<p>LR(0) FSM</p>
<p>从I<del>0</del>看，S‘-&gt;·S,期望字符是非终结符S，根据上面的规则2，得到GOTO(0,S)&#x3D;1；<br>S‘-&gt;·(S),期望字符是终结符(，根据上面的规则1，得到ACTION(0,()&#x3D;S<del>2</del>；<br>从I<del>3</del>看，S-&gt;a·，根据规则3，置ACTION[3, a]为r<del>2</del>;<br>从I<del>1</del>看，S‘-&gt;S·，根据规则4，置ACTION[1, #]为“acc”;</p>
<p><img src="https://img-blog.csdnimg.cn/201812291317408"></p>
<p>LR(0)分析表</p>
</blockquote>
<h3 id="3-LR-0-分析流程"><a href="#3-LR-0-分析流程" class="headerlink" title="3.LR(0) 分析流程"></a>3.LR(0) 分析流程</h3><p>设输入串为w，ip指向输入串w的首符号a，i指向符号栈顶；状态栈的初始栈顶为0，符号栈初始栈顶为#。</p>
<p>算法流程图为：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/image-20200427170434108.png"></p>
<h2 id="SLR-1-分析法"><a href="#SLR-1-分析法" class="headerlink" title="SLR(1)分析法"></a>SLR(1)分析法</h2><h3 id="1-SLR-1-解决的问题"><a href="#1-SLR-1-解决的问题" class="headerlink" title="1.SLR(1)解决的问题"></a>1.SLR(1)解决的问题</h3><p>LR(0)文法的要求是①不同时含有移进项目和归约项目，即不存在移进-归约冲突。②不含有两个以上归约项目，即不存在归约-归约冲突。</p>
<p>例如项目集I<del>i</del>中存在： I<del>i</del> ＝{A-&gt;α•bγ ， B→ γ•，C→β• }，此时就同时存在移进-归约冲突和归约-归约；因为你不知道下一步是选择归约还是移进，选择归约的话选择哪个产生式归约。</p>
<p>而事实上一般文法满足这种要求有一定难度，但是假如在归约时出现了移进-归约冲突或者归约-归约冲突，我们可以通过在待分析的字符串中向后再看一位，大多数情况下通过这一位字符就可以确定，选择哪一个表达式归约，或是移进操作。</p>
<p>这种方法就叫做SLR(1)分析法，即简单的LR(1)分析法。</p>
<h3 id="2-SLR-1-冲突解决方法"><a href="#2-SLR-1-冲突解决方法" class="headerlink" title="2.SLR(1)冲突解决方法"></a>2.SLR(1)冲突解决方法</h3><p>如上面所述，我们需要知道下一位待分析的字符，然后和现有项目进行比较。</p>
<p>分析过程与LR(0)一样，但是需要解决分析表上的冲突问题。</p>
<p>假如LR(0) 项目集规范族中有项目集 I<del>i</del> 含有移进-归约冲突和归约-归约冲突：<br> I<del>i</del> ＝{A<del>1</del>-&gt;α<del>1</del>•b<del>1</del>γ<del>1</del>，… ， A<del>m</del>-&gt;m•b<del>m</del> γ<del>m</del>， B<del>1</del>-&gt;β<del>1</del>• ，…， B<del>n</del>-&gt; β<del>n</del>• }，若集合{b<del>1</del> ，b<del>2</del>，… ，b<del>m</del> }、FOLLOW(B<del>1</del>) 、 FOLLOW(B<del>2</del>) ，…，FOLLOW(Bn)均两两不相交，则可用SLR(1)解决方法解决分析表上第i行上的冲突问题。</p>
<p>假设下一个移进的字符为b:</p>
<p>1、若b∈ {b<del>1</del> ，b<del>2</del>，… ，b<del>m</del> }，则移进输入符；</p>
<p>2、若b∈FOLLOW(B<del>j</del>) ，j＝1 ，… ，n，则用B<del>j</del>-&gt; β<del>j</del> 归约；</p>
<p>3、此外，报错</p>
<p>通过这个方法，就可以在知道下一位待分析的字符的情况下，解决冲突。</p>
<p>继续采用SLR(1)分析的方法，我们可以对出错情况进行优化：</p>
<p>在LR(0)和SLR(1)分析中，我们在可以归约且没有冲突时（假如归约成A），是不关心下一位待分析的字符a和follow(A)的关系的，假如a!∈follow(A)则当前字符串是不被接受的，当然这会在之后的继续移进字符过程中发现错误，但是如果不管是否有冲突看，将SLR(1)分析方法应用到所有分析表的构建过程中，可以提前发现字符串的错误。</p>
<h3 id="3-构造SLR-1-分析表的方法"><a href="#3-构造SLR-1-分析表的方法" class="headerlink" title="3.构造SLR(1)分析表的方法"></a>3.构造SLR(1)分析表的方法</h3><p>1、把G扩广成G’</p>
<p>2、对G’构造：得到LR(0)项目集规范族C；活前缀识别自动机的状态转换函数GO</p>
<p>3、使用C和GO，构造SLR分析表：构造action和goto子表：</p>
<ul>
<li>若项目A -&gt;α • aβ属于 I<del>k</del> 且 GO (I<del>k</del>, a)&#x3D; I<del>j</del>,期望字符a为终结符，则置ACTION[k, a] &#x3D;s<del>j</del> (j表示新状态I<del>j</del>);</li>
<li>若项目A -&gt;α • Aβ属于 I<del>k</del>，且GO (I<del>k</del>, A)&#x3D; I<del>j</del>,期望字符 A为非终结符，则置GOTO(k, A)&#x3D;j (j表示文法中第j个产生式);</li>
<li>若项目A -&gt;α •属于I<del>k</del>, 那么对任何终结符a，<strong>当满足a属于follow(A)时</strong>， 置ACTION[k, a]&#x3D;r<del>j</del>；其中，假定A-&gt;α为文法G 的第j个产生式；</li>
<li>若项目S’ -&gt;S • 属于I<del>k</del>, 则置ACTION[k, #]&#x3D;“acc”;</li>
<li>分析表中凡不能用上述规则填入信息的空白格均置上“出错标志”</li>
</ul>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/image-20200427182955125.png"></p>
<p>SLR分析是有选择的放置的</p>
<h3 id="4-SLR（1）文法"><a href="#4-SLR（1）文法" class="headerlink" title="4.SLR（1）文法"></a>4.SLR（1）文法</h3><p>按上述方法构造出的ACTION和GOTO表如果不含多重入口，则称该文法是SLR(1)文法。</p>
<p>使用SLR表的分析器叫做一个SLR分析器</p>
<p>每个SLR(1)文法都是无二义的。<br>$$<br>LR(0)\subset SLR(1)\subset 无二义文法<br>$$</p>
<h3 id="5-SLR-1-分析的例子"><a href="#5-SLR-1-分析的例子" class="headerlink" title="5.SLR(1)分析的例子"></a>5.SLR(1)分析的例子</h3><blockquote>
<p>算术表达式文法G[E]：<br>E→E +T | T<br>T→T * F | F<br>F→ （E）| i<br>求此文法的识别规范句型活前缀的DFA，分析句子i+i *i。</p>
</blockquote>
<ol>
<li>将文法拓广为G’[E’]：<br>(0) E’ -&gt;E<br>(1) E-&gt; E +T<br>(2) E -&gt;T<br>(3) T -&gt;T * F<br>(4) T -&gt;F<br>(5) F -&gt;(E)<br>(6) F -&gt;i</li>
<li>构造识别规范句型活前缀的DFA</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20181229131728485"></p>
<ol>
<li><p>判断有无冲突：</p>
<p>I<del>1</del> ，I<del>2</del> ，I<del>9</del>有移进_归约冲突。<br>I<del>1</del>:E´ -&gt;E· E -&gt;E·+T<br>I<del>2</del>: E -&gt;T · T -&gt;T · *F<br>I<del>9</del>: E -&gt;E+T· T -&gt;T · *F</p>
</li>
<li><p>考虑能否用SLR(1)方法解决冲突：</p>
<p>对于I<del>1</del>: <code>&#123; E´ -&gt;E· E -&gt;E·+T&#125;</code> 因为：<code>&#123;+&#125; ∈FOLLOW(E´)= &#123;+&#125; ∩ &#123;＃&#125; ＝∅</code>, 所以可用SLR(1)方法 解决I<del>1</del>的冲突。</p>
<p>对于I<del>2</del>: <code>&#123;E -&gt;T· T -&gt;T·*F&#125;</code> 因为：<code>&#123;*&#125; ∈ FOLLOW(E)= &#123;*&#125; ∩ &#123;＃，）,+&#125; ＝ ∅</code> 所以可用SLR(1)方法解决I<del>2</del>的冲突。</p>
<p>对于I<del>9</del>: <code>&#123;E -&gt;E+T· T -&gt;T ·*F&#125;</code> 因为：<code>&#123;*&#125; FOLLOW(E)= ∅</code>, 所以可用SLR(1)方法解决I<del>9</del>的冲突。</p>
</li>
<li><p>构建分析表：</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20181229131728536"></p>
<p>6.句子i+i *i的分析过程：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>状态栈</th>
<th>符号栈</th>
<th>输入符</th>
<th>剩余输   入串</th>
<th align="left">查表</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
<td>#</td>
<td>i</td>
<td>i+i*i#</td>
<td align="left">Action[0,i]&#x3D;S5</td>
<td>移进i</td>
</tr>
<tr>
<td>2</td>
<td>0 5</td>
<td># i</td>
<td>+</td>
<td>+i*i#</td>
<td align="left">Action[5,+]&#x3D;r6,GOTO(0,F)&#x3D;3</td>
<td>用F -&gt; i 归约</td>
</tr>
<tr>
<td>3</td>
<td>0 3</td>
<td># F</td>
<td>+</td>
<td>+i*i#</td>
<td align="left">Action[3,+]&#x3D;r4,GOTO(0,T)&#x3D;2</td>
<td>用F -&gt; T归约</td>
</tr>
<tr>
<td>4</td>
<td>0 2</td>
<td># T</td>
<td>+</td>
<td>+i*i#</td>
<td align="left">Action[2,+]&#x3D;r4,GOTO(0,E)&#x3D;1</td>
<td>用F -&gt; E归约</td>
</tr>
<tr>
<td>5</td>
<td>0 1</td>
<td># E</td>
<td>+</td>
<td>+i*i#</td>
<td align="left">Action[1,+]&#x3D;S6</td>
<td>移进+</td>
</tr>
<tr>
<td>6</td>
<td>0 1 6</td>
<td># E +</td>
<td>i</td>
<td>i*i#</td>
<td align="left">Action[6,i]&#x3D;S6</td>
<td>移进+</td>
</tr>
<tr>
<td>7</td>
<td>0 1 6 5</td>
<td># E + i</td>
<td>*</td>
<td>*i#</td>
<td align="left">Action[5,*]&#x3D;r6,GOTO(6,F)&#x3D;3</td>
<td>用F -&gt; i 归约</td>
</tr>
<tr>
<td>8</td>
<td>0 1 6 3</td>
<td># E + F</td>
<td>*</td>
<td>*i#</td>
<td align="left">Action[3,*]&#x3D;r6,GOTO(6,T)&#x3D;9</td>
<td>用F -&gt; F 归约</td>
</tr>
<tr>
<td>9</td>
<td>0 1 6 9</td>
<td># E + T</td>
<td>*</td>
<td>*i#</td>
<td align="left">Action[9,*]&#x3D;S7</td>
<td>移进*</td>
</tr>
<tr>
<td>10</td>
<td>0 1 6 9 7</td>
<td># E + T *</td>
<td>i</td>
<td>i#</td>
<td align="left">Action[7,i]&#x3D;S5</td>
<td>移进i</td>
</tr>
<tr>
<td>11</td>
<td>0 1 6 9 7 5</td>
<td># E + T * i</td>
<td>#</td>
<td>#</td>
<td align="left">Action[5,#]&#x3D;r6,GOTO(7,F)&#x3D;10</td>
<td>用F -&gt; i 归约</td>
</tr>
<tr>
<td>12</td>
<td>0 1 6 9 7 10</td>
<td># E + T * F</td>
<td>#</td>
<td>#</td>
<td align="left">Action[10,#]&#x3D;r3,GOTO(6,T)&#x3D;9</td>
<td>用T -&gt; T+F归约</td>
</tr>
<tr>
<td>13</td>
<td>0 1 6 9</td>
<td># E + T</td>
<td>#</td>
<td>#</td>
<td align="left">Action[9,#]&#x3D;r1,GOTO(0,E)&#x3D;1</td>
<td>用E -&gt; E+T归约</td>
</tr>
<tr>
<td>14</td>
<td>0 1</td>
<td># E</td>
<td>#</td>
<td>#</td>
<td align="left">Action[1,#]&#x3D;acc</td>
<td>接受</td>
</tr>
</tbody></table>
<h2 id="LR-1-分析法"><a href="#LR-1-分析法" class="headerlink" title="LR(1)分析法"></a>LR(1)分析法</h2><h3 id="SLR冲突消解存在的问题"><a href="#SLR冲突消解存在的问题" class="headerlink" title="SLR冲突消解存在的问题"></a>SLR冲突消解存在的问题</h3><p>在SLR方法中，如果项目集I<del>i</del>含项目A -&gt;α •而且下一输入符号α∈FOLLOW(A)，则状态i面临α时，可选用“用A -&gt;α归约”动作。</p>
<p>但是在某些情况下，当状态i显现于栈顶时，当前单词是α，栈里的活前缀βα未必允许把α归约为A，因为可能根本不存在一个形如“βAα”的规范句型。在这种情况下，用“A -&gt;α”归约不一定合适</p>
<p>【因为FOLLOW（A）集合提供的信息太泛】</p>
<h3 id="构造LR-1-分析表的方法"><a href="#构造LR-1-分析表的方法" class="headerlink" title="构造LR(1)分析表的方法"></a>构造LR(1)分析表的方法</h3><p>1、把G扩广成G’</p>
<p>2、对G’构造：得到LR(1)项目集规范族C；活前缀识别自动机的状态转换函数GO</p>
<p>3、使用C和GO，构造LR（1）分析表：</p>
<p>LR(K)项目：扩展LR(0)项目，附带有k个终结符[A-&gt;α •β,α<del>1</del>α<del>2</del>····α<del>k</del>]<br>α<del>1</del>α<del>2</del>····α<del>k</del>称为向前搜索符串（或展望串）</p>
<p>归约项目[A-&gt;α •,α<del>1</del>α<del>2</del>····α<del>k</del>]的意义：当它所属的状态呈现现在栈顶且后续的k个输入符号为α<del>1</del>α<del>2</del>····α<del>k</del>时，才可以把栈顶上的α归约为A</p>
<p> 对于任何移进或待约项目[A-&gt;α •β,α<del>1</del>α<del>2</del>····α<del>k</del>]，β不等于α，搜索符串α<del>1</del>α<del>2</del>····α<del>k</del>没有直接作用 </p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">构造项目集规范族的算法：</span><br><span class="line"><span class="function"><span class="keyword">PROCEDURE</span> <span class="title">ITEMSET</span><span class="params">(G<span class="string">&#x27;)；</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">BEGIN</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">C:&#123;CLOSURE&#123;S&#x27;</span>-&gt;.S,#&#125;&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">REPEAT</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">FOR</span> C中的每一个项目集I和G<span class="string">&#x27;的每一个符号X DO</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		IF GO(I,X)非空且不属于C THEN</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		把GO(I,X)放入C族中</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">	UNTIL C不再增大</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">End</span></span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>若项目[A -&gt;α • aβ，b]属于 I<del>k</del> 且 GO (I<del>k</del>, a)&#x3D; I<del>j</del>,期望字符a为终结符，则置ACTION[k, a] &#x3D;s<del>j</del> (j表示新状态I<del>j</del>);</li>
<li>若项目[A -&gt;α •，a]属于I<del>k</del>, 那么对任何终结符a，<strong>当满足a属于follow(A)时</strong>， 置ACTION[k, a]&#x3D;r<del>j</del>；其中，假定A-&gt;α为文法G 的第j个产生式；</li>
<li>若项目[S’ -&gt;S • ，#]属于I<del>k</del>, 则置ACTION[k, #]&#x3D;“acc”;</li>
<li>若GO[I<del>k</del>，A]&#x3D;I<del>j</del>，则置GOTO[K,A]&#x3D;j</li>
<li>分析表中凡不能用上述规则填入信息的空白格均置上“出错标志”</li>
</ul>
<p>$$<br>LR(0)\subset SLR(1)\subset LR(1)\subset 无二义文法<br>$$</p>
<p><strong>（SLR(1)和LR(1)的区别在于LR(1)多使用了一个预判信息，即项目后面的符号如A →·e,c中的c，这个预判信息是用first集而非follow集得出的）</strong></p>
<h1 id="LR-0-、SLR-1-、LL-1-等的区别"><a href="#LR-0-、SLR-1-、LL-1-等的区别" class="headerlink" title="LR(0)、SLR(1)、LL(1)等的区别"></a>LR(0)、SLR(1)、LL(1)等的区别</h1><p>LL(1)定义：一个文法G是LL（1）的，当且仅当对于G的每一个非终结符A的任何两个不同产生式 A→α|β，下面的条件成立：SELECT( A→α)∩SELECT( A→β)&#x3D;,其中，</p>
<p>α|β不能同时ε。</p>
<p>解释：LL(1)的意思是，第一个L,指的是从左往右处理输入，第二个L,指的是它为输入生成一个最左推导。1指的是向前展望1个符号。LL(1)文法是上下文无关文法的一个子集。它用的方法是自顶向下的(递归式的处理)。它要求生成的预测分析表的每一个项目至多只能有一个生成式。上面的定义说的是，任何两个不同的产生式 A→α和 A→β,选择A→α或者 A→β是不能有冲突的，即SELECT( A→α)∩SELECT( A→β)&#x3D;，具体来说，就是，第一:First( A→α) ∩ First( A→β)&#x3D;,首符集不能有交集，否则当交集中的元素出现时，选择哪个产生式进行推导是不确定的，（这其中也包含了α|β不能同时ε，否则交集就是{ε}不为空），第二：若任何一个产生式β，有ε属于First(β),应有First(A)∩Follow( A)为空（当ε属于First(β)，则A有可能被空串代替，那么就要看A的下一个字符，即Follow集，即要求Follow集和First集不能相交，否则可能发生冲突）。</p>
<p>LR文法：定义：如果某一文法能够构造一张分析表，使得表中每一个元素至多只有一种明确动作，则该文法称为LR文法。</p>
<p>拓展：由上面的定义可以看到，LL(1)和LR文法都是无二义性的：LL(1)要求生成的预测分析表的每一个项目至多只能有一个生成式，即对于读头下的每一个字符，都可以明确地选择哪个产生式来推导，LR文法要求每一步都有明确的动作，移进和归约都是可确定的，没有二义性。</p>
<p>比较两大类型（自顶向下　vs 自底向上）的文法的特点：</p>
<p>1.首先LL(1)分析法是自上而下的分析法。LR(0),LR(1),SLR(1),LALR(1)是自下而上的分析法。<br>   2.自上而下:从开始符号出发，根据产生式规则推导给定的句子。用的是推导<br>   3.自下而上:从给定的句子规约到文法的开始符号。用的是归约<br>   4.自上而下就是一种试探过程，怎么试探？需要你写出它的FIRST()集与FOLLOW()集。写出这两个集合后根据LL(1)分析表构造规则画出LL(1)分析表。现在基本完成了大半，当计算机输入句子时，分析程序便会根据输入去和分析表进行匹配，如果每步都能够匹配成功则说明符合该语法规则，分析成功。<br>   FIRST()集：其实是终结符的集合，看该非终结符A能不能产生以它里面的某个符号开头的句子。（这也是自上而下分析法的思想）<br>   5.自下而上就是把句子变成非终结符，在把非终结符变成非终结符，这样不断的进行如果能到根节点则成功。</p>
<p> LL(1)就是向前只搜索1个符号，即与FIRST()匹配，如果FIRST为空则还要考虑Follow。<br>　 LR需要构造一张LR分析表，此表用于当面临输入字符时，将它移进，规约（即自下而上分析思想），接受还是出错。<br>   LR(0)找出句柄前缀，构造分析表，然后根据输入符号进行规约。不考虑先行，只要出现终结符就移进，只要出现归约状态，就无条件归约,这样子可能出现归约－移进，归约－归约冲突。<br>   SLR(1)使用LR(0)时若有归约－归约冲突，归约－移进冲突，所以需要看先行，则只把有问题的地方向前搜索一次。</p>
<p>SLR(1)定义：满足下面两个条件的文法是SLR(1)文法</p>
<p>a.对于在s中的任何项目 A→α.Xβ,当X是一个终结符，且X在Follow(B)中时，s中没有完整的项目B→r.</p>
<p>b.对于在s中的任何两个完整项目A→α.和 B→β.,Follow(A)∩Follow(B)为空。</p>
<p>解释：a.当X是一个终结符且X出现在读头上，对于项目 A→α.Xβ应该采用移进，若有完整的项目B→r.且Follow(B)中有X，当X出现在读头上时，此时应该归约，于是，就产生了移进和归约冲突</p>
<p>b.假设Follow(A)∩Follow(B)为{ X },对于A→α.，若Follow(A)[A后面的元素]出现时，应该归约，同理B也一样，于是，会产生归约－归约冲突，SLR(1)是为了消除LR(0)的两个冲突。<br>   LR(1)1.在每个项目中增加搜索符。2.举个列子如有A-&gt;α.Bβ，则还需将B的规则也加入。<br>   LALR(1)就是假如两个产生式集相同则将它们合并为一个，几合并同心集</p>
<p><strong>总结：</strong></p>
<p><strong>见到First集就移进，见到Follow集就归约。</strong></p>
<p><strong>LR(0):见到First集就移进，见到终态就归约</strong></p>
<p><strong>SLR(1)见到First集就移进，见到终态先看Follow集，与Follow集对应的项目归约，其它报错。</strong></p>
<p><strong>SLR分析法包含的展望信息是体现在利用了Follow(A)信息，可以解决“归约－归约”冲突</strong></p>
<p><strong>SLR分析法没有包含足够的展望信息，不能完成解决“移进－归约”冲突，需要改进。</strong></p>
<p><strong>下面是LR(0),SLR(1),LALR(1),LR(1)文法处理能力的比较，圆圈越大说明能力越强。</strong></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-LR%E5%88%86%E6%9E%90/20130703204706828"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/03/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">编译原理-语法分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-27 15:18:13" itemprop="dateCreated datePublished" datetime="2020-03-27T15:18:13Z">2020-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="词法分析程序设计"><a href="#词法分析程序设计" class="headerlink" title="词法分析程序设计"></a>词法分析程序设计</h1><h2 id="词法分析任务"><a href="#词法分析任务" class="headerlink" title="词法分析任务"></a>词法分析任务</h2><p>词法分析阶段是编译的第一阶段，它的主要任务是<strong>从左至右扫描文本格式的源程序，从基于字符理解的源程序中分离出符合源语言词法的单词，最终转换成基于单词理解的源程序。</strong></p>
<blockquote>
<p>  <strong>输出形式为：</strong> <strong>（单词种类，单词）</strong></p>
<p><strong>单词种类类似于自然语言的词性，由构词规则等因素确定的。</strong></p>
<p>计算机高级语言一般都有<strong>关键字、标识符、常数、运算符和定界符</strong>这5类单词。</p>
</blockquote>
<h2 id="词法分析程序和语法分析程序的接口方式"><a href="#词法分析程序和语法分析程序的接口方式" class="headerlink" title="词法分析程序和语法分析程序的接口方式"></a>词法分析程序和语法分析程序的接口方式</h2><p>词法分析程序通常与后阶段语法分析程序接口有下列两种方式。</p>
<p>⑴词法分析程序和语法分析程序各自独立一趟方式。即词法分析程序把字符流的源程序转换成单词流的内部程序形式，供语法分析程序之用。</p>
<p>⑵词法分析程序和语法分析程序合并为一趟方式。即<strong>词法分析程序由反复语法分析程序调用，每调用一次从源程序中一个新单词返回给语法分析程序。</strong></p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200329103603763.png" style="zoom:67%;" />

<p>第一种方式的效率比较低。</p>
<h1 id="单词的描述工具"><a href="#单词的描述工具" class="headerlink" title="单词的描述工具"></a>单词的描述工具</h1><p>基于<strong>生成观点、计算观点和识别观点</strong>，分别形成了<strong>正规文法、正规式和有穷自动机</strong> 3种用于描述计算机高级语言词法的工具。</p>
<h2 id="正规文法"><a href="#正规文法" class="headerlink" title="正规文法"></a>正规文法</h2><p>对应的是生成观点。</p>
<p>左线性&#x2F;右线性正规文法描述。</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200329111144052.png" style="zoom:67%;" />

<h2 id="正规式"><a href="#正规式" class="headerlink" title="正规式"></a>正规式</h2><p>对应的是计算观点。</p>
<p>基于字母表∑上的正规式（也称为<strong>正则表达式</strong>）定义如下,正规式e的计算值称为正规集,记为L(e)。 </p>
<ol>
<li><p>ε是∑上的正规式，L(ε)＝ {ε} 【ε是空串】</p>
</li>
<li><p>Ф是∑上的正规式，L(Ф)＝Ф【Ф和ε不一样，它表示的是空集，对应的是实体的完整性】</p>
</li>
<li><p>任何a∈∑，a是∑上的正规式，L(a)＝ {a}</p>
</li>
<li><p>如果e<del>1</del>和e<del>2</del>是∑上的正规式，则</p>
<p>4.1.  (e<del>1</del>)是∑上的正规式，L((e<del>1</del>))＝L(e<del>1</del>)【直接脱括号】</p>
<p>4.2. e<del>1</del>︱e<del>2</del> 是∑上的正规式，L(e<del>1</del>︱e<del>2</del>)＝L(e<del>1</del>)∪L(e<del>2</del>)</p>
<p>4.3. e<del>1</del> · e<del>2</del> 是∑上的正规式，L(e<del>1</del>· e<del>2</del>)＝L(e<del>1</del>)·L(e<del>2</del>)</p>
<p>4.4. e<del>1</del>* 是∑上的正规式，L(e<del>1</del>*)＝L(e<del>1</del>)* 【闭包运算】</p>
</li>
</ol>
<blockquote>
<p>字母表∑1和∑2的乘积( product)：</p>
<p>　　∑1∑2 &#x3D;{ab|a ∈∑1, b ∈ ∑2}</p>
<p>　　例： {0, 1} {a, b} &#x3D;{0a, 0b, 1a, 1b}</p>
<p><em><strong>字母表∑的n次幂( power)：长度为n的符号串构成的集合</strong></em></p>
<p>　　∑0 &#x3D;{ ε }<br>　　∑n &#x3D;∑n-1 ∑ , n ≥0</p>
<p>　　例： {0, 1}3 &#x3D;{0, 1} {0, 1} {0, 1}&#x3D;{000, 001, 010, 011, 100, 101, 110, 111}</p>
<p>字母表的正闭包（positive closure）：长度正数的符号串构成的集合：</p>
<p>　　∑+ &#x3D; ∑ ∪∑2 ∪∑3 ∪…</p>
<p>　　例：{a, b, c, d }+ &#x3D; {a, b, c, d,aa, ab, ac, ad, ba, bb, bc, bd, …, aaa, aab, aac, aad, aba, abb, abc, …}</p>
<p>字母表的克林闭包（Kleene closure）：任意符号串（长度可以为零）构成的集合：</p>
<p>　　∑* &#x3D; ∑0 ∪∑+ &#x3D; ∑0 ∪∑ ∪∑2 ∪∑3 ∪…</p>
<p>　　例：{a, b, c, d }* &#x3D; {ε, a, b, c, d,aa, ab, ac, ad, ba, bb, bc, bd, …, aaa, aab, aac, aad, aba, abb, abc, …}</p>
</blockquote>
<blockquote>
<p>例 3.1 令∑＝{a,b}，则∑上正规式的例子如下，</p>
<p>​        a、a︱b、ab、(a︱b)* 、(a︱b)*a，</p>
<p>且 L(a)＝{a}</p>
<p>   L(a︱b)＝L(a)∪L(b)＝ {a}∪{b} ＝ {a,b}</p>
<p>   L((a︱b)*)＝L(L(a︱b))*＝({a,b})*＝{a,b}*</p>
<p>   L((a︱b)*a)＝L((a︱b)*)·L(a)＝ {a,b}*{a}【集合运算更有利于计算机的操作】</p>
</blockquote>
<p><strong>两个正规式e<del>1</del>和e<del>2</del>相等，是指正规式e<del>1</del>和e<del>2</del>计算值相等(即L(e<del>1</del>)＝ L(e<del>2</del>))，记为e<del>1</del>＝ e<del>2</del> 。</strong></p>
<p><strong>设r,s,t为正规式，则正规式有如下定律：</strong></p>
<p>​    <strong>1. 交换律：r︱s ＝ s︱r</strong></p>
<p>​    <strong>2. 结合律：（r︱s）︱t ＝ r︱（s︱t）</strong></p>
<p>​     <strong>（r·s）·t ＝ r·（s·t）</strong></p>
<p>​    <strong>3. 分配律：r·（s︱t）＝ r·s︱r·t</strong></p>
<p>​    <strong>（s︱t）·r ＝ s·r︱t·r</strong></p>
<blockquote>
<p>(1) 描述“标识符”单词的正规式</p>
<p>a(a︱b)*</p>
<p>​    其中，∑＝{a,b}，a —— 字母， b —— 数字</p>
<p> 正规集 ： L(a(a︱b)*)&#x3D;{a}{a,b}*</p>
<p>(2) 描述“整数”单词的正规式</p>
<p>dd*︱＋dd*︱－dd</p>
<p>​	其中，∑＝{＋,－,d}， d —— 数字</p>
<p>  正规集： L(dd*︱＋dd*︱－dd*)&#x3D;{+,－, ε}{d}{d}*</p>
</blockquote>
<h3 id="正规式和正规文法之间的转换"><a href="#正规式和正规文法之间的转换" class="headerlink" title="正规式和正规文法之间的转换"></a>正规式和正规文法之间的转换</h3><p>如果正规式r和文法G，有L(r)＝L(G)则称正规式r和文法G是等价的。</p>
<p><strong>转换方法：</strong></p>
<p>设∑上正规式r，则等价文法G＝(V<del>N</del>,V<del>T</del>,P,S)。其中,V<del>T</del>＝∑；从形如产生式 S→r 开始，按下表规则进行转换， 直到全部形如产生式， 符合正规文法之规则形式为止，可得到P和V<del>N</del> 。</p>
<table>
<thead>
<tr>
<th>规则1</th>
<th>A→xy</th>
<th>A→xB,B→y</th>
</tr>
</thead>
<tbody><tr>
<td>规则2</td>
<td>A→x*****y</td>
<td>A→xB,A→y；B→xB,B→y</td>
</tr>
<tr>
<td>规则3</td>
<td>A→x︱y</td>
<td>A→x, A→ y</td>
</tr>
<tr>
<td>注：A，B∈V<del>N</del> ，B为新增非终结符</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>逆过程</p>
<table>
<thead>
<tr>
<th>规则1</th>
<th>A→xB,B→y</th>
<th>A→xy</th>
</tr>
</thead>
<tbody><tr>
<td>规则2</td>
<td>A→xA︱y</td>
<td>A→x*y</td>
</tr>
<tr>
<td>规则3</td>
<td>A→x, A→ y</td>
<td>A→x |y</td>
</tr>
</tbody></table>
<h1 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/AndyEvans/p/10240790.html">参考文章</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/AndyEvans/p/10241031.html">参考文章</a></p>
<p>对应的是识别观点。</p>
<p>有穷自动机首先包含一个有限<strong>状态</strong>的集合，还包含了从一个状态到另外一个状态的<strong>转换</strong>。有穷自动机看上去就像是一个有向图，其中状态是图的节点，而状态转换则是图的边。此外这些状态中还必须有一个<strong>初始状态</strong>和至少一个<strong>接受状态</strong>。</p>
<p>这里提到的自动机特指有限状态自动机，简称为FA，根据状态转移的性质又分为确定的自动机（DFA）和非确定的自动机（NFA）。FA的表达能力等价于正规表达式或者正规文法。<strong>FA可以看做是一个有向带权图，图的顶点集合称为自动机的状态集合，图的权值集合为自动机的字母集合。</strong></p>
<p><strong>DFA、NFA和正则表达式是等价的。</strong></p>
<p>转换图 (Transition Graph)<br>　　结点：FA的状态<br>　　初始状态（开始状态）：只有一个，由start箭头指向<br>　　终止状态（接收状态）：可以有多个，用双圈表示<br>　　带标记的有向边：如果对于输入a，存在一个从状态p到状态q的转换，就在p、q之间画一条有向边，并标记上a</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108151439378-850603381.png" style="zoom:67%;" />

 

<h2 id="确定有穷自动机DFA"><a href="#确定有穷自动机DFA" class="headerlink" title="确定有穷自动机DFA"></a>确定有穷自动机DFA</h2><p>一个确定的有穷自动机DFA M是一个五元组：M&#x3D;(K,Σ,f,S,Z)。 </p>
<p>其中:</p>
<ul>
<li>K是非空有穷集，每个元素称为状态；</li>
<li>Σ是有穷字母表；</li>
<li>f是K×S→K映射，称为状态转换函数；s∈S, a∈Σ, δ(s,a)表示从状态s出发，沿着标记为a的边所能到达的状态。</li>
<li>S∈K，称为开始状态；</li>
<li>Z ⊂K，称为结束状态集，或接受状态集。</li>
</ul>
<p>转换函数<strong>f可以扩充为f’: K×Σ*→K</strong>映射，并以f替代f’使用。</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108152731112-2109218224.png" style="zoom:67%;" />

<p>上图中r&#x3D;(a|b)*abb；状态1：串以a结尾；状态2：串以ab结尾；状态3：串以abb结尾；</p>
<h2 id="DFA识别的语言"><a href="#DFA识别的语言" class="headerlink" title="DFA识别的语言"></a>DFA识别的语言</h2><p>设DFA M＝(K,Σ,f,S,Z)，如果α∈Σ*，f’(S,α)∈Z，则称符号串α是DFA M所接受(或识别)的。DFA M所接受的符号串的集合记为L(M)，即：</p>
<p><strong>L(M)＝{α︱α∈Σ*，f’(S,α)∈Z}。</strong></p>
<blockquote>
<p>一个DFA M＝(K,Σ,f,S,Z)，以带权有向图G&#x3D;(V，E)观点，还可采用图形直观描述：</p>
<ul>
<li>顶点表示状态(即V＝K)</li>
<li>加上粗箭头的顶点表示开始状态</li>
<li>双圈顶点表示接受状态</li>
<li>权为a的弧&lt;A,B&gt;(∈E)表示f(A,a)＝B。</li>
</ul>
<p>f(A，a)＝B也读作“状态A经过a转换到状态B”。</p>
</blockquote>
<h2 id="不确定有穷自动机NFA"><a href="#不确定有穷自动机NFA" class="headerlink" title="不确定有穷自动机NFA"></a>不确定有穷自动机NFA</h2><p>一个不确定的有穷自动机NFA M是一个五元组：M&#x3D;(K,Σ,f,S,Z)。</p>
<p>其中：</p>
<ul>
<li>K是非空有穷集，每个元素称为状态；</li>
<li>Σ是有穷字母表；</li>
<li>f是K×Σ∪{ε}→ρ(K)映射；f称为状态转换函数，ρ(K) 表示K之幂集。</li>
<li>S ⊂K，称为开始状态集；</li>
<li>Z ⊂K，称为结束状态集，或接受状态集。</li>
</ul>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108153217858-287134971.png" style="zoom:67%;" />

<p>上图中r&#x3D;(a|b)*abb；状态1：串以a结尾；状态2：串以ab结尾；状态3：串以abb结尾；</p>
<h3 id="带有“ε-边”的NFA"><a href="#带有“ε-边”的NFA" class="headerlink" title="带有“ε-边”的NFA"></a>带有“ε-边”的NFA</h3><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108160754427-678793579.png"></p>
<h3 id="NFA识别的语言"><a href="#NFA识别的语言" class="headerlink" title="NFA识别的语言"></a>NFA识别的语言</h3><p>设NFA M＝(K,Σ,f,S,Z)，如果α∈Σ*，f’(S,α)∩Z≠Φ，则称符号串α是NFA M所接受(或识别)的。NFA M所接受的符号串的集合亦记为L(M)，即：</p>
<p>​     <strong>L(M)＝{α︱α∈Σ*，f’(S,α)∩Z≠Φ}。</strong></p>
<h2 id="自动机的等价性"><a href="#自动机的等价性" class="headerlink" title="自动机的等价性"></a>自动机的等价性</h2><p>如果FA M<del>1</del>和FA M<del>2</del>接受相同的符号串的集合(即L(M<del>1</del>)＝L(M<del>2</del>))，则称FA M<del>1</del>和FA M<del>2</del>是等价的。</p>
<blockquote>
<p>对任何非确定的有穷自动机N ，存在定义同一语言的确定的有穷自动机D<br>对任何确定的有穷自动机D ，存在定义同一语言的非确定的有穷自动机N</p>
</blockquote>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108154711824-544131721.png"></p>
<h2 id="DFA和NFA的比较"><a href="#DFA和NFA的比较" class="headerlink" title="DFA和NFA的比较"></a>DFA和NFA的比较</h2><p>两类引擎要顺利工作，都必须有一个正则式和一个文本串，一个捏在手里，一个吃下去。DFA捏着文本串去比较正则式，看到一个子正则式，就把可能的匹配串全标注出来，然后再看正则式的下一个部分，根据新的匹配结果更新标注。而NFA是捏着正则式去比文本，吃掉一个字符，就把它跟正则式比较，匹配就记下来：“某年某月某日在某处匹配上了！”，然后接着往下干。一旦不匹配，就把刚吃的这个字符吐出来，一个个的吐，直到回到上一次匹配的地方。</p>
<p>DFA与NFA机制上的不同带来5个影响：</p>
<ol>
<li>DFA对于文本串里的每一个字符只需扫描一次，比较快，但特性较少；NFA要翻来覆去吃字符、吐字符，速度慢，但是特性丰富，所以反而应用广泛，当今主要的正则表达式引擎，如Perl、Ruby、Python的re模块、Java和.NET的regex库，都是NFA的。</li>
<li>只有NFA才支持lazy和backreference等特性；</li>
<li>NFA急于邀功请赏，所以最左子正则式优先匹配成功，因此偶尔会错过最佳匹配结果；DFA则是“最长的左子正则式优先匹配成功”。</li>
<li>NFA缺省采用greedy量词；</li>
<li>NFA可能会陷入递归调用的陷阱而表现得性能极差。</li>
</ol>
<p>e.g.</p>
<blockquote>
<p>例如用正则式&#x2F;perl|perlman&#x2F;来匹配文本 ‘perlman book’。如果是NFA，则以正则式为导向，手里捏着正则式，眼睛看着文本，一个字符一个字符的吃，吃完 ‘perl’ 以后，跟第一个子正则式&#x2F;perl&#x2F;已经匹配上了，于是记录在案，往下再看，吃进一个 ‘m’，这下糟了，跟子式&#x2F;perl&#x2F;不匹配了，于是把m吐出来，向上汇报说成功匹配 ‘perl’，不再关心其他，也不尝试后面那个子正则式&#x2F;perlman&#x2F;，自然也就看不到那个更好的答案了。</p>
<p>如果是DFA，它是以文本为导向，手里捏着文本，眼睛看着正则式，一口一口的吃。吃到&#x2F;p&#x2F;，就在手里的 ‘p’ 上打一个钩，记上一笔，说这个字符已经匹配上了，然后往下吃。当看到 &#x2F;perl&#x2F; 之后，DFA不会停，会尝试再吃一口。这时候，第一个子正则式已经山穷水尽了，没得吃了，于是就甩掉它，去吃第二个子正则式的&#x2F;m&#x2F;。这一吃好了，因为又匹配上了，于是接着往下吃。直到把正则式吃完，心满意足往上报告说成功匹配了 ‘perlman’。</p>
</blockquote>
<h2 id="ε闭包运算"><a href="#ε闭包运算" class="headerlink" title="ε闭包运算"></a>ε闭包运算</h2><p><strong>当处于某个指定状态时，如果该状态有ε边，那么，不需要吸收任何字符，就可以从该状态转换到ε边所指向的状态。</strong></p>
<p>e.g：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/643298-20190520094021908-797811750.png"></p>
<p>一开始，状态机处于起始状态12，</p>
<p>在状态12，通过ε边可直达状态2，6，</p>
<p>在状态2，可以通过ε边，直达状态0，3。也就是说，当处于状态12时，通过ε边的连接，可以同时抵达状态的集合是 {12，2，6，0，3}。</p>
<p><strong>通过一个状态，推算出它能同时抵达的状态集合,这个状态集合称作ε闭包集合，这种运算称之为ε闭包运算</strong>：<br>ε-closure(12) &#x3D; {12, 2, 6, 0, 3}。</p>
<p>接下来读入字符1，我们从闭包集合中看看，哪个状态节点有能够吸收数字的转换边。从上图观察，我们发现，</p>
<p>状态6和0，拥有吸收数字字符的转换边。</p>
<p>状态6吸收一个数字字符后，跳转到状态7，</p>
<p>状态0吸收字符1后，跳转到状态1，</p>
<p>这样我们可以说，状态集合{12， 2， 6， 0， 3} 在吸收字符1后，跳转到集合{1，7}，</p>
<p>后面这个集合{1，7}，<strong>我们称为转移集合(move set)</strong>, 我们把这种跳转运算标记如下：<br>move({12, 2, 6, 0, 3}, D} &#x3D; {1, 7}。</p>
<h2 id="NFA到DFA转换方法（子集法）"><a href="#NFA到DFA转换方法（子集法）" class="headerlink" title="NFA到DFA转换方法（子集法）"></a>NFA到DFA转换方法（子集法）</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012359618/article/details/42456771">参考文章</a></p>
<p>设 NFA M＝(K,Σ,f,S,Z)则与之等价的DFA M¢＝(K’,Σ’,f’,S’,Z’)，其中</p>
<p>⑴ K’＝ρ(K)(ρ(K)是K全部子集之集合称为K之幂集)</p>
<p>⑵ Σ’＝Σ</p>
<p>⑶ f’(q，a)＝ε_closure(M(q，a))【转换闭包ε-closure(s)表示由状态s经由条件ε可以到达的<strong>所有状态</strong>的集合】</p>
<p>⑷ S’＝ε_closure(S)</p>
<p>⑸ Z’＝{q︱q∈K’, q∩Z≠Φ}</p>
<p><strong>注解：</strong></p>
<p><strong>①从FA开始状态不存在路径到达的状态,称为不可达状态。</strong></p>
<p><strong>②考虑舍弃不可达状态的转换状态之计算,子集法可以简化从S’＝ε_closure(S)开始计算。</strong></p>
<p><strong>这些步骤的目的是为了消掉ε。</strong></p>
<p>设 NFA M＝(K,Σ,f,S,Z)，子集法得到与其等价的DFA M¢＝(K’,Σ,f’,S’,Z’之具体计算步骤可以是：</p>
<p>① 置K’为空集；</p>
<p>② 计算M’的开始状态S’＝ε_closure(S)， S’作为K’新增状态；</p>
<p>③ 对于K’每一新增状态q，计算出每个a∈S的转换状态p，即f’(q，a) ＝p＝ε_closure(M(q,a))。如果p∉K’，则p作为K’新增状态；</p>
<p>④ 重复③，直到K’不再出现新增状态为止；</p>
<p>⑤ 计算接受状态集Z’＝{q︱q∈K’,q∩Z≠Φ}。</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108191338570-1952257461.png"></p>
<p>例子：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/66efc2e9856a561252d36fcd.jpg"></p>
<h2 id="DFA的最小化"><a href="#DFA的最小化" class="headerlink" title="DFA的最小化"></a>DFA的最小化</h2><h3 id="消除多余状态"><a href="#消除多余状态" class="headerlink" title="消除多余状态"></a>消除多余状态</h3><ul>
<li>什么是多余状态<ul>
<li><strong>从这个状态出发没有通路到达终态</strong>（也称为死状态）</li>
<li><strong>从开始状态出发，任何输入串也不能到达的那个状态</strong></li>
</ul>
</li>
<li>如何消除多余状态<ul>
<li>删除</li>
</ul>
</li>
</ul>
<p> 例如：</p>
<blockquote>
<p>   如下为正规文法G[S]</p>
<p>​    S→aA|bQ； A→aA|bB|b；B→bD|aQ；Q→aQ|bD|b；D→bB|aA；E→aB|bF；F→bD|aE|b</p>
<p> 构造相应的DFA。 </p>
</blockquote>
<p>此处我们观察到E不出现在任何产生式的右部，所以E是无效符号，（其对应的状态就是多余状态）<br>删除E所在的产生式之后，符号F也不出现在任何产生式的右部，则F是无效符号，<br>删除F及其所在产生式。此时除了文法开始符号S之外，其余非终结符都是从S可达的。</p>
<h3 id="等价状态"><a href="#等价状态" class="headerlink" title="等价状态"></a>等价状态</h3><ul>
<li>何为等价状态，对于两个状态s和t<ul>
<li><strong>一致性条件</strong>：<strong>状态s和t必须同时为终态或非终态</strong></li>
<li><strong>蔓延性条件</strong>：<strong>对于所有输入符号，状态s和状态t必须转化到等价的状态里</strong></li>
</ul>
</li>
</ul>
<h3 id="DFA的化简算法：分割法"><a href="#DFA的化简算法：分割法" class="headerlink" title="DFA的化简算法：分割法"></a>DFA的化简算法：分割法</h3><p>对于DFA M&#x3D;(S,Σ,f,S0,Z)</p>
<ul>
<li><p>首先将DFA的状态集进行初始化，分成Π&#x3D;(Z,S-Z);</p>
</li>
<li><p>用下面的过程对Π构造新的划分Π new<br> for (Π中每个组G) do    &#x2F;&#x2F;每个组都是一个状态集<br> begin<br> 把G划分成小组，G中的任意两个状态Si和Sj在同一组中，当且仅当对于Σ中任意输入符号a ，Si和Sj的a转换是到同一组中，move(Si,a) ∈Gi ，move(Sj,a) ∈Gi。这样，只要Si和Sj的a转换是到不同的组中，则说明Si和Sj是可区别的，可进行划分。在Π new中用刚完成的对G的划分代替原来的G。<br> end ; Π :&#x3D; Π new；</p>
</li>
<li><p>重复执行(2)，直到Π中每个状态集不能再划分(Π new&#x3D; Π)为止;</p>
</li>
<li><p>合并等价状态 ,在每个G中，取任意状态作为代表，删去其它状态;</p>
</li>
<li><p>删去无关状态，从其它状态到无关状态的转换都成为无定义。</p>
</li>
</ul>
<blockquote>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/9251733-245a040972e1ec21.webp" style="zoom:67%;" />

<p>①首次划分: Π0&#x3D;({2,3,4,5},{0,1})<br> ②在G&#x3D;{2,3,4,5}中:f(2,a)&#x3D;1，f(4,a)&#x3D;0(转向终态集{0,1})；f(3,a)&#x3D;3,f(5,a)&#x3D;5(转向非终态集{2,3,4,5})，故{2,4}和{3,5}是可区别的，得Π1&#x3D;({2,4}，{3,5}，{0,1})；<br> ③在G&#x3D;{2,4}中，f(2,a)&#x3D;1，f(4,a)&#x3D;0(转向终态子集),而f(2,b)&#x3D;3,f(4,b)&#x3D;5(转向非终态子集{3,5}),所以不可区别，不再进行划分；<br> ④考察G&#x3D;{3,5}，f(3,a)&#x3D;3,f(5,a)&#x3D;5(转向非终态子集{3,5})，f(3,b)&#x3D;2,f(5,b)&#x3D;4(转向非终态子集{2,4}), 所以不可区别，不再进行划分；<br> ⑤考察G&#x3D;{0,1}，f(0,a)&#x3D;f(1,a)&#x3D;1(转向终态集{0,1}); f(0,b)&#x3D;2,f(1,b)&#x3D;4(转向非终态子集{2,4}),所以不可区别，不再进行划分；<br> ⑦进一步进行考察，可以发现每个子集都不能再划分了；<br> ⑧消去等价状态：{0,1}用0表示，{2,4}用2表示，{3,5}用3表示，如右图所示<br> ⑨去掉无关状态，因DFA M’中没有无关状态，所以下图即为最后结果。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9251733-887727ca13d4c204.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/756/format/webp" alt="img"></p>
</blockquote>
<h1 id="正规式和有穷自动机的等价性"><a href="#正规式和有穷自动机的等价性" class="headerlink" title="正规式和有穷自动机的等价性"></a>正规式和有穷自动机的等价性</h1><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108183412603-1278831634.png"></p>
<h2 id="正则式-到NFA的转换"><a href="#正则式-到NFA的转换" class="headerlink" title="正则式 到NFA的转换"></a>正则式 到NFA的转换</h2><p>□ ε对应的NFA</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108183642258-773357630.png" alt="img"></p>
<p>□ 字母表Σ中符号a对应的NFA</p>
<p><img src="https://img2018.cnblogs.com/blog/1350938/201901/1350938-20190108183656822-1565813934.png" alt="img"></p>
<p>□ r &#x3D; r1r2对应的NFA</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108184004292-217968247.png" alt="img"></p>
<p>□ r &#x3D; r1|r2对应的NFA</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108184016617-1377042977.png" alt="img"></p>
<p>□ r &#x3D; (r1)*对应的NFA</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108184040443-1516153785.png" alt="img"></p>
<p>例:r&#x3D;(a|b)*abb 对应的NFA</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1350938-20190108184348115-1799178457.png" alt="img"></p>
<h2 id="NFA到正规式的转换方法"><a href="#NFA到正规式的转换方法" class="headerlink" title="NFA到正规式的转换方法"></a>NFA到正规式的转换方法</h2><p>设NFA M＝( K,Σ,f,S,Z)，则与之等价的Σ上正规式R，可以由下列方法构造。</p>
<p>⑴ 在NFA M上，新增两个状态X和Y作为开始状态和接受状态，且将X经ε指向M的开始状态(任意q∈K，增加f(X,ε)&#x3D;q）, 将将M的开始状态经ε指向Y(任意q∈Z，增加f(q, ε)&#x3D;Y）。这样，得到一个与NFA M等价的、只有唯一开始状态X和唯一接受状态Y的NFA M’； </p>
<p>⑵ 按下列转换规则，逐步消除NFA M’中的状态，直到只剩下X和Y两个状态为止。弧上符号串，即为等价的S上正规式R。</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200331134705228.png" style="zoom:50%;" />

<h2 id="DFA到右线性正规文法转换"><a href="#DFA到右线性正规文法转换" class="headerlink" title="DFA到右线性正规文法转换"></a>DFA到右线性正规文法转换</h2><p>要把一个 DFA 转化为正则表达式，我们可以通过将它分解为更简单的子问题来迭代求解：</p>
<ul>
<li>将状态按 1、2、…、n 的顺序依次标号</li>
<li>先求任意状态 i 到 j（i 可以等于 j，即自身到自身），不经过其它状态的路径对应的正则表达式</li>
<li>求状态 i 到 j，最高只经过状态 1 的路径对应的正则表达式</li>
<li>求状态 i 到 j，最高只经过状态 2 的路径对应的正则表达式</li>
<li>依此类推……</li>
<li>求状态 i 到 j，最高只经过状态 n 的路径对应的正则表达式，即经过所有状态的路径对应的正则表达式</li>
</ul>
<h1 id="正规文法和有穷自动机间的转换"><a href="#正规文法和有穷自动机间的转换" class="headerlink" title="正规文法和有穷自动机间的转换"></a>正规文法和有穷自动机间的转换</h1><h2 id="正规文法到NFA转换方法"><a href="#正规文法到NFA转换方法" class="headerlink" title="正规文法到NFA转换方法"></a>正规文法到NFA转换方法</h2><p>设右线性正规文法G＝(V<del>N</del>,V<del>T</del>,P,S)，则与之等价的NFA M＝(V<del>N</del>∪{Z},V<del>T</del>,f,{S},{Z})，其中V<del>N</del>∩{Z}＝Φ，转换函数f可以由下列方法构造：</p>
<p>（1）如果A→a∈P ，  则f(A，a)&#x3D;Z；</p>
<p>（2） 如果A→ ε ∈P ，则f(A， ε)&#x3D;Z；</p>
<p>（3）如果A→aB∈P， 则f(A， a)&#x3D;B。</p>
<blockquote>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200331161412369.png" style="zoom:50%;" />

<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200331161358726.png"></p>
</blockquote>
<h2 id="DFA到正规文法转换方法"><a href="#DFA到正规文法转换方法" class="headerlink" title="DFA到正规文法转换方法"></a>DFA到正规文法转换方法</h2><p>设DFA M＝(K,Σ,f,S,Z)，则与之等价的右线性正规文法G＝(K,Σ,P,S)，其中规则集转换P可以由下列方法构造：</p>
<p>(1) 如果 f(B，a)＝C， 则B→aC∈P。</p>
<p>(2) 对接收状态 ∈Z， 增加S→ε</p>
<h2 id="构造词法分析程序的技术线路"><a href="#构造词法分析程序的技术线路" class="headerlink" title="构造词法分析程序的技术线路"></a>构造词法分析程序的技术线路</h2><p>(1)依据给定的源语言之单词集，设计其正规文法或正规式；</p>
<p>(2)之后等价地转换成非确定有穷自动机；</p>
<p>(3)再通过子集法将其确定化，最终将确定有穷自动机最小化；</p>
<p>(4最后依据最小化确定有穷自动机，设计词法分析程序。</p>
<h1 id="自顶向下语法分析方法"><a href="#自顶向下语法分析方法" class="headerlink" title="自顶向下语法分析方法"></a>自顶向下语法分析方法</h1><h2 id="分析思想"><a href="#分析思想" class="headerlink" title="分析思想"></a>分析思想</h2><p>自顶向下语法分析方法(即推导法)是从文法开始符S出发，逐步进行推导，以证实S&#x3D;&gt;α的推导过程是否存在的方法。</p>
<p>问题是每步推导会面临两次多种可能选择：</p>
<p>  ⑴ 选择句型中哪一个非终结符进行推导</p>
<p>  ⑵ 选择非终结符的哪一个规则进行推导</p>
<p>问题⑴可以采用<strong>最左推导</strong>解决。<strong>问题⑵通常需要穷举每一个规则的可能推导，即不确定的自顶向下语法分析</strong>。具体思想是：</p>
<p>一旦寻找到一个符号串α之推导过程，便结束穷举过程，断定符号串α是句子。</p>
<p>只有当穷举全部可能的推导，而没有一个符号串α之推导过程的时候，才可以断定符号串α不是句子。</p>
<h3 id="递归向下分析"><a href="#递归向下分析" class="headerlink" title="递归向下分析"></a>递归向下分析</h3><p>　　递归向下的语法分析可能需要回溯（aka需要重复扫描输入），考虑以下文法： S -&gt; aBc ，B -&gt; bc | b ,当我们用递归向下分析，输入为abc时，语法树如下图：</p>
<p>　　<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/102001293123161.jpg"></p>
<p>　　当我们第一次匹配时识别失败了（a匹配a，bc匹配B，最后一个c未匹配到），输入必须回到b，用B的另外一种方式匹配。</p>
<p>　　递归向下的分析十分直观，实现起来也比较方便，但效率较低，所以一般不采用。递归向下的分析方法实际上是深度优先搜索+回溯。而下面要说的预测分析则是用高效的动态规划来实现语法分析。</p>
<h3 id="递归预测向下分析"><a href="#递归预测向下分析" class="headerlink" title="递归预测向下分析"></a>递归预测向下分析</h3><p>　　　在讨论使用动态规划的预测向下分析之前，我们先来看一种特殊的预测向下分析。它在本质上也是递归的，唯一的区别在于它不需要回溯。考虑以下文法：A -&gt; aBb | bAB，伪代码实现如下：</p>
<p> <em>proc A {</em></p>
<p><em>case 当前标记 {</em></p>
<p>　　<em>‘a’:匹配a, 移动到下个标记;</em></p>
<p>　　　　　<em>调用函数B;<br>　　　　　匹配b, 移动到下个标记；<br>　　‘b’:匹配b，移动到下个标记；<br>　　　　　调用函数A；</em></p>
<p>　　　　　<em>调用函数B；</em></p>
<p>　　　　　　　<em>}<br>　　　　}</em></p>
<p> 　其实这种分析方式与前者的区别就在于它用了case语句来预测A的两种可能性，从而做出不同的判断。但这种方式的效率也是不如动态规划的。</p>
<h3 id="非递归预测向下分析"><a href="#非递归预测向下分析" class="headerlink" title="非递归预测向下分析"></a>非递归预测向下分析</h3><p>　　非递归预测向下分析是表驱动的分析方法，也叫做LL(1)分析。第一个”L”表示从左到右扫描。第二个”L”表示产生最左推导。”1”表示每次只要往前走一步就可以决定语法分析的动作。</p>
<p>所谓表驱动就是通过查表的方式来分析一个输入流是否符合文法。假设我们已经得到了这张语法分析表，现在来具体分析这种方式是如何工作的。</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/102344125308901.jpg">　　</p>
<p>首先我们需要一个栈来存储start symbol，即语法树的根。然后从表中查找当栈顶为S，输入为a时对应的文法，然后将S替换为aBa（注意入栈顺序），然后a与输入的a匹配，非终结标志B对应到了b，此时查找表中相应的文法，将B弹出栈，将bB压入栈（注意顺序）。以此类推直到栈底的终止字符匹配到了输入的终止字符，表示匹配成功。</p>
<p>上面是实例，下面我们给出一个高度的分析行为概括：</p>
<p>　　当栈顶为X,当前输入为a时，有以下四种分析行为：</p>
<p>　　1.如果X和a都为终止符号$，匹配成功，停止匹配。</p>
<p>　　2.如果X和a都是同一种终结标志(terminal symbol)，将X弹出栈，将输入移动到下个标志。（表示该标志成功匹配，准备匹配下个标志）</p>
<p>　　3.如果X是非终结标志(nonterminal symbol)，查询语法分析表，找到[S,a]，如果[S,a]为 X-&gt;Y<del>1</del>Y<del>2</del>Y<del>3</del>…Y<del>k</del>，则将Y<del>1</del>Y<del>2</del>Y<del>3</del>…Y<del>k</del>逆序放入栈中。（即Y<del>1</del>为栈顶）</p>
<p>　　4.不符合以上三种情况，匹配失败，进入错误恢复模式。</p>
<h4 id="FIRST集的定义"><a href="#FIRST集的定义" class="headerlink" title="FIRST集的定义"></a>FIRST集的定义</h4><p>设文法G＝（V<del>N</del>，V<del>T</del>，P，S），则FIRST(α)＝{a︱α&#x3D;&gt;*a β，a∈V<del>T</del>，α，β∈V *}</p>
<p>  特别地，α&#x3D;&gt;*ε，约定ε∈FIRST(α)。</p>
<p><strong>FIRST(α)是由α可以推导以终结符号开头符号串的头符号集合</strong>。如果所有非终结符右部的FIRST集合两两相交为空，可以使用确定的最左推导。</p>
<p>计算规则如下：</p>
<p>　　1.如果X是终结符号，first(X)&#x3D;{X}</p>
<p>　　2.如果X是非终结符号且X-&gt;ε是一个文法规则，那么ε属于first(X)</p>
<p>　　3.如果X是非终结符号且X-&gt;Y<del>1</del>Y<del>2</del>Y<del>3</del>…Y<del>n</del>是一个文法规则，那么：①如果终结符号a在first(Y<del>i</del>)中且ε在所有的first(Y<del>j</del>) (j-1,2,…i-1)中，那么a也属于first(X) ②如果ε在所有的first(Y<del>j</del>) (j&#x3D;1,2…n) 那么ε也属于first(X)</p>
<p>　　4.如果X本身为ε，那么first(X)&#x3D;{ε}</p>
<p>　　以上的规则将一直使用直到没有元素能够加入到任何first()当中。</p>
<blockquote>
<blockquote>
<p>如A-&gt;aB | CD</p>
</blockquote>
<p>这里面包含了组成First（A）的两种情况：<br>以终结符开头，当然要把这个终结符（a）放到A的First里<br>以非终结符开头，先把C的First放到A的First里</p>
</blockquote>
<h4 id="FOLLOW集的定义"><a href="#FOLLOW集的定义" class="headerlink" title="FOLLOW集的定义"></a>FOLLOW集的定义</h4><p>一般形式：</p>
<p>  输 入 串：  a<del>1</del>a<del>2</del>……a<del>i-1</del> a<del>i</del>……a<del>n</del></p>
<p>  句型推导：S&#x3D;&gt;* a<del>1</del>a<del>2</del>……a<del>i-1</del> Aβ</p>
<p>  如果使用空规则，意味着需要：β &#x3D;&gt;* a<del>i</del>……a<del>n</del></p>
<p>  则有句型：  S&#x3D;&gt;* a<del>1</del>a<del>2</del>……a<del>i-1</del> A a<del>i</del>……a<del>n</del></p>
<p>设文法G＝(V<del>N</del>,V<del>T</del>,P,S)，则FOLLOW(A)＝{a︱S&#x3D;&gt;* αAβ,A∈V<del>N</del>, a∈FIRST(β),α,β∈V*}</p>
<p>（或者：FOLLOW(A）＝{a︱S &#x3D;&gt;*  ···Aa···，A∈V<del>N</del>，a∈V<del>T</del> }）</p>
<p>　<strong>follow(A):从A之后可以立即得到（可以理解为与A相邻）的终结符号的集合,其中A是非终结符号。</strong></p>
<p>如果对非终结符A，有一条空规则，则A的FOLLOW集合和A的非空右部的FIRST集合两两相交为空，可以使用确定的最左推导。</p>
<p>计算规则如下：</p>
<p>　　1.如果A-&gt;aBb是一个文法规则，那么所有在first(b)中的元素除了ε都包含在follow(B)中。</p>
<p>　　2.如果A-&gt;aB是一个文法规则或者A-&gt;aBb是一个文法规则且ε包含在first(b)中，那么在follow(A)中的所有元素都在follow(B)中。即follow(A)属于follow(B)</p>
<p>　　以上的规则也将一直使用直到没有元素能够加入到任何follow()当中。</p>
<blockquote>
<blockquote>
<p>如S-&gt;(L) | aL | LC</p>
</blockquote>
<p>找Follow的三种情况：<br>先在候选式（右边）中找到该非终结符，如L（注意例中只有一个定义，但找Follow要看到所有右边出现该非终结符的）</p>
<p>如果L的右边是终结符，    那么这个终结符加入L的Follow</p>
<p>如果L的右边是非终结符， 那么把这个非终结符的First除去空加到L的Follow中</p>
<p>如果L处在末尾，那么，’-&gt;’左边符号的Follow成为L的Follow</p>
<p>另外要注意的是：<br>    开始符号的Follow中要加上‘#’        </p>
</blockquote>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/121008231083082.jpg"></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/20200314210706645.png"></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/121009242658099.jpg"></p>
<h4 id="SELECT集的定义"><a href="#SELECT集的定义" class="headerlink" title="SELECT集的定义"></a>SELECT集的定义</h4><p>$$<br>设文法G&#x3D;（V_N,V_T,P,S）,A\in V_N,A\to{\alpha}\in P,则\<br>SELECT(A\to{\alpha})&#x3D;\begin{cases}<br>FIRST(\alpha),&amp;(\alpha\not\Rightarrow\star\varepsilon)\<br>(FIRST(\alpha)-{(\varepsilon)})\cup(FOLLOW(A))&amp;(\alpha\Rightarrow\star\varepsilon)\<br>\end{cases}<br>$$</p>
<p>SELECT(A→α)称为规则A→α的选择集。它是FIRST(α)和FOLLOW(A)组成，是终结符号集V<del>T</del>的子集。</p>
<h2 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h2><p>文法G是LL(1)的，当且仅当G的任意两个具有相同左部的产生式A→α∣β满足下面的条件：</p>
<ul>
<li><p>不存在终结符a使得α和β都能推导出以a开头的串。</p>
</li>
<li><p>α和β至多有一个能推导出ϵ</p>
</li>
<li><p>如果$\beta \Rightarrow^*{\epsilon}$⇒则$FIRST(α)∩FOLLOW(A)&#x3D;Φ$<br>如果$α\Rightarrow^*{\epsilon}$⇒ 则$FIRST(β)∩FOLLOW(A)&#x3D;Φ$<br>因为如果$\beta \Rightarrow^*{\epsilon}$⇒ 那么$SELECT(β)$就包含了$FOLLOW(A)$，所以$FIRST(\alpha)$就不能包含$FOLLOW(A)$中元素。不然两个的SELECT集将会相交。</p>
</li>
<li><p>同一非终结符的各个产生式的可选集互不相交</p>
</li>
</ul>
<h3 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h3><ol>
<li><p>检查产生式中是否有含有左递归或左公因子：<br><strong>含有左递归或左公因子的文法一定不是LL(1)文法；</strong><br><strong>不含有左递归或左公因子的文法也不能确定是否为LL(1)文法；</strong></p>
</li>
<li><p>计算每个<strong>产生式</strong>的FIRST集：</p>
<p>①如果这个产生式右部第一个字符是终结符，那么这个终结符就属于它的FIRST集。</p>
<p>②如果这个产生式右部第一个字符是非终结符，那么这个非终结符的FIRST集就属于它的FIRST集。</p>
<p>如果这个非终结符的FIRST集中含ε，那么后面的字符如果是终结符……</p>
<p>③如果这个产生式右部可以推出ε，那么ε也属于它的FIRST集。</p>
</li>
<li><p>计算每个<strong>非终结符</strong>的FOLLOW集：</p>
<p>首先向开始符号的FOLLOW集中添加<code>#</code>，然后对于所有非终结符，不断的找含有它的产生式右部：</p>
<p>①该非终结符后面的字符若是终结符，那么这个终结符就属于它的FOLLOW集；</p>
<p>②该非终结符后面的字符若是非终结符，那么这个非终结符的FIRST()集中的所有元素就属于它的FOLLOW集；</p>
<p>如果这个非终结符的FIRST()集中含ε，将ε删去，同时将这个产生式左部FOLLOW集中的所有元素添加至它的FOLLOW集中；</p>
<p>注意：不需要考虑后面的字符了，因为已经包含在FIRST()集中了。</p>
</li>
<li><p>计算每个<strong>产生式</strong>的SELECT集：</p>
<p>①如果这个产生式可以推出ε，那么它的SELECT集是<code>&#123;FIRST(该产生式右部)-ε&#125;∪FOLLOW(该产生式左部的非终结符)</code>。</p>
<p>②如果这个产生式不能推出ε，那么它的SELECT集是<code>&#123;FIRST(该产生式右部)&#125;</code>。</p>
</li>
<li><p>检查相同左部产生式的SELECT集的交集：</p>
<p>检查相同左部产生式的SELECT集的交集，如果全为空集说明该文法是LL(1)文法，反之则不是。</p>
</li>
</ol>
<h2 id="非LL-1-文法到LL-1-文法的等价变换"><a href="#非LL-1-文法到LL-1-文法的等价变换" class="headerlink" title="非LL(1)文法到LL(1)文法的等价变换"></a>非LL(1)文法到LL(1)文法的等价变换</h2><p>但下面讨论的等价变换方法，仅仅确保变换的等价性（即L(G)＝L(G′)），不能保证变换后的文法G′一定是LL(1)文法。因此，对于变换后的文法G′，必须判别它是LL(1)文法后，方可使用确定的自顶向下语法分析方法。</p>
<h3 id="提取左公共因子法"><a href="#提取左公共因子法" class="headerlink" title="提取左公共因子法"></a>提取左公共因子法</h3><p>A→αβ<del>1</del>︱αβ<del>2</del>︱···︱αβ<del>n</del>︱γ<del>1</del>︱γ<del>2</del>︱···︱γ<del>m</del>可以推导出：</p>
<p> A→αB︱γ<del>1</del>︱γ<del>2</del>︱···︱γ<del>m</del>；B→β<del>1</del>︱β<del>2</del> ︱···︱β<del>n</del></p>
<h3 id="消除左递归法"><a href="#消除左递归法" class="headerlink" title="消除左递归法"></a>消除左递归法</h3><p>有直接左递归和间接左递归和一般左递归，对于间接左递归要先化成直接；</p>
<ul>
<li>直接左递归经过一次推导就可以看出文法存在左递归，如P→Pa｜b。</li>
<li>间接左递归侧需多次推导才可以看出文法存在左递归，如文法：S→Qc｜c，Q→Rb｜b，R→Sa｜a有S &#x3D;&gt;Qc &#x3D;&gt;Rbc &#x3D;&gt;Sabc</li>
</ul>
<h4 id="消除直接左递归法"><a href="#消除直接左递归法" class="headerlink" title="消除直接左递归法"></a>消除直接左递归法</h4><p>A→Aα<del>1</del>︱Aα<del>2</del>︱···︱Aα<del>m</del>︱β<del>1</del>︱β<del>2</del>︱···︱β<del>n</del> &#x3D;&gt;</p>
<p>A  →β<del>1</del> A′︱β<del>2</del> A′︱···︱β<del>n</del> A′；A′→α<del>1</del>A′︱α<del>2</del>A′︱···︱α<del>m</del>A′︱ε </p>
<blockquote>
<p>有文法G(E)：</p>
<p>E→E +T |T</p>
<p>T→T*F | F</p>
<p>F→i| (E)</p>
<p>消除该文法的直接左递归。</p>
<p>解：按转换规则,可得:</p>
<p>E→TE’</p>
<p>E’→+TE’|ε</p>
<p>T→FT ‘</p>
<p>T’→*FT’|ε</p>
<p>F→i| (E)</p>
</blockquote>
<h4 id="消除间接左递归法"><a href="#消除间接左递归法" class="headerlink" title="消除间接左递归法"></a>消除间接左递归法</h4><p>设非终结符按某种规则排序为A1，A2，<strong>…</strong>，An。</p>
<p><strong>For i﹕&#x3D;1 to n do</strong></p>
<p><strong>begin</strong></p>
<p><strong>For j﹕&#x3D;1 to i-1 do</strong></p>
<p><strong>begin</strong></p>
<p><strong>若Aj的所有产生式为：</strong></p>
<p><strong>Aj →δ1| δ2 | … | δn</strong></p>
<p><strong>替换形如Ai → Aj γ的产生式为：</strong></p>
<p><strong>Ai →δ1γ |δ2γ | … |δnγ</strong></p>
<p><strong>end</strong></p>
<p><strong>消除Ai中的一切直接左递归</strong></p>
<p><strong>end</strong></p>
<blockquote>
<p>以文法G6为例消除左递归：</p>
<p>(1)A→aB</p>
<p>(2)A→Bb</p>
<p>(3)B→Ac</p>
<p>(4)B→d</p>
<p>解：用产生式(1)，(2)的右部代替产生式(3)中的非终结A得到左部为B的产生式：</p>
<p>(1)B→aBc</p>
<p>(2)B→Bbc</p>
<p>(3)B→d</p>
<p>消除左递归后得到：</p>
<p>B→aBcB’ |dB’</p>
<p>B’→bcB’ |ε</p>
<p>再把原来其余的产生式A→aB,A→Bb加入，最终得到等价文法为:</p>
<p>(1) A→aB</p>
<p>(2) A→Bb</p>
<p>(3) B→(aBc|d)B’</p>
<p>(4) B’→bcB’|ε</p>
<p>c)消除文法中一切左递归的算法</p>
</blockquote>
<h3 id="递归下降分析法"><a href="#递归下降分析法" class="headerlink" title="递归下降分析法"></a>递归下降分析法</h3><p>通过计算的SELECT集判断编写子程序：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200423151629988.png"></p>
<p>递归下降分析法</p>
<p>ParseE’函数表示进入E’的产生式，通过switch函数分离相同左部的产生式，然后依次检查产生式右部字符，如果是终结符，则通过MatchToken函数判断符合，不符合则出错；如果是非终结符，则继续递归跳转至它所对应的Parse函数。</p>
<p>递归下降分析法对应的是最左推导过程<br>优点：程序结构和层次清晰明了，易于手工实现；<br>对于语义加工，这种方法十分灵活；<br>缺点：递归调用可能带来效率问题。</p>
<h3 id="预测分析法"><a href="#预测分析法" class="headerlink" title="预测分析法"></a>预测分析法</h3><p>首先根据计算出的SELECT集绘制出预测分析表</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200423151732414.png"></p>
<p>然后新建一个分析栈，向空栈中依次压入<code>#</code>和文法的开始符号<code>E</code>，然后比较剩余输入串的首字符和分析栈顶元素，如果不同，则先将分析栈顶元素出栈，然后将对应预测分析表中的产生式右部<u>从后向前</u>依次入栈；如果相同，则先将分析栈顶元素出栈，并将剩余输入串的首字符删去；然后重复以上过程直到栈为<code>#</code>，剩余输入串也为<code>#</code>，则表示语法匹配成功。</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200423151751741.png"></p>
<h3 id="LL-1-分析中的一种错误处理办法"><a href="#LL-1-分析中的一种错误处理办法" class="headerlink" title="LL(1)分析中的一种错误处理办法"></a><strong>LL(1)分析中的一种错误处理办法</strong></h3><p>发现错误的情况：<br>(1) 栈顶的终结符与当前输入符不匹配;<br>(2) 非终结符A于栈顶，面临的输入符为a，但分析表M的M[A,a]为空 （FIRST(A)中没有a）;</p>
<p>应急”恢复策略:<br>对于错误(1) 跳过输入串中的一些符号直至遇到和栈顶的终结符相同的字符为止。</p>
<p>对于错误((2) 跳过输入串中的一些符号直至遇到“同步符号”为止 。</p>
<p>同步符号的选择<br>(1) 把FOLLOW(A)中的所有符号作为A的同步符号。跳过输入串中的一些符号直至遇到这些“同步符号”，把A从栈中弹出，可使分析继续。（跳过A）<br>(2) 把FIRST(A)中的符号加到A的同步符号集，当FIRST(A)中的符号在输入中出现时，可根据A恢复分析。 （不跳过A）</p>
<h1 id="自底向上优先分析"><a href="#自底向上优先分析" class="headerlink" title="自底向上优先分析"></a>自底向上优先分析</h1><h2 id="优先分析概述"><a href="#优先分析概述" class="headerlink" title="优先分析概述"></a>优先分析概述</h2><p>优先分析法是利用句型相邻两个符号之间的所谓“优先关系”确定句柄。</p>
<p>优先关系由文法规则确定，其本质含义是在句型相邻两个符号中哪个符号可以优先归约。</p>
<p>采用简单优先分析法或算符优先分析法构造语法分析程序时，语法分析程序的总体框架如图所示。</p>
<h2 id="简单优先分析法"><a href="#简单优先分析法" class="headerlink" title="简单优先分析法"></a>简单优先分析法</h2><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200423160030288.png"></p>
<h3 id="优先关系定义"><a href="#优先关系定义" class="headerlink" title="优先关系定义"></a>优先关系定义</h3><p>1、X和Y优先级相等，表示为 <code>X=·Y</code>，当且仅当G中存在产生式规则A&#x3D;&gt;···XY···。</p>
<p><em>解读：X、Y的优先级相同，当XY存在一个句柄之中，它们将同时被归约。表现在语法树中S&#x3D;·b。</em></p>
<p>2、X优先级小于Y，表示为 <code>X&lt;·Y</code> ，当且仅当G中存在产生式规则A&#x3D;&gt;···XB···，B&#x3D;+&#x3D;&gt;Y···。</p>
<p><em>解读：X优先级小于Y，当XY存在一个句型中时，它们将不可能出现在同一个句柄中，Y一定比X先被规约。表现在语法树中b&lt;·a。</em></p>
<p>3、X优先级大于Y，表示为 <code>X&gt;·Y</code> ，当且仅当G中存在产生式规则A&#x3D;&gt;··BD···，B&#x3D;+&#x3D;&gt;···X，D&#x3D;*&#x3D;&gt;Y···。</p>
<p><em>解读：X优先级大于Y，当XY存在一个句型中时，它们将不可能出现在同一个句柄中，X一定比Y先被规约。表现在语法树中a&gt;·S。</em></p>
<p>X和Y的优先级为空，表示在文法的任何句型中都不会出现该符号对相邻出现的情况。</p>
<h3 id="简单优先文法定义"><a href="#简单优先文法定义" class="headerlink" title="简单优先文法定义"></a>简单优先文法定义</h3><p>一个文法是简单优先文法，需要满足以下两个条件：</p>
<ol>
<li>在文法符号集中V，任意两个符号之间必须之后一种优先关系存在。（显然满足）</li>
<li>在文法中，两个产生式不能有相同的右部。</li>
</ol>
<h3 id="简单优先分析法的操作步骤"><a href="#简单优先分析法的操作步骤" class="headerlink" title="简单优先分析法的操作步骤"></a>简单优先分析法的操作步骤</h3><ol>
<li><p>将输入输入串a<del>1</del>a<del>2</del>···a<del>n</del>#依次压栈，不断比较栈顶符号a<del>i</del>和下一个待输入符号a<del>j</del>的优先级，若a<del>i</del>&gt;·a<del>j</del>则进行下一步，否则重复此步骤。</p>
<p><em>解读：停止条件是a<del>i</del>&gt;·a<del>j</del>表示前面输入串一定比后面先归约，所以只需要在前面找句柄就行了。</em></p>
</li>
<li><p>栈顶符号a<del>i</del>即为句柄尾，从此处向左寻找句柄头a<del>k</del>，满足a<del>k-1</del>&lt;·a<del>k</del>。</p>
<p><em>解读：从后向前找a<del>k-1</del>&lt;·a<del>k</del>表示a<del>k</del>之前的输入串一定比a<del>i</del>···a<del>k</del>后归约，由此确定现在就是要归约a<del>i</del>···a<del>k</del>。</em></p>
</li>
<li><p>由句柄a<del>i</del>···a<del>k</del>在文法中寻找右部为a<del>i</del>···a<del>k</del>的产生式；找到则将句柄替换为相应左部，找不到则说明该输入串不是该文法的句子。</p>
</li>
<li><p>重复以上步骤直到归约完成。</p>
</li>
</ol>
<h2 id="算符优先分析法"><a href="#算符优先分析法" class="headerlink" title="算符优先分析法"></a>算符优先分析法</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li><p>**算符文法(OG)**：文法G中没有形如A&#x3D;&gt;···BC···的产生式，其中B、C为非终结符，则G为算符文法（operator grammar）。</p>
<p>也就是说产生式的<strong>右部不能出现两个非终结符相邻</strong>，就好像算式中两个操作数相连。</p>
<p><strong>算符文法的两个性质：</strong></p>
<p><code>①算符文法中任何句型都不包含两个相邻的非终结符。</code></p>
<p><code>②如果Ab（bA）出现在算符文法的句型y中，则y中含b的短语必含A，含A的短语不一定含b。</code></p>
</li>
<li><p>**算符优先文法(OPG)**：一个不含ε产生式的算符文法G，任意终结符对(a,b)之间最多只有一种优先关系存在，则G为算符优先文法（operator precedence grammar）。</p>
<p>以算式类比，也就是说我们只关心算符之间的优先关系，不关心操作数的优先关系，·利用算符的优先性和结合性来判断哪个部分先计算（归约）。</p>
<p><strong>注意 ：这里的优先关系与简单优先分析法中不一样。</strong></p>
<blockquote>
<p>a、b为终结符，A、B、C为非终结符</p>
<ol>
<li><p>a和b优先级相等，表示为 <code>a=·b</code> ，当且仅当G中存在产生式规则A&#x3D;&gt;···ab···或者A&#x3D;&gt;···aBb···。</p>
<p><em>解读：表示a、b在同一句柄中同时归约。</em></p>
</li>
<li><p>a优先级小于b，表示为<code>a&lt;·b</code>，当且仅当G中存在产生式规则A&#x3D;&gt;···aB···，且B&#x3D;^+^&#x3D;&gt;b···或B&#x3D;^+^&#x3D;&gt;Cb···。</p>
<p><em>解读：表示b、a不在一个句柄中，b比a先归约。</em></p>
</li>
<li><p>a优先级大于b，表示为 <code>a&gt;·b</code> ，当且仅当G中存在产生式规则A&#x3D;&gt;··Bb···，且B&#x3D;^+^&#x3D;&gt;···a或B&#x3D;^+^&#x3D;&gt;···aC。</p>
<p><em>解读：表示b、a不在一个句柄中，a比b先归约。</em></p>
</li>
</ol>
</blockquote>
<ol>
<li><strong>FIRSTVT()：</strong>FIRSTVT(B)&#x3D;{b|B&#x3D;^+^&#x3D;&gt;b···或B&#x3D;^+^&#x3D;&gt;Cb···,B∈V<del>N</del>，C∈V<del>N</del>,b∈V<del>T</del> }【在算符优先中，非终结符只会和一个终结符相邻】</li>
<li><strong>LASTVT()：</strong>LASTVT(B)&#x3D;{b|B&#x3D;^+^&#x3D;&gt;···b或B&#x3D;^+^&#x3D;&gt;···bC，B∈V<del>N</del>，C∈V<del>N</del>,b∈V<del>T</del>}</li>
<li><strong>素短语：</strong>（a）它首先是<strong>一个短语</strong>，（b）它至少含一个终结符号，（c）除自身外，不再包含其他素短语。</li>
</ol>
</li>
</ol>
<h3 id="最左素短语定理"><a href="#最左素短语定理" class="headerlink" title="最左素短语定理"></a>最左素短语定理</h3><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200427113818455.png" style="zoom:67%;" />

<h3 id="FIRSTVT-的构造算法"><a href="#FIRSTVT-的构造算法" class="headerlink" title="FIRSTVT()的构造算法"></a>FIRSTVT()的构造算法</h3><ol>
<li><p><strong>原理:</strong></p>
<p>①如果有这样的表达式：A&#x3D;&gt;a···或者A&#x3D;&gt;Ba···，那么a∈FIRSTVT(A)。</p>
<p>②如果有这样的表达式：B&#x3D;&gt;A···且有a∈FIRSTVT(A)，则a∈FIRSTVT(B)。</p>
</li>
<li><p><strong>算法：</strong></p>
<p>数据结构：</p>
<p> 布尔数组F[m,n]，m为非终结符数量，n为终结符数量，为真时表示对应a∈FIRSTVT(A)。</p>
<p> 栈S：暂存用于进行原理②的元素。</p>
<p>流程图：</p>
</li>
</ol>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200423191044780.png"></p>
<h3 id="算符优先关系矩阵的构造算法"><a href="#算符优先关系矩阵的构造算法" class="headerlink" title="算符优先关系矩阵的构造算法"></a>算符优先关系矩阵的构造算法</h3><ol>
<li><p><strong>原理</strong></p>
<p>&#x3D;·关系</p>
<p>查看所有产生式的右部，寻找A&#x3D;&gt;···ab···或者A&#x3D;&gt;···aBb···的产生式，可得a&#x3D;·b。</p>
<p>&lt;·关系</p>
<p>查看所有产生式的右部，寻找A&#x3D;&gt;···aB···的产生式，对于每一b∈FIRSTVT(B)，可得a&lt;·b。</p>
<p>&gt;·关系</p>
<p>查看所有产生式的右部，寻找A&#x3D;&gt;··Bb···的产生式，对于每一a∈LASTVT(B)，可得a&gt;·b。</p>
</li>
<li><p><strong>算法：</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">for</span> 每条规则U::= x1 x2…xn do</span><br><span class="line">    <span class="attribute">for</span> i:=<span class="number">1</span> to n-<span class="number">1</span> do</span><br><span class="line">    <span class="attribute">begin</span></span><br><span class="line">        <span class="attribute">if</span> xi和xi+<span class="number">1</span>均为终结符, THEN 置 xi=xi+<span class="number">1</span></span><br><span class="line">        <span class="attribute">if</span> i≤n-<span class="number">2</span>，且xi和xi+<span class="number">2</span>都为终结符号但xi+<span class="number">1</span>为非终结符号 then 置 xi=xi+<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">        <span class="attribute">if</span> xi为终结符号xi+<span class="number">1</span>为非终结符号 then</span><br><span class="line">            <span class="attribute">for</span> FIRSTVT(xi+<span class="number">1</span>)中的每个b do 置xi&lt;b</span><br><span class="line">    </span><br><span class="line">        <span class="attribute">if</span> xi为非终结符号xi+<span class="number">1</span>为终结符号 then</span><br><span class="line">            <span class="attribute">for</span> LASTVT(xi)中的每个a do 置a&gt;xi+<span class="number">1</span></span><br><span class="line">    <span class="attribute">end</span></span><br></pre></td></tr></table></figure>

<p>流程图：</p>
</li>
</ol>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200423191122833.png"></p>
<h2 id="算符优先分析法-1"><a href="#算符优先分析法-1" class="headerlink" title="算符优先分析法"></a>算符优先分析法</h2><p>实现算符优先分析法：<strong>找句型的最左子串（最左素短语）【在语法树中，位子在句型最左边的那个素短语】并进行规约</strong>。</p>
<p>具体实现：当栈内终结符的优先级＜或＝栈外终结符的优先级时，移进；当栈内终结符的优先级＞栈外终结符的优先级时，表明找到了素短语的尾，再往前找其头，并进行规约。</p>
<p>读入字符串为X<del>1</del>X<del>2</del>···X<del>n</del>#</p>
<p>数组S[n+2]用于存放压入栈的字符</p>
<p>流程图：</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/image-20200423191158915.png"></p>
<h2 id="算符优先函数"><a href="#算符优先函数" class="headerlink" title="算符优先函数"></a>算符优先函数</h2><p><strong>迭代法</strong></p>
<p>若已知运算符之间的优先关系，可按如下步骤构造优先函数：</p>
<p>1、对每个运算符a（包括#在内）令f(a)&#x3D;g(a)&#x3D;1</p>
<p>2、如果a⋗b且f(a)&lt;&#x3D;g(b)令f(a)&#x3D;g(b)+1</p>
<p>3、如果a⋖b且f(a)&gt;&#x3D;g(b)令g(b)&#x3D; f(a)+1</p>
<p>4、如果a≐b而f(a) ≠g(b)，令min{f(a),g(b)}&#x3D;max{f(a),g(b)}</p>
<p>5、重复2~4，直到过程收敛。如果重复过程中有一个值大于2n，则表明不存在算符优先函数。</p>
<h2 id="算符优先关系表"><a href="#算符优先关系表" class="headerlink" title="算符优先关系表"></a>算符优先关系表</h2><h2 id="算符优先归约和规范规约"><a href="#算符优先归约和规范规约" class="headerlink" title="算符优先归约和规范规约"></a>算符优先归约和规范规约</h2><p>自下而上的语法分析，其分析过程为<strong>边输入单词符号，边归约，</strong>直至归约到文法的开始符号。（归约是指根据文法的产生式规则，把产生式的右部替换成左部符号）自下而上的分析方法的关键就是<strong>找到可归约串。</strong></p>
<p>对于简单问题（不用考虑优先级等问题）的自下而上语法分析有以下方法：<br>1.<strong>移进归约</strong>，即用一个寄存符号的先进后出栈，把输入符号一个一个地移进到栈里，当栈顶形成某个产生式的候选式时，即把栈顶的这一部分替换成(归约为)该产生式的左部符号；<br>2.<strong>规范规约</strong>，首先了解规范规约的定义，假定α是文法G的一个句子，如果序列α<del>n</del>，α<del>n-1</del>，… ，α<del>0</del>满足：(1)α<del>n</del>&#x3D;α(2)α<del>0</del>为文法的开始符号，即α<del>0</del>&#x3D;S(3)  对任何i，0&lt;i≤n，α<del>i-1</del>是α<del>i</del>把句柄（句型的最左直接短语即最左端的简单子树）替换成为相应产生式左部符号而得到的。我们称该序列是α的一个规范归约，<strong>规范规约即最左归约，可通过修剪最左简单子树实现；</strong><br>3.用符号栈进行自下而上的语法分析，取一个栈作为符号栈，在分析开始时，’#’预先进栈，作为栈底符号，将输入串中的符号依次入栈并规约，’#’作为输入串的结束符。</p>
<p>  在实际问题中往往能够需要考虑优先级，对于优先级问题有以下处理方法:（1）算符优先分析法，即定义算符之间的某种优先关系，借助这种优先关系找到可归约串并规约。这种优先关系往往是单向的，没有自反性。在算符优先分析法中将最左素短语作为可归纳串（算符优先分析一般不等于规范归约）；（2）优先函数法，优先函数是把每个终结符α与两个自然数f(α)与g(α)相对应，使得若α1 &lt;. α2，则f(α1) &lt; g(α2)，若α1 &#x3D;. α2，则f(α1) &#x3D; g(α2)，若α1 &gt;. α2，则f(α1) &gt; g(α2)，f称为入栈优先函数，g称为比较优先函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/03/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">编译原理-文法和语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-27 15:17:55" itemprop="dateCreated datePublished" datetime="2020-03-27T15:17:55Z">2020-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文法的直接概念"><a href="#文法的直接概念" class="headerlink" title="文法的直接概念"></a>文法的直接概念</h1><p>文法是阐述语法的一个工具，语句是语法的实例 。</p>
<blockquote>
<p>语言的构成：组成语言的基本形式是句子，句子是由单词序列构成的，单词是由语言基本符号（字母或单字）组成的。</p>
<p>语言既包含单词和句子这样的语言成分，又包含将这些成分组织起来的语言规则，如词法规则、句法规则等。</p>
<ul>
<li>语法：是一组规则，定义符号如何排列，排列与符号含义无关。</li>
<li>语句：是一组规则，定义符号如何排列，排列与符号含义无关。</li>
<li>语义：研究语法的含义</li>
</ul>
</blockquote>
<p><strong>约定（1）:符号”::&#x3D;”表示“···是由···组成的”</strong></p>
<p><strong>约定（2):符号”|”表示“或者”的意义</strong></p>
<p><strong>约定（3):符号”&#x3D;&gt;”表示“推导”</strong></p>
<p>eg：</p>
<blockquote>
<p>&lt;句子&gt; ∷＝&lt;主语&gt; &lt;谓语&gt; &lt;宾语&gt;<br>&lt;主语&gt; ∷＝&lt;名词&gt;<br>&lt;主语&gt; ∷＝&lt;代词&gt;<br>&lt;谓语&gt; ∷＝&lt;动词&gt;<br>&lt;宾语&gt; ∷＝&lt;名词&gt;<br>&lt;宾语&gt; ∷＝&lt;代词&gt;<br>&lt;代词&gt; ∷＝ 我<br>&lt;代词&gt; ∷＝ 你<br>&lt;动词&gt; ∷＝ 吃<br>&lt;动词&gt; ∷＝ 做<br>&lt;名词&gt; ∷＝ 饭<br>&lt;名词&gt; ∷＝ 菜</p>
</blockquote>
<blockquote>
<p>&lt;句子&gt; &#x3D;&gt; &lt;主语&gt; &lt;谓语&gt; &lt;宾语&gt;<br>&#x3D;&gt; &lt;代词&gt; &lt;谓语&gt; &lt;宾语&gt;<br>&#x3D;&gt; 我 &lt;谓语&gt; &lt;宾语&gt;<br>&#x3D;&gt; 我&lt;动词&gt; &lt;宾语&gt;<br>&#x3D;&gt; 我吃&lt;宾语&gt;<br>&#x3D;&gt; 我吃&lt;名词&gt;<br>&#x3D;&gt; 我吃饭</p>
</blockquote>
<blockquote>
<p>1、推导过程不唯一</p>
<p>2、推导起点的不同，导致语法意义上差异的推导结果</p>
</blockquote>
<p>语法形式化方法要点：</p>
<ul>
<li>语法规则的形式化</li>
<li>语法规则含有语法单位符号</li>
<li>语法规则含有构成语句的单词符号</li>
<li>特殊的语法单位符号——开始符号</li>
</ul>
<p><strong>语法形式化的最终目的在于将语法分析的问题将装换成形式化的推导过程。</strong></p>
<h1 id="符号和符号串"><a href="#符号和符号串" class="headerlink" title="符号和符号串"></a>符号和符号串</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><strong>字母表：字母表∑是非空有穷集合，其元素称为符号。</strong> </li>
<li><strong>符号串 由字母表∑中的符号组成的有穷序列称为 (字母表∑上的)符号串。特别地，不含任何符号的有穷序列称为空串，记为ε。单词和源程序都是符号串！</strong></li>
</ul>
<p>eg</p>
<blockquote>
<p>设字母表∑＝｛0，1｝，则</p>
<p>​     101是∑上的符号串，201不是∑上的符号串。</p>
</blockquote>
<ul>
<li><strong>符号串长度：符号串α的长度是指符号串α中含有符号的个数，记为︱α︱。特别约定，空串ε为零，即︱α︱＝0。</strong></li>
<li><strong>符号串集合：如果集合A的元素都是字母表∑上的符号串，则称集合A为∑上的符号串集合，简称串集。</strong></li>
</ul>
<p>eg</p>
<blockquote>
<p>  设字母表∑＝｛a，b，c｝，A＝｛ε，a，ba，cab｝，B＝｛a1，ba，cab｝，则</p>
<p>   A是∑上的符号串集合，B不是∑上的符号串集合。</p>
</blockquote>
<h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><ul>
<li><strong>符号串连接运算：设x和y是字母表∑上的符号串，在符号串x的最后一个符号之后顺序接上符号串y的符号得到的新符号串z，则称符号串z是由符号串x和符号串y经过连接运算的结果，记为z＝x·y，其中，·是连接运算符。</strong></li>
</ul>
<blockquote>
<p>设字母表∑＝｛a，b，c，0，1｝，x＝abc，y＝01cba，则  z＝x·y＝ abc01cba</p>
</blockquote>
<ul>
<li><p><strong>符号串方幂运算 设x是字母表∑上的符号串，z是由n(≥0)个x自身连接得到的符号串，则称符号串z是由符号串x的n次方幂运算的结果，记为z ＝ x^n^ 。特别约定，x^0^ ＝ε, x^1^＝x 。</strong></p>
</li>
<li><p><strong>符号串集连接运算 设A，B是字母表∑上的符号串集，·是符号串集连接运算，则C＝A·B＝｛x·y︱x∈A ，y∈B｝。 笛卡尔积</strong></p>
</li>
<li><p><strong>符号串集方幂运算 设A是字母表∑上的符号串集，则C是由n(≥0)个A自身连接得到的符号串集，则称符号串集C是由符号串A的n次方幂运算的结果，记为C ＝ A^n^ 。特别约定，A^0^ ＝｛ε｝,A^1^＝A 。</strong></p>
</li>
<li><p><strong>符号串集正闭包运算 设A是字母表∑上的符号串集， A+是A的正闭包，则: A+＝A^1^∪A^2^∪A^3^∪···∪A^n^··· 。</strong></p>
</li>
<li><p><strong>符号串集闭包运算 设A是字母表∑上的符号串集， A*是A的闭包，则 : A* ＝A0∪A+ ，</strong></p>
<p>​     <strong>即：A* ＝A^0^∪A^1^∪A^2^∪A^3^∪···∪A^n^··· 。</strong></p>
</li>
</ul>
<h2 id="文法和语言的形式定义"><a href="#文法和语言的形式定义" class="headerlink" title="文法和语言的形式定义"></a>文法和语言的形式定义</h2><p>规则是字母表V上形如 a∷＝b的式子，可以简写成a→b。其中，符号串a∈V^+^称为规则的左部，符号串b∈V*称为规则的右部。<strong>规则也称为重写规则、产生式或生成式。</strong></p>
<p>特别地，a∷＝ε（ε空串）称为a的空规则。</p>
<p>对于相同左部的多个规则，可以使用符号∣简写。如，规则a∷＝b和a∷＝δ，简写成a∷＝b∣δ。 简写为a → b∣δ</p>
<h3 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h3><p>文法G定义为一个四元组（V<del>N</del>，V<del>T</del>，P，S），记为G＝（V<del>N</del>，V<del>T</del>，P，S）。其中，</p>
<p> ① V<del>N</del>是非空有穷集合，称为非终结符集，其元素称为非终结符；</p>
<p> ② V<del>T</del>是有穷集合，称为终结符集，其元素称为终结符；</p>
<p> ③ P是非空有穷集合，称为规则集，其元素是字母表V<del>N</del>∪V<del>T</del>上的规则，<strong>V<del>N</del>∪V<del>T</del>称为文法的字母表V，且V<del>N</del>∩V<del>T</del>＝空集；</strong></p>
<p> ④ S∈V<del>N</del>，称为开始符。</p>
<h3 id="直接推导、直接归约"><a href="#直接推导、直接归约" class="headerlink" title="直接推导、直接归约"></a>直接推导、直接归约</h3><p>设文法G＝（V<del>N</del>，V<del>T</del>，P，S），<strong>如果α→β∈P，则称γ α δ推导出γ β δ，记为γ α δ&#x3D;&gt;γ β δ</strong>，其中,γ,δ∈V。</p>
<p>γ α δ&#x3D;&gt;γ β δ也称为直接推导或一步推导。</p>
<p>如果γ α δ&#x3D;&gt;γ β δ，则也称为γ β δ归约到γ α δ，也称为直接归约或一步归约。</p>
<blockquote>
<p>例如，例3.1 定义的文法G1＝({S}，{a，b}，{S→aSb，S→ab}，S)，推导例子有：</p>
<p>（1）S&#x3D;&gt; aSb (α＝S，β＝aSb，γ＝ε，δ＝ε)【ε是空集】</p>
<p>（2）aSb &#x3D;&gt; aaSbb (α＝S，β＝aSb，γ＝a，δ＝b)</p>
<p>（3）aSb &#x3D;&gt; aabb (α＝S，β＝ab，γ＝a，δ＝b)</p>
<p>（4）aSbSb &#x3D;&gt; aaSbbSb (α＝S，β＝aSb，γ＝a，δ＝bSb )</p>
</blockquote>
<h3 id="多步推导、多步归约"><a href="#多步推导、多步归约" class="headerlink" title="多步推导、多步归约"></a>多步推导、多步归约</h3><p>设文法G＝（V<del>N</del>，V<del>T</del>，P，S），α,β∈（V<del>N</del>∪V<del>T</del>）*， 如果α,β之间存在推导序列：</p>
<p>α＝ W<del>0</del> &#x3D;&gt; W<del>1</del> &#x3D;&gt; W<del>2</del> ··· &#x3D;&gt; W<del>n</del> ＝β（n≥1）,</p>
<p>则称α经过n步推导出β，记为α&#x3D;&gt;^+^β。其中，W<del>i</del>∈(V<del>N</del>∪V<del>T</del>)*</p>
<p>(1≤i≤n)。α&#x3D;&gt;^+^β也称n步推导或多步推导。</p>
<p>如果α&#x3D;&gt;^+^β，也称为β归约到α，也称为n步归约或多步归约。</p>
<blockquote>
<p>例如，例3.1 定义的文法G1＝({S}，{a，b}，{S→aSb，S→ab}，S) ，多步推导(Þ)例子有：</p>
<p>（1）S&#x3D;&gt;^+^ ab (∵S&#x3D;&gt; ab)</p>
<p>（2）S&#x3D;&gt;^+^ aabb (∵ S&#x3D;&gt; aSb&#x3D;&gt; aabb)</p>
<p>（3）S&#x3D;&gt;^+^ aaaSbbb (∵ S&#x3D;&gt; aSb&#x3D;&gt; aaSbb&#x3D;&gt; aaaSbbb)</p>
<p>（4）aSb &#x3D;&gt;^+^ aaabbb (∵ aSb&#x3D;&gt; aaSbb&#x3D;&gt; aaabbb)</p>
</blockquote>
<h3 id="0步或0步以上推导与归约"><a href="#0步或0步以上推导与归约" class="headerlink" title="0步或0步以上推导与归约"></a>0步或0步以上推导与归约</h3><p>设文法G＝（V<del>N</del>，V<del>T</del>，P，S），α,β∈（V<del>N</del>∪V<del>T</del> ) ^*^，如果有α→β或α&#x3D;&gt;^+^β，则称α经过0步或0步以上推导出β，记为α&#x3D;&gt;*β。亦称β经过0步或0步以上归约到α。</p>
<blockquote>
<p>例如，例3.1 定义的文法G1＝({S}，{a，b}，{S→aSb，S→ab}，S) ， 0步或0步以上推导(Þ)例子有：</p>
<p>   （1）S&#x3D;&gt;* ab，因为有S&#x3D;&gt;^+^ ab</p>
<p>   （2）S&#x3D;&gt;* aabb， 因为有S&#x3D;&gt;^+^aabb</p>
<p>   （3）S&#x3D;&gt;* aaabbb，因为有S&#x3D;&gt;^+^aaabbb</p>
<p>   （4）aSb &#x3D;&gt;* aaabbb，因为有aSb&#x3D;&gt;^+^ aaabbb</p>
<p>   （5）aSbSb &#x3D;&gt;*aSbSb，因为有aSbSb &#x3D;&gt;^+^ aSbSb</p>
</blockquote>
<h3 id="句型、句子"><a href="#句型、句子" class="headerlink" title="句型、句子"></a>句型、句子</h3><p>设文法G＝（V<del>N</del>，V<del>T</del>，P，S），如果有S&#x3D;&gt;* β，则称β是文法G的句型。如果有S&#x3D;&gt;* β，且β∈V<del>T</del>*，则称β是文法G的句子。</p>
<blockquote>
<p>例如，例3.1 定义的文法G1＝({S}，{a，b}，{S→aSb，S→ab}，S) ，句型和句子例子有：</p>
<p>（1）ab是G的句子，因为有S&#x3D;&gt;* ab ，ab∈VT*</p>
<p>（2）aabb是G的句子，因为有S&#x3D;&gt;*  aabb，aabb∈VT*</p>
<p>（3）aaaSbbb是G的句型，因为有S&#x3D;&gt;* aaaSbbb(aaaSbbb ∉ VT*)</p>
</blockquote>
<h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><p>文法G＝（V<del>N</del>，V<del>T</del>，P，S）的产生<strong>语言定义为文法G的句子集合</strong>，记为L(G)。即：</p>
<p>L(G)＝｛β︱S&#x3D;&gt;^<em>^β，β∈V<del>T</del>^</em>^｝。</p>
<h3 id="文法等价"><a href="#文法等价" class="headerlink" title="文法等价"></a>文法等价</h3><p>设G1和G2是两个文法，如果L(G1)＝L(G2)，则称文法G1和G2是等价的。</p>
<blockquote>
<p>例如，下列文法G2和G3是等价的。因为它们产生的语言都是以字母a开头、字母a和b构成的符号串的集合。即L(G2)＝L(G2）＝{a}{a，b}*。</p>
<p>G2＝(｛S，C｝，｛a，b｝，P，S），</p>
<p>  其中，P＝｛S→aC，C→aC ，C→bC, C→ε｝。</p>
<p>G3＝(｛S｝，｛a，b｝，P，S），</p>
<p>  其中，P＝｛S→Sa，S→Sb ，S→a｝。</p>
</blockquote>
<h2 id="文法类型"><a href="#文法类型" class="headerlink" title="文法类型"></a>文法类型</h2><h3 id="0型文法"><a href="#0型文法" class="headerlink" title="0型文法"></a>0型文法</h3><p>设文法G＝（V<del>N</del>，V<del>T</del>，P，S），如果任意α→β∈P，α中至少含有一个非终结符，则称文法G属于0型文法。0型文法，也称为短语文法。</p>
<h3 id="1型文法"><a href="#1型文法" class="headerlink" title="1型文法"></a>1型文法</h3><p>设文法G＝（V<del>N</del>，V<del>T</del>，P，S），如果任意α→β∈P，α中至少含有一个非终结符，且除空规则之外，α的长度不大于β的长度，即︱α︱≤︱β︱，则称文法G属于1型文法。1型文法，也称为上下文有关文法。</p>
<blockquote>
<p>文法G5定义如下，显然G5是1型文法。</p>
<p>​      L(G5）＝｛a^n^b^n^c^n^︱n≥1｝。</p>
<p>G5 ＝（V<del>N</del>，V<del>T</del>，P，S），</p>
<p>  其中，V<del>N</del>＝｛S，B，C｝，</p>
<p>   V<del>T</del>＝｛a，b，c｝，</p>
<p>   P ＝｛S→aSBC︱aBC，CB→BC，</p>
<p>​        aB→ab，bB→bb，</p>
<p>​        bC→bc，cC→cc｝</p>
</blockquote>
<h3 id="2型文法"><a href="#2型文法" class="headerlink" title="2型文法"></a>2型文法</h3><p>设文法G＝（V<del>N</del>，V<del>T</del>，P，S），如果任意α→β∈ P，α∈V<del>N</del> ，则称文法G属于2型文法。2型文法，也称为上下文无关文法。</p>
<blockquote>
<p>例3.6 文法G6定义如下，显然G6是2型文法。</p>
<p>  L(G6）＝｛w$w^R^︱n≥0, w^R^ 为w之逆，w∈{0，1}*｝</p>
<p>G6 ＝（V<del>N</del>，V<del>T</del>，P，S），</p>
<p>   其中，V<del>N</del>＝｛S｝，</p>
<p>​      V<del>T</del> ＝｛$，0，1｝，</p>
<p>​      P ＝｛S→0S0︱1S1︱$ ｝</p>
</blockquote>
<h3 id="3型文法"><a href="#3型文法" class="headerlink" title="3型文法"></a>3型文法</h3><p>文法  设文法G＝（V<del>N</del>，V<del>T</del>，P，S），如果任意α→β∈ P，α∈ V<del>N</del> ，且β只能是aB或a（除空规则之外），则称文法G属于右线性3型文法。【B是非终结符】</p>
<p>设文法G＝（V<del>N</del>，V<del>T</del>，P，S），如果任意α→β∈ P，α∈ V<del>N</del> ，且β只能是Ba或a（除空规则之外），则称文法G属于左线性3型文法。</p>
<p>左线性3型文法和右线性3型文法，统称3型文法，也称为正规文法。</p>
<blockquote>
<p>例2.7 文法G7定义如下。显然G7是3型文法。</p>
<p>​      L(G7）＝｛00，01，10，11｝。</p>
<p>G7 ＝（V<del>N</del>，V<del>T</del>，P，S），</p>
<p> 其中，V<del>N</del>＝｛S，A，B｝，</p>
<p> V<del>T</del>＝｛0，1｝，</p>
<p>  P ＝｛S→A0︱B1，A→0︱1，B→0︱1｝</p>
</blockquote>
<p>文法分类是对规则形式逐步加以限制而得。换言之，从0型文法到1型文法、2型文法和3型文法，其规则形式逐步简单。自然，其表达力也随之逐步减弱。</p>
<p>如果L0、L1、L2和L3分别是0型文法、1型文法、2型文法和3型文法能产生的语言之集，则有如下关系：</p>
<p>L0 ⊋ L1 ⊋ L2 ⊋ L3。</p>
<h2 id="上下无关文法及其语法树"><a href="#上下无关文法及其语法树" class="headerlink" title="上下无关文法及其语法树"></a>上下无关文法及其语法树</h2><p>上下无关文法一个显著特征是<strong>规则左部一定有且仅有一个非终结符</strong>。利用这个特征，可以不列出V<del>N</del>和V<del>T</del> ，给出一个上下无关文法的简洁描述方法：①文法名G改写成G[S]，其中，S表示开始符；②规则集P，仅书写其具体规则。</p>
<h3 id="最左推导、最右推导"><a href="#最左推导、最右推导" class="headerlink" title="最左推导、最右推导"></a>最左推导、最右推导</h3><p>如果在推导的每一步<strong>总是选择当前句型的最左（最右）边非终结符进行推导</strong>，则称这种推导过程为最左（最右）推导。最右推导，也叫规范推导。由规范推导所得的句型，叫做规范句型。规范推导的逆过程，叫做规范归约。</p>
<blockquote>
<p>G[S]：S→aAS︱a</p>
<p>   A→SbA︱SS︱ba</p>
<p>最左推导：S &#x3D;&gt; aAS &#x3D;&gt; aSbAS &#x3D;&gt; aabAS &#x3D;&gt; aabbaS &#x3D;&gt; aabbaa</p>
<p>最右推导：S &#x3D;&gt; aAS &#x3D;&gt; aAa &#x3D;&gt; aSbAa &#x3D;&gt; aSbbaa &#x3D;&gt; aabbaa</p>
<p>一般推导：S &#x3D;&gt; aAS &#x3D;&gt; aSbAS &#x3D;&gt; aSbAa &#x3D;&gt; aabAa &#x3D;&gt; aabbaa</p>
</blockquote>
<h3 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h3><p>假设文法G＝（V<del>N</del>，V<del>T</del>，P，S），则文法G的语法树是一个满足下列条件的多叉树：</p>
<p>（1）以文法开始符S做为树根；</p>
<p>（2）以终结符号或非终结符号做为树的其他结点，且子树根和其孩子结点分别是某规则的左部和右部。</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E9%9F%B3/image-20200328134034228.png" style="zoom: 67%;" />

<p><strong>推论： ①非叶子结点一定是非终结符</strong></p>
<pre><code>           **②全部叶子结点组成的符号串是文法的句子**
</code></pre>
<h3 id="语义二义性"><a href="#语义二义性" class="headerlink" title="语义二义性"></a>语义二义性</h3><p>如果一个文法G，某个句子存在对应的至少两棵不同的语法树，则称文法G是二义性的。</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E9%9F%B3/image-20200328134255807.png" alt="image-20200328134255807" style="zoom:67%;" />

<p><strong>推论</strong>： </p>
<p> <strong>① 如果文法是无二义性的，一个句子的语法树反映了该句子的全部推导过程；</strong></p>
<p> <strong>②</strong> <strong>如果文法是无二义性的，一个句子的最左（最右）推导是唯一的。</strong></p>
<h3 id="语义的先天二义性"><a href="#语义的先天二义性" class="headerlink" title="语义的先天二义性"></a>语义的先天二义性</h3><p>文法的二义性，并不等同于语言的二义性，尽管两者之间可能存在非必然的联系。</p>
<p>因为二义性文法G，可能存在与之等价的无二义性的文法G′，即L(G)＝L(G′）。 </p>
<p>如果一个语言不存在无二义性的文法，则称该语言是先天二义性的。</p>
<blockquote>
<p>例如，语言L＝{a^i^b^j^c^k^︱(i＝j 或i＝k)，(i，j，k≥1)}不存在无二义性的文法，是先天二义性的语言。</p>
</blockquote>
<p><strong>已经证明：文法的二义性判定问题是递归不可解的。即不存在这个判定问题的算法。</strong></p>
<h2 id="句型分析"><a href="#句型分析" class="headerlink" title="句型分析"></a>句型分析</h2><p>假设文法G[S]是语言L之文法，即L(G)＝L，则“符号串α是否符合语言L的语法问题”被等价地转化成“推导或归约问题”，即：</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E9%9F%B3/image-20200328134758183.png" style="zoom:50%;" />

<p>【从起始符推导出α，并且α是非终结符组成的串，也就是α不能再细分】</p>
<p>【归约和推导可以视作是一个相反的过程】</p>
<p>这样，自然地形成了推导法和归约法两大类分析方法。推导法和归约法，也分别称为自上而下的分析方法和自下而上的分析方法。</p>
<h3 id="自上而下的分析方法"><a href="#自上而下的分析方法" class="headerlink" title="自上而下的分析方法"></a>自上而下的分析方法</h3><p>从文法开始符号出发，反复使用规则，寻找匹配符号串（推导）的句型，直到推导出句子或规则用遍。<strong>进行每步推导时，存在两个选择问题：</strong></p>
<p>  <strong>⑴ 选择句型中哪一个非终结符进行推导</strong></p>
<p>  <strong>⑵ 选择非终结符的哪一个规则进行推导</strong></p>
<p><strong>问题⑴可以采用最左推导解决。问题⑵通常需要穷举每一个规则的可能推导。</strong></p>
<p><strong>成功：在推到过程中一旦出现个符号串α，便结束穷举过程，断定符号串α是句子。</strong></p>
<p><strong>失败：当穷举全部可能的推导，而不存在一个符号串α之推导过程的时候，才可以断定符号串α不是句子。</strong></p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E9%9F%B3/image-20200328140215540.png" style="zoom:67%;" />

<h3 id="自下而上的分析方法"><a href="#自下而上的分析方法" class="headerlink" title="自下而上的分析方法"></a>自下而上的分析方法</h3><p>从输入符号串α开始，逐步进行“归约”，直至归约出文法的开始符号 S，则输入串α是文法G定义的语言的句子。否则不是。</p>
<p>这种分析方法在进行每步归约时，存在两个如何选择句型α的子串β进行归约的问题(α&#x3D;β δ)。</p>
<p>如果文法规则没有相同的右部，则在语法分析的过程中，一旦出现子串β与某条规则的右部相同，就可以使用这条规则进行归约,简单优先分析法就是采用此方法进行归约。</p>
<p>但这种限制，实际上也限制了文法的表达能力，所以通常是通过在句型中寻找所谓的“句柄”的途径解决的。</p>
<h3 id="短语、直接短语、句柄"><a href="#短语、直接短语、句柄" class="headerlink" title="短语、直接短语、句柄"></a>短语、直接短语、句柄</h3><p>设G[S]是一文法，αβδ是文法G的句型，如果有S&#x3D;&gt;^*^αAδ且A&#x3D;&gt;^+^β，则称β是句型αβδ的、相对于非终结符A的短语。</p>
<p>特别地，当A&#x3D;&gt;^+^β实际是A&#x3D;&gt;β即<strong>一步推导时</strong>，则又称β是句型αβδ的、相对于非终结符A的直接短语（或简单短语）。</p>
<p><strong>句型的最左直接短语，称为该句型的句柄。</strong></p>
<blockquote>
<p>短语的理解：</p>
<p> “αβδ是文法G的句型”，即S &#x3D;&gt;^*^αβδ</p>
<p> “S&#x3D;&gt;^*^αAδ且A&#x3D;&gt;^+^β”，即S&#x3D;&gt; … &#x3D;&gt;αAδ&#x3D;&gt; … &#x3D;&gt;αβδ</p>
<p>  这表明，如果β是句型αβδ的、相对于A的短语，则至少存在一个推导，使得αAδ &#x3D;&gt;^+^ αβδ，或者αβδ&lt;&#x3D;^+^ αAδ。</p>
<p>  特别地，如果β是直接短语，则αAδ &#x3D;&gt; αβδ，或者αβδ&lt;&#x3D;αAδ。</p>
</blockquote>
<p>【直接短语、短语都是某一个句型的子串】</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E9%9F%B3/image-20200328144445764.png"></p>
<p>在语法树中，<strong>短语是子树的叶子的组合</strong>；<strong>直接短语是两层子树的末端</strong>【i3和F1是两层子树】</p>
<h2 id="文法在实用中的一些说明"><a href="#文法在实用中的一些说明" class="headerlink" title="文法在实用中的一些说明"></a>文法在实用中的一些说明</h2><p>在实际应用中，对于文法规则提出了一些限制条件，但这些并没有限制文法的语言描述能力。限制下列 3种规则的使用：</p>
<p><strong>（1）有害规则 形如U→U的规则，称为有害规则。</strong></p>
<p><strong>（2）不可达规则 不在任何规则右部出现的非终结符对应的规则，称为不可达规则。</strong></p>
<p><strong>（3）不可终止规则  如果从某非终结符开始，不可能推导出任意终结串来，则该非终结符对应的规则称为不可终止规则。</strong></p>
<p><strong>不含有多余规则的文法，称为压缩过的文法。在后面讨论的文法时，都假设是压缩过的的文法。</strong></p>
<h3 id="ε规则问题"><a href="#ε规则问题" class="headerlink" title="ε规则问题"></a>ε规则问题</h3><p>在文法设计中，使用ε规则有时会带来方便，但会导致文法讨论和证明的复杂。</p>
<p>一个上下文无关文法G是否必须使用ε规则，完全取决于文法G产生的语言L(G[S])中是否含有ε语句。</p>
<p>可以证明，如果ε不属于L(G[S]),则存在一个等价的文法G’[S’] ，且G’ 不含ε规则。</p>
<p>如果ε∈ L(G[S]),则存在一个等价的文法G’[S’] ，且G’ 仅含S’ →ε的一个空规则。</p>
<p><strong>提示：使用“代入法”，即可得到等价的文法G’(S’)</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/03/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">编译原理-概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-22 19:57:34" itemprop="dateCreated datePublished" datetime="2020-03-22T19:57:34Z">2020-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="编译原理概述"><a href="#编译原理概述" class="headerlink" title="编译原理概述"></a>编译原理概述</h1><h2 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a>编译程序</h2><p>编译程序是现代计算机系统的基本组成部分。</p>
<ul>
<li>功能上：一个编译程序就是一个语言翻译程序。把源语言翻译成目标语言。</li>
<li>目的：让程序员不需要考虑机器的细节。</li>
</ul>
<blockquote>
<p>需要处理的源程序—（预处理器）—源程序—（编译程序）—-目标汇编程序—（汇编程序）—可再装配的机器代码—（装配连接编辑）—绝对机器码</p>
</blockquote>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%A6%82%E8%BF%B0/image-20200325150810603.png" style="zoom:67%;" />

<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%A6%82%E8%BF%B0/image-20200325151402593.png" style="zoom:67%;" />

<p>编译过程的阶段是一种逻辑上的划分：</p>
<ul>
<li>划分“前端&#x2F;后端”。 将与仅依赖于源程序而与目标机器（硬件）无关的阶段组合成前端，将与目标机器（硬件）相关的阶段组合成后端。<ul>
<li>前端：语法分析程序、语义分析程序</li>
<li>后端：中间代码生成程序、代码优化程序、目标代码生成程序</li>
</ul>
</li>
<li>划分“遍”。从头到尾扫描一遍输入串称谓遍。每遍可以完成编译的若干阶段的编译任务。</li>
</ul>
<h3 id="词法分析（扫描）"><a href="#词法分析（扫描）" class="headerlink" title="词法分析（扫描）"></a>词法分析（扫描）</h3><p>语法分析器读入组成源程序的字符流，并且将它们组织成为有意义的词素的序列。&lt;token-name,attribute-value&gt;</p>
<p>token-name是一个由语法分析步骤使用的抽象符号；attribute-value指向符号表中关于这个词法单元的条目。符号表条目的信息会被语义分析和代码生成步骤使用。</p>
<p><strong>单词符号：</strong></p>
<ul>
<li>常数</li>
<li>保留字</li>
<li>标识符</li>
<li>运算符</li>
<li>界符等类型（例如：空格、括号···）</li>
</ul>
<h3 id="语法分析（解析）"><a href="#语法分析（解析）" class="headerlink" title="语法分析（解析）"></a>语法分析（解析）</h3><p>语法分析器使用由词法分析器生成的各个词法单元的第一个分量来创建树形的中间表示。该中间表示给出了词法分析产生的词法单元流的语法结构。</p>
<p><strong>功能：</strong>层次分析，依据源程序的语法规则把源程序的单词序列组成语法短语（表示成语法树）</p>
<p>语法树中的每个内部结点表示一个运算，而该结点的子结点表示该运算的分量。</p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>语义分析器使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。同时收集类型信息，并且将这些信息存放在语法树或符号表中，方便在随后的中间代码生成过程中使用。</p>
<p><strong>类型检查：检查每个运算符是否具有匹配的运算分量（例如：要求的数组是一个整数，但是给定的是一个浮点数，编译器就会报错）</strong></p>
<h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><p>在源程序的语法分析和语义分析完成后，很多编译器生成一个明确的低级的或类机器语言的中间表示。可以把这个表示看作是某个抽象机器的程序（应具有两个性质：易于生成、易于翻译成目标机器的语言。）</p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>机器无关的代码优化步骤试图改进中间代码，以便生成更好的目标代码。</p>
<h3 id="符号表管理"><a href="#符号表管理" class="headerlink" title="符号表管理"></a>符号表管理</h3><ul>
<li><p>记录源程序中使用的各种符号名称</p>
</li>
<li><p>收集每个符号的各种名称的属性信息</p>
</li>
<li><p>类型、作用域、分配存储信息</p>
</li>
<li><p>符号表管理(）</p>
<ul>
<li>登录：扫描到说明语句就将标识符登记在符号表中</li>
<li>查找：在执行语句查找标识符的属性，判断语义是否正确</li>
</ul>
</li>
</ul>
<p>错误检查</p>
<ul>
<li><p>报告出错信息</p>
</li>
<li><p>排错</p>
</li>
<li><p>恢复编译工作</p>
</li>
</ul>
<h2 id="编译方式和解释方式"><a href="#编译方式和解释方式" class="headerlink" title="编译方式和解释方式"></a>编译方式和解释方式</h2><p>采用编译方式的编译程序称为编译型的编译程序，简称编译程序；采用解释方式的编译程序称为解释型的编译程序，简称解释程序。</p>
<p>　　编译方式是先翻译后执行，即将整个源程序翻译完毕，再执行目标程序，只需要保存完整的目标程序而无需保存源程序。一次翻译后无需再翻译，可多次执行。</p>
<p>　　解释方式是边翻译边执行，即翻译一句就执行一句，翻译完毕也执行完毕，只保存源程序无需保存完整的目标程序。执行一次需要翻译一次。**</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%A6%82%E8%BF%B0/image-20200325155908423.png" style="zoom:67%;" />

<h3 id="解释程序"><a href="#解释程序" class="headerlink" title="解释程序"></a>解释程序</h3><ul>
<li><strong>不产生目标程序文件</strong></li>
<li><strong>不区别翻译阶段和执行阶段</strong></li>
<li><strong>翻译源程序的每条语句后直接执行</strong></li>
<li><strong>程序执行期间一直有解释程序守候</strong></li>
<li><strong>常用于实现虚拟机</strong></li>
</ul>
<h3 id="存储组织不同"><a href="#存储组织不同" class="headerlink" title="存储组织不同"></a>存储组织不同</h3><p>编译程序处理时,在源语言程序被编译阶段,存储区中要为源程序(中间形式)和目标代码开辟空间,要存放编译用的各种各样表格,比如符号表.在目标代码运行阶段,存储区中主要是目标代码和数据,编译所用的任何信息都不再需要.</p>
<p><strong>解释程序一般是把源程序一条语句一条语句的进行语法分析,转换为一种内部表示形式,存放在源程序区</strong>,比如BASIC解释程序,将LET和GOTO这样的关键字表示为一个字节的操作码,标识符用其在符号表的入口位置表示.因为解释程序允许在执行用户程序时修改用户程序,这就要求<strong>源程序,符号表等内容始终存放在存储区中,并且存放格式要设计的易于使用和修改.</strong></p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%A6%82%E8%BF%B0/image-20200325160411573.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">计算机系统结构-指令系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-22 19:57:24" itemprop="dateCreated datePublished" datetime="2020-03-22T19:57:24Z">2020-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机系统结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本概念和分类"><a href="#基本概念和分类" class="headerlink" title="基本概念和分类"></a>基本概念和分类</h1><p>ISA(指令系统)定义了软硬件交互的协约。</p>
<h2 id="指令系统设计原则"><a href="#指令系统设计原则" class="headerlink" title="指令系统设计原则"></a>指令系统设计原则</h2><ul>
<li>可编程性</li>
<li>可实现性</li>
<li>兼容性</li>
</ul>
<h2 id="指令系统设计要素"><a href="#指令系统设计要素" class="headerlink" title="指令系统设计要素"></a>指令系统设计要素</h2><ul>
<li><p><strong>指令格式</strong>：包括了指令长度（定长或者是变长）以及编码方式</p>
</li>
<li><p><strong>操作数存储位置（寄存器、主存、累加器、堆栈）、类型（整型、浮点）、长度（字节、字、双字）和个数（1，2，3，多操作数）</strong></p>
</li>
<li><p><strong>寻址方式</strong></p>
</li>
<li><p><strong>支持的操作类型：加减、比较</strong></p>
</li>
</ul>
<h2 id="指令系统结构分类"><a href="#指令系统结构分类" class="headerlink" title="指令系统结构分类"></a>指令系统结构分类</h2><p>根据操作数的存储位置对指令进行分类：</p>
<ul>
<li>主存型结构：主存</li>
<li>累加器型结构：累加器</li>
<li>堆栈型结构：堆栈</li>
<li>通用寄存器结构：通用寄存器组</li>
</ul>
<p><strong>指令系统中操作数给出方式：</strong></p>
<ul>
<li>显式给出：用指令字中的操作数字段给出</li>
<li>隐式给出：隐式给出则是使用实现约定好的单元</li>
</ul>
<h1 id="指令系统的发展和改进"><a href="#指令系统的发展和改进" class="headerlink" title="指令系统的发展和改进"></a>指令系统的发展和改进</h1><p>由性能公式：CPU时间&#x3D;指令条数IC*CPI *周期时间</p>
<h2 id="复杂指令系统CISC"><a href="#复杂指令系统CISC" class="headerlink" title="复杂指令系统CISC"></a>复杂指令系统CISC</h2><p><strong>改进方法：</strong></p>
<ul>
<li>减少指令条数，使用复杂的指令</li>
<li>对于使用频率高的指令串，用一条新的指令来代替</li>
</ul>
<p><strong>问题：</strong></p>
<ul>
<li>设计周期长，准确性难以保证</li>
<li>需要大量的硬件支持</li>
<li>很多复杂指令使用频率低，造成资源浪费</li>
<li>许多指令由于操作复杂，其CPI值比较大，执行速度慢</li>
<li>规整性不好，不利于采用流水线技术来提高性能</li>
</ul>
<h2 id="精简指令系统RISC"><a href="#精简指令系统RISC" class="headerlink" title="精简指令系统RISC"></a>精简指令系统RISC</h2><p><strong>RISC遵循的原则：</strong></p>
<ul>
<li>指令条数少，功能简单<br>【只选取使用频率很高的指令，再补充一些其他最有用的指令】</li>
<li>指令格式简单、规整、并减少寻址方式</li>
<li>指令的执行在单个周期内完成（采用流水线机制）</li>
<li>只有load和store指令才能访问存储器，其他指令的操作都是在寄存器之间进行（load-store结构）</li>
<li>大多数指令都采用硬连逻辑来实现</li>
<li>强调优化编译器的作用，为高级语言程序生成优化的代码</li>
<li>充分利用流水线技术来提高性能</li>
</ul>
<p><strong>改进方法：</strong></p>
<ul>
<li>减少CPI，使用大量单周期指令</li>
<li>增加指令条数，复杂的指令使用频率很低，实际程序的指令条数并不太多</li>
<li>减少时钟周期时间</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/03/23/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/23/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-22 19:57:09" itemprop="dateCreated datePublished" datetime="2020-03-22T19:57:09Z">2020-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>数据模型是数据库系统的核心和基础。它是现实世界的模拟。</p>
<p>三要素：数据结构、数据操作、数据约束</p>
<h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><p>信息模型，按用户的观点来对数据和信息建模。</p>
<ul>
<li>实体：客观存在并可相互区别的事物</li>
<li>属性：实体所具有的某一特性</li>
<li>码：<strong>唯一</strong>标识实体的属性集</li>
<li>实体型：</li>
</ul>
<h3 id="逻辑模型和物理模型"><a href="#逻辑模型和物理模型" class="headerlink" title="逻辑模型和物理模型"></a>逻辑模型和物理模型</h3><ul>
<li>逻辑模型主要包括网状模型、层次模型、关系模型、面向对象模型···</li>
<li>物理模型是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或者是磁带上的存储方式和存取方法。</li>
</ul>
<h3 id="客观对象的抽象过程–两步抽象"><a href="#客观对象的抽象过程–两步抽象" class="headerlink" title="客观对象的抽象过程–两步抽象"></a>客观对象的抽象过程–两步抽象</h3><p>1、客观对象抽象为概念模型</p>
<p>2、把概念模型转换为某一DBMS支持的数据模型</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200323175234167.png" style="zoom:67%;" />

<h2 id="常用的数据模型"><a href="#常用的数据模型" class="headerlink" title="常用的数据模型"></a>常用的数据模型</h2><ul>
<li><strong>非关系模型</strong><ul>
<li>层次模型</li>
<li>网状模型</li>
</ul>
</li>
<li><strong>关系模型</strong><ul>
<li>面向对象模型</li>
<li>对象关系模型</li>
</ul>
</li>
</ul>
<h3 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h3><p>使用<strong>树状结构</strong>来表示各类实体以及实体间的联系。</p>
<p>要求：</p>
<ol>
<li>有且只有一个结点没有双亲结点，这个结点称为根节点</li>
<li><strong>根以外的其他结点有且只有一个双亲结点</strong></li>
</ol>
<p>根据上述的要求，可以确认层次模型其实是<strong>父与子之间一对多的联系</strong>。每个结点表示的是记录类型，记录类型之间的联系用结点之间的连线表示。</p>
<h4 id="层次模型的特点"><a href="#层次模型的特点" class="headerlink" title="层次模型的特点"></a>层次模型的特点</h4><ul>
<li>结点的双亲是唯一的</li>
<li>只能直接处理<strong>一对多</strong>的实体联系<br>【如果一个结点有多个双亲结点的话，只能通过引入冗余数据或者创建非自然的数据结构来解决】</li>
<li>每个记录类型可以定义一个排序字段（码字段）<br>【方便查找，并且查找效率高】</li>
<li>任何记录值只有按其路径查看时，才能显出它的全部意义<br>【可以直观的知道其一脉相承的父子关系，结构严密】</li>
<li>没有一个子女记录值能够脱离双亲记录值而独立存在<br>【例如：插入操作时，要先找到其父结点值；删除操作时，其子结点会一并被删除】</li>
<li>查询子女结点必须通过双亲结点</li>
</ul>
<h4 id="多对多联系在层次模型中的表示"><a href="#多对多联系在层次模型中的表示" class="headerlink" title="多对多联系在层次模型中的表示"></a>多对多联系在层次模型中的表示</h4><p>基本思路是：将多对多联系分解成一对多联系</p>
<p><strong>冗余结点法</strong>：就是将存在多对多联系的结点拆分成一对多联系的模式。会产生多个根节点，同时该多个根结点也表示子结点。</p>
<p><strong>虚拟结点法</strong>：就是将存在多对多联系的结点拆分，产生多个根结点。每个根节点连接一个虚拟结点【该虚拟结点就是上述拆开的子节点】</p>
<h4 id="增删查改与完整性约束"><a href="#增删查改与完整性约束" class="headerlink" title="增删查改与完整性约束"></a>增删查改与完整性约束</h4><ul>
<li>无相应的双亲结点值就不能插入子女结点值</li>
<li>如果删除双亲结点值，则相应的子女结点值也会被删除</li>
<li><strong>更新操作时，应更新所有相应记录，以保证数据的一致性</strong></li>
</ul>
<h4 id="层次数据模型的存储结构"><a href="#层次数据模型的存储结构" class="headerlink" title="层次数据模型的存储结构"></a>层次数据模型的存储结构</h4><p><strong>邻接法</strong></p>
<p>按照层次树前序遍历将所有的记录值一次邻接存储，通过<strong>物理空间的位置相邻</strong>来实现层次顺序</p>
<p><strong>链接法</strong></p>
<p>用指针来反映数据之间的层次联系</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200324103822351.png" style="zoom:67%;" />

<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200324103845301.png" style="zoom:67%;" />



<h3 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h3><p>要求：</p>
<ol>
<li>允许一个以上的结点无双亲结点</li>
<li>一个结点可以有多个双亲结点</li>
</ol>
<p>层次模型可以看成是网状模型的一个特例</p>
<h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p><strong>用二维表来表示实体及其联系：行、列</strong></p>
<blockquote>
<p>用表格表示实体集，用列表示属性，表结构表示实体的型</p>
<p>用表间的特定的冗余信息表示实体间的联系（主键和外键）</p>
<p>行、列是无序的</p>
<p>列不可再分</p>
<p>没有重复行</p>
</blockquote>
<p><strong>关系规范化要求：</strong>关系的每一个分量必须是一个不可分的数据项 <strong>不允许表中还有表</strong></p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200324104653997.png" style="zoom:50%;" />

<h4 id="关系模型的存储结构"><a href="#关系模型的存储结构" class="headerlink" title="关系模型的存储结构"></a>关系模型的存储结构</h4><p>实体及实体间的联系都用表来表示</p>
<p>表以文件形式存储</p>
<h2 id="数据库系统结构"><a href="#数据库系统结构" class="headerlink" title="数据库系统结构"></a>数据库系统结构</h2><p>在数据模型中有“型”和“值”的概念。<strong>型是指对某一类数据的结构和属性的说明。值是型的一个具体赋值</strong></p>
<p>数据库系统内部的体系结构：采取三级模式结构</p>
<p>数据库系统外部的体系结构：</p>
<ul>
<li>单用户结构</li>
<li>主从式结构</li>
<li>分布式结构</li>
<li>客户|服务器</li>
<li>浏览器|应用服务器|数据库服务器多层结构</li>
</ul>
<h3 id="数据库系统的三级模式结构"><a href="#数据库系统的三级模式结构" class="headerlink" title="数据库系统的三级模式结构"></a>数据库系统的三级模式结构</h3><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200324120106956.png"></p>
<h4 id="模式（逻辑模式）"><a href="#模式（逻辑模式）" class="headerlink" title="模式（逻辑模式）"></a>模式（逻辑模式）</h4><p>对数据库中的全部数据的逻辑结构和特征的描述，它仅仅涉及到的是型的描述，不涉及到具体的值。</p>
<p><strong>模式的定义：</strong></p>
<ul>
<li>数据的逻辑结构（包括了数据项的名字、类型、取值范围···）</li>
<li>数据之间的联系</li>
<li>数据有关的安全性、完整性要求</li>
</ul>
<blockquote>
<p><strong>模式（schema）</strong>：反映的是数据的结构及其联系</p>
<p><strong>实例（instance）</strong>：模式的一个具体值，实例会随着数据库中的数据的更新而变动</p>
<p><strong>模式是相对稳定的，而实例是相对变动的</strong></p>
</blockquote>
<p><strong>一个数据库只有一个模式，可以将模式视为是数据库数据在逻辑级上的视图。</strong></p>
<p>&#x3D;&#x3D;<strong>模式是数据库系统模式结构的中间层</strong>&#x3D;&#x3D;</p>
<ul>
<li>与数据的物理存储细节和硬件环境无关</li>
<li>与具体的应用程序、开发工具及高级程序设计语言无关</li>
</ul>
<h4 id="外模式（子模式、用户模式）"><a href="#外模式（子模式、用户模式）" class="headerlink" title="外模式（子模式、用户模式）"></a>外模式（子模式、用户模式）</h4><p><strong>数据库用户的数据视图，是用户使用的局部数据的逻辑结构和特征的描述</strong></p>
<p>&#x3D;&#x3D;<strong>外模式介于模式和应用之间</strong>&#x3D;&#x3D;</p>
<ul>
<li>模式与外模式的关系：一对多<ul>
<li>外模式通常是模式的子集</li>
<li>一个数据库可以拥有多个外模式。</li>
<li>对模式中同一数据，在外模式中的结构、类型、长度、保密级别都不同（这倒是让我想起了在同一个项目下使用不同数据库存储不同的数据）</li>
</ul>
</li>
<li>外模式与应用的关系：一对多<ul>
<li>同一外模式可以为某个用户的多个应用系统所使用</li>
<li>但是一个应用程序只能使用一个外模式</li>
</ul>
</li>
</ul>
<p>外模式的用途</p>
<ul>
<li>保证数据库安全性</li>
<li>每个用户只能看见和访问所对应的外模式中的数据</li>
</ul>
<h3 id="内模式（存储模式）"><a href="#内模式（存储模式）" class="headerlink" title="内模式（存储模式）"></a>内模式（存储模式）</h3><p>是数据物理结构和存储方式的描述（不同数据库的内部实现方式）</p>
<p>是数据在数据库内部的表示方式</p>
<ul>
<li>记录的存储方式（顺序存储、按照B树结构存储、按照hash方式存储）</li>
<li>索引的组织方式</li>
<li>数据是否压缩存储</li>
<li>数据是否加密</li>
<li>数据存储记录结构的规定</li>
</ul>
<p><strong>一个数据库只有一个内模式</strong></p>
<h3 id="数据库的二级映像功能与数据独立性"><a href="#数据库的二级映像功能与数据独立性" class="headerlink" title="数据库的二级映像功能与数据独立性"></a>数据库的二级映像功能与数据独立性</h3><p>二级映像在DBMS内部实现这三个抽象层次的联系和转换</p>
<ul>
<li>外模式|模式映像</li>
<li>模式|内模式映像</li>
</ul>
<h4 id="外模式-模式映象"><a href="#外模式-模式映象" class="headerlink" title="外模式|模式映象"></a>外模式|模式映象</h4><p>定义外模式与模式之间的对应关系。映象定义通常包含在各自外模式的描述中。</p>
<blockquote>
<p>模式描述的是数据的全局逻辑结构；外模式描述的是数据的局部逻辑结构。</p>
<p>同一个模式下可以有任意多个外模式。</p>
</blockquote>
<p><strong>保证数据的逻辑独立性</strong>：应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性。</p>
<h4 id="模式-内模式映象"><a href="#模式-内模式映象" class="headerlink" title="模式|内模式映象"></a>模式|内模式映象</h4><p>定义了数据全局逻辑结构与存储结构之间的对应关系。通常包含在模式描述中。</p>
<p><strong>数据库中模式|内模式映象是唯一的。</strong></p>
<p><strong>保证了数据的物理独立性：</strong>当数据库的存储结构改变了，只要修改模式|内模式映象使得模式保持不变，应用程序就不会受到影响。</p>
<h4 id="数据库模式"><a href="#数据库模式" class="headerlink" title="数据库模式"></a>数据库模式</h4><ul>
<li>全局逻辑结构</li>
<li>设计数据库模式结构时应该首先确定数据库的逻辑模式</li>
</ul>
<h4 id="数据库的内模式"><a href="#数据库的内模式" class="headerlink" title="数据库的内模式"></a>数据库的内模式</h4><ul>
<li>依赖其全局逻辑结构</li>
<li>独立于数据库的用户视图（外模式）</li>
<li>独立于具体的存储设备</li>
<li>将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，提高空间使用率。</li>
</ul>
<h4 id="数据库的外模式"><a href="#数据库的外模式" class="headerlink" title="数据库的外模式"></a>数据库的外模式</h4><ul>
<li>面向的是具体的应用程序</li>
<li>定义在逻辑模式之上</li>
<li>独立于存储模式和存储设备</li>
<li>当应用需求发生较大的变化时，相对应外模式不能满足其视图要求时，该外模式就得做出相应改动。</li>
<li>设计外模式时应充分考虑到应用的扩展性</li>
</ul>
<h4 id="特定的应用程序"><a href="#特定的应用程序" class="headerlink" title="特定的应用程序"></a>特定的应用程序</h4><ul>
<li>是在外模式描述的数据结构上编制的</li>
<li>依赖于特定的外模式</li>
<li>与数据库的模式和存储结构独立</li>
<li>不同的应用程序有时可以共用一个外模式</li>
</ul>
<h2 id="数据库系统的组成"><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h2><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200324155703346.png" style="zoom:67%;" />

<h3 id="硬件平台及数据库"><a href="#硬件平台及数据库" class="headerlink" title="硬件平台及数据库"></a>硬件平台及数据库</h3><ol>
<li><p>足够大的内存</p>
<blockquote>
<p>存放操作系统、数据库管理系统的核心模块、数据缓冲区和应用程序</p>
</blockquote>
</li>
<li><p>足够大的外存</p>
<blockquote>
<p>可以用作数据的备份</p>
</blockquote>
</li>
<li><p>较高的通道能力，提高数据传送率</p>
</li>
</ol>
<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><ol>
<li><p>DBMS</p>
<blockquote>
<p>数据库管理系统是为数据库的建立、使用和维护配置的系统软件</p>
</blockquote>
</li>
<li><p>支持DBMS运行的操作系统</p>
</li>
<li><p>与数据库接口的高级语言和配套的编译系统</p>
</li>
<li><p>以DBMS为核心的应用开发工具</p>
</li>
<li><p>为特定应用环境开发的数据库应用系统</p>
</li>
</ol>
<h3 id="人员"><a href="#人员" class="headerlink" title="人员"></a>人员</h3><ol>
<li><p>数据库管理人员DBA</p>
<blockquote>
</blockquote>
</li>
<li><p>系统分析员和数据库设计人员</p>
</li>
<li><p>应用程序员</p>
</li>
<li><p>用户</p>
</li>
</ol>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20200324160326154.png" style="zoom:67%;" />

<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p>文件系统和数据库系统都能管理数据，也都支持通过应用程序访问数据，两种方式在数据独立性上有何不同？</p>
<p>数据管理文件系统阶段和数据库系统阶段“数据独立性”有何不同？</p>
<blockquote>
<p> 在数据管理技术的发展过程中，经历了人工管理阶段、文件系统阶段和数据库系统阶段，其中数据独立性最高的阶段是数据库系统。数据库阶段用数据模型表示复杂的数据，有较高的数据独立性。数据库系统为用户提供了方便的用户接口，用户可使用查询语言或终端命令操作数据库，也可以用程序方式操作数据库。数据库管理系统提供了数据控制功能。</p>
<p> 文件系统和数据库系统之间的区别：</p>
<p> （1） 文件系统用文件将数据长期保存在外存上，数据库系统用数据库统一存储数据；</p>
<p> （2） 文件系统中的程序和数据有一定的联系，数据库系统中的程序和数据分离；</p>
<p> （3） 文件系统用操作系统中的存取方法对数据进行管理，数据库系统用DBMS统一管理和控制数据；</p>
<p> （4） 文件系统实现以文件为单位的数据共享，数据库系统实现以记录和字段为单位的数据共享。</p>
<p> 文件系统和数据库系统之间的联系：</p>
<p> （1） 均为数据组织的管理技术；</p>
<p> （2） 均由数据管理软件管理数据，程序与数据之间用存取方法进行转换；</p>
<p> （3） 数据库系统是在文件系统的基础上发展而来的。</p>
<p> 文件系统是操作系统用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。</p>
<p> 文件系统由三部分组成：文件系统的接口，对对象操纵和管理的软件集合，对象及属性。从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等。</p>
</blockquote>
<p>数据库系统在管理数据时采用的分层管理的思想，也就是三级模式两级映像的架构，这么做起到了什么作用？</p>
<blockquote>
<p>采用三级模式和二级映像的原因：</p>
<p>1）保证了数据的独立性。将模式与内模式、模式与外模式分开保证了数据的物理独立性和逻辑独立性</p>
<p>2）简化了用户接口，按照外模式编写应用程序或敲入命令，不需了解内部结构</p>
<p>3）有利于数据共享，不同应用可共用一个外模式，减少了数据冗余</p>
<p>4）有利于数据的安全保密，在外模式限定下进行操作，不能对限定数据操作，保证了其他数据的安全</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/03/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-ML%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-ML%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">函数式编程-ML编程基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-22 19:56:50" itemprop="dateCreated datePublished" datetime="2020-03-22T19:56:50Z">2020-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">函数式编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ML概览"><a href="#ML概览" class="headerlink" title="ML概览"></a>ML概览</h1><ul>
<li>ML强调的是表达式估计</li>
<li>ML更倾向于代数</li>
<li>ML表达式特征：类型可有可无、值可有可无、效果可有可无</li>
<li>类型检查十分严格</li>
</ul>
<h2 id="ML标准类型"><a href="#ML标准类型" class="headerlink" title="ML标准类型"></a>ML标准类型</h2><ul>
<li>基础类型(basic types) unit, int, real, bool, string</li>
<li>表(lists)  int list, (int -&gt; int) list</li>
<li>元组(tuples)  int * int, int * int * real</li>
<li>函数(functions) int -&gt; int, real -&gt; int * int</li>
</ul>
<p>所有对象都要有类型，不一定显式说明，但必须能静态推导(在编译时该类型能被编译器根据上下文推算出来)。例如：int y&#x3D;x+3就默认了x和y均是int型，因为会强制类型转换。</p>
<ul>
<li>单元(unit) 只包含一个元素，用空的括号表示，类似于C语言中的void类型。 ( ) : unit</li>
<li>整型(int) 负号用“~”表示。</li>
<li>浮点型(real)</li>
<li>布尔型(bool) true, false</li>
<li>字符串型(string) 双引号间的字符序列</li>
</ul>
<h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><ul>
<li>包含<strong>相同类型的元素</strong>序列</li>
<li>表中元素用“,”分隔，整个表用[ ]括起来</li>
<li>空表：[ ]或nil</li>
<li>表的类型表达式取决于表的元素类型，写作：<br>  &lt;元素类型&gt; list</li>
</ul>
<p> 如： int list, (int -&gt; int) list</p>
<ul>
<li>表可以嵌套</li>
</ul>
<p> 如: [1,2,3] : int list  [“张三”, “李四”]: string list</p>
<ul>
<li><p>相同类型元素的有限序列</p>
</li>
<li><p>元素可以重复出现，其顺序是有意义的</p>
</li>
<li><p>表中元素可以为任意类型，但需具有相同类型</p>
</li>
<li><p>表为多态类型</p>
</li>
<li><p>表的基本函数：</p>
<p>  :: (追加元素), @ (连接表), null (空表测试), hd(返回表头元素), tl(返回非空表的表尾), length(返回表长)</p>
<blockquote>
<p>• [1, 3, 2, 1, 21+21] : int list</p>
<p>• [true, false, true] : bool list</p>
<p>• [[1],[2, 3]] : (int list) list</p>
<p>• [ ] : int list, [ ] : bool list, ……</p>
<p>• 1::[2, 3] &#x3D; [1, 2, 3]</p>
<p>• [1, 2]@[3, 4] &#x3D; [1, 2, 3, 4]</p>
<p>• nil &#x3D; [ ]</p>
</blockquote>
</li>
</ul>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><ul>
<li><strong>包含任意类型数据元素的定长序列</strong></li>
<li>类型表达式：每个元素的类型用*间隔并排列在一起。如： int * int, int * int * real</li>
<li>圆括号中用逗号分隔的数据元素，允许嵌套。如: (“张三”, “男”, 19, 1.75)</li>
</ul>
<p>​    [((“赵”,”子昂”)，21, 1.81), ((“张”, “文艺”), 20, 1.69)]对应的是((string * string)* int * real)list</p>
<h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><ul>
<li>类似C中的结构类型，可以包含不同类型的元素</li>
<li>每个元素有个名字</li>
<li>记录的值和类型的写法都用{ }括起来。如： {First_name&#x3D;“赵”, Last_name&#x3D;“子昂”}</li>
</ul>
<h3 id="元组、表和记录的异同点"><a href="#元组、表和记录的异同点" class="headerlink" title="元组、表和记录的异同点"></a>元组、表和记录的异同点</h3><ul>
<li>符号：（）  、   [ ]    、{  }</li>
<li>元素类型：可以不同    、    必须相同      、可以不同</li>
<li>长度：定长    、    变长       、变长</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>以一定的规则将定义域上的值映射到值域上去</li>
<li>类型由它的定义域类型和值域类型共同描述</li>
<li>-&gt;表示定义域到值域的映射</li>
</ul>
<p> fn: &lt;定义域类型&gt; -&gt; &lt;值域类型&gt;。如: fun add(x, y) &#x3D; x + y;</p>
<h4 id="ML标准函数"><a href="#ML标准函数" class="headerlink" title="ML标准函数"></a>ML标准函数</h4><ul>
<li><p>标准布尔函数：not, andalso, orelse。如：not true;    true andalso false;   true orelse false;</p>
</li>
<li><p>标准算数运算函数：~, +, -, *, div, &#x2F;。如：6 * 7;   3.0 * 2.0;</p>
<ul>
<li>运算符重载(operator ): 把同一运算符作用在不同类型上。</li>
<li>重载运算符的两边必须为同一类型。</li>
<li>整数到实数的转换：real</li>
<li>实数到整数的转换：floor(下取整), ceil(上取整), round(四舍五入)，trunc(忽略小数)</li>
</ul>
</li>
<li><p>标准字符串函数：</p>
<ul>
<li>把两个字符串合并成一个：^</li>
<li>返回字符串的长度：size</li>
</ul>
</li>
</ul>
<h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><ul>
<li><p>每个类型都有一个值的集合<br>  For each type t there is a set of <em>values</em></p>
</li>
<li><p>一个类型的表达式求值结果为该类型的一个值(或出错)<br>  An expression of type t <em>evaluates to a value of type</em> t (or fails to terminate)</p>
</li>
</ul>
<h4 id="函数求值"><a href="#函数求值" class="headerlink" title="函数求值"></a>函数求值</h4><p>函数：以一定的规则将定义域上的值映射到值域上</p>
<p>原型： fn:&lt;定义域类型&gt; -&gt; &lt;值域类型&gt;</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p><strong>赋予某个对象一个名字，包括值、类型、签名、结构和函子</strong></p>
<ul>
<li>函数的声明： fun &lt;函数名&gt; (&lt;形式参数&gt;) : &lt;结果类型&gt; &#x3D; &lt;函数体&gt;</li>
</ul>
<p> 例：fun divmod(x:int, y:int) : int*int &#x3D; (x div y, x mod y)</p>
<ul>
<li><p>值的声明：val pi &#x3D; 3.1415；val (q:int, r:int) &#x3D; divmod(42, 5)；</p>
<p>采用静态绑定方式——重新声明不会损坏系统、库或程序</p>
</li>
<li><p>类型绑定：type float &#x3D; real</p>
<p>type count &#x3D; int and average &#x3D; real</p>
</li>
<li><p>值绑定：val m : int &#x3D; 3+2</p>
<p>val pi : real &#x3D; 3.14 and e : real &#x3D; 2.17</p>
</li>
<li><p>组合声明：val m : int &#x3D; 3+2</p>
<p>val n : int &#x3D; m*m</p>
</li>
</ul>
<h4 id="声明的使用"><a href="#声明的使用" class="headerlink" title="声明的使用"></a>声明的使用</h4><p>声明函数：<br>  check : int * int -&gt; bool</p>
<p>局部声明：</p>
<p>  let D in E end</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> check(x<span class="operator">:</span><span class="type">int</span>, y<span class="operator">:</span><span class="type">int</span>)<span class="operator">:</span><span class="type">bool</span> <span class="operator">=</span></span><br><span class="line"><span class="keyword">let</span></span><br><span class="line">	<span class="keyword">val</span> (q<span class="operator">:</span><span class="type">int</span>, r<span class="operator">:</span><span class="type">int</span>)<span class="operator">=</span> divmod(x, y)</span><br><span class="line"><span class="keyword">in</span></span><br><span class="line">	(x <span class="operator">=</span> q<span class="operator">*</span>y <span class="operator">+</span> r)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>全局声明</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pi : real = <span class="number">3.14</span>;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">square</span><span class="params">(r:<span class="type">real</span>)</span></span> : real = r * r;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">(r:<span class="type">real</span>)</span></span> : real = pi * square(r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> pi : real = <span class="number">3.14159</span>;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">(r:<span class="type">real</span>)</span></span> : real = pi * square(r);</span><br></pre></td></tr></table></figure>



<h3 id="声明、类型和值"><a href="#声明、类型和值" class="headerlink" title="声明、类型和值"></a>声明、类型和值</h3><ul>
<li>任意一个类型的表达式都可以进行求值操作</li>
<li>任意一个类型表达式求值的结果为该类型的一个值</li>
<li>ML提供重新声明功能 </li>
<li>声明将产生名字(变量)和值的绑定(结合)</li>
<li>绑定具有静态作用域</li>
</ul>
<h3 id="ML-x3D"><a href="#ML-x3D" class="headerlink" title="ML &#x3D;"></a>ML &#x3D;</h3><ul>
<li>“&#x3D;”用于类型的等式判断，称为等式类型(“<em>equality types</em>”)</li>
<li>等式类型包括整数、布尔值结合元组、表等构造子生成的类型</li>
</ul>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul>
<li><p>只包含变量、构造子(数值、字符、元组、表等)和通配符的表达式</p>
<ul>
<li>模式中不是构造子的名字，是变量</li>
<li>模式中的变量必须彼此不同</li>
<li>构造子必须和变量区分开来</li>
</ul>
</li>
<li><p>通配符:  _</p>
</li>
<li><p>变量  : x   &#x2F;&#x2F;同一模式中，一个变量不能出现两次</p>
</li>
<li><p>常数  : 42, true, ~3   &#x2F;&#x2F; 实数和函数没有常数模式</p>
</li>
<li><p>元组  : (p1, …, pk)   &#x2F;&#x2F;p1, …, pk均为模式</p>
</li>
<li><p>表    : nil, p1::p2, [p1, …, pk]</p>
</li>
</ul>
<h3 id="规则说明"><a href="#规则说明" class="headerlink" title="规则说明"></a>规则说明</h3><ul>
<li>部分操作的内建规则：<ul>
<li>结合性强于 -&gt;</li>
<li>无结合规则</li>
<li>-&gt; 为右结合</li>
</ul>
</li>
</ul>
<h3 id="替代"><a href="#替代" class="headerlink" title="替代"></a>替代</h3><ul>
<li><p>给定集合绑定值【 x1:v1,…,xk:vk 】</p>
</li>
<li><p>及表达式e，计为[ x1:v1, …, xk:vk ] e</p>
</li>
<li><p>表达式替换为</p>
</li>
<li><p>v1 for x1,…,vk for xk </p>
</li>
<li><p>如</p>
<p>[ x:2 ] (x + x) is (2 + 2)；[ x:2 ] (fn y &#x3D;&gt; x + y) is (fn y &#x3D;&gt; 2 + y) </p>
<p>[ x:2 ] (if x&gt;0 then 1 else f(x-1))  is (if 2&gt;0 then 1 else f(2-1))</p>
</li>
</ul>
<h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ul>
<li>函数定义前，用注释信息描述函数功能，形如(* comments*) ：<ul>
<li>函数名字和类型 (类型定义)</li>
<li>REQUIRES：参数说明 (明确参数范围)</li>
<li>ENSURES：函数在有效参数范围内的执行结果 (函数功能)</li>
</ul>
</li>
</ul>
<blockquote>
<p>范例1：函数eval的说明</p>
<p><strong>fun</strong> eval ([ ]:int list) : int &#x3D; 0<br> | eval (d::L) &#x3D; d + 10 * (eval L);</p>
<p>(* eval : int list -&gt; int  <em>)<br> ( * REQUIRES:  <em>)<br> (  * every integer in L is a decimal digit    * ) (</em> ENSURES:  * )<br> (</em>   eval(L) evaluates to a non-negative integer *)</p>
</blockquote>
<h3 id="程序正确性证明"><a href="#程序正确性证明" class="headerlink" title="程序正确性证明"></a>程序正确性证明</h3><ul>
<li>基于等式或者推导的方式进行数学证明</li>
<li>程序结构作为指导</li>
</ul>
<blockquote>
<p>为什么要进行程序正确性证明？</p>
<p>传统程序编写地是否正确性依靠分支测试，根据条件分支输入不同的数据检验是否正确？延伸出来很多自动化测试工具，黑盒测试、白盒测试和覆盖度测试。</p>
<p>函数式编程程序正确性证明是代码完成后用严格的数学推导证明对所有可能输入都产生正确结果。</p>
</blockquote>
<h2 id="归纳法"><a href="#归纳法" class="headerlink" title="归纳法"></a>归纳法</h2><h3 id="简单归纳法"><a href="#简单归纳法" class="headerlink" title="简单归纳法"></a>简单归纳法</h3><ul>
<li><strong>适用于涉及自然数的递归函数</strong><ul>
<li>参数为非负整数</li>
<li>f(x)的递归调用形如f(y),且size(y)&#x3D;size(x)-1</li>
</ul>
</li>
</ul>
<h3 id="完全归纳法"><a href="#完全归纳法" class="headerlink" title="完全归纳法"></a>完全归纳法</h3><p>证明对所有非负整数n，P(n)都成立</p>
<p>将P(k)简化为k个子问题： P(0), P(1), … , P(k-1)，且它们均成立时，可以利用{P(0), P(1), … , P(k-1)}推导出P(k)也成立</p>
<blockquote>
<p>如：P(0)成立</p>
<p>​    P(1)可由P(0)推导出来</p>
<p>​    P(2)可由P(0)， P(1)推导出来</p>
<p>​     P(3)可由P(0)， P(1)， P(2)推导出来</p>
<p>​    ……  </p>
<p>​    P(k)可由P(0), P(1), … , P(k-1)推导出来</p>
</blockquote>
<ul>
<li><strong>适用于涉及自然数的递归函数</strong><ul>
<li>参数为非负整数</li>
<li>f(x)的递归调用形如f(y),且size(y)&lt;size(x)</li>
</ul>
</li>
</ul>
<h3 id="结构归纳法"><a href="#结构归纳法" class="headerlink" title="结构归纳法"></a>结构归纳法</h3><p>基本情形： P([ ])</p>
<p>归纳步骤：对具有类型t的所有元素y和t list类型的数ys，都有P(ys)成立时， P(y::ys)成立</p>
<p>  ∀ i &lt; k, P(i)成立的条件下有P(k)</p>
<ul>
<li><strong>适用于涉及表和树的递归函数</strong></li>
</ul>
<h3 id="良基归纳法"><a href="#良基归纳法" class="headerlink" title="良基归纳法"></a>良基归纳法</h3><p>关系≺是良基的：</p>
<p>  不存在无穷降序链：…≺Xn≺…≺X2≺X1,</p>
<p>  <strong>对所有y’≺y</strong>，有P(y)，则P(y’)成立</p>
<ul>
<li><strong>可以处理广泛的可终止计算问题</strong></li>
</ul>
<h2 id="近似运行时间（近似时间复杂度）"><a href="#近似运行时间（近似时间复杂度）" class="headerlink" title="近似运行时间（近似时间复杂度）"></a>近似运行时间（近似时间复杂度）</h2><ul>
<li><p>反映基于大批量数据的程序运行性能</p>
<ul>
<li><p>假设基本操作为常量执行时间(Assume basic ops take <em>constant</em> time)</p>
</li>
<li><p>用Ο记号表示算法的时间性能(Give big-O classification)</p>
</li>
</ul>
</li>
<li><p>求解步骤：</p>
<ul>
<li>1.找出算法中的<strong>基本语句</strong>：算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体</li>
<li>2.<strong>计算基本语句的执行次数的数量级</strong>：忽略所有低次幂和最高次幂的系数，保证基本语句执行次数的函数中的最高次幂正确</li>
<li>3.用Ο记号表示算法的时间性能：将基本语句执行次数的数量级放入Ο记号中。</li>
</ul>
</li>
</ul>
<h2 id="递归分析"><a href="#递归分析" class="headerlink" title="递归分析"></a>递归分析</h2><p>递归函数的定义给出了程序的递推关系，执行情况用<em>work</em>表示</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/03/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">函数式编程概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-22 19:56:50" itemprop="dateCreated datePublished" datetime="2020-03-22T19:56:50Z">2020-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">函数式编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="functional-programming"><a href="#functional-programming" class="headerlink" title="functional programming"></a>functional programming</h1><h2 id="函数式语言的特点"><a href="#函数式语言的特点" class="headerlink" title="函数式语言的特点"></a>函数式语言的特点</h2><ul>
<li><p><strong>不依赖于冯·诺伊曼体系结构的计算机</strong></p>
</li>
<li><p><strong>函数是”第一等公民”</strong></p>
<blockquote>
<p>所谓<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/First-class_function">“第一等公民”</a>（first class），指的是<strong>函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</strong></p>
</blockquote>
</li>
<li><p><strong>只用”表达式”，不用”语句”</strong></p>
<blockquote>
<p>“表达式”（expression）是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，<strong>每一步都是单纯的运算，而且都有返回值。</strong></p>
<p>原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I&#x2F;O）。”语句”属于对系统的读写操作，所以就被排斥在外。</p>
<p>当然，实际应用中，不做I&#x2F;O是不可能的。因此，编程过程中，函数式编程只要求把I&#x2F;O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。</p>
</blockquote>
</li>
<li><p><strong>没有”副作用”</strong></p>
<blockquote>
<p>所谓<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Side_effect_(computer_science)">“副作用”</a>（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。</p>
<p>函数式编程强调没有”副作用”，意味着<strong>函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</strong></p>
</blockquote>
</li>
<li><p><strong>不修改状态</strong></p>
<blockquote>
<p>上一点已经提到，函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。</p>
<p>在其他类型的语言中，变量往往用来保存”状态”（state）。不修改变量，意味着状态不能保存在变量中。<strong>函数式编程使用参数保存状态，最好的例子就是递归</strong>。</p>
<p>由于使用了递归，函数式语言的运行速度比较慢。</p>
<p>【递归的速度慢，一般都是将递归写成尾递归，然后编译器进行优化，将尾递归转化成迭代】</p>
</blockquote>
</li>
<li><p><strong>引用透明（referential transparency）</strong></p>
<blockquote>
<p>引用透明（Referential transparency），指的是<strong>函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。</strong></p>
<p>有了前面的第三点和第四点，这点是很显然的。其他类型的语言，函数的返回值往往与系统状态有关，不同的状态之下，返回值是不一样的。这就叫”引用不透明”，很不利于观察和理解程序的行为。</p>
</blockquote>
</li>
<li><p><strong>确定性（determinism）</strong></p>
<blockquote>
<p>所谓确定性的意思就是像数学那样 f(x) &#x3D; y ，这个函数无论在什么场景下，都会得到同样的结果，这个我们称之为函数的确定性。而不是像程序中的很多函数那样，同一个参数，却会在不同的场景下计算出不同的结果。所谓不同的场景的意思就是我们的函数会根据一些运行中的状态信息的不同而发生变化。</p>
</blockquote>
</li>
<li><p><strong>惰性求值（延迟计算）与并行</strong></p>
<blockquote>
<p>惰性求值：</p>
<p>这个需要编译器的支持。<strong>表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。</strong>也就是说，当调用函数时，不是盲目的计算所有实参的值后再进入函数体，而是先进入函数体，只有当需要实参值时才计算所需的实参值（<strong>按需调用</strong>）</p>
</blockquote>
</li>
<li><p><strong>递归调用及其优化</strong></p>
<blockquote>
<p>就是使用尾递归进行优化</p>
</blockquote>
</li>
</ul>
<h2 id="函数式语言的优点"><a href="#函数式语言的优点" class="headerlink" title="函数式语言的优点"></a>函数式语言的优点</h2><ol>
<li><p>代码简洁，开发快速</p>
<p>其实这条是比较好理解的，函数式的编程使用了大量的函数，减少了代码的重复。</p>
</li>
<li><p>易于理解</p>
</li>
<li><p>方便代码管理</p>
<p>函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。因此，每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和除错（debugging），以及模块化组合。</p>
</li>
<li><p><strong>易于“并发编程”</strong></p>
<p><strong>函数式编程不需要考虑”死锁”（deadlock），因为它不修改变量，所以根本不存在”锁”线程的问题。</strong>不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署”并发编程”（concurrency）。</p>
</li>
<li><p><strong>可以进行代码的热升级</strong></p>
<p><strong>函数式编程没有副作用，只要保证接口不变，内部实现是外部无关的。所以，可以在运行状态下直接升级代码，不需要重启，也不需要停机。</strong></p>
</li>
</ol>
<h2 id="函数式编程的几个技术"><a href="#函数式编程的几个技术" class="headerlink" title="函数式编程的几个技术"></a>函数式编程的几个技术</h2><ol>
<li><p><strong>map&amp;reduce</strong></p>
</li>
<li><p><strong>pipeline</strong></p>
</li>
<li><p><strong>recursing递归</strong></p>
</li>
<li><p><strong>currying</strong></p>
</li>
<li><p><strong>higher-order function高阶函数</strong></p>
<blockquote>
<p>所谓高阶函数就是函数当参数，把传入的函数做一个封装，然后返回这个封装函数。现象上就是函数传进传出，就像面向对象对象满天飞一样。</p>
</blockquote>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.byvoid.com/zhs/blog/why-functional-programming">参考文章</a></p>
<p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/10822.html">参考文章</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/03/22/Algorithm-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/22/Algorithm-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/" class="post-title-link" itemprop="url">Algorithm_双指针法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-21 23:41:10" itemprop="dateCreated datePublished" datetime="2020-03-21T23:41:10Z">2020-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h1><p>双指针法可以分成两个部分：<strong>快慢指针，左右指针</strong>。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。</p>
<p> (注：这里的指针，并非专指c中指针的概念，而是指索引，游标或指针，可迭代对象等)</p>
<h2 id="快慢指针常见算法"><a href="#快慢指针常见算法" class="headerlink" title="快慢指针常见算法"></a>快慢指针常见算法</h2><h2 id="左右指针常见算法"><a href="#左右指针常见算法" class="headerlink" title="左右指针常见算法"></a>左右指针常见算法</h2><p>左右指针在数组中实际是指两个索引值，一般初始化为 left &#x3D; 0, right &#x3D; nums.length - 1 。</p>
<p>一般我们会对数组进行排序，然后在进行比较时，通过移动指针来找到解。</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>两个指针的算法都是很基础的，也是很简单的，通常只要取一头一尾进行移动比较即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/">Leetcode：167——两数之和II-输入有序数组</a></p>
<p>题目描述：在有序数组中找出两个数，使它们的和为 target。</p>
<p>在进行数组元素相加后比较之类的问题，都可以采取双指针方式进行求解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> []output = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span>(right&lt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[right]+numbers[left]==target)&#123;</span><br><span class="line">                output[<span class="number">0</span>]=right+<span class="number">1</span>;</span><br><span class="line">                output[<span class="number">1</span>]=left+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[right]+numbers[left]&lt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两数平方和"><a href="#两数平方和" class="headerlink" title="两数平方和"></a>两数平方和</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-square-numbers/description/?utm_source=LCUS&utm_medium=ip_redirect_q_uns&utm_campaign=transfer2china">Leetcode：633——平方数之和</a></p>
<p>题目描述：给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2^ + b^2^ &#x3D; c。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judgeSquareSum</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>,left =(<span class="type">int</span>)Math.sqrt(c);</span><br><span class="line">        <span class="keyword">while</span>(right&lt;=left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Math.pow(right,<span class="number">2</span>)+Math.pow(left,<span class="number">2</span>)==c)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(Math.pow(right,<span class="number">2</span>)+Math.pow(left,<span class="number">2</span>)&lt;c)</span><br><span class="line">            &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/4sum/submissions/">Leetcode：18</a></p>
<p>左右指针：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="literal">null</span>||nums.length&lt;<span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> length=nums.length;</span><br><span class="line">        <span class="comment">//一个指向最小的值，一个指向最大的值</span></span><br><span class="line">        <span class="type">int</span> head,tail;</span><br><span class="line">        <span class="type">int</span> left,right;</span><br><span class="line">        <span class="keyword">for</span>(head=<span class="number">0</span>;head&lt;length-<span class="number">3</span>;head++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//在有相同的数的前提下，移动到最右边的数</span></span><br><span class="line">            <span class="keyword">if</span>(head&gt;<span class="number">0</span>&amp;&amp;nums[head]==nums[head-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//如果当前可以取得的最小值比目标值大的话，直接退出。</span></span><br><span class="line">            <span class="type">int</span> min=nums[head]+nums[head+<span class="number">1</span>]+nums[head+<span class="number">2</span>]+nums[head+<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span>(min&gt;target)<span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//如果当前取得的最大值比目标值小的话，将head往后移动</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[head]+nums[length-<span class="number">1</span>]+nums[length-<span class="number">2</span>]+nums[length-<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span>(max&lt;target)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(left=head+<span class="number">1</span>;left&lt;length-<span class="number">2</span>;left++)</span><br><span class="line">            &#123;</span><br><span class="line">                tail = length-<span class="number">1</span>;</span><br><span class="line">                right = left+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(left&gt;head+<span class="number">1</span>&amp;&amp;nums[left-<span class="number">1</span>]==nums[left])<span class="keyword">continue</span>;</span><br><span class="line">                min = nums[head]+nums[left]+nums[left+<span class="number">1</span>]+nums[left+<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span>(min&gt;target)<span class="keyword">continue</span>;</span><br><span class="line">                max = nums[head]+nums[left]+nums[tail-<span class="number">1</span>]+nums[tail];</span><br><span class="line">                <span class="keyword">if</span>(max&lt;target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(right&lt;tail)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">all</span> <span class="operator">=</span> nums[head]+nums[left]+nums[right]+nums[tail];</span><br><span class="line">                    <span class="keyword">if</span>(all==target)</span><br><span class="line">                    &#123;</span><br><span class="line">                        result.add(Arrays.asList(nums[head],nums[left],nums[right],nums[tail]));</span><br><span class="line">                        right++;</span><br><span class="line">                    <span class="keyword">while</span>(right&gt;left&amp;&amp;right&lt;tail&amp;&amp;nums[right-<span class="number">1</span>]==nums[right])</span><br><span class="line">                    &#123;</span><br><span class="line">                        right++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tail--;</span><br><span class="line">                    <span class="keyword">while</span>(tail&gt;left&amp;&amp;nums[tail]==nums[tail+<span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        tail--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(all&gt;target)</span><br><span class="line">                    &#123;</span><br><span class="line">                        tail--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(all&lt;target)</span><br><span class="line">                    &#123;</span><br><span class="line">                        right++;</span><br><span class="line">                    &#125;</span><br><span class="line">                 </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rhb</p>
  <div class="site-description" itemprop="description">纵浪大化中，不喜亦不惧</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">154</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RShawshank" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RShawshank" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rhb</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://lib.baomitu.com/canvas-nest.js/1.0.1/canvas-nest.js"></script>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
