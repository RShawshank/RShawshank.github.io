<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rshawshank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="纵浪大化中，不喜亦不惧">
<meta property="og:type" content="website">
<meta property="og:title" content="rhb_blog">
<meta property="og:url" content="http://rshawshank.github.io/page/10/index.html">
<meta property="og:site_name" content="rhb_blog">
<meta property="og:description" content="纵浪大化中，不喜亦不惧">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rhb">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rshawshank.github.io/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>rhb_blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rhb_blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">rao的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">64</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">28</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">160</span></a>

  </li>
        <li class="menu-item menu-item-photos">

    <a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
        <li class="menu-item menu-item-readnote">

    <a href="/readnote" rel="section"><i class="fa fa-book fa-fw"></i>阅读笔记</a>

  </li>
        <li class="menu-item menu-item-somethink">

    <a href="/somethink/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>随笔闲谈</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/RShawshank" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">数据库_数据库设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-04 19:13:08" itemprop="dateCreated datePublished" datetime="2020-06-04T19:13:08Z">2020-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库设计概述"><a href="#数据库设计概述" class="headerlink" title="数据库设计概述"></a>数据库设计概述</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>反复性：反复设计、逐步求精</li>
<li>多解性：设计结果不唯一，多种方案并存</li>
<li>分步进行：数据库设计分为多个阶段</li>
<li>结构设计与行为设计相结合<ul>
<li>面向数据的设计方法（以信息需求为主）</li>
<li>面向过程的设计方法（以处理需求为主）</li>
</ul>
</li>
</ul>
<h2 id="数据库设计方法"><a href="#数据库设计方法" class="headerlink" title="数据库设计方法"></a>数据库设计方法</h2><ul>
<li>直观设计法（手工试凑法）</li>
<li>规范设计法<ul>
<li>新奥尔良法：运用软件工程的思想和方法进行数据库设计</li>
<li>基于E-R模型的设计法：先用E-R图构造企业模式，然后转换为特的那个数据库模式</li>
<li>基于3NF的设计法：确定数据库模式中的全部属性和属性间的依赖关系，将它们组织在一个单一的关系模式中，然后再分解成若干个3NF关系模式的集合</li>
<li>基于视图的设计法：先为每个应用建立视图，再将这些视图合并为全局概念模式</li>
</ul>
</li>
<li>计算机辅助设计法：<ul>
<li>以人的知识或经验为主导，通过人机交互方式实现设计中的某些部分</li>
</ul>
</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20200604195650588.png"></p>
<h1 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h1><h2 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h2><p>1、语义表达能力丰富</p>
<p>2、易于理解和交流</p>
<p>3、易于修改和扩充</p>
<p>4、易于向各种数据模型转换</p>
<p>可以使用E-R模型、UML、ODL</p>
<p>E-R模型的基本观点：现实世界是由实体和实体间的联系构成的。</p>
<ul>
<li><p>实体：客观存在并且可以相互区分的物体。</p>
</li>
<li><p>实体集：具有相同类型、相同属性的实体集合 。</p>
</li>
<li><p>属性：实体集中每个成员具有的描述性性质。</p>
<ul>
<li>原子属性——不可再分的属性</li>
<li>复合属性——由多个原子属性构成，如：生日（年、月、日）</li>
<li>多值属性——多个同类原子&#x2F;复合属性值，如：买家有多个收货地址</li>
</ul>
</li>
<li><p>域：属性的取值范围。</p>
</li>
<li><p>码：能唯一标识实体集的属性或属性组，称为超码。而最小的超码（就是任意真子集都不能称为超码的超码）称为候选码。从候选码中选出一个来区别同一实体集中的不同实体称为主码（比如学生实体集中的学号）。主码在E-R图中用_____表示。</p>
</li>
<li><p>联系：实体之间相互的关联，如学生和老师的授课关系，同类联系的集合称为联系集。</p>
</li>
<li><p>元或度：参与联系的实体集的个数称为元。参与联系的实体集的主码的集合形成了联系集的超码。</p>
</li>
<li><p>参与：实体集之间的关联称为参与，实体参与联系。如学生选修课程，学生和课程参与了联系选修。</p>
<p>E中所有实体均参与R称为E全部参与R（用实体集合联系间的双线表示），否则称为E部分参与R。</p>
</li>
<li><p>映射基数：实体之间的联系数量，即一个实体通过一份联系集能与另一实体集相关联的实体数目。</p>
<ul>
<li><p>一对一</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20190627104254145.png"></p>
<p>注意箭头：带箭头的表示1</p>
</li>
<li><p>一对多</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/2019062710455293.png"></p>
<p>不带箭头的线段表示n</p>
</li>
<li><p>多对多</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20190627104836953.png"></p>
</li>
</ul>
</li>
</ul>
<h2 id="E-R模型的表示方法"><a href="#E-R模型的表示方法" class="headerlink" title="E-R模型的表示方法"></a>E-R模型的表示方法</h2><p>总结来说，E-R图的四个组成的部分</p>
<p>1、<strong>矩形框</strong>:表示<strong>实体</strong>，在矩形框中写上实体的名字</p>
<p>2、<strong>椭圆形框</strong>:表示实体或联系的<strong>属性</strong></p>
<p>3、<strong>菱形框</strong>:表示<strong>联系，</strong>在框中记入联系名</p>
<p>4、连线:实体与属性之间;实体与联系之间;联系与属性之间用直线相连，(对于一对一联系，要在两个实体连线方向各写1; 对于一对多联系，要在一的一方写1，多的一方写N;对于多对多关系，则要在两个实体连线方向各写N,M。)。<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/132158066981840.png"></p>
<h2 id="E-R模型的设计原则"><a href="#E-R模型的设计原则" class="headerlink" title="E-R模型的设计原则"></a>E-R模型的设计原则</h2><ul>
<li><strong>避免冗余</strong>，避免浪费空间和操作异常。</li>
<li>一般情况下，凡是可以作为属性对待的，应该尽量作为属性</li>
<li>作为实体对待，应该满足如下条件中的一个：<ul>
<li>该实体具有除码以为的其他属性</li>
<li>该实体是某个一对多或多对多联系的”多“端</li>
</ul>
</li>
</ul>
<h1 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h1><h2 id="概念结构设计的方法与步骤"><a href="#概念结构设计的方法与步骤" class="headerlink" title="概念结构设计的方法与步骤"></a>概念结构设计的方法与步骤</h2><ul>
<li><p>设计概念结构的E-R模型可采用四种方法</p>
<ul>
<li>自顶向下</li>
<li>自底向上</li>
<li>逐步扩张</li>
<li>混合策略</li>
</ul>
</li>
<li><p>最常用的方法是自底向上设计法，包含两个步骤：</p>
<ul>
<li>设计局部E-R模型，即设计用户视图</li>
<li>集成各局部E-R模型，形成全局E-R模型</li>
</ul>
</li>
</ul>
<h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h3><p>设计局部E-R模型</p>
<h3 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h3><p>1、合并局部E-R图，消除冲突，生成初步E-R图</p>
<h4 id="属性冲突"><a href="#属性冲突" class="headerlink" title="属性冲突"></a>属性冲突</h4><ul>
<li>属性域冲突——属性值的类型、取值范围或是取值集合不同</li>
<li>属性取值单位冲突</li>
</ul>
<p>属性冲突属于用户业务上的约定，必须与用户协商后解决</p>
<h4 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h4><ul>
<li>同名异义</li>
<li>异名同义</li>
</ul>
<p>命名冲突的解决方式同属性冲突</p>
<h4 id="结构冲突"><a href="#结构冲突" class="headerlink" title="结构冲突"></a>结构冲突</h4><ul>
<li>同一对象在不同应用中有不同的抽象</li>
<li>同一实体在不同应用中属性组成不同</li>
<li>同一联系在不同应用中呈现不同的类型</li>
</ul>
<p>2、消除不必要的冗余，生成基本的E-R图</p>
<ul>
<li><p>冗余包括冗余的数据和冗余的联系</p>
<ul>
<li>冗余的数据是指可由基本数据导出的数据</li>
<li>冗余的联系是指可由其他联系导出的联系</li>
</ul>
</li>
<li><p>通常采用分析的方法消除冗余。依据为数据字典和数据流图。</p>
</li>
</ul>
<h1 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h1><h2 id="任务和步骤"><a href="#任务和步骤" class="headerlink" title="任务和步骤"></a>任务和步骤</h2><ul>
<li>数据库逻辑设计的任务是将概念结构转换成特定DBMS所支持的数据模型</li>
<li>步骤<ul>
<li>初始化关系模式设计</li>
<li>关系模式优化</li>
<li>设计子模式</li>
</ul>
</li>
</ul>
<h2 id="步骤一：初始关系模式设计"><a href="#步骤一：初始关系模式设计" class="headerlink" title="步骤一：初始关系模式设计"></a>步骤一：初始关系模式设计</h2><p>1、E-R图向关系模型转换</p>
<ul>
<li>实体的转换<ul>
<li>一个实体转换为一个关系</li>
<li>关系的属性就是该实体的属性</li>
<li>关系的码就是该实体的码</li>
</ul>
</li>
<li>联系的转换<ul>
<li>一个联系转换为一个关系</li>
<li>关系的属性：与该联系相连的各实体的码和该联系自身的属性</li>
<li>关系的码<ul>
<li>一对一的二元联系：两端实体的码都是候选码</li>
<li>一对多的二元联系：”多“端实体的码</li>
<li>多对多的二元联系：至少包含两端实体的码的并集</li>
<li>存在”一“端的多元联系：除了一端以外的其他实体的码的并集</li>
<li>不存在一端的多元联系：至少包含所有相关尸体的码的并集</li>
</ul>
</li>
<li>关系的外码：对于每个与联系相连的实体，建立与该实体关系的外码约束</li>
</ul>
</li>
</ul>
<p>1对多或者多对1的联系可以被合并到1端实体对应的关系中</p>
<h2 id="步骤二：关系模式优化"><a href="#步骤二：关系模式优化" class="headerlink" title="步骤二：关系模式优化"></a>步骤二：关系模式优化</h2><ul>
<li>进行规范化，消除关系模式中存在的各种异常，改善完整性、一致性和存储效率</li>
<li>进行反规范化设计，是为了提高查询效率</li>
</ul>
<h3 id="垂直分解"><a href="#垂直分解" class="headerlink" title="垂直分解"></a>垂直分解</h3><p>把关系模式的属性分解为若干个子集</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20200604213654671.png"></p>
<h3 id="水平分解"><a href="#水平分解" class="headerlink" title="水平分解"></a>水平分解</h3><p>把关系中的元组分解为若干个子集</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20200604213640636.png"></p>
<h2 id="步骤三：设计子模式"><a href="#步骤三：设计子模式" class="headerlink" title="步骤三：设计子模式"></a>步骤三：设计子模式</h2><p>制导思想：注重局部用户的要求</p>
<p>具体方法：</p>
<ul>
<li>使用更符合用户习惯的别名、计量单位等</li>
<li>从安全性出发，对不同级别的用户定义不同的视图</li>
<li>从易用性触发，将复杂查询语句定义为视图</li>
</ul>
<h1 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>对于给定的逻辑模型，设计一个最合适应用要求的物理结构</p>
<p>约束条件：</p>
<ul>
<li>应用需求（响应时间、吞吐率、存储空间利用率、安全）</li>
<li>应用特征（数据量、事务频率、涉及的关系和属性）</li>
<li>具体DBMS产品的特点（存取方法，存储结构，参数）</li>
<li>存储设备特性</li>
</ul>
<p>设计内容：</p>
<ul>
<li>设计存取方法</li>
<li>设计存储方案</li>
<li>确定系统配置参数</li>
</ul>
<h2 id="设计存取方法"><a href="#设计存取方法" class="headerlink" title="设计存取方法"></a>设计存取方法</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tfstone/article/details/81197921">参考文章</a></p>
<ul>
<li>索引</li>
<li>聚簇</li>
</ul>
<p>聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>是与基表的属性组相关的数据对象，能够提供对基表数据的快速访问。</p>
<p>同一个基表上可键多个索引，执行查询语句，DBMS自动选择合适的索引访问数据</p>
<p>当表中的数据更新时，DBMS自动更新索引</p>
<p>数据越多，索引的优势越明显</p>
<p>索引可以提高查询效率，但是增加了空间开销以及维护的代价</p>
<h4 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h4><blockquote>
<p><strong>B-Tree介绍</strong></p>
<p>B-Tree是一种多路搜索树（并不是二叉的）：<br>    1.定义任意非叶子结点最多只有M个儿子；且M&gt;2；<br>    2.根结点的儿子数为[2, M]；<br>    3.除根结点以外的非叶子结点的儿子数为[M&#x2F;2, M]；<br>    4.每个结点存放至少M&#x2F;2-1（取上整）和至多M-1个关键字；（至少2个关键字）<br>    5.非叶子结点的关键字个数&#x3D;指向儿子的指针个数-1；<br>    6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；<br>    7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；<br>    8.所有叶子结点位于同一层；<br>    如：（M&#x3D;3）</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/4.JPG"><br>B-树的特性：<br>    1.关键字集合分布在整颗树中；<br>    2.<strong>任何一个关键字出现且只出现在一个结点中</strong>；<br>    3.搜索有可能在非叶子结点结束；<br>    4.其搜索性能等价于在关键字全集内做一次二分查找；<br>    5.自动层次控制；</p>
<p>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；</p>
</blockquote>
<p>B+树是B-树的变体，也是一种多路搜索树：</p>
<p>​    1.其定义基本与B-树同，除了：</p>
<p>​    2.非叶子结点的子树指针与关键字个数相同；</p>
<p>​    3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；</p>
<p>​    5.为所有叶子结点增加一个链指针；</p>
<p>​    6.所有关键字都在叶子结点出现；</p>
<p>​    如：（M&#x3D;3）</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/5.JPG"></p>
<p>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p>
<p>​    B+的特性：</p>
<p>​    1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</p>
<p>​    2.不可能在非叶子结点命中；</p>
<p>​    3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</p>
<p>​    4.更适合文件索引系统；</p>
<p>适用范围广：</p>
<ul>
<li>等值查询</li>
<li>范围查询</li>
<li>聚集函数计算</li>
<li>排序</li>
<li>遍历</li>
</ul>
<h4 id="hash索引"><a href="#hash索引" class="headerlink" title="hash索引"></a>hash索引</h4><p>适用于：</p>
<ul>
<li>等值查询</li>
<li>等值连接</li>
</ul>
<p>不适用于：</p>
<ul>
<li>范围查询</li>
<li>排序</li>
<li>模糊</li>
</ul>
<h3 id="聚簇"><a href="#聚簇" class="headerlink" title="聚簇"></a>聚簇</h3><p>为了提高查询速度，把在某个属性组上具有相同值的元组集中地存放在<strong>相邻</strong>的物理块中。该属性组称为聚簇码。</p>
<ul>
<li>单表聚簇：将单个表的数据按聚簇码分组有序的存储</li>
<li>多表聚簇：把多个表的数据按聚簇码集中存储在一起</li>
</ul>
<h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><ul>
<li>一个表最多只能属于一个聚簇</li>
<li>聚簇维护的开销很大</li>
<li>频繁更新的属性不适合作为聚簇码</li>
<li>单表聚簇：最常用于等值比较的属性，且该属性上的重复取值较多</li>
<li>多表聚簇：经常进行连接操作的表可以建立聚簇</li>
</ul>
<h2 id="设计存储方案"><a href="#设计存储方案" class="headerlink" title="设计存储方案"></a>设计存储方案</h2><ul>
<li>确定数据的存放位置：<ul>
<li>将表和索引分别存放在不同的磁盘上</li>
<li>将日志文件和数据库对象放在不同的磁盘上</li>
<li>将数据库的备份文件存放在磁盘上</li>
</ul>
</li>
<li>对空间效率要求较高的应用，考虑压缩存储</li>
<li>对安全需求较高的应用，考虑加密存储</li>
</ul>
<h2 id="确定系统配置参数"><a href="#确定系统配置参数" class="headerlink" title="确定系统配置参数"></a>确定系统配置参数</h2><p>根据应用特点和运行环境重新配置系统配置参数：</p>
<ul>
<li>最大连接数</li>
<li>内存配置参数（查询缓存、日志缓存、数据缓存······）受总的物理内存大小的约束，参数之间相关制约</li>
<li>存储配置参数（数据文件的大小、日志文件的大小、物理块大小、物理块装填因子）</li>
<li>其他</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/06/04/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/04/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/" class="post-title-link" itemprop="url">数据库_关系数据理论概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-04 11:12:57" itemprop="dateCreated datePublished" datetime="2020-06-04T11:12:57Z">2020-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="关系数据理论概述"><a href="#关系数据理论概述" class="headerlink" title="关系数据理论概述"></a>关系数据理论概述</h1><p>数据库逻辑结构设计的任务：为数据库应用构造良好的数据库模式</p>
<h1 id="关系模式中的异常问题"><a href="#关系模式中的异常问题" class="headerlink" title="关系模式中的异常问题"></a>关系模式中的异常问题</h1><ul>
<li>数据冗余</li>
<li>更新异常</li>
<li>插入异常</li>
<li>删除异常</li>
</ul>
<p>出现异常的原因：</p>
<p>关系模式中存在不合适的数据依赖</p>
<p>解决方式：</p>
<p>通过分解，消除不合适的数据依赖（规范化）</p>
<h1 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h1><h2 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h2><p>一个关系模式可以表示为一个五元组R(U,D,DOM,F)；</p>
<ul>
<li>R：关系名称</li>
<li>U：R中所有属性的集合</li>
<li>D：U中属性所来自的域的集合、</li>
<li>DOM：属性到域的映射</li>
<li>F：U中属性间的数据依赖的集合</li>
</ul>
<p>模式涉及重点关注U和F</p>
<h2 id="数据依赖"><a href="#数据依赖" class="headerlink" title="数据依赖"></a>数据依赖</h2><p>是一个关系中的属性之间的某种语义约束关系</p>
<p>知道A可以确切的找到B，这样的函数叫做函数依赖。其实就是单值函数</p>
<h3 id="函数依赖-1"><a href="#函数依赖-1" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>分类一：</p>
<ul>
<li>平凡函数依赖：任何情况下都成立<br>例如：在一个职工关系中,职工号总能函数决定它本身,记作“职工号→职工号”,对于任一个给定的职工号,都有它本身的职工号值唯一对应,此为平凡函数依赖。又如:职工号和性别构成的属性子集总是能够函数决定其中的职工号或性别属性,可分别记作为“(职工号,性别)→职工号”和“(职工号,性别)→性别”,因为对于任何给定的一个元组中的职工号和性别的组合值,都唯一对应一个职工号值或性别值,不可能出现其他的职工号值或性别值,此种也为平凡函数依赖。</li>
<li>非平凡函数依赖<br>如在职工关系中,职工号函数决定其他每个属性都是非平凡函数依赖,另外“(职工号,姓名)→性别”也是非平凡函数依赖,虽然在这里由决定因素中所含的职工号单属性就能够函数决定性别,而带有的姓名属性有些多余。</li>
</ul>
<p>分类二：</p>
<ul>
<li><p>完全函数依赖：记作是f</p>
<p>设R（U）是属性集U上的关系，x、y是U的子集，x’是x的真子集。若对于R（U）的任何一个可能的关系，有x→y但x’→y，则称y完全函数依赖于x，记作X→^F^Y。<br>  所谓完全依赖是说明在依赖关系的决定项（即依赖关系的左项）中没有多余属性，有多余属性就是部分依赖。</p>
</li>
<li><p>部分函数依赖：记作是p</p>
<p> 设R（U）是属性集U上的关系，x、y是U的子集，x’是x的真子集，若x→y且x’→y，则称y部分依赖x，记作X→^P^Y。显然，当且仅当x为复合属性组时，才有可能出现部分函数依赖。 </p>
<p>例如：职工号	姓名	性别	年龄	职务<br>         1001	张三	   男	    36	正处<br>         1002	李四	   男	    38	副处<br>         1003	王五	   男	    50	正科<br>         1004	赵六	   女	    38	副处<br>         1005	孙七	   女	    49	科员<br>职工号和其他的属性之间的函数依赖都是完全函数依赖。因为职工号是一个单属性决定因素，他不可能在包含其他任何属性，那么就不存在真子集函数决定其他每个属性的情况存在，如（职工号，性别）的值虽然能够决定相应职工的年龄，但其中的真子集“职工号”就能够函数决定其年龄，所以（职工号，性别）到年龄之间的函数为部分函数依赖（因为只通过“职工号”就可以决定）。（简单的说：真子集可以决定结果）</p>
<p>假设存在：“学号→系号”、“系号→系名”和“系号→系主任名”<br>那么存在：“学号→系名”和“学号→系主任名”这两个函数依赖是传递函数依赖。</p>
</li>
</ul>
<p>分类三：</p>
<ul>
<li><p>传递函数依赖</p>
<p>一个关系R（U），X,Y,Z为属性集U上的子集，其中存在X→Y和Y→Z，但Y不决定X，同时Y不包含Z，则存在X→Z，即X传递函数决定Z，Z传递函数依赖于X。</p>
</li>
</ul>
<h2 id="有关码的术语"><a href="#有关码的术语" class="headerlink" title="有关码的术语"></a>有关码的术语</h2><p>码：一个关系的所有属性</p>
<ul>
<li>码为单个属性，称为单属性码</li>
<li>码为多个属性，称为多属性码</li>
<li>码为全部属性，称为全码</li>
<li>包含一个码的属性组，称为超码。</li>
<li>包含在任何一个码中的属性，称为主属性</li>
<li>不包含在任何一个码中的属性，称为非主属性</li>
</ul>
<blockquote>
<p><strong>候选码：</strong> 唯一标识一个关系的属性组<br><strong>主码：</strong> 候选码多于一个，从候选码中选出的一个码作为主码。<br><strong>主属性：</strong> 候选码的所有属性。<br><strong>非主属性：</strong> 不包含在任何候选码中的属性<br><strong>全码：</strong> 极端情况下，整个属性组都是码。<br><strong>外码：</strong> X不是该关系模式的码，但是X是另一个关系模式的码。比如(Sno,Cno,Grade)中的Sno不是码，但Sno是(Sno,Sname,Sage)的码，则Sno是外码</p>
</blockquote>
<h1 id="1NF、2NF、3NF和BCNF"><a href="#1NF、2NF、3NF和BCNF" class="headerlink" title="1NF、2NF、3NF和BCNF"></a>1NF、2NF、3NF和BCNF</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jsj13263690918/article/details/79796275">参考文章</a></p>
<h2 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h2><p>是为了减少数据冗余和消除各种异常。</p>
<p>范式：满足规范化要求的关系模式</p>
<p>范式分类：</p>
<ul>
<li>第一范式：满足最基本的规范化要求的关系模式</li>
<li>第二范式：在第一范式的基础上，进一步满足一些要求</li>
<li>依次类推：第三范式、BC范式、第四范式等</li>
</ul>
<h3 id="第一范式（1NF）：无重复列"><a href="#第一范式（1NF）：无重复列" class="headerlink" title="第一范式（1NF）：无重复列"></a>第一范式（1NF）：无重复列</h3><p><strong>1NF的定义为：符合1NF的关系中的每个属性都不可再分。</strong></p>
<p>第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。</p>
<p>　　说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/image-20200602233716629.png" style="zoom:80%;" />

<p>问题：可能会出现：数据冗余、更新异常、插入异常、删除异常</p>
<h3 id="第二范式（2NF）：属性完全依赖于主键【消除部分子函数依赖】"><a href="#第二范式（2NF）：属性完全依赖于主键【消除部分子函数依赖】" class="headerlink" title="第二范式（2NF）：属性完全依赖于主键【消除部分子函数依赖】"></a>第二范式（2NF）：属性完全依赖于主键【消除部分子函数依赖】</h3><p>满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）<strong>要求数据库表中的每个实例或行必须可以被唯一地区分</strong>。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是唯一的，因此每个员工可以被唯一区分。这个唯一属性列被称为主关键字或主键、主码。</p>
<p>　　第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，<strong>第二范式就是属性完全依赖于主键。</strong></p>
<p>比如给出一个表：<br>$$<br>(Sno,Sdept,Sloc,Cno,Grade)<br>$$<br>其中Sno学号，Sdept是系，Sloc是寝室地址，Cno是课程号，Grade是该学生某个课程的成绩。<br>$$<br>(Sno,Cno)\stackrel{F}{\longrightarrow}Grade\Sno→Sdept, (Sno,Cno)\stackrel{P}{\longrightarrow}Sdept\<br>    Sno→Sloc, (Sno,Cno)\stackrel{P}{\longrightarrow} Sloc<br>$$<br>那么上述存在了部分函数依赖，需要把部分函数依赖的进行消除：<br>$$<br>Sno→Sdept \<br>Sno→Sloc<br>$$<br>因此得出新的关系模式：<br>$$<br>(Sno,Sloc,Sdept)\<br>(Sno,Cno,Grade)<br>$$<br>判断的方法是：</p>
<p>第一步：找出数据表中所有的<strong>码</strong>。<br>第二步：根据第一步所得到的码，找出所有的<strong>主属性</strong>。<br>第三步：数据表中，除去所有的主属性，剩下的就都是<strong>非主属性</strong>了。<br>第四步：查看是否存在非主属性对码的<strong>部分函数依赖</strong>。</p>
<p>问题：可能会出现：数据冗余、更新异常、插入异常、删除异常</p>
<p>结论：<strong>对码的传递依赖不友好</strong></p>
<h3 id="第三范式（3NF）属性不依赖于其它非主属性-消除传递依赖"><a href="#第三范式（3NF）属性不依赖于其它非主属性-消除传递依赖" class="headerlink" title="第三范式（3NF）属性不依赖于其它非主属性[消除传递依赖]"></a>第三范式（3NF）属性不依赖于其它非主属性[消除传递依赖]</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43371004/article/details/88970261">https://blog.csdn.net/qq_43371004/article/details/88970261</a></p>
<p><strong>第三范式（3NF）</strong> <strong>3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖</strong>。</p>
<p>第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。</p>
<p>例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。</p>
<p>结论：<strong>主属性对码的不良函数依赖也会导致异常</strong></p>
<h3 id="BC范式（BCNF）消除主属性对于码的部分与传递函数依赖"><a href="#BC范式（BCNF）消除主属性对于码的部分与传递函数依赖" class="headerlink" title="BC范式（BCNF）消除主属性对于码的部分与传递函数依赖"></a>BC范式（BCNF）消除主属性对于码的部分与传递函数依赖</h3><ol>
<li>所有非主属性对每一个码都是完全函数依赖；</li>
<li>所有的主属性对每一个不包含它的码，也是完全函数依赖；</li>
<li>没有任何属性完全函数依赖于非码的任何一组属性。</li>
</ol>
<h1 id="多值依赖和4NF"><a href="#多值依赖和4NF" class="headerlink" title="多值依赖和4NF"></a>多值依赖和4NF</h1><h2 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h2><p>多值依赖： 设R(U)是属性集U上的一个关系模式，X,Y,Z是U的子集，且Z&#x3D;U−X−Y。当且仅当R(U)的任一关系r，给定的一对(x,y)值，有一组Y的值，这组值仅仅取决于X的值而与Z的值无关，则成R(U)中的多值依赖$X\rightarrow   \rightarrow Y$成立。</p>
<p><strong>判定方法：对于任意关系中，如果存在两个元组（就是行），记为A,B，如果他们的某一属性X的值相等，那么我们交换它们另外的属性Y的值后，得到的新的两个元组，在表中是可以在原来的表中找到与它们相匹配的元组的。</strong></p>
<p>平凡多值依赖： 若$X \rightarrow \rightarrow Y$，而$Z&#x3D;\empty$，则称$X\rightarrow \rightarrow Y$为平凡多值依赖。</p>
<p>非平凡多值依赖：若$X \rightarrow \rightarrow Y$，而$Z\neq\empty$，则称$X\rightarrow \rightarrow Y$为非平凡多值依赖。</p>
<h3 id="多值依赖的性质"><a href="#多值依赖的性质" class="headerlink" title="多值依赖的性质"></a>多值依赖的性质</h3><p>（1）多值依赖具有对称性</p>
<p>若X→→Y，则X→→Z，其中Z＝U－X－Y</p>
<p>（2）多值依赖具有传递性</p>
<p>若X→→Y，Y→→Z， 则X→→Z –Y</p>
<p>（3）函数依赖是多值依赖的特殊情况。</p>
<p>若X→Y，则X→→Y。</p>
<p>（4）若X→→Y，X→→Z，则X→→YU Z。</p>
<p>（5）若X→→Y，X→→Z，则X→→Y∩Z。</p>
<p>（6）若X→→Y，X→→Z，则X→→Y-Z，X→→Z -Y。</p>
<h3 id="多值依赖和函数依赖的对比"><a href="#多值依赖和函数依赖的对比" class="headerlink" title="多值依赖和函数依赖的对比"></a>多值依赖和函数依赖的对比</h3><p>1）若函数依赖X→Y在R（U）上成立，则对于任何Y’ 属于Y均有X→Y’ 成立</p>
<p>2）多值依赖X→→Y若在R(U)上成立，不能断言对于任何Y’ 属于Y有X→→Y’ 成立，因为多值依赖中，其实就是一对一组，一个老师可能交多门课，所以不同老师可能有教相同的课，所以不能推出X→→Y’ 成立。我们可以看出，如果把一组改为一个，实际上就是函数依赖，所以所<strong>函数依赖是多值依赖的特例</strong>，多值依赖不一定是函数依赖，但函数依赖一定是多值依赖。</p>
<h2 id="4NF"><a href="#4NF" class="headerlink" title="4NF"></a>4NF</h2><p>关系模式$R&lt;U,F&gt;\in 1NF$，如果对于R的每个非平凡多值依赖$X\rightarrow \rightarrow Y(Y \nsubseteq X)$，X都含有码，则$R&lt;U,F&gt;\in 4NF$。</p>
<p><strong>1）不允许有非平凡且非函数依赖的多值依赖</strong> </p>
<p><strong>2）允许的非平凡多值依赖是函数依赖</strong></p>
<p><strong>3）平凡的多值依赖属于第四范式</strong></p>
<h2 id="关系规范化小结"><a href="#关系规范化小结" class="headerlink" title="关系规范化小结"></a>关系规范化小结</h2><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/image-20200603163427186.png" style="zoom:80%;" />

<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/image-20200603163453406.png"></p>
<h1 id="ArmStrong公理系统"><a href="#ArmStrong公理系统" class="headerlink" title="ArmStrong公理系统"></a>ArmStrong公理系统</h1><h2 id="逻辑蕴涵和闭包"><a href="#逻辑蕴涵和闭包" class="headerlink" title="逻辑蕴涵和闭包"></a>逻辑蕴涵和闭包</h2><p>函数依赖:</p>
<p>属性集 α 决定属性集 β ,则称有函数依赖 α→β</p>
<p>逻辑蕴含:</p>
<p>F能推出原不直观存在于函数依赖集F 中的函数依赖 α → β,则成α→β被函数依赖集F逻辑蕴含</p>
<p>函数依赖的闭包 F^+^:</p>
<p>由关系模式R直观得到的函数依赖F所推出的所有隐含的或未隐含的(直观的)函数依赖的集合<br>举例:</p>
<blockquote>
<p>F中有α–&gt;β,β–&gt;ω<br>则函数闭包F^+^中存在α–&gt;ω</p>
</blockquote>
<p>若F&#x3D;F^+^，则称F是函数依赖的完备集</p>
<p>理论上，如果能求出F的闭包，就能求出R的所有码</p>
<h2 id="Armstrong公理系统"><a href="#Armstrong公理系统" class="headerlink" title="Armstrong公理系统"></a>Armstrong公理系统</h2><p>设关系模式R&lt;U,F&gt;，其中U为属性集，F是U上的一组函数依赖，Y,X,Z⊆U那么有如下推理规则：</p>
<ol>
<li>自反律(叫大推小更确切):<br>$若Y⊆X⊆U，则X→Y$ </li>
<li>增广律(加了也不影响)<br> $若X-&gt;Y,则XZ–&gt;YZ$ </li>
<li>传递律(一传十十传百)<br>$X-&gt;Y,Y-&gt;Z,则X-&gt;Z$</li>
</ol>
<h2 id="Armstrong公理的推论"><a href="#Armstrong公理的推论" class="headerlink" title="Armstrong公理的推论"></a>Armstrong公理的推论</h2><ul>
<li><p>合并规则（合并右边）：<br>$X-&gt;Y,X-&gt;Y,则X-&gt;YZ$</p>
</li>
<li><p>分解规则（分解右边）：<br>$X-&gt;YZ,则X-&gt;Y,X-&gt;Z$</p>
</li>
<li><p>伪传递规则（左边加一点）：<br>$X-&gt;Y,YW-&gt;Z则XW-&gt;Z$</p>
</li>
</ul>
<p>引理：$X→A_1A_2…A_k成立的充分必要条件是X→A_i成立(i&#x3D;1,2,…,k)。$</p>
<h2 id="Armstrong公理系统的证明"><a href="#Armstrong公理系统的证明" class="headerlink" title="Armstrong公理系统的证明"></a>Armstrong公理系统的证明</h2><p>1、自反律：若Y,X⊆U，则X→Y为F所蕴含<br>证明:</p>
<blockquote>
<p>设Y⊆X⊆U。<br>对R&lt;U,F&gt;的任一关系r中的任意两个元组t,s：<br>若t[X]&#x3D;s[X]，由于Y X，则有t[Y]&#x3D;s[Y]，所以X→Y成立，自反律得证。</p>
</blockquote>
<p>2、增广律：若X→Y为F所蕴含，且Z U，则XZ→YZ为F所蕴含<br>证明:</p>
<blockquote>
<p>设X→Y为F所蕴含，且Z⊆U。<br>对R&lt;U,F&gt;的任一关系r中的任意两个元组t,s：<br>若t[XZ]&#x3D;s[XZ]，由于X ⊆XZ，Z⊆ XZ，根据自反律，则有t[X]&#x3D;s[X]和t[Z]&#x3D;s[Z]；<br>由于X→Y，于是t[Y]&#x3D;s[Y]，所以t[YZ]&#x3D;s[YZ]；所以XZ→YZ成立，增广律得证。</p>
</blockquote>
<p>3、传递律：若X→Y，Y→Z为F所蕴含，则X→Z为F所蕴含<br>证明：</p>
<blockquote>
<p>设X→Y及Y→Z为F所蕴含。<br>对R&lt;U,F&gt;的任一关系r中的任意两个元组t,s：<br>若t[X]&#x3D;s[X]，由于X→Y，有t[Y]&#x3D;s[Y]；<br>再由于Y→Z，有t[Z]&#x3D;s[Z]，所以X→Z为F所蕴含，传递律得证。</p>
</blockquote>
<p>4、合并规则：若X→Y，X→Z，则X→YZ为F所蕴含<br>证明：</p>
<blockquote>
<p>因X→Y ，所以X→XY （增广律 XX→XY即X→XY）<br>因X→Z ，所以XY→YZ （增广律）<br>因X→XY，XY→YZ<br>故X→YZ （传递律）</p>
</blockquote>
<p>5、伪传递规则：若X→Y，WY→Z，则XW→Z为F所蕴含</p>
<p>证明：</p>
<blockquote>
<p>因X→Y ，所以WX→WY （增广律）<br>因WY→Z ，所以XW→Z （传递律）</p>
</blockquote>
<p>6、分解规则：若X→Y，Z∈Y，则X→Z为F所蕴含</p>
<p>证明：</p>
<blockquote>
<p>因Z∈Y 　所以Y→Z （自反律）<br>因X→Y 所以X→Z （传递律）</p>
</blockquote>
<h1 id="属性闭包"><a href="#属性闭包" class="headerlink" title="属性闭包"></a>属性闭包</h1><p>在关系模式R所对应的F^+^中,有α→β ,则所有β组成的集合α<del>F</del>^+^ 叫做属性集α关于F的属性闭包</p>
<p>属性闭包算法:</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">result</span>=A<span class="comment"> //此处A是一个属性集,result就是要计算的属性闭包</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> α<span class="comment">--&gt;β in F:</span></span><br><span class="line">    <span class="keyword">if</span> α <span class="keyword">in</span> <span class="built_in">result</span>:  <span class="comment"> //α已经在属性闭包里了,即A--&gt;α是成立的</span></span><br><span class="line">    <span class="built_in">result</span>=<span class="built_in">result</span>+β  <span class="comment"> //增加属性闭包</span></span><br></pre></td></tr></table></figure>

<h2 id="正则覆盖-F"><a href="#正则覆盖-F" class="headerlink" title="正则覆盖 F^+^"></a>正则覆盖 F^+^</h2><p> 将原函数依赖集F中的函数依赖α–&gt;β中的部分(α或β属性中)冗余属性删除。F^+^ 和 F 的函数依赖的闭包是相同的</p>
<p>属性是否冗余判断条件,对于α–&gt;β函数依赖(哪边冗余F在哪边)</p>
<p>1、α属性集中有属性A是冗余的,$(α−A)→β$成立:<br>        F 逻辑蕴含 $(F−(α→β))∪((α−A)→β)$</p>
<p>2、β属性集中有属性b是冗余的,$α→(β−b)$成立<br>      $(F−(α→β))∪(α→(β−b))$ 逻辑蕴含 F</p>
<h2 id="无损分解"><a href="#无损分解" class="headerlink" title="无损分解"></a>无损分解</h2><p>将关系模式R分解成 关系模式R<del>1</del>和R<del>2</del>,则:</p>
<p>$R_1∩R_2→R_1或R_2$ ;即$R_1$和$R_2$的交集是R<del>1</del>或R<del>2</del>的super key</p>
<h1 id="最小函数依赖集"><a href="#最小函数依赖集" class="headerlink" title="最小函数依赖集"></a>最小函数依赖集</h1><h2 id="函数依赖集的等价"><a href="#函数依赖集的等价" class="headerlink" title="函数依赖集的等价"></a>函数依赖集的等价</h2><p>定义：设F和G是关系模式R的两个函数依赖集，如果F^+^&#x3D;G^+^,则称F和G等价。也称F是G的覆盖，或G是F的覆盖。</p>
<p>定理：设F和G是R的两个函数依赖集，则F和G等价的充要条件是F⊆G^+^且G⊆F^+^.</p>
<p>问题：给定两个函数依赖集G和F，判断F和G是否等价？</p>
<blockquote>
<p>方法：</p>
<p>1、对于F中的每个函数依赖X-&gt;Y,求X<del>G</del>^+^，若都有Y⊆X<del>G</del>^+^，则说明F⊆X<del>G</del>^+^</p>
<p>2、对于G中的每个函数依赖X-&gt;Y,求X<del>F</del>^+^，若都有Y⊆X<del>F</del>^+^，则说明G⊆X<del>F</del>^+^</p>
</blockquote>
<h2 id="最小函数依赖集（最小覆盖）"><a href="#最小函数依赖集（最小覆盖）" class="headerlink" title="最小函数依赖集（最小覆盖）"></a>最小函数依赖集（最小覆盖）</h2><p>1、定义：</p>
<p>如果函数依赖集F满足以下条件，则称F为一个极小函数依赖集。也称为最小依赖集或最小覆盖。</p>
<p>(1)F中任一函数依赖的右部仅含有一个属性（右部都是单属性）。</p>
<p>(2)F中不存在这样的函数依赖X→A，使得F与F-{X→A}等价（没有多余的依赖）。</p>
<p>(3)F中不存在这样的函数依赖X→A，X有真子集Z使得(F-{X→A})U{Z→A}与F等价（左部不存在多余属性）。</p>
<h2 id="最小依赖集通用算法"><a href="#最小依赖集通用算法" class="headerlink" title="最小依赖集通用算法"></a>最小依赖集通用算法</h2><p>① 用分解的法则，使F中的任何一个函数依赖的右部仅含有一个属性；</p>
<p>② 去掉多余的函数依赖：从第一个函数依赖X→Y开始将其从F中去掉，然后在剩下的函数依赖中求X的闭包X+，看X+是否包含Y，若是，则去掉X→Y；否则不能去掉，依次做下去。直到找不到冗余的函数依赖；</p>
<p>③ 去掉各依赖左部多余的属性。一个一个地检查函数依赖左部非单个属性的依赖。例如XY→A，若要判Y为多余的，则以X→A代替XY→A是否等价？若A属于(X)+，则Y是多余属性，可以去掉。（以上步骤中，求出关系依赖集F,此时，再F的基础上，求出X或者Y的闭包，是否包含A）</p>
<p>反复执行步骤2、3，直至F不再变化</p>
<p>注意：最小函数依赖集不是唯一的。</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/image-20200604170542264.png" style="zoom:80%;" />

<h1 id="模式分解概述"><a href="#模式分解概述" class="headerlink" title="模式分解概述"></a>模式分解概述</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sumaliqinghua/article/details/86246762?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">参考文章</a></p>
<p>当模式不符合关系范式时，需要进行模式分解。</p>
<h2 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h2><h2 id="函数依赖的投影"><a href="#函数依赖的投影" class="headerlink" title="函数依赖的投影"></a>函数依赖的投影</h2><h2 id="投影的计算方法"><a href="#投影的计算方法" class="headerlink" title="投影的计算方法"></a>投影的计算方法</h2><h1 id="分解正确性检验"><a href="#分解正确性检验" class="headerlink" title="分解正确性检验"></a>分解正确性检验</h1><h2 id="无损连接性"><a href="#无损连接性" class="headerlink" title="无损连接性"></a>无损连接性</h2><p>分解所得到的各个关系模式，经过自然连接可以还原成被分解的关系模式。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/image-20200604171832489.png"></p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zxcoder/p/11963759.html">参考文章</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangyige/p/6786047.html">参考</a></p>
<ul>
<li>对于一个分解，有k个子集，n个属性，建立一张k行n列的初始表，对于每一行也就是分解的每个子集，把该分解子集出现的属性对应的列写上a<del>j</del>，否则写上b<del>ij</del></li>
<li>对于每一个依赖，找到左部属性对应的列，根据行的值分组，对于行的值相同的这些行，查看对应右部属性的列，如果这些格子里有a值，那把所有这些格子改成a值，如果没有，改成行最小的b值。<strong>如果某个b值改成a值，那么其他行(不属于当前操作的行)的相同b值也要改成a值</strong>。</li>
<li>如果不变则停止，如果出现有一行为a<del>1</del> a<del>2</del> … a<del>n</del>，那么说明该连接为无损连接。</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/image-20200604171909544.png"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/image-20200604171943983.png"></p>
<h2 id="依赖保持性"><a href="#依赖保持性" class="headerlink" title="依赖保持性"></a>依赖保持性</h2><p>分解所得到的各个关系模式上的函数依赖集的并集，与被分解关系模式原有的函数依赖集等价。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/image-20200604171932832.png"></p>
<h1 id="模式分解算法"><a href="#模式分解算法" class="headerlink" title="模式分解算法"></a>模式分解算法</h1><h2 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h2><ul>
<li>无损连接法：可保证分解达到BCNF</li>
<li>无损连接法+依赖保持法：可保证分解达到3NF</li>
<li>依赖保持性：可保证分解达到3NF</li>
</ul>
<h2 id="3NF和保持函数依赖的分解"><a href="#3NF和保持函数依赖的分解" class="headerlink" title="3NF和保持函数依赖的分解"></a>3NF和保持函数依赖的分解</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><ul>
<li>F&#x3D;F的最小依赖集</li>
<li>U<del>0</del>&#x3D;{不在F出现的属性}</li>
<li>U&#x3D;U-U<del>0</del></li>
<li>若F中有函数依赖X-&gt;A，使得XA&#x3D;U，那么分解就是R本身</li>
<li>如果没有，将剩下的F按左部分组，得到U<del>i</del>，分解就是{R<del>1</del>&lt;U<del>1</del>,F<del>1</del>&gt;，…} ∪ R<del>0</del>&lt;U<del>0</del>,F<del>0</del>&gt;</li>
</ul>
<h2 id="3NF和保持函数依赖和具有无损连接性的分解"><a href="#3NF和保持函数依赖和具有无损连接性的分解" class="headerlink" title="3NF和保持函数依赖和具有无损连接性的分解"></a>3NF和保持函数依赖和具有无损连接性的分解</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><ul>
<li>求出3NF和保持函数依赖的分解。</li>
<li>X是R的码，让已有的分解∪上一个{R^∗^&lt;X,F<del>X</del>&gt;}。</li>
<li>如果分解中有某个U<del>i</del>属于X，那么删掉该U<del>i</del>，如果X属于某个U<del>i</del>，那么删掉。</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/image-20200604184803328.png"></p>
<h2 id="BCNF和具有无损连接性的分解"><a href="#BCNF和具有无损连接性的分解" class="headerlink" title="BCNF和具有无损连接性的分解"></a>BCNF和具有无损连接性的分解</h2><h3 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h3><ul>
<li>类似递归的方法，首先判断自身是不是BC范式，如果是，无需分解。</li>
<li>否则，找到当前关系R的主码，找到一个左边不含主码的依赖X-&gt;A，设U<del>1</del>&#x3D;A，分解出去，**剩下的U<del>2</del>&#x3D;U-{A}**作为一个关系模式，继续重复上面的步骤。</li>
<li>根据X-&gt;A的选择的不同，得到的分解也是不同。</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/image-20200604184820756.png"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/image-20200604184837656.png"></p>
<h2 id="4NF和具有无损连接性的分解"><a href="#4NF和具有无损连接性的分解" class="headerlink" title="4NF和具有无损连接性的分解"></a>4NF和具有无损连接性的分解</h2><h3 id="算法-4"><a href="#算法-4" class="headerlink" title="算法"></a>算法</h3><ul>
<li>求出BCNF和具有无损连接性的分解。</li>
<li>对于一个关系R&lt;U,F&gt;，如果多值依赖X–&gt;Y成立，则分解{R1&lt;X,Y&gt;,R2&lt;X,Z&gt;)}具有无损连接性，其中Z&#x3D;U-X-Y。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">数据库_数据库恢复技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-03 11:14:02" itemprop="dateCreated datePublished" datetime="2020-06-03T11:14:02Z">2020-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="事务的基本概念"><a href="#事务的基本概念" class="headerlink" title="事务的基本概念"></a>事务的基本概念</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wzhao-cn/p/11557698.html">参考文章</a></p>
<p>事务（trancaction）：用户定义的一个数据库操作序列，该序列构成一个独立的、不可分割的逻辑处理任务。<strong>要么全做，要么全不做。</strong></p>
<p>一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包含有以下两个目的：</p>
<blockquote>
<p>1、为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。<br>2、当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</p>
</blockquote>
<h2 id="事务的组成"><a href="#事务的组成" class="headerlink" title="事务的组成"></a>事务的组成</h2><p>1、一条SQL语句</p>
<p>2、一组SQL语句序列</p>
<h2 id="事务的描述方式"><a href="#事务的描述方式" class="headerlink" title="事务的描述方式"></a>事务的描述方式</h2><h3 id="显式"><a href="#显式" class="headerlink" title="显式"></a>显式</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION</span><br><span class="line">	update...</span><br><span class="line">	insert...</span><br><span class="line"><span class="keyword">COMMIT</span> 或者<span class="keyword">ROLLBACK</span></span><br></pre></td></tr></table></figure>

<p>其中：</p>
<p>COMMIT：提交。事务对数据库的所有修改操作写回到磁盘上的数据库文件中。</p>
<p>ROLLBACK：回滚。撤销所有已实施的对数据库的修改，数据库回滚到事务开始状态。</p>
<h3 id="隐式"><a href="#隐式" class="headerlink" title="隐式"></a>隐式</h3><p>一条SQL语句，例如execDirect（）。</p>
<p>程序隐式定义，例如会话结束、程序对象关闭时其中隐藏的COMMIT&#x2F;ROLLBACK。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/image-20200603165222252.png"></p>
<h2 id="事务的ACID性质"><a href="#事务的ACID性质" class="headerlink" title="事务的ACID性质"></a>事务的ACID性质</h2><p>并非任意的对数据库的操作序列都是数据库事务。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。</p>
<h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>定义：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</p>
<p>目标：保证数据库中数据的正确性</p>
<p>技术：</p>
<ul>
<li>日志+COMMIT&#x2F;ROLLBACK（UNDO）；</li>
<li>并发控制（交叉执行）。</li>
</ul>
<h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>定义：事务应确保数据库（DB）的状态从一个一致（正确）状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</p>
<p>目标：保证数据库中数据的正确性（有效、相容，防止对数据的更新结果被丢失、读到无效的数据、读到不一致的数据）。</p>
<p>技术：</p>
<ul>
<li>并发控制（保护临界资源）</li>
</ul>
<h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>定义：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</p>
<p>目标：防止事务之间由于相互干扰而出现并发错误、链式夭折。</p>
<p>技术</p>
<ul>
<li>并发控制</li>
</ul>
<blockquote>
<p><strong>原子性与隔离行</strong></p>
<p>一致性与原子性是密切相关的,原子性的破坏可能导致数据库的不一致，数据的一致性问题并不都和原子性有关。<br>比如刚刚的例子，在第五步的时候，对B账户做加法时只加了50元。那么该过程可以符合原子性，但是数据的一致性就出现了问题。</p>
<p>因此，事务的原子性与一致性缺一不可。</p>
</blockquote>
<h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>定义：一个事务一旦提交，他对数据库的修改应该<strong>永久保存</strong>在数据库中。</p>
<p>目标：保证数据库的可靠性</p>
<p>技术：</p>
<p>（事务终止前应完成commit）</p>
<ul>
<li>提交的持久化（内存是挥发性存储装置，外存是非挥发性存储装置）。</li>
<li>备份+日志。（外存）</li>
</ul>
<h1 id="数据库系统故障分类"><a href="#数据库系统故障分类" class="headerlink" title="数据库系统故障分类"></a>数据库系统故障分类</h1><h2 id="数据库系统故障种类"><a href="#数据库系统故障种类" class="headerlink" title="数据库系统故障种类"></a>数据库系统故障种类</h2><ul>
<li>事务故障</li>
<li>系统故障</li>
<li>介质故障</li>
<li>计算机病毒</li>
</ul>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/image-20200603171227161.png" style="zoom:80%;" />

<h3 id="事务故障"><a href="#事务故障" class="headerlink" title="事务故障"></a>事务故障</h3><p>1、表现形式：</p>
<ul>
<li>应用处理异常<ul>
<li>可能产生自程序预留的异常情况的应对方案。</li>
<li>可能来自于非预期的、不能由应用程序处理的故障<ul>
<li>断网</li>
<li>应用程序进程僵死</li>
<li>应用程序进行被意外杀死</li>
<li>应用程序端电脑死机、断电</li>
</ul>
</li>
</ul>
</li>
<li>系统异常<ul>
<li>事务超时、死锁、活锁等【为避免过久占用资源、DBMS系统按照事先设定的系统参数强行终止事务。】</li>
</ul>
</li>
</ul>
<p>2、特征：</p>
<ol>
<li>特定的事务没有到达预期的终点（COMMIT），事务夭折；</li>
<li>夭折事务对数据库的部分修改可能已写入数据文件。<br>（数据库可能因此处于不正确、不一致状态）</li>
</ol>
<h3 id="系统故障"><a href="#系统故障" class="headerlink" title="系统故障"></a>系统故障</h3><p>1、表现形式</p>
<ul>
<li>某些类型的硬件故障<ul>
<li>CPU、内存、主板。。。<br>【服务器上的硬件，其故障影响到DBMS系统的正常运行，但不涉及外存储设备】</li>
</ul>
</li>
<li>系统软件故障<ul>
<li>DBMS：ORACLE、SQL SERVER、MYSQL、DB2。。。</li>
<li>OS：UNIX、WINDOWS、LINUX。。。</li>
<li>死机、蓝屏、意外重启、某系统功能意外退出</li>
<li>服务器上的系统软件，其故障影响到DBMS系统的正常运行，但不涉及外存储设备。</li>
</ul>
</li>
<li>系统操作失误<ul>
<li>非正常关机\重启、强行终止系统进程、意外卸载相关系统运行环境。。。</li>
</ul>
</li>
<li>系统异常断电<ul>
<li>重启之后系统未发现数据库的存储文件错误或者磁盘错误。</li>
</ul>
</li>
</ul>
<p>2、特征</p>
<ul>
<li>内存数据丢失或不再可靠</li>
<li>外存数据未受到破坏</li>
<li>一些尚未完成事务的更新结果可能已写入数据库存储介质</li>
<li>已完成事务的更新结果可能部分还未写入数据库（数据文件，也可能正处于提交过程中）</li>
<li>已完成事务的结果可能全部未写入数据库（例如正在等待检查点）<br>数据库的数据存储介质依旧可靠，但是数据处于不正确或不一致状态</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/image-20200603202249629.png"></p>
<h3 id="介质故障"><a href="#介质故障" class="headerlink" title="介质故障"></a>介质故障</h3><p>1、表现形式</p>
<ul>
<li>磁盘故障<ul>
<li>磁盘损坏（磁道、扇区、分区、文件分配信息）</li>
<li>磁盘读写装置损坏（磁头、电机）</li>
</ul>
</li>
<li>外界干扰<ul>
<li>强磁场干扰（磁性数据被清洗），灾害</li>
</ul>
</li>
</ul>
<p>2、特征</p>
<p>硬故障，外存中数据的部分或全部丢失，数据相关存储文件本身异常。<br>（目前比较成熟的DBMS软件一般能够在服务启动时校验存储介质上的数据文件是否异常）</p>
<h3 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h3><p>1、表现形式</p>
<ul>
<li>消耗资源<ul>
<li>内存、磁盘、网络端口，破坏系统的正常运行</li>
</ul>
</li>
<li>泄露信息<ul>
<li>系统信息、数据库信息</li>
</ul>
</li>
<li>篡改数据</li>
<li>篡改程序<ul>
<li>植入木马、埋下隐患</li>
</ul>
</li>
</ul>
<p>2、特征</p>
<p>计算机病毒是一种人为造成的技术故障或破坏，含有非法或者恶意企图，在执行某个功能时启动病毒代码，可能造成对数据库系统的危害</p>
<p>系统不再可靠、可信</p>
<h3 id="各类故障对数据库的影响"><a href="#各类故障对数据库的影响" class="headerlink" title="各类故障对数据库的影响"></a>各类故障对数据库的影响</h3><ul>
<li><p>数据本身被破坏</p>
<p>需要去寻找可用的数据，重建数据库状态</p>
</li>
<li><p>数据可能不正确（事务的运行被恶意干扰或非正常终止）<br>需要截至系统的容错机制，恢复数据的正确性</p>
<p>不同的故障影响的范围不同，采取的恢复策略也不同<br>自动、人工启动、借助外部资源</p>
</li>
</ul>
<p>恢复的基本原理：冗余</p>
<h1 id="数据库备份和日志"><a href="#数据库备份和日志" class="headerlink" title="数据库备份和日志"></a>数据库备份和日志</h1><h2 id="数据转储"><a href="#数据转储" class="headerlink" title="数据转储"></a>数据转储</h2><p>一般由数据库管理员制定计划，定期的将数据库内容复制到磁带、磁盘或者其他存储介质上保存起来，成为后备副本或后援副本。</p>
<p>转储需要考虑的问题：耗费时间和资源，不宜频繁进行。</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/1962436-20200309193857188-954650598.png" style="zoom:80%;" />

<h3 id="转储状态"><a href="#转储状态" class="headerlink" title="转储状态"></a>转储状态</h3><h4 id="静态转储"><a href="#静态转储" class="headerlink" title="静态转储"></a>静态转储</h4><p>数据库系统中无事务运行时进行转储。</p>
<p>①特征：转储期间不对数据库进行任何联机事务操作。一定得到一个数据一致性付本。</p>
<p>②优点——简单</p>
<p>③ 缺点：停止一切事务运行；降低数据库的可用性</p>
<h4 id="动态转储"><a href="#动态转储" class="headerlink" title="动态转储"></a>动态转储</h4><p>转储与事务同时（并发）执行。</p>
<p>①特征：转储期间可对数据库进行读写操作。</p>
<p>②优点：不用等待正在运行的事务结束，也不影响新事务的运行。</p>
<p>③缺点：获得一致性副本比较麻烦。<br>解决思路：把转储期间各事务对数据库的修改活动登记下来——日志文件</p>
<h3 id="转储方式"><a href="#转储方式" class="headerlink" title="转储方式"></a>转储方式</h3><h4 id="海量备份"><a href="#海量备份" class="headerlink" title="海量备份"></a>海量备份</h4><p>① 方法：将数据库的全部数据转储。</p>
<p>② 优点：简单——备份简单，恢复简单</p>
<p>③ 缺点：重复执行全部数据的转储动作<br>                                        转储量大；<br>                                        停止运行（多为静态转储）。</p>
<h4 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h4><p>① 方法：每次转储上次转储后更新过的数据。</p>
<p>② 优点：备份量小。</p>
<p>③ 缺点：恢复过程相对复杂。</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/image-20200603204933157.png" style="zoom:80%;" />

<h2 id="登记日志文件"><a href="#登记日志文件" class="headerlink" title="登记日志文件"></a>登记日志文件</h2><p>在数据库系统中，数据文件也是一种设备，里面的数据是资源，也有类似的需求，相应的有日志文件及其维护机制。</p>
<p>日志——数据库恢复子系统“自己的数据”。</p>
<h3 id="日志文件及其类型"><a href="#日志文件及其类型" class="headerlink" title="日志文件及其类型"></a>日志文件及其类型</h3><h4 id="日志文件的概念"><a href="#日志文件的概念" class="headerlink" title="日志文件的概念"></a>日志文件的概念</h4><p>记录事务对数据库的更新操作的文件称之为日志文件。</p>
<h4 id="日志文件类型"><a href="#日志文件类型" class="headerlink" title="日志文件类型"></a>日志文件类型</h4><p>①记录为单位的日志文件</p>
<p>②数据块为单位的日志文件</p>
<h4 id="以记录为单位的日志文件内容"><a href="#以记录为单位的日志文件内容" class="headerlink" title="以记录为单位的日志文件内容"></a>以记录为单位的日志文件内容</h4><p>①事务开始标记（一个日志记录，Begin Transaction）；</p>
<p>②事务结束标记（一个日志记录，Commit，或者Rollback）；</p>
<p>③每个事务的所有更新操作（每个操作一个日志记录）。</p>
<p>每个日志记录内容：</p>
<p>1）事务标识（TRID）；<br>2）操作类型；<br>3）操作对象；<br>4）更新前数据旧值；<br>5）更新后数据新值。</p>
<h4 id="以数据块为单位的日志文件内容"><a href="#以数据块为单位的日志文件内容" class="headerlink" title="以数据块为单位的日志文件内容"></a>以数据块为单位的日志文件内容</h4><p>事务标识+数据块</p>
<p>①数据块（整块）更新前内容；</p>
<p>②数据块更新后内容。</p>
<h3 id="日志文件的作用"><a href="#日志文件的作用" class="headerlink" title="日志文件的作用"></a>日志文件的作用</h3><p>1）事务恢复<br>2）数据库故障恢复<br>3）系统分析</p>
<h3 id="日志文件的登记"><a href="#日志文件的登记" class="headerlink" title="日志文件的登记"></a>日志文件的登记</h3><p>为保证数据库的恢复能正确进行，日志文件的登记必须遵循两条原则：<br>1）按事务操作执行时间顺序登记日志（多个事务操作并发）<br>如实记录数据库的状态变化过程，从而保障恢复时能按照逻辑顺序定位到相应的状态。</p>
<p>2）须先写日志文件，后写数据库文件！！！！！<br>（先写日志协议——WAL）</p>
<p>日志包含了状态变化过程的与事务相关的完整信息，数据块则未必。因此，恢复的依据必须首先是日志。若先写数据文件之后日志文件因故障未能写出，则无法判断相关数据块在恢复时应该采取的动作。</p>
<h1 id="故障恢复策略"><a href="#故障恢复策略" class="headerlink" title="故障恢复策略"></a>故障恢复策略</h1><p>事务故障恢复：UNDO</p>
<p>系统故障恢复：REDO+UNDO</p>
<p>介质故障恢复：装入后备副本+REDO</p>
<h2 id="恢复的背景需求"><a href="#恢复的背景需求" class="headerlink" title="恢复的背景需求"></a>恢复的背景需求</h2><p>1）文件管理系统和数据库管理系统都有备份与恢复技术</p>
<p>文件管理系统<br>Ghost、副本文件、操作系统补丁更新时的备份、平台提供的备份软件（例如：手机和电脑数据云备份）</p>
<p>数据库管理系统<br>转储备份+日志、镜像、逻辑备份（数据导出）</p>
<p>2）恢复的需求存在差异</p>
<p>文件管理系统<br>恢复到某个版本或某个时间点、恢复某个文件集合【数据的正确性一般由应用程序或人工判断】</p>
<p>数据库管理系统<br>以数据库为单位，恢复到某个时刻的数据库正确状态【数据的正确性由DBMS判断】</p>
<p>3）数据库恢复的任务</p>
<p>将因破坏或故障而导致的数据库数据的错误状态恢复到最近一个正确状态。</p>
<p>4）目标</p>
<p>①保持事务原子性（Atomicity）<br>②保持事务持久性（Durability）</p>
<p>5）恢复的数据基础</p>
<p>当前可用的数据文件——当前可看到的正确以及错误的数据<br>转储的数据文件——转储时可以看到的正确以及错误的数据<br>日志——用于分析可看到的数据的错误以及看不到的正确数据</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/image-20200603212521281.png" style="zoom:80%;" />

<h2 id="事务故障的恢复【事务在运行至正常终点前被终止】"><a href="#事务故障的恢复【事务在运行至正常终点前被终止】" class="headerlink" title="事务故障的恢复【事务在运行至正常终点前被终止】"></a>事务故障的恢复【事务在运行至正常终点前被终止】</h2><p>——因各种异常或错误导致事务未执行完而夭折时的恢复。</p>
<p>此时，数据库管理系统正常运行，数据文件和日志文件均未损坏；可能存在其他并发执行的事务，这些事务不受影响。</p>
<p>1）目标：维护原子性</p>
<p>2）动作特征：执行已有操作的“逆向”操作，称为撤销，或者undo。</p>
<p>3）恢复步骤</p>
<p>① 反向扫描日志文件（从日志文件尾向文件头）：<br>——<strong>查找事务执行过最后一条更新操作记录</strong>；</p>
<p>② 执行上述找到的最后一条日志记录的UNDO操作【插入→删除，删除→插入，修改前的值→修改后】；</p>
<p>③ 循环执行上述扫描及undo操作，直至事务开始标记。</p>
<p>4）执行方式DBMS自动完成</p>
<h2 id="系统故障的恢复【系统终止造成数据库不一致状态】"><a href="#系统故障的恢复【系统终止造成数据库不一致状态】" class="headerlink" title="系统故障的恢复【系统终止造成数据库不一致状态】"></a>系统故障的恢复【系统终止造成数据库不一致状态】</h2><p>——撤消故障发生时未完成事务和重做已完成事务的恢复。</p>
<p>此时，数据文件和日志文件均未损坏，但数据库管理系统出现异常，可能存在多个并发执行的事务，一些已提交事务的日志已写到日志文件，但最新数据却有可能遗留在数据缓冲区。</p>
<p>1）目标：原子性、持久性</p>
<p>2）动作特征：未完成事务已有操作需落实其逆向操作，称为撤销，或者undo；已完成事务需落实其全部操作动作，确保其原子性、持久性，称为“重做”，或者redo。</p>
<p>3）步骤</p>
<p>①正向扫描日志文件（从日志文件头向文件尾）：</p>
<ul>
<li><p>找出故障发生前已提交事务，该事务标识记入REDO队列；<br>【有BEGIN TRANSANCTION和COMMIT的加入REDO队列】</p>
</li>
<li><p>找出故障发生时未完成事务，该事务标识记入UNDO队列；<br>【只有BEGIN TRANSANCTION没有COMMIT的加入UNDO队列】</p>
</li>
</ul>
<p>②执行undo和redo操作</p>
<ul>
<li><p>依照日志记录反向顺序对UNDO队列中事务进行UNDO操作（写入修改前的值）：<br>（反向扫描日志文件，执行队列中事务的undo操作）；</p>
</li>
<li><p>依照日志记录正向顺序对REDO队列中事务进行REDO操作（写入修改后的值）：<br>（正向扫描日志文件，执行队列中事务的redo操作）。</p>
</li>
</ul>
<p>4）执行方式：一般是DBMS重启后自动完成。</p>
<h2 id="介质故障的恢复【需要DBA介入】"><a href="#介质故障的恢复【需要DBA介入】" class="headerlink" title="介质故障的恢复【需要DBA介入】"></a>介质故障的恢复【需要DBA介入】</h2><p>——数据库文件和日志文件被破环时的恢复。</p>
<p>数据库管理系统发现数据文件或日志文件读写异常，系统无法正常运行，并且依靠重启也无法恢复到正确状态。</p>
<p>此时，需要以往转储的后备副本数据，以及相应的日志文件（包括归档日志文件和联机日志文件）。<br>如果联机日志文件损坏，则有可能丢失数据。</p>
<p>1）目标：原子性、持久性</p>
<p>2）动作特征：寻找、装载副本；未完成事务已有操作需落实其逆向操作，undo；已完成事务需落实其全部动作，确保其持久化，redo。</p>
<p>3）恢复步骤</p>
<p>①装入后备数据副本（一般选择最新的转储副本）</p>
<p>②运用与后备数据副本配套的归档日志<br>采用系统故障的恢复方法，通过归档日志中的事务的redo和undo操作，将数据恢复到和转储副本配套的数据库正确状态。</p>
<p>③运用后期的归档日志和联机日志副本<br>依次装入日志文件，正向扫描日志，直至日志文件尾，建立UNDO和REDO队列，按照系统故障的恢复动作，执行两个队列的redo和undo操作。</p>
<p>4）执行方式：人工介入、通过恢复子系统完成。</p>
<h1 id="检查点技术"><a href="#检查点技术" class="headerlink" title="检查点技术"></a>检查点技术</h1><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>利用日志恢复系统故障的过程需要扫描全部的日志记录，进行相关的恢复操作，因而较大的日志文件将带来大量的日志扫描和恢复操作。</p>
<p>Undo——为了确保夭折事务的更新影响不生效，逻辑上可看作一种撤销操作。</p>
<blockquote>
<p>DBMS缓存中的数据会因为内外存交换机制写出到磁盘，不一致的数据必须物理上更新回正确状态，undo恢复是唯一能够执行此类撤销操作的系统机制。</p>
</blockquote>
<p>Redo——为了确保已提交事务的更新的持久性。</p>
<blockquote>
<p>事务提交时它所更新的数据可能仍在缓存中，缓存数据不具备持久化状态，此时，日志的redo功能可以看做其持久性的保障，所以需要先写日志协议。</p>
</blockquote>
<p>如果数据存在不违背先写日志的前提下，及时的被写出到磁盘文件，结果会怎样？</p>
<blockquote>
<p>许多需要redo的事务的数据更新结果（后像数据）已被写入磁盘文件中，对其redo只是重复的将数据再次设置为后像的值，没有必要。</p>
</blockquote>
<p>可以将这一思想用于恢复的优化</p>
<p>优化机制——定期的在不违背先写日志的前提下，将缓存中的数据写出到磁盘文件——检查点（checkpoint）。【周期性、先写日志、缓存写出、记录优化完成】</p>
<p>优化了redo任务，undo的相关开销是否减少？</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/image-20200604013806672.png" style="zoom:80%;" />

<h2 id="检查点机制"><a href="#检查点机制" class="headerlink" title="检查点机制"></a>检查点机制</h2><p>生成检查点的时机——周期性</p>
<p>①时间周期；</p>
<p>②日志记录周期（日志文件写满或者到达一定数量）。</p>
<p>两个“增加”：</p>
<p>（1）在日志中增加一类记录（检查点记录）</p>
<p>​		检查点记录内容：</p>
<p>​			① 建立检查点时刻所有正在执行的（active）事务清单；</p>
<p>​			②上述事务的最早一条日志记录的地址。</p>
<p>（2）增设重新开始文件。<br>            用来记录各个检查点记录在日志文件中的地址。</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/image-20200604013938573.png" style="zoom:80%;" />

<h2 id="检查点动作"><a href="#检查点动作" class="headerlink" title="检查点动作"></a>检查点动作</h2><p>——保存数据库状态，建立检查点。</p>
<p>1）将当前日志缓冲区中的所有日志记录写入磁盘的日志文件；</p>
<p>2）在日志文件中写入一个检查点记录；</p>
<p><strong>3）把当前数据缓冲区的所有数据写入磁盘数据文件；</strong></p>
<p>4）在重新开始文件中记录检查点记录的地址。</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/image-20200604014019727.png" style="zoom:67%;" />

<h2 id="使用检查点的恢复技术"><a href="#使用检查点的恢复技术" class="headerlink" title="使用检查点的恢复技术"></a>使用检查点的恢复技术</h2><p>恢复子系统可以定期或不定期地建立检查点,保存数据库状态</p>
<ol>
<li>定期：按照预定的一个时间间隔，如每隔一小时建立一个检查点</li>
<li>不定期：按照某种规则，如日志文件已写满一半建立一个检查点</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/image-20200604014443958.png"></p>
<p>T1：在检查点之前提交</p>
<p>T2：在检查点之前开始执行，在检查点之后故障点之前提交</p>
<p>T3：在检查点之前开始执行，在故障点时还未完成</p>
<p>T4：在检查点之后开始执行，在故障点之前提交</p>
<p>T5：在检查点之后开始执行，在故障点时还未完成</p>
<h3 id="采用检查点的恢复步骤"><a href="#采用检查点的恢复步骤" class="headerlink" title="采用检查点的恢复步骤"></a>采用检查点的恢复步骤</h3><p>1）从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录；</p>
<p>2）由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST</p>
<ol>
<li>建立两个事务队列<ul>
<li>UNDO-LIST</li>
<li>REDO-LIST</li>
</ul>
</li>
<li>把ACTIVE-LIST暂时放入UNDO-LIST队列，REDO队列暂为空。</li>
</ol>
<p>3）从检查点开始正向扫描日志文件，直到日志文件结束</p>
<ol>
<li>如有新开始的事务Ti，把Ti暂时放入UNDO-LIST队列</li>
<li>如有提交的事务Tj，把Tj从UNDO-LIST队列移到REDO-LIST队列</li>
</ol>
<p>4）以检查点记载的最早日志记录和日志文件末尾为界</p>
<ol>
<li>对UNDO-LIST中的每个事务执行UNDO操作</li>
<li>对REDO-LIST中的每个事务执行REDO操作</li>
</ol>
<h2 id="问题回答"><a href="#问题回答" class="headerlink" title="问题回答"></a>问题回答</h2><p>1、为什么需要检查点？</p>
<ul>
<li>搜索整个日志文件需要耗费的时间很多</li>
<li>重做处理，重新执行，耗费了大量的时间</li>
</ul>
<p>2、解决方案是什么？</p>
<ul>
<li><p>在日志文件中增加检查点（check point）记录</p>
</li>
<li><p>增加重新开始文件</p>
</li>
<li><p>恢复子系统在登录日志文件期间动态的维护日志</p>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/1752663-20190920153317447-1216888502.png" style="zoom:80%;" /></li>
</ul>
<p>3、检查点记录的内容有哪些？</p>
<ul>
<li>建立检查点时刻，所有正在执行的事务清单</li>
<li>这些事务最近一个日志记录的地址</li>
</ul>
<p>4、重新开始文件的内容有哪些？</p>
<ul>
<li>记录各个检查点记录在日志文件中的地址</li>
</ul>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>事务是数据库的逻辑工作单位</p>
<p>DBMS保证系统中一切事务的原子性、一致性、隔离性和持续性</p>
<p>DBMS必须对事务故障、系统故障和介质故障进行恢复<br>恢复中最经常使用的技术：数据库转储和登记日志文件<br>恢复的基本原理：利用存储在后备副本、日志文件和数据库镜像中的冗余数据来重建数据库<br>常用恢复技术<br>事务故障的恢复（UNDO）<br>系统故障的恢复（UNDO + REDO）<br>介质故障的恢复（重装备份并恢复到一致性状态 + REDO）<br>提高恢复效率的技术<br>检查点技术（<br>Ø可以提高系统故障的恢复效率<br>Ø可以在一定程度上提高利用动态转储备份进行介质故障恢复的效率<br>）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/" class="post-title-link" itemprop="url">编译原理-代码优化和目标代码生成</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-30 11:36:21" itemprop="dateCreated datePublished" datetime="2020-04-30T11:36:21Z">2020-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="优化技术介绍"><a href="#优化技术介绍" class="headerlink" title="优化技术介绍"></a>优化技术介绍</h1><p>代码优化，是指对中间代码或目标代码进行等价变换，使得变换后的代码运行速度加快和存储空间减少。</p>
<p>代码优化按照优化的代码块尺度分为：局部优化、循环优化和全局优化。即</p>
<ol>
<li>局部优化：只有一个控制流入口、一个控制流出口的基本程序块上进行的优化；</li>
<li>循环优化：对循环中的代码进行的优化；</li>
<li>全局优化：在整个程序范围内进行的优化。</li>
</ol>
<h1 id="常见的代码优化手段"><a href="#常见的代码优化手段" class="headerlink" title="常见的代码优化手段"></a>常见的代码优化手段</h1><p>常见的代码优化技术有：删除多余运算、合并已知量和复写传播，删除无用赋值等。</p>
<p>针对目标代码：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">P</span> := <span class="number">0</span></span><br><span class="line"><span class="attribute">for</span> I := <span class="number">1</span> to <span class="number">20</span> do </span><br><span class="line">    <span class="attribute">P</span> := P + A[I]*B[I] </span><br></pre></td></tr></table></figure>

<p>假设其翻译所得的中间代码如下</p>
<p><img src="https://i.loli.net/2021/01/17/D6wA2XkBIuGHhYE.png"></p>
<ol>
<li><p><strong>删除多余运算</strong><br> 分析上图的中间代码，可以发现(3)和式(6)属于重复计算（因为I并没有发生变化），故而式(6)是多余的，完全可以采用T<del>4</del>∶&#x3D;T<del>1</del>代替。</p>
</li>
<li><p><strong>代码外提</strong><br> 减少循环中代码总数的一个重要办法是循环中不变的代码段外提。这种变换把循环不变运算，即结果独立于循环执行次数的表达式，提到循环的前面,使之只在循环外计算一次。针对改定的例子，显然数组A和 B的首地址在计算过程中并不改变，则作出的改动如下</p>
</li>
</ol>
<p>  <img src="https://i.loli.net/2021/01/17/NirHpLcfsoCmdla.png"></p>
<ol start="3">
<li><strong>强度削弱</strong><br> 强度削弱的本质是把<strong>强度大的运算换算成强度小</strong>的运算，例如将乘法换成加法运算。针对上面的循环过程，每循环一次，I的值增加1，T<del>1</del>的值与I保持线性关系，每次总是增加4。因此，可以把循环中计算T<del>1</del>值的乘法运算变换成在循环前进行一次乘法运算，而在循环中将其变换成加法运算。</li>
</ol>
<p>  <img src="https://i.loli.net/2021/01/17/jkxtV8F3sfoOQI9.png"></p>
<ol start="4">
<li><p><strong>变换循环控制条件</strong><br> I和T<del>1</del>始终保持T<del>1</del>＝4*I的线性关系，因此可以把四元式（12）的循环控制条件I≤20变换成T<del>1</del>≤80，这样整个程序的运行结果不变。这种变换称为变换循环控制条件。经过这一变换后，循环中I的值在循环后不会被引用，四元式（11）成为多余运算，可以从循环中删除。变换循环控制条件可以达到代码优化的目的。</p>
</li>
<li><p><strong>合并已知量和复写传播</strong><br> 四元式（3）计算4 * I时，I必为1。即4*I的两个运算对象都是编码时的已知量，可在编译时计算出它的值，即四元式（3）可变为T<del>1</del>＝4，这种变换称为合并已知量。</p>
</li>
</ol>
<p>  四元式(6)把T<del>1</del>的值复写到T<del>4</del>中，四元式（8）要引用T<del>4</del>的值，而从四元式（6）到四元式（8）之间未改变T<del>4</del>和T<del>1</del>的值，则将四元式（8）改为T<del>6</del>∶&#x3D;T<del>5</del>[T<del>1</del>]，这种变换称为复写传播。</p>
<p>  <img src="https://i.loli.net/2021/01/17/jfz2uI8gO7UYNDQ.png"></p>
<ol start="6">
<li><strong>删除无用赋值</strong><br> 式（6）对T<del>4</del>赋值，但T<del>4</del>未被引用；另外，（2）和（11）对I赋值，但只有（11）引用I。所以，只要程序中其它地方不需要引用T<del>4</del>和I，则（6），（2）和（11）对程序的运行结果无任何作用。我们称之为无用赋值，无用赋值可以从程序中删除。至此，我们可以得到删减后简洁的代码</li>
</ol>
<p>  <img src="https://i.loli.net/2021/01/17/5QshwyeKM6UdCkv.png"></p>
<h2 id="基本块内的局部优化"><a href="#基本块内的局部优化" class="headerlink" title="基本块内的局部优化"></a>基本块内的局部优化</h2><h3 id="基本块的划分"><a href="#基本块的划分" class="headerlink" title="基本块的划分"></a>基本块的划分</h3><p>入口语句的定义如下：<br>　　① 程序的第一个语句；或者，<br>　　② 条件转移语句或无条件转移语句的转移目标语句；<br>　　③ 紧跟在条件转移语句后面的语句。<br>有了入口语句的概念之后，就可以给出划分中间代码（四元式程序）为基本块的算法，<br>　　其步骤如下：<br>　　① 求出四元式程序中各个基本块的入口语句。<br>　　② 对每一入口语句，构造其所属的基本块。<strong>它是由该入口语句到下一入口语句（不包括下一入口语句），或到一转移语句（包括该转移语句），或到一停语句（包括该停语句）之间的语句序列组成的。</strong><br>　 ③ 凡未被纳入某一基本块的语句、都是程序中控制流程无法到达的语句，因而也是不会被执行到的语句，可以把它们删除。</p>
<h3 id="基本块的优化手段"><a href="#基本块的优化手段" class="headerlink" title="基本块的优化手段"></a>基本块的优化手段</h3><p>由于基本块内的逻辑清晰，故而要做的优化手段都是较为直接浅层次的。目前基本块内的常见的块内优化手段有：</p>
<ol>
<li><p>删除公共子表达式</p>
</li>
<li><p>删除无用代码</p>
</li>
<li><p>重新命名临时变量 （一般是用来应对创建过多临时变量的，如t<del>2</del> :&#x3D; t<del>1</del> + 3如果后续并没有对t<del>1</del>的引用，则可以t<del>1</del> :&#x3D; t<del>1</del> + 3来节省一个临时变量的创建）</p>
</li>
<li><p>交换语句顺序</p>
</li>
<li><p>在结果不变的前提下，更换代数操作（如$x∶&#x3D;y<strong>2$是需要根据 $</strong>$运算符重载指数函数的，这是挺耗时的操作，故而可以用强度更低的$x∶&#x3D;y*y$来代替）</p>
</li>
</ol>
<p>根据以上原则，对如下代码进行优化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t1 := <span class="number">4</span> - <span class="number">2</span></span><br><span class="line">t2 := t1 / <span class="number">2</span> </span><br><span class="line">t3 := a * t2</span><br><span class="line">t4 := t3 * t1</span><br><span class="line">t5 := b + t4</span><br><span class="line"> c := t5 * t5</span><br></pre></td></tr></table></figure>

<p>给出优化的终版代码</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">t1</span> := a + a</span><br><span class="line"><span class="built_in">t1</span> := <span class="keyword">b </span>+ <span class="built_in">t1</span></span><br><span class="line"> c := <span class="built_in">t1</span> * <span class="built_in">t1</span></span><br></pre></td></tr></table></figure>

<p>显然代码优化的工作不能像上面那样的人工一步步确认和遍历，显然必然要将这些优化工作公理化。而一般到涉及到数据流和控制流简化的这种阶段，都是到了图论一展身手的时候。</p>
<h3 id="DAG（无环路有向图）应用于基本块的优化工作"><a href="#DAG（无环路有向图）应用于基本块的优化工作" class="headerlink" title="DAG（无环路有向图）应用于基本块的优化工作"></a>DAG（无环路有向图）应用于基本块的优化工作</h3><p><strong>利用DAG进行基本块优化的基本思想是：按照构造DAG结点的顺序，对每一个结点写出其相应的三地址代码表示</strong></p>
<p>在DAG图中，通过节点间的连线和层次关系来表示表示式或运算的归属关系：<br>① 图的叶结点，即无后继的结点，以一标识符（变量名）或常数作为标记，表示这个结点代表该变量或常数的值。如果叶结点用来代表某变量A的地址，则用addr（A）作为这个结点的标记。<br>② 图的内部结点，即有后继的结点,以一运算符作为标记，表示这个结点代表应用该运算符对其后继结点所代表的值进行运算的结果。<br>（注：该部分内容转载自教材《编译原理》第11章DAG无环路有向图应用于代码优化）</p>
<p>DAG构建的流程如下</p>
<blockquote>
<p>对基本块的每一四元式，依次执行：<br>　　1． </p>
<p>​	   如果NODE（B）无定义，则构造一标记为B的叶结点并定义NODE（B）为这个结点；<br>　　如果当前四元式是0型，则记NODE（B）的值为n，转4。<br>　　如果当前四元式是1型，则转2.（1）。<br>　　如果当前四元式是2型，则：（Ⅰ）如果NODE（C）无定义，则构造一标记为C的叶结点并定义NODE（C）为这个结点，（Ⅱ）转2.（2）。<br>　　2．<br>　　（1） 如果NODE（B）是标记为常数的叶结点，则转2.（3），否则转3.（1）。<br>　　（2） 如果NODE（B）和NODE（C）都是标记为常数的叶结点，则转2.（4），否则转3.（2）。<br>　　（3） 执行op　B（即合并已知量），令得到的新常数为P。如果NODE（B）是处理当前四元式时 新构造出来的结点，则删除它。如果NODE（P）无定义，则构造一用P做标记的叶结点n。置NODE（P）＝n，转4.。<br>　　（4） 执行B　op　C(即合并已知量)，令得到的新常数为P。如果NODE（B）或NODE（C）是处理当前四元式时新构造出来的结点，则删除它。如果NODE（P）无定义，则构造一用P做标记的叶结点n。置NODE（P）＝n，转4.。<br>　　3．<br>　　（1） 检查DAG中是否已有一结点，其唯一后继为NODE（B），且标记为op（即找公共子表达式）。如果没有，则构造该结点n，否则就把已有的结点作为它的结点并设该结点为n，转4.。<br>　　（2） 检查DAG中是否已有一结点，其左后继为NODE（B），右后继为NODE（C），且标记为op(即找公共子表达式)。如果没有，则构造该结点n，否则就把已有的结点作为它的结点并设该结点为n。转4.。<br>　　4．<br>　　如果NODE（A）无定义，则把A附加在结点n上并令NODE（A）＝n；否则先把A从NODE（A）结点上的附加标识符集中删除（注意，如果NODE（A）是叶结点，则其标记A不删除），把A附加到新结点n上并令NODE（A）＝n。转处理下一四元式。</p>
</blockquote>
<p>说着很复杂，下面看一个案例</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) <span class="built_in">T0</span>∶=<span class="number">3</span>.<span class="number">14</span></span><br><span class="line">(<span class="number">2</span>) <span class="built_in">T1</span>∶=<span class="number">2</span> * <span class="built_in">T0</span></span><br><span class="line">(<span class="number">3</span>) <span class="built_in">T2</span>∶=R + r</span><br><span class="line">(<span class="number">4</span>) A∶=<span class="built_in">T1</span> * <span class="built_in">T2</span></span><br><span class="line">(<span class="number">5</span>) <span class="keyword">B∶=A</span></span><br><span class="line"><span class="keyword"></span>(<span class="number">6</span>) <span class="built_in">T3</span>∶=<span class="number">2</span> * <span class="built_in">T0</span></span><br><span class="line">(<span class="number">7</span>) <span class="built_in">T4</span>∶=R + r</span><br><span class="line">(<span class="number">8</span>) <span class="built_in">T5</span>∶=<span class="built_in">T3</span> * <span class="built_in">T4</span></span><br><span class="line">(<span class="number">9</span>) <span class="built_in">T6</span>∶=R - r</span><br><span class="line">(<span class="number">10</span>) <span class="keyword">B∶=T5 </span>* <span class="built_in">T6</span></span><br></pre></td></tr></table></figure>

<p>其DAG图的构建过程如下</p>
<p><img src="https://i.loli.net/2021/01/17/3fgHueUhVzjFGWr.png"></p>
<p>通过DAG图可以发现诸多的优化信息，如重复定义、无用定义等，则根据上图的DAG图可以构建最后的优化代码序列</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　(<span class="number">1</span>) <span class="built_in">S1</span>∶=R+r</span><br><span class="line">　　(<span class="number">2</span>) A∶=<span class="number">6</span>.<span class="number">28</span>*<span class="built_in">S1</span></span><br><span class="line">　　(<span class="number">3</span>) <span class="built_in">S2</span>∶=R-r</span><br><span class="line">　　(<span class="number">4</span>) <span class="keyword">B∶=A </span>*<span class="built_in">S2</span></span><br></pre></td></tr></table></figure>

<h2 id="循环优化"><a href="#循环优化" class="headerlink" title="循环优化"></a>循环优化</h2><p>循环优化的主要手段有：循环次数无关性代码外提、删除归纳变量和运算强度削弱。关于这三种手段的理解可以借助此前的描述进行类比，基本并无太多差异。</p>
<h3 id="流图"><a href="#流图" class="headerlink" title="流图"></a>流图</h3><p>结点是基本块的有向图G &#x3D; ( N, E, root)</p>
<ul>
<li>N是结点的集合，每个结点表示一个基本块</li>
<li>E是边的集合，如果结点n<del>i</del>和n<del>j</del>间存在前驱和后继的关系，则在存在一条从n<del>i</del>到n<del>j</del>的有向边（此时意味着，在n<del>i</del>执行后，可能会执行n<del>j</del>）<ul>
<li>n<del>i</del>的出口语句是goto(s)或if … goto(s)，且(s)是的n<del>j</del>入口语句</li>
<li>n<del>j</del>在程序中的位置紧跟在n<del>i</del>后，且n<del>i</del>的出口语句不是无条件转移语句和停语句</li>
</ul>
</li>
<li>root是流图的首结点（或称为根结点），是包含程序第一个语句的基本块</li>
</ul>
<p>每个流图都可以等价变换为单入口，且每个结点最多有两个后继的图</p>
<p>根据上面基本块的定义，我们将诸多基本块组装在一起，构建成程序循环图，如针对下面这个例子</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="comment">(1)</span> read x</span><br><span class="line">　　<span class="comment">(2)</span> read y</span><br><span class="line">　　<span class="comment">(3)</span> r∶=x mod y</span><br><span class="line">　　<span class="comment">(4)</span> <span class="keyword">if</span> r=<span class="number">0</span> <span class="keyword">goto</span> <span class="comment">(8)</span></span><br><span class="line">　　<span class="comment">(5)</span> x∶=y</span><br><span class="line">　　<span class="comment">(6)</span> y∶=r</span><br><span class="line">　　<span class="comment">(7)</span> <span class="keyword">goto</span> <span class="comment">(3)</span></span><br><span class="line">　　<span class="comment">(8)</span> write y</span><br><span class="line">　　<span class="comment">(9)</span> halt</span><br></pre></td></tr></table></figure>

<p>则按照上面基本块的划分，可以分成四个部分，四个部分的控制流分析可知可以得到一个循环图（流图）</p>
<p><img src="https://i.loli.net/2021/01/17/empRxLUdXWEMIhO.png"></p>
<p>循环块最主要的特点是<strong>只有一个数据流和控制流入口，而出口可能有多个。</strong></p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87/" class="post-title-link" itemprop="url">编译原理-运行时存储组织</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-30 11:36:01" itemprop="dateCreated datePublished" datetime="2020-04-30T11:36:01Z">2020-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="运行时存储组织概述"><a href="#运行时存储组织概述" class="headerlink" title="运行时存储组织概述"></a>运行时存储组织概述</h1><p>编译程序是将源程序的<strong>算法描述部分和数据说明部分</strong>，分别翻译成<strong>机器目标代码和数据存储单元</strong>，最终获得目标程序。</p>
<p>目标程序在目标机环境中运行时，都置身于自己的一个运行时存储空间。在基于操作系统之上运行的情况下，目标程序将在自己的逻辑地址空间内运行并存储数据。编译程序在生成代码时，负责明确各类对象在逻辑地址空间是如何存放的，以及目标代码运行时，如何使用逻辑地址空间。</p>
<p>在编译过程中，源程序的对象地址分配往往是相对于运行存储空间的偏移量，对象访问采用“基地址＋偏移量”寻址方式进行，使得可以选择内存的任意可用区域作为目标程序运行时的存储区。这样生成的目标代码称为浮动地址代码</p>
<blockquote>
<p><strong>注：“基地址”是指运行存储空间之首址。</strong></p>
</blockquote>
<p><strong>重点：符号表的内容、组织，过程调用实现，</strong>      </p>
<p>   <strong>静态存储分配、动态存储分配的基本方法。</strong></p>
<p><strong>难点：参数传递，过程说明语句代码结构，</strong></p>
<p>​    <strong>过程调用语句的代码结构，</strong></p>
<p>​    <strong>过程调用语句的语法制导定义，</strong></p>
<p>​    <strong>栈式存储分配。</strong></p>
<h1 id="运行时存储组织的任务和作用"><a href="#运行时存储组织的任务和作用" class="headerlink" title="运行时存储组织的任务和作用"></a>运行时存储组织的任务和作用</h1><p>编译程序生成的代码大小通常是固定的，一般存放在专用的区域，即代码区；<br>目标程序运行过程中，需要创建和访问的数据对象存放在数据区。</p>
<h1 id="程序运行时存储空间的布局"><a href="#程序运行时存储空间的布局" class="headerlink" title="程序运行时存储空间的布局"></a>程序运行时存储空间的布局</h1><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87/image-20200705134412828.png"></p>
<h2 id="存储分配策略"><a href="#存储分配策略" class="headerlink" title="存储分配策略"></a>存储分配策略</h2><p>数据空间分配是将<strong>源程序数据对象名与给定的数据存储空间地址建立映射关系</strong>。数据对象名与数据存储地址可能是一对多的关系，因为在源程序中说明的一个数据对象，在运行时可能对应不同的存储地址，如递归程序中的局部变量。</p>
<h3 id="静态存储分配"><a href="#静态存储分配" class="headerlink" title="静态存储分配"></a>静态存储分配</h3><p>静态存储管理是一种最简单的存储管理。<strong>当在编译阶段能够确定源程序中各个数据实体的存储空间大小</strong>时，就可以采用静态存储管理。一般而言，适于静态管理的语言必须满足下面的条件：</p>
<p>( 1 )、数组的上下界必须是常数；</p>
<p>( 2 )、过程调用不允许递归；</p>
<p>( 3 )、不允许用户动态地建立数据实体。</p>
<p>对于静态存储分配，数据空间仅需要有静态数据区即可。在源程序翻译时，对于所有数据对象，其分配的存储地址都是相对于静态数据区的偏移量。这个偏移量就是登记在符号表中数据对象的地址( .place)属性值。在目标程序运行时，访问数据对象的绝对地址是：</p>
<p><strong>绝对地址＝静态数据区首址+偏移量。</strong> </p>
<h3 id="动态存储分配"><a href="#动态存储分配" class="headerlink" title="动态存储分配"></a>动态存储分配</h3><p>如果源语言允许递归调用、可变数组和允许运行期间自由申请与释放空间，那么其需占用的存储空间在编译阶段无法确定，这样数据对象就需要采用动态存储分配的策略。</p>
<p>所谓动态存储分配是指在运行期间，动态进行存储地址分配。</p>
<p>•<strong>基于控制栈的原理，存储空间被组织成栈，活动记录的推入和弹出分别对应于活动的开始和结束。</strong></p>
<p>•<strong>与静态分配不同，在每次活动中把局部名字和新的存储单元绑定，在活动结束时，活动记录从栈中弹出，因此局部名字的存储空间也随之消失。</strong></p>
<h4 id="栈式动态存储分配"><a href="#栈式动态存储分配" class="headerlink" title="栈式动态存储分配"></a>栈式动态存储分配</h4><p>由于过程允许递归，在某一时刻一个过程A 很可能已被自己调用了若干次，但只有最近一次正处于执行状态，而其余各次则处于等待返回被中断的那次调用的状态。这样，属于每次调用相应的数据区中的内容就必须保存起来，以便于调用返回时继续使用<strong>。对于这种语言来说，其存储分配策略必须采用栈式存储管理，即引入一个运行栈，让过程的每一次执行和过程的调用记录相对应，每调用一次过程，就把该过程的相应调用记录推入栈中，过程执行结束时再把栈顶的调用记录从找中弹出。</strong></p>
<blockquote>
<p>在运行期间以子程序数据区为基本单位，在数据空间栈中进行动态地址分配。</p>
<p>当调用子程序时，在数据空间栈顶，给子程序分配所需的子程序数据区；</p>
<p>当子程序返回时，从数据空间栈顶，收回分配给子程序所占用存储区。</p>
<p>当子程序被递归调用时，同一个子程序可能在数据空间中同时拥有多个子程序数据区，每个数据区对应于同一个子程序的一次执行过程。</p>
</blockquote>
<h4 id="堆式动态存储分配"><a href="#堆式动态存储分配" class="headerlink" title="堆式动态存储分配"></a>堆式动态存储分配</h4><p>某些程序设计语言(如C 和PASCAL等）允许程序在运行时，为其中的一些变量动态地申请和释放所需的存储空间，并且申请和释放这两类操作可以在任何时间、以任意的顺序来进行，这就需要一种更为灵活和更加有效的动态分配策略，即堆式存储分配来完成上述工作。</p>
<p>堆式分配的基本思想是：<strong>为正运行的程序划出一适当大的存储区域，称之为堆（Heap) ; 每当该程序提出申请时, 就按某种分配原则在堆的自由区（可占用区） 中，找出一块能满足其需求的存储空间分配给它，对于释放操作，则是将程序不再占用的存储空间归还给堆的自由区。</strong><br>可能遇到的各种情况与操作系统给进程分配存储空间时遇到的极其相似，如同样会出现“碎片”现象等，其根本差异就在于分配的层次和分配对象的粒度。</p>
<h2 id="活动记录"><a href="#活动记录" class="headerlink" title="活动记录"></a>活动记录</h2><p>1.活动记录本质是什么？</p>
<blockquote>
<p>活动记录本质上是每次为函数调用时分配的一大块内存。一个函数的活动记录只由在函数被调用时才会创建，并且当函数返回时就会被销毁。</p>
</blockquote>
<p>2.活动记录是如何存在的？</p>
<blockquote>
<p>活动记录被组织在栈中，栈可以是物理上的实体也可以是逻辑上的概念。在数据结构中的栈是一个逻辑上的概念，而芯片中也可以根据这个概念来设计一部分电路，这部分能够模拟栈操作的电路就是物理意义上的栈了。<br>主函数的活动记录位于栈底，当一个函数调用另外一个函数时，被调用函数的活动记录就会被压入栈。或当记录所在的栈满足数据结构中的栈的特性：FILO(first in last out)。这个限制使得当主调函数和被调函数中出现了同名函数时，在执行被调函数时主调函数的变量对被调函数来说是不可见的。<br>特别提醒：大部分计算机为活动记录栈分配内存地址都是从高到低！</p>
</blockquote>
<p>3.活动记录是如何进行入栈出栈的？</p>
<blockquote>
<p>由于活动记录是位于一个栈中的，所以要近栈就需要知道栈结束处的位置，当出栈时就需要知道当前活动记录之前的一个活动记录的结束点。<br>所以编译器和硬件都会维护两个很重要的值：栈指针，帧指针。<br>栈指针：始终指向战结束处（注意不是栈底！）的地址，如果有新的活动记录入栈，那里就是新活动记录的起始地址所在。<br>帧指针：保存着先前那个活动记录的结束处的地址，在当前函数返回后，栈指针就会指向那里。<br>In short,栈指针和帧指针就是用来界定活动记录的，并操作活动记录。</p>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87/20171025112910951"></p>
</blockquote>
<h2 id="过程调用"><a href="#过程调用" class="headerlink" title="过程调用"></a>过程调用</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97/" class="post-title-link" itemprop="url">编译原理-语法制导的语义计算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-30 11:35:26" itemprop="dateCreated datePublished" datetime="2020-04-30T11:35:26Z">2020-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="语法制导的语义计算"><a href="#语法制导的语义计算" class="headerlink" title="语法制导的语义计算"></a>语法制导的语义计算</h1><p>编译原理的几个核心阶段：词法分析、语法分析和语义分析，其实<strong>编译的本质便是翻译，其各个阶段便是承担不同的翻译任务，词法分析阶段的任务是将程序输入的字符串流翻译成语言认可的字符流（剔除空格和注释等部分）；语法分析便是将程序按照语言文法的规则构建成语法树；语义分析便是在语法树构建的基础上完成语言规则的语义动作（类型检查、作用域和可视性检查、一致性检查等）。</strong></p>
<h2 id="属性文法（属性翻译文法）"><a href="#属性文法（属性翻译文法）" class="headerlink" title="属性文法（属性翻译文法）"></a>属性文法（属性翻译文法）</h2><p>对于语言而言，无论变量、函数、过程在程序中都是用一个标识符来代替，但如果给定了一个标识符，我们如何确定这个标识符的意义呢？其实这便引导出属性文法的概念（其实语义分析的公式化有多种方式，比如操作语义学、公理语义学、属性文法等，其中属性文法最为直观，也是当前绝大多数编译器采用的编译方式），比如变量有int\float\double之类的区别，那显然给定一个变量标识符，必须要指明该标识符的“数据类型属性”，所以必须给所有标识符配备一系列的属性。利用标识符的这些属性，便可以用来配合此前构建的语法树进行一系列的语义动作（类型检查、可见性是否合法等）。</p>
<p>语义分析一般是和语法分析组合在一起执行的，语法分析完成前一步语法树分析的构建（调用某个产生式完成一步规约，形成当前的树节点），然后语义分析便接着调用相应产生式配备的语义动作或子程序，完成属性文法所要求的语义动作（比如类型转换或生成中间代码）。所以对于属性文法而言，属性的加工和使用过程便是语义处理的意义。</p>
<p>形式上讲，一个属性文法是一个三元组，A＝（G，V，F），一个上下文无关文法G；一个属性的有穷集V和关于属性的谓词函数的有穷集F。每个断言与文法的某产生式相联。如果对G中的某一输入串而言（句子），A中的所有断言对该输入串的语法树结点的属性全为真，则该串也是A语言中的句子。</p>
<p>以上下文无关文法为基础：</p>
<ol>
<li>它为每个文法符号（终结符或者非终结符）配备若干相关的“值”（称为属性），代表与文法符号相关信息，如类型、值、代码序列、符号表内容等</li>
<li>对于文法的每个产生式都配备了一组属性的语义规则，对属性进行计算和传递。【凡是能够用程序实现的信息处理都可以称为语义规则】</li>
</ol>
<h3 id="S-属性文法"><a href="#S-属性文法" class="headerlink" title="S-属性文法"></a>S-属性文法</h3><p>只含有综合属性的属性文法</p>
<ul>
<li>如果一个SDD是<code>S</code>属性的，可以按照语法分析树节点的任何自底向上顺序来计算它的各个属性值</li>
<li>S-属性定义可以在<strong>自底向上的语法分析</strong>过程中实现</li>
</ul>
<h3 id="L-属性文法"><a href="#L-属性文法" class="headerlink" title="L-属性文法"></a>L-属性文法</h3><p>直观含义：在一个产生式所关联的各属性之间，依赖图的边可以<strong>从左到右，但不能从右到左</strong>。【 产生式右边符号的继承属性不能依赖他右边的符号的属性】<br>正式定义：一个SDD是L-属性定义，当且仅当它的每个属性要么是一个综合属性，要么是满足如下条件的继承属性：假设存在一个产生式$A\rightarrow{X_1X_2…X_n}$其右部符号$X_i$的继承属性仅依赖于下列属性：</p>
<ul>
<li>A的继承属性</li>
<li>产生式中$X_i$左边的符号$X_1,X_2,…,X_{i-1}$的属性<br>$X_i$本身的属性，但$X_i$的全部属性不能在依赖图中形成环路</li>
<li>注：每个S-属性定义都是L-属性定义</li>
</ul>
<h3 id="综合属性"><a href="#综合属性" class="headerlink" title="综合属性"></a>综合属性</h3><p><strong>自下而上传递信息</strong></p>
<p>语法规则：根据右部候选式中的符号的属性计算左部被定义符号的综合属性</p>
<p>语法树：根据子结点的属性和父结点自身的属性计算父结点的综合属性</p>
<p>由此可知，综合属性是自下而上传递的。</p>
<h3 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h3><p><strong>主要是用来自上而下传递信息。</strong></p>
<p>语法规则：根据右部候选式中的符号的属性和左部被定义符号的属性计算右部候选式中的符号的继承属性</p>
<p>语法树：根据父结点的属性和兄弟结点自身的属性计算子结点的继承属性</p>
<h3 id="属性依赖"><a href="#属性依赖" class="headerlink" title="属性依赖"></a>属性依赖</h3><p>对应每个产生式A -&gt; α都有一套与之相关联的语义规则，每条规则的形式为：<br>b:f(c<del>1</del>,c<del>2</del>····c<del>k</del>)；f是一个函数，c<del>1</del>,c<del>2</del>····c<del>k</del>是某些属性，b是需要计算的属性。</p>
<p>我们称b依赖属性c<del>1</del>,c<del>2</del>····c<del>k</del>：</p>
<ul>
<li>b是A的一个综合属性并且c<del>1</del>,c<del>2</del>····c<del>k</del>是产生式右边符号的属性</li>
<li>b是产生式右边某个文法符号的一个继承属性并且c<del>1</del>,c<del>2</del>····c<del>k</del>是A或产生式右边任何文法符号的属性</li>
</ul>
<p>注意：<br>(1)终结符只有综合属性，它由词法分析器提供<br>(2)非终结符既可以有综合属性也可以有继承属性，文法开始符号的所有继承属性作为属性计算前的初始值。<br>(3) 产生式<strong>右边符号的继承属性</strong>和产生式<strong>左边符号的综合属性</strong>都必须提供一个计算规则<br>(4) 产生式<strong>左边符号的继承属性</strong>和产生式<strong>右边符号的综合属性</strong>不由所给的产生式的属性计算规则进行计算，它们<strong>由其它产生式的属性规则计算</strong></p>
<p>所以在对属性计算的过程即是对语义处理的过程，对于文法的每一个产生式配备一组属性的计算规则，则称为语义规则。</p>
<h2 id="语义规则"><a href="#语义规则" class="headerlink" title="语义规则"></a>语义规则</h2><p>语义规则也是属性文法，对上下文无关文法做的一个扩充。每个产生式应该配备的语义规则，要说明该产生式中出现的语法符号的对应的属性的计算方法，以表达这个产生式所对应的语法结构的意义。</p>
<p>语义规则是描述该产生式中出现的语法符号的属性之间的相互关系，是以函数计算的方式体现。</p>
<p>注意：<br>(1)语义规则可能产生副作用（如产生代码），<br>(2)也可能是过程，不是严格的函数（即不一定有返回值）</p>
<h2 id="带注释的语法树"><a href="#带注释的语法树" class="headerlink" title="带注释的语法树"></a>带注释的语法树</h2><p>在语法树中：</p>
<ul>
<li>一个结点的综合属性的值由其子结点和它本身的属性值确定</li>
<li>一个结点的继承属性由其父结点、其兄弟结点和其本身的某些属性确定</li>
<li>用继承属性来表示程序涉及语言结构中的上下文依赖关系很方便</li>
</ul>
<p>使用自底向上的方法在每一个结点处使用语义规则计算综合属性的值</p>
<h1 id="属性计算"><a href="#属性计算" class="headerlink" title="属性计算"></a>属性计算</h1><p>语义规则的计算：</p>
<ul>
<li>产生代码</li>
<li>在符号表中存放信息</li>
<li>给出错误信息</li>
<li>执行任何其它动作</li>
</ul>
<p>对输出串的翻译就是根据语义规则进行计算</p>
<p>在属性文法的基础上进行处理</p>
<p><strong>输入串语法树-&gt;依赖图-&gt;语义规则计算次序-&gt;计算结果</strong><br>这种由源程序的语法结构所驱动的处理办法就是语法制导翻译法。</p>
<h1 id="基于属性文法的处理方法"><a href="#基于属性文法的处理方法" class="headerlink" title="基于属性文法的处理方法"></a>基于属性文法的处理方法</h1><h2 id="依赖图"><a href="#依赖图" class="headerlink" title="依赖图"></a>依赖图</h2><p>在一颗语法树中的结点的继承属性和综合属性之间的相互依赖关系可以用称作<strong>依赖图</strong>的一个有向图来描述。依赖图可以确定属性计算的先后顺序。</p>
<p>依赖图中为每一个属性设置一个结点，如果属性b依赖于属性c，则从属性c的结点有一条有向边连到属性b的结点。</p>
<h3 id="良定义的属性文法"><a href="#良定义的属性文法" class="headerlink" title="良定义的属性文法"></a>良定义的属性文法</h3><p><strong>如果一属性文法不存在属性之间的循环依赖关系，那么该文法为良定义的。为了设计编译程序，我们只处理良定义的属性文法。</strong></p>
<p>一个依赖图的任何拓扑排序都给出一个语法树中结点的语义规则计算的有效顺序。</p>
<h3 id="属性的计算次序"><a href="#属性的计算次序" class="headerlink" title="属性的计算次序"></a>属性的计算次序</h3><p>一个有向非循环图的拓扑序是图中结点的任何顺序m<del>1</del>,m<del>2</del>, …m<del>k</del>,使得边必须是从序列中前面的结点指向后面的结点。也就是说，如果m<del>i</del>m<del>j</del>是m<del>i</del>到m<del>j</del>的一条边，那么在序列中m<del>i</del>必须出现在m<del>j</del>之前。<br>一个依赖图的任何拓扑排序都给出一个语法树中结点的语义规则计算的有效顺序。这就是说，在拓扑排序中，在一个结点上，语义规则b:&#x3D;f（c<del>1</del>,c<del>2</del>,…c<del>k</del>)中的属性c<del>1</del>,c<del>2</del>…c<del>k</del>在计算b以前都是可用的。</p>
<h2 id="树遍历的属性计算方法"><a href="#树遍历的属性计算方法" class="headerlink" title="树遍历的属性计算方法"></a>树遍历的属性计算方法</h2><p>通过树遍历的方法计算属性的值</p>
<ul>
<li>假设语法树已经建立，且树中带有开始符号的继承属性和终结符的综合属性</li>
<li>以某种次序遍历语法树，直至计算出所有属性</li>
<li>深度优先，从左到右进行遍历</li>
<li>基于<strong>递归</strong></li>
</ul>
<p>输入串-&gt;语法树-&gt;遍历语法树计算属性</p>
<h2 id="一遍扫描的处理方法"><a href="#一遍扫描的处理方法" class="headerlink" title="一遍扫描的处理方法"></a>一遍扫描的处理方法</h2><p>与语法分析方法相关，将属性计算穿插在语法分析的过程中进行。</p>
<p>产生语法结构的顺序决定了属性计算的顺序。【语法制导的思想】</p>
<p><strong>所谓的语法制导翻译法，直观上说就是为文法中每个产生式配上一组语义规则，并且在语法分析的同时执行这些语义规则。</strong></p>
<ul>
<li>在自上而下分析，一个产生式匹配输入串成功时，就执行相应的语义规则</li>
<li>在自下而上分析，一个产生式被归约时，就执行相应的语义规则</li>
</ul>
<h2 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h2><p>从语法树中去掉对翻译不必要的信息，而获得更有效的源程序中间表示。<br>这种经变换后的语法树称之为抽象语法树（Abstract Syntax Tree）。<br>在抽象语法树中，操作符和关键字都不作为叶结点出现，而是把它们作为内部结点，即这些叶结点的父结点。</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97/20180612214932367.png" style="zoom:50%;" />

<h1 id="S-属性文法的自下而上计算"><a href="#S-属性文法的自下而上计算" class="headerlink" title="S-属性文法的自下而上计算"></a>S-属性文法的自下而上计算</h1><p>s-属性文法：只含有综合属性</p>
<p>在自下而上的分析器分析输入符号串的同时计算综合属性</p>
<ul>
<li>分析栈中保存语法符号和有关的综合属性值</li>
<li>每当进行归约时，新的语法符号的属性值由栈中正在归约的产生式右边符号的属性值进行计算</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>原来自下而上分析栈一般只保存状态和语法符号。</p>
<p>现在，我们在分析栈中增加附加域存放综合属性值。</p>
<h1 id="L-属性文法的自顶向下翻译"><a href="#L-属性文法的自顶向下翻译" class="headerlink" title="L-属性文法的自顶向下翻译"></a>L-属性文法的自顶向下翻译</h1><p>按照深度优先遍历语法树，计算所有属性值</p>
<p>与LL(1)自上而下分析方法结合</p>
<ul>
<li>深度优先建立语法树</li>
<li>按照语义规则计算属性</li>
</ul>
<h1 id="翻译模式"><a href="#翻译模式" class="headerlink" title="翻译模式"></a>翻译模式</h1><p>语义规则：给出了属性计算的定义，没有属性计算的次序等实现细节。所以，我们得通过依赖图、树遍历等方法确定属性计算的顺序。</p>
<p>翻译模式：给出使用语义规则进行计算的次序，把实现细节表现出来</p>
<p>（1）在翻译模式中，和文法符号相关的属性和语义规则用花括号括起来，插入到产生式右部的合适位置上，可被插入到产生式右部的任何合适的位置上。</p>
<p>（2）这是一种语法分析和语义动作交错的表示法，他表达在按深度优先遍历分析树的过程中何时执行语义动作。</p>
<p>（3）翻译模式给出了使用语义规则进行计算的顺序。可看成是分析过程中翻译的注释。</p>
<h2 id="设计翻译模式（根据语法制导定义）"><a href="#设计翻译模式（根据语法制导定义）" class="headerlink" title="设计翻译模式（根据语法制导定义）"></a>设计翻译模式（根据语法制导定义）</h2><p>条件：<strong>语法制导定义是L-属性定义</strong><br><strong>保证语义动作不会引用还没有计算的属性值。【必须保证当某个动作引用一个属性时它必须是有定义的】</strong></p>
<h3 id="只需要综合属性的情况"><a href="#只需要综合属性的情况" class="headerlink" title="只需要综合属性的情况"></a>只需要综合属性的情况</h3><p>为每一个语义规则建立一个包含赋值的动作，并把这个动作放在相应的产生式右边的末尾。<br>例如：<br>产生式：T-&gt;T<del>1</del>*F<br>语义规则：T.val:&#x3D;T<del>1</del>.valxF.val<br>翻译模式:T-&gt;T<del>1</del>*F {T.val:&#x3D;T<del>1</del>.valxF.val}</p>
<blockquote>
<p>因为父节点的综合属性的值只依赖于子节点，把综合属性的值计算放在最右边，它的子节点已经扩展完毕了。我们也就得到子节点的属性值</p>
</blockquote>
<h3 id="既有综合属性又有继承属性的情况"><a href="#既有综合属性又有继承属性的情况" class="headerlink" title="既有综合属性又有继承属性的情况"></a>既有综合属性又有继承属性的情况</h3><p>要求：</p>
<p>①产生式右边的符号的继承属性必须在这个符号以前的动作中计算出来。<br>②一个动作不能引用这个动作右边符号的综合属性。<br>③产生式左边非终结符号的综合属性只有在它所引用的所有属性都计算出来以后才能计算。计算这种属性的动作通常可放在产生式右端的未尾。</p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97/20180612215501603.png" style="zoom:50%;" />

<p>此时Pt（A1.in）是不好的，这个翻译模式不对。因为A1.in还没有出来（在最右边）</p>
<p>改进翻译模式：</p>
<p>S-&gt;{A1.in:&#x3D;1}A1{A2.in:&#x3D;2}A2       A-&gt;a{print(A.in)}</p>
<h2 id="语义动作执行时机统一"><a href="#语义动作执行时机统一" class="headerlink" title="语义动作执行时机统一"></a>语义动作执行时机统一</h2><p>把所有的语义动作都放在产生式的末尾</p>
<ul>
<li><p>语义动作的执行时机统一</p>
</li>
<li><p>转换方法</p>
<ul>
<li>加入新产生式M-&gt;ε</li>
<li>把嵌入在产生式中的每个语义动作用不同的非终结符M代替，并把这个动作放在产生式M-&gt;ε的末尾</li>
</ul>
</li>
</ul>
<p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97/image-20200507184555454.png"></p>
<h2 id="消除翻译模式的左递归"><a href="#消除翻译模式的左递归" class="headerlink" title="消除翻译模式的左递归"></a>消除翻译模式的左递归</h2><p>语义动作是在相同位置上的符号被展开（匹配成功）时执行的。为了构造不带回溯的自顶向下语法分析，必须消除文法中的左递归</p>
<p>当消除一个翻译模式的基本文法的左递归时同时考虑属性计算</p>
<ul>
<li>适合带综合属性的翻译模式</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8/" class="post-title-link" itemprop="url">计算机系统结构-多处理器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 12:50:43" itemprop="dateCreated datePublished" datetime="2020-04-15T12:50:43Z">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机系统结构-互连网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 12:50:06" itemprop="dateCreated datePublished" datetime="2020-04-15T12:50:06Z">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机系统结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="互连网络（ICN）"><a href="#互连网络（ICN）" class="headerlink" title="互连网络（ICN）"></a>互连网络（ICN）</h1><p>互连网络是计算机部件、计算机节点或计算机系统之间的连接。</p>
<p>例如：CPU和CPU之间、CPU内的多核之间、CPU和内存之间、内存和内存之间、计算机节点之间、网络和网络之间。</p>
<p>互连网络的直接设计目标是：在最少传输延迟约束内，传输尽可能多的数据，避免成为系统的瓶颈。</p>
<p>高速互连网络（&lt;100s时钟周期）</p>
<p>片上&#x2F;系统高速互连网络是一种由网络元件按照一定的拓扑结构和控制方式构成的网络，用来实现计算机系统中部件之间的高速连接。</p>
<ul>
<li>三大要素：网络元件、互连结构、控制方式</li>
<li>结点：处理器、存储模块或其它设备</li>
<li>在拓扑上，互连网络为输入结点到输出结点之间的一组互连或映象。<ul>
<li>互连结构是静态连接拓扑</li>
<li>控制方式是基于静态拓扑结构的动态传输机制</li>
</ul>
</li>
</ul>
<p>互连网络的主要操作：</p>
<ul>
<li>置换（N-N）</li>
<li>广播（1-N）</li>
<li>选播（1-部分）</li>
</ul>
<h2 id="互连网络的结构参数和指标"><a href="#互连网络的结构参数和指标" class="headerlink" title="互连网络的结构参数和指标"></a>互连网络的结构参数和指标</h2><h3 id="结构参数"><a href="#结构参数" class="headerlink" title="结构参数"></a>结构参数</h3><p>网络通常是用有向边或无向边连接有限个结点的图来表示。</p>
<p>互连网络的主要特性参数：</p>
<ul>
<li>网络规模N：网络中接点的个数</li>
<li>结点度d：与结点相连接的边数，包括入度和出度</li>
<li>结点距离：对于网络中任意两个结点，从一个结点出发到另一个结点终止所需要跨越的边数的最小值</li>
<li>网络直径D：网络中任意两结点间距离的最大值<ul>
<li>网络直径应尽可能小</li>
</ul>
</li>
<li>等分宽度b：把由N个结点构成的网络切成结点数相同（N&#x2F;2）的两半，在各种切法中，沿切口边数的最小值。<ul>
<li>线等分宽度：B&#x3D;b X w，w为通道宽度</li>
<li>该参数反映了网络最大流量</li>
</ul>
</li>
<li>对称性：从任何结点看到的拓扑结构都相同的网络称为对称网络。</li>
</ul>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p><strong>时延和带宽</strong></p>
<ul>
<li>通信时延：指从源节点到目的结点传送一条消息所需的总时间<br>【&#x3D;软件开销+通道时延+选路时延+竞争时延】</li>
<li>网络时延：通道时延与选路时延的和<ul>
<li>由网络硬件特征决定，与程序行为和网络传输状态无关</li>
</ul>
</li>
<li>端口带宽<ul>
<li>对于互连网络中任意一个端口来说，其端口带宽是指单位时间内从该端口传送到其他端口的最大信息量。</li>
</ul>
</li>
<li>聚集带宽<ul>
<li>网络从一半结点向另一半结点传输时，单位时间内能够传送的最大信息量</li>
</ul>
</li>
</ul>
<h1 id="互连函数"><a href="#互连函数" class="headerlink" title="互连函数"></a>互连函数</h1><p>反映了网络输入数组和输出数组之间对应的置换关系或排列关系（置换函数或排列函数）</p>
<p>变量x：输入  函数f(x)：输出</p>
<p>在互连函数f的作用下，输入端x连接到输出端f(x)</p>
<p>互连函数采用循环表示：（x<del>0</del>,x<del>1</del>,x<del>2</del>,x<del>3</del>,···x<del>j-2</del>,x<del>j-1</del>）表示f(x<del>0</del>)&#x3D;x<del>1</del>,f(x<del>1</del>)&#x3D;x<del>2</del>,f(x<del>j-1</del>)&#x3D;x<del>0</del></p>
<h2 id="基本的互连函数"><a href="#基本的互连函数" class="headerlink" title="基本的互连函数"></a>基本的互连函数</h2><ol>
<li><p>恒等函数：实现同号输入端和输出端之间的连接<br>$I(X_{n-1}X_{n-2}···X_{1}X_{0})&#x3D;X_{n-1}X_{n-2}···X_{1}X_{0}$</p>
</li>
<li><p>交换函数：实现<strong>二进制地址编码</strong>中第K位互反的输入端和输出端之间的连接<br>$E(X_{n-1}X_{n-2}···X_{k+1}X_{k}X_{k-1}···X_{1}X_{0})&#x3D;X_{n-1}X_{n-2}···X_{k+1}\bar{X_{k}}X_{k-1}···X_{1}X_{0}$</p>
<ul>
<li><p>主要用于构造立方体互连网络和各种超立方体互连网络</p>
</li>
<li><p>供有n&#x3D;log<del>2</del>N种互连函数（N为结点个数）</p>
</li>
<li><p>$$<br>Cube_0(x_2x_1x_0)&#x3D;x_2x_1\overline{x_0}\<br>Cube_1(x_2x_1x_0)&#x3D;x_2\overline{x_1}x_0\<br>Cube_2(x_2x_1x_0)&#x3D;\overline{x_2}x_1x_0\<br>$$</p>
</li>
</ul>
</li>
<li><p>均匀洗牌函数（混洗函数、置换函数,shuffle函数）：将输入端分成数目相等的两半，前一半和后一半按类似均匀混洗扑克牌的方式交叉地连接到输出端（输出端相当于混洗的结果）<br>$\sigma(X_{n-1}X_{n-2}···X_{1}X_{0})&#x3D;X_{n-2}X_{n-3}···X_{0}X_{n-1}$</p>
<ul>
<li>即把输入端的二进制编号循环左移一位</li>
<li>$shuffle^{n}(j)&#x3D;j$</li>
<li>$shuffle_n(j)&#x3D;j$</li>
</ul>
</li>
<li><p>子函数和超函数</p>
<ul>
<li>互连函数(s)的第k个子函数s<del>k</del>：把s作用输入端的二进制编号的低k位</li>
<li>互连函数(s)的第k个超函数s^k^：把s作用输入端的二进制编号的高k位</li>
</ul>
</li>
<li><p>逆函数</p>
<ul>
<li>对于任意一种函数f(x),如果存在g(x)，使得$f(x)\times g(x)&#x3D;I(x)$。则称g(x)是f(x)的逆函数，记作$f^{-1}(x)&#x3D;g(x)$</li>
</ul>
</li>
<li><p>逆均匀洗牌函数：将输入端的二进制编号<strong>循环右移一位</strong>而得到所连接的输出端编号<br>$\sigma^{-1}(X_{n-1}X_{n-2}···X_{1}X_{0})&#x3D;X_{0}X_{n-1}···X_{2}X_{1}$</p>
</li>
<li><p>碟式函数（$\beta$）：把输入端的二进制编号的最高位与最低位互换位置得到输出端的编号。</p>
<ul>
<li>第k个子函数：<br>$\beta_{(k)}(X_{n-1}X_{n-2}···X_{k}X_{k-1}X_{k-2}···X_{1}X_{0})&#x3D;X_{n-1}X_{n-2}···X_{k}X_{0}X_{k-2}···X_{1}X_{k-1}$</li>
<li>第k个超函数：<br>$\beta^{(k)}(X_{n-1}X_{n-2}···X_{n-k+1}X_{n-k}X_{n-k-1}···X_{1}X_{0})&#x3D;X_{n-k}X_{n-2}···X_{n-k+1}X_{n-1}X_{n-k-1}···X_{1}X_{0}$</li>
<li>碟式变换与交换变换的多级组合是构成多级立方体网络的基础</li>
</ul>
</li>
<li><p>反位序函数：将输入端二进制编号的位序颠倒过来求得相应输出端的编号<br>$\rho(X_{n-1}X_{n-2}···X_{1}X_{0})&#x3D;X_{0}X_{1}···X_{n-2}X_{n-1}$</p>
<ul>
<li>第k个子函数<br>$\rho_{(k)}(X_{n-1}X_{n-2}···X_{k}X_{k-1}X_{k-2}···X_{1}X_{0})&#x3D;X_{n-1}X_{n-2}···X_{k}X_{0}X_{1}···X_{k-2}X_{k-1}$</li>
<li>第k个超函数<br>$\rho^{(k)}(X_{n-1}X_{n-2}···X_{n-k+1}X_{n-k}X_{n-k-1}···X_{1}X_{0})&#x3D;X_{n-k}X_{n-k+1}···X_{n-2}X_{n-1}X_{n-k-1}···X_{1}X_{0}$</li>
</ul>
</li>
<li><p>移数函数：将各输入端都错开一定的位置（模N）后连到输出端</p>
</li>
<li><p>PM2I函数（加减2^i^函数）</p>
<ul>
<li>P和M分别表示加和减，2I表示2^i^</li>
<li>一种移数函数<br>$PM2_{+i}(x)&#x3D;x+2^i\quad mod(N)$<br>$PM2_{-i}(x)&#x3D;x-2^i\quad mod(N)$<br>$0\leq x\leq N-1\quad o\leq i\leq n-1\quad n&#x3D;log_2N,N表示结点数$</li>
<li>PM2I互连网络共有2n个互连函数</li>
</ul>
</li>
</ol>
<h1 id="静态互连网络"><a href="#静态互连网络" class="headerlink" title="静态互连网络"></a>静态互连网络</h1><p>各结点之间有固定的连接通路、且在运行中不能改变的网络。</p>
<h2 id="1、2维互连函数"><a href="#1、2维互连函数" class="headerlink" title="1、2维互连函数"></a>1、2维互连函数</h2><h3 id="线性阵列"><a href="#线性阵列" class="headerlink" title="线性阵列"></a>线性阵列</h3><p>一种一维的线性网络，其中N个结点由N-1个链路连成一行。</p>
<ul>
<li>端结点的度：1</li>
<li>其余结点的度：2</li>
<li>直径：N-1</li>
<li>等分宽度b&#x3D;1</li>
</ul>
<h3 id="环和带弦环"><a href="#环和带弦环" class="headerlink" title="环和带弦环"></a>环和带弦环</h3><p>环：线性阵列的两个端点连接起来。可以单向工作也可以双向工作。</p>
<ul>
<li>对称</li>
<li>结点的度：2</li>
<li>双向环的直径：N&#x2F;2</li>
<li>单向环的直径：N-1</li>
<li>环的等分宽度b&#x3D;2</li>
</ul>
<h3 id="带弦环"><a href="#带弦环" class="headerlink" title="带弦环"></a>带弦环</h3><p>增加的链路越多，结点度越高，网络直径越小</p>
<ol>
<li><p>全连接网络：两两结点之间都有链路</p>
</li>
<li><p>循环移数网络：通过在环上每个结点到所有与其距离为2的整数幂的结点之间都增加一条附加链</p>
</li>
<li><p>树形和星形：<br>树形是二叉树</p>
<ul>
<li>最大结点度：3</li>
<li>直径：2(k-1)【k层完全平衡的二叉树】</li>
<li>等分宽度b&#x3D;1</li>
</ul>
<p>星形：<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C/image-20200418185318359.png"></p>
<ul>
<li>结点度：N-1</li>
<li>直径较小：2</li>
<li>等分宽度b&#x3D;[N&#x2F;2]【向下取整】</li>
</ul>
</li>
<li><p>胖树形</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C/image-20200418185441475.png" style="zoom:67%;" />
</li>
<li><p>网格形和环网形</p>
<ul>
<li>网格形：<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C/image-20200418185559655.png" style="zoom:50%;" />
一个由N=n^k^个结点构成的k维网格形网络（每维n个结点）的内部结点度d=2k，网络直径D=k(n-1)</li>
<li>Illiac网络：把2维网格形网络的每一列的两个端结点连接起来，再把每一行的尾结点与下一行的头结点连接起来，并把最后一行的尾结点与第一行的头结点连接起来<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C/image-20200418185935578.png" style="zoom:50%;" />
一个规模为nxn的Illiac网格：
- 所有结点的度d=4
- 网络直径D=n-1
- 等分宽度：2n</li>
<li>环网形：把2维网格形网络的每一列的两个端结点连接起来，再把每一行的两个端结点连接起来。<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C/image-20200418190203697.png" style="zoom:50%;" />
一个nxn的环网形网
- 结点度：4
- 网络直径：2x[n/2]【向下取整】
- 等分宽度b=2n</li>
</ul>
</li>
</ol>
<h2 id="超立方体和寻径"><a href="#超立方体和寻径" class="headerlink" title="超立方体和寻径"></a>超立方体和寻径</h2><h3 id="超立方体"><a href="#超立方体" class="headerlink" title="超立方体"></a>超立方体</h3><p>一种二元n-立方体结构，由N&#x3D;2^n^个结点组成；分布在n维上，每维有两个结点。<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C/image-20200418190523155.png" style="zoom:50%;" /></p>
<p>为实现一个n-立方体，只要把两个（n-1）立方体中相对应的结点用链路连接起来即可。共需要2^n-1^条链路。</p>
<p>n-立方体中结点的度都是n，直径也是n，等分宽度为b&#x3D;N&#x2F;2。</p>
<h3 id="带环立方体（3-CCC）"><a href="#带环立方体（3-CCC）" class="headerlink" title="带环立方体（3-CCC）"></a>带环立方体（3-CCC）</h3><p>将k-立方体的每个结点用由k个结点的环来代替，组成带环k-立方体。<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C/image-20200418190859708.png" style="zoom:67%;" /></p>
<ul>
<li>网络规模：$N&#x3D;k\times2^k$</li>
<li>网络直径：$D&#x3D;2k-1+\lfloor k&#x2F;2\rfloor$</li>
<li>等分宽度：$b&#x3D;\frac{N}{2k}$</li>
</ul>
<h3 id="k元n-立方体网络"><a href="#k元n-立方体网络" class="headerlink" title="k元n-立方体网络"></a>k元n-立方体网络</h3><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C/image-20200418194426267.png" style="zoom:67%;" />

<ul>
<li>环形、网格、环网形、二元n-立方体（超立方体）都是k元n-立方体网络系列的拓扑同构体</li>
<li>在k元n-立方体网络中，参数n是立方体的维数，k是基数，即每一维上的结点个数$N&#x3D;N^n$</li>
<li>k元n-立方体的结点可以用基数为k的n位地址A&#x3D;a<del>1</del>a<del>2</del>a<del>3</del>a<del>4</del>来表示【a<del>i</del>表示该结点在第i维上的位置】</li>
<li>通常把低维k元n-立方体称为环网，而把高维k元n-立方体称为超立方体</li>
</ul>
<h3 id="基于静态互连网络的寻径机制"><a href="#基于静态互连网络的寻径机制" class="headerlink" title="基于静态互连网络的寻径机制"></a>基于静态互连网络的寻径机制</h3><ul>
<li>确定性寻径：通信路径完全由源结点地址和目的地址来决定，寻径路径是预先唯一确定好了的，与网络状况无关</li>
<li>自适应寻径：通信的通路每一次都要根据资源或者网络的情况来选择【TCP&#x2F;IP网络】</li>
</ul>
<h3 id="二维网格网络的X-Y寻径"><a href="#二维网格网络的X-Y寻径" class="headerlink" title="二维网格网络的X-Y寻径"></a>二维网格网络的X-Y寻径</h3><p>先沿X维方向进行寻径，然后再沿Y维方向寻找路径</p>
<h3 id="超立方体E-cube寻径"><a href="#超立方体E-cube寻径" class="headerlink" title="超立方体E-cube寻径"></a>超立方体E-cube寻径</h3><h1 id="动态互连网络"><a href="#动态互连网络" class="headerlink" title="动态互连网络"></a>动态互连网络</h1><p>由交换开关构成、可按运行程序的要求动态地改变连接状态的网络。</p>
<h2 id="总线和交叉开关"><a href="#总线和交叉开关" class="headerlink" title="总线和交叉开关"></a>总线和交叉开关</h2><h3 id="总线网络"><a href="#总线网络" class="headerlink" title="总线网络"></a>总线网络</h3><p>由一组导线和插座构成，经常被用来实现计算机系统中处理机模块、存储模块和外围设备等之间的互连。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-I-O%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-I-O%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">计算机系统结构-I/O系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 12:49:40" itemprop="dateCreated datePublished" datetime="2020-04-15T12:49:40Z">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机系统结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="IO系统的基本概念"><a href="#IO系统的基本概念" class="headerlink" title="IO系统的基本概念"></a>IO系统的基本概念</h1><p>通常包含IO设备和IO设备与处理机的连接接口两个主要部分。</p>
<h1 id="系统评价"><a href="#系统评价" class="headerlink" title="系统评价"></a>系统评价</h1><p>参数指标：连接特性、IO系统的容量、响应时间和吞吐率</p>
<p>吞吐率反映单位时间内完成的I&#x2F;O数量，响应时间则反映了完成一次I&#x2F;O所花费的时间</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rshawshank.github.io/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rhb">
      <meta itemprop="description" content="纵浪大化中，不喜亦不惧">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhb_blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">计算机系统结构-存储系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 12:49:31" itemprop="dateCreated datePublished" datetime="2020-04-15T12:49:31Z">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-13 09:13:26" itemprop="dateModified" datetime="2022-11-13T09:13:26Z">2022-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机系统结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="存储系统性能量化分析"><a href="#存储系统性能量化分析" class="headerlink" title="存储系统性能量化分析"></a>存储系统性能量化分析</h1><p>存储器越靠近CPU，则CPU对它的访问频度越高，但是容量也越低，单位存储容量价格越高。</p>
<p>存储容量S：一般来说，整个存储系统的容量即是第二级存储器M<del>2</del> ，即S&#x3D;S<del>2</del></p>
<p>命中率H：CPU访问存储系统时，在M<del>1</del> 中找到所需信息的概率$H&#x3D;\frac{N_1}{N_1+N_2}$</p>
<p>平均访问时间T<del>A</del> ：</p>
<ul>
<li><p>当命中时，访问时间即是T<del>1</del> （命中时间）</p>
</li>
<li><p>当没命中时，$T_2+T_1+T_B&#x3D;T_1+T_M\T_m&#x3D;T_2+T_B\传递一个信息块所需的时间为T_B\不命中开销T_M:从向M_2发出访问请求到整个数据块调入M_1中所需的时间$</p>
</li>
</ul>
<h1 id="Cache基本知识"><a href="#Cache基本知识" class="headerlink" title="Cache基本知识"></a>Cache基本知识</h1><p>Cache-利用局部性原理，加快经常性事件原理，将程序和数据放到与CPU速度匹配的高速存储器中。</p>
<p>cache关注的四个问题：</p>
<ul>
<li><p>如何放</p>
<ul>
<li>全相联映象</li>
<li>直接映象</li>
<li>组相联映象</li>
</ul>
</li>
<li><p>如何找</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200416191002374.png" style="zoom:80%;" />
</li>
<li><p>如何写</p>
<ul>
<li>写穿：写cache的同时也在写内存</li>
<li>写回：只写cache，只有被替换时才写回内存</li>
</ul>
</li>
<li><p>如何换</p>
<ul>
<li>轮换法</li>
<li>LRU算法</li>
</ul>
</li>
</ul>
<p>具体见《组原原理》</p>
<h1 id="映象规则及其变换"><a href="#映象规则及其变换" class="headerlink" title="映象规则及其变换"></a>映象规则及其变换</h1><p>见《组成原理》</p>
<h1 id="降低cache不命中率"><a href="#降低cache不命中率" class="headerlink" title="降低cache不命中率"></a>降低cache不命中率</h1><h2 id="三种类型的不命中"><a href="#三种类型的不命中" class="headerlink" title="三种类型的不命中"></a>三种类型的不命中</h2><ul>
<li>强制性不命中：当第一次访问一个块时，该块不在cache中，需从下一级存储器中调入cache。（冷启动不命中，首次访问不命中。）</li>
<li>容量不命中：如果程序执行时所需的块不能全部调入cache中，则当某些块被替换后，若重新被访问，就会发生不命中。</li>
<li>冲突不命中：在组相联或者直接映象cache中，如果太多的块映象到同一组（块）中，则该组中某个块被别的块替换（即使别的组或块有空闲位置），然后又被重新访问的情况。（碰撞不命中，干扰不命中）</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>相联度越高，冲突不命中就越少；</li>
<li>强制性不命中和容量不命中不受相联度的影响</li>
<li>强制性不命中不受cache容量的影响，但是容量不命中却随着容量的增加而减少</li>
</ol>
<h2 id="减少三种不命中的方法"><a href="#减少三种不命中的方法" class="headerlink" title="减少三种不命中的方法"></a>减少三种不命中的方法</h2><ul>
<li>强制性不命中：增加块大小，预取</li>
<li>容量不命中：增加容量</li>
<li>冲突不命中：提高相关度</li>
</ul>
<p><strong>许多降低不命中率的方法会增加命中时间或不命中开销</strong></p>
<h3 id="增加cache块的大小"><a href="#增加cache块的大小" class="headerlink" title="增加cache块的大小"></a>增加cache块的大小</h3><p>对于给定的cache容量，当块大小增加时，不命中率开始是下降的，但是后来就上升了。</p>
<ul>
<li>一方面它减少了强制性不命中；</li>
<li>另一方面，由于增加块大小会减少Cache中块的数目，可能会增加冲突不命中</li>
</ul>
<p><strong>增加块的大小会增加不命中开销</strong></p>
<h3 id="增加cache的容量"><a href="#增加cache的容量" class="headerlink" title="增加cache的容量"></a>增加cache的容量</h3><p>缺点：</p>
<ul>
<li>增加成本</li>
<li>增加命中时间</li>
</ul>
<h3 id="提高相联度"><a href="#提高相联度" class="headerlink" title="提高相联度"></a>提高相联度</h3><p>采取相联度超过8的方案实际意义不大</p>
<p><strong>容量为N的直接映象cache的不命中率和容量为N&#x2F;2的两路组相联cache的不命率差不多相同</strong></p>
<p>提高相联度是以增加命中时间为代价的</p>
<h2 id="伪相联cache和列相联cache"><a href="#伪相联cache和列相联cache" class="headerlink" title="伪相联cache和列相联cache"></a>伪相联cache和列相联cache</h2><p>基本思想：在逻辑上把直接映象cache分为上下两个区。对于任何一次访问，伪相联cache先按直接映象cache的方式去处理：如果命中，则其访问过程和直接映象cache的情况一样；如果不命中，则再对另一区相应的位置去查找。如果找到了，则发生了伪命中，否则只好访问下一级存储器。</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200417152901445.png" style="zoom:50%;" />

<h2 id="硬件预取"><a href="#硬件预取" class="headerlink" title="硬件预取"></a>硬件预取</h2><ol>
<li>指令和数据都可以预取</li>
<li>预取内容即可放入cache中，也可放在外缓冲器中</li>
<li>指令预取通常由cache之外的硬件完成</li>
</ol>
<p>预取应利用存储器的空闲带宽，不能影响对正常不命中的处理，否则会降低性能。</p>
<h2 id="编译器控制的预取"><a href="#编译器控制的预取" class="headerlink" title="编译器控制的预取"></a>编译器控制的预取</h2><p>在编译的时候加入预取指令，在数据被用到之前发出预取请求。</p>
<ol>
<li>按照预取数据所放的位置，可把预取分为两种类型：<ul>
<li>寄存器预取：把数据放在寄存器中</li>
<li>cache预取：只将数据放在cache中</li>
</ul>
</li>
<li>按照预取的处理方式不同，分为：<ul>
<li>故障性预取：在预取时，如果出现虚地址故障或违反保护权限，就会发生异常</li>
<li>非故障性预取：不会发生异常，编译器会放弃预取，转为空操作</li>
</ul>
</li>
<li>在预取数据的同时，处理器应能继续执行</li>
<li>编译器控制预取的目的：使得执行指令和读取数据能重叠执行</li>
<li>每次预取需要花费一条指令的开销<ul>
<li>保证开销低于收益</li>
<li>编译器可以通过把重点放在那些可能会导致不命中的访问上，使得程序避免不必要的预取</li>
</ul>
</li>
</ol>
<h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><p>通过对软件进行优化来降低不命中率</p>
<ol>
<li>程序代码和数据重组<ul>
<li>重新组织程序而不影响程序的正确性<ul>
<li>把一个程序的过程重新排序，减少冲突不命中，降低指令不命中率</li>
<li>把基本块对齐，提高大cache块的效率</li>
</ul>
</li>
<li>假设编译器知道分支指令会成功转移：<ul>
<li>将转移目标处的基本块和紧跟着该分支指令后的基本块进行对调</li>
<li>把该分支指令转为操作语义相反的分支指令（？）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="牺牲cache"><a href="#牺牲cache" class="headerlink" title="牺牲cache"></a>牺牲cache</h2><p>在cache和它的下一级存储器之间设置一个全相联的小cache；用来存放被替换出去的块（牺牲者），以备重新使用</p>
<p>对于减小冲突不命中很有效，特别是对于小容量的直接映象数据cache，作用尤其明显。</p>
<h2 id="采取两级cache"><a href="#采取两级cache" class="headerlink" title="采取两级cache"></a>采取两级cache</h2><p>第一级cache小且快；第二级cache容量大。</p>
<p>全部不命中率和局部不命中率：$全局不命中率&#x3D;不命中率_{L1} X 不命中率_{L2}$</p>
<ul>
<li><p>评价第二级Cache需要使用全局不命中率；</p>
</li>
<li><p>第二级cache不会影响CPU的时钟频率；</p>
</li>
</ul>
<p>$平均访存时间&#x3D;命中时间L_1+不命中率L_1X()$</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ol>
<li>容量：第二级cache的容量一般比第一级cache的大很多</li>
<li>相联度：第二级cache可以采用较高的相联度或伪相联方法</li>
<li>块大小：第二级cache可以采用较大的块</li>
</ol>
<h2 id="让读不命中优先于写"><a href="#让读不命中优先于写" class="headerlink" title="让读不命中优先于写"></a>让读不命中优先于写</h2><ol>
<li>cache中的写缓冲器导致对存储器访问的复杂化：在读不命中时，所读单元的最新值可能还在写缓冲器中，还没有进入主存。</li>
<li>读不命中的处理：<ul>
<li>推迟对读不命中的处理，直到写缓冲器清空</li>
<li>检查写缓冲器的内容</li>
</ul>
</li>
<li>在写回法cache中，可采取写缓冲器</li>
</ol>
<h2 id="写缓冲合并"><a href="#写缓冲合并" class="headerlink" title="写缓冲合并"></a>写缓冲合并</h2><p>写直达cache：</p>
<p>依靠写缓冲来减少对下一级存储器写操作的时间。</p>
<p>如果写缓冲器为空，就把数据和相应地址写入该缓冲器【从CPU的角度来看，该写操作就算完成了】</p>
<p>如果写缓冲器中已经有了待写入数据，就要把这次写入地址与写缓冲器中已有的所有地址进行比较，看看是否有匹配的项。如果有地址匹配而对应的位置又空闲，就把这次要写入的数据与该项合并。【这就是写缓冲合并】</p>
<p>如果写缓冲器满并且没有能进行写合并的项，就等待。</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200417163741394.png" style="zoom:67%;" />

<h2 id="请求字处理技术"><a href="#请求字处理技术" class="headerlink" title="请求字处理技术"></a>请求字处理技术</h2><p>请求字：从下一级存储器调入cache块中，只有一个字是立即需要的，该字就是请求字。</p>
<p>应尽早把请求字发送给CPU</p>
<ul>
<li>尽早重启动：调块时，从块的起始位置开始读起。一旦请求字到达了，就立即发送给CPU，让CPU继续执行。【请求字优先】</li>
</ul>
<h2 id="非阻塞cache技术"><a href="#非阻塞cache技术" class="headerlink" title="非阻塞cache技术"></a>非阻塞cache技术</h2><p>cache不命中时依旧允许CPU进行其他的命中访问。</p>
<h1 id="减少命中时间"><a href="#减少命中时间" class="headerlink" title="减少命中时间"></a>减少命中时间</h1><p>命中时间直接影响处理器的时钟频率。</p>
<p>Cache的访问时间限制了处理器的时钟频率。</p>
<h2 id="容量小、结构简单的Cache"><a href="#容量小、结构简单的Cache" class="headerlink" title="容量小、结构简单的Cache"></a>容量小、结构简单的Cache</h2><p>硬件越简单，速度就越快。</p>
<h2 id="虚拟cache"><a href="#虚拟cache" class="headerlink" title="虚拟cache"></a>虚拟cache</h2><h3 id="物理cache"><a href="#物理cache" class="headerlink" title="物理cache"></a>物理cache</h3><p>使用物理地址进行访问的传统cache。</p>
<p>标识存储器中存放的是物理地址，进行地址检测越是用物理地址。</p>
<p>缺点就是：地址转换和访问cache串行进行，访问速度慢。</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200417185513804.png" style="zoom:67%;" />

<h3 id="虚拟cache-1"><a href="#虚拟cache-1" class="headerlink" title="虚拟cache"></a>虚拟cache</h3><p>直接使用虚拟地址进行访问的cache。标识存储器存放的是虚拟地址，进行地址检测用的也是虚拟地址</p>
<p>优点：在命中时不需要进行地址转换，省去了地址转换的时间。就算是不命中，地址转换和访问cache也是并行进行的，速度比物理cache快。</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200417185536512.png" style="zoom:50%;" />

<p>虚拟地址和进程相关。</p>
<p>虚拟地址&#x3D;虚拟索引+物理标识<br>用虚地址中页内位移作为cache的索引，标识用物理地址；</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200417190140461.png" style="zoom:67%;" />

<h2 id="Cache访问流水化"><a href="#Cache访问流水化" class="headerlink" title="Cache访问流水化"></a>Cache访问流水化</h2><p>对第一级cache访问按流水线方式组织</p>
<p>访问cache需要多个时钟周期才能完成</p>
<p>不能够真正减少cache命中时间，但是可以提高时钟频率，提高cache的带宽。</p>
<h2 id="踪迹Cache"><a href="#踪迹Cache" class="headerlink" title="踪迹Cache"></a>踪迹Cache</h2><p>存放CPU所执行的动态指令序列：包含了由分支预测展开的指令，该分支预测是否需要在取到该指令时进行确认。</p>
<ul>
<li>地址映象机制复杂</li>
<li>相同的指令序列有可能被当作条件分支的不同选择而重复存放</li>
<li>能够提高指令cache的空间利用率</li>
</ul>
<h1 id="并行主存系统"><a href="#并行主存系统" class="headerlink" title="并行主存系统"></a>并行主存系统</h1><p>主存的主要性能指标：<strong>延迟</strong>和<strong>带宽</strong></p>
<p>定义：是在一个访存周期内能并行访问多个存储字的存储器</p>
<p>在单体单字宽的存储器中：存储器的访问周期为T<del>M</del> ,字长为W位，则<br>带宽为$B_M&#x3D;\frac{W}{T_M}$</p>
<h2 id="单体多字存储器"><a href="#单体多字存储器" class="headerlink" title="单体多字存储器"></a>单体多字存储器</h2><p>存储器能够每个存储周期读出m个CPU字</p>
<p>$B_M&#x3D;\frac{mW}{T_M}$</p>
<p>单体多字存储器的实际带宽比最大带宽小</p>
<p>缺点：访存效率不高</p>
<ul>
<li>如果一次去读的m个指令字中有分支指令，而且分支成功，则该分支指令之后的指令是无用的。</li>
<li>一次取出的m个数据不一定都是有用的。此外，当前执行指令所需要的多个操作数也不一定正好都存放在同一个长存储字中</li>
<li>写入可能变得复杂</li>
<li>当要读出的数据字和要写入的数据字处于同一个长存储字内时，读和写的操作就无法在同一个存储周期内完成</li>
</ul>
<h2 id="多体交叉存储器"><a href="#多体交叉存储器" class="headerlink" title="多体交叉存储器"></a>多体交叉存储器</h2><p>由多个单字存储体构成，每个体都有自己的地址寄存器以及地址译码和读&#x2F;写驱动等电路。</p>
<p>编址方式：</p>
<ul>
<li>高位交叉编址</li>
<li>低位交叉编址</li>
</ul>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20200417195600835.png" style="zoom:67%;" />

<h3 id="高位交叉编址"><a href="#高位交叉编址" class="headerlink" title="高位交叉编址"></a>高位交叉编址</h3><p>对存储单元矩阵按列优先的方式进行编址</p>
<h3 id="低位交叉编址"><a href="#低位交叉编址" class="headerlink" title="低位交叉编址"></a>低位交叉编址</h3><p>对存储单元矩阵按行优先进行编址</p>
<h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><blockquote>
<p>进程保护：</p>
<ol>
<li>界地址寄存器：基地址、上界地址；检测条件：（基地址+地址）&lt;&#x3D;上界地址</li>
<li>虚拟存储器：给每个页面增加访问权限标识</li>
<li>环形保护</li>
<li>加锁和解锁</li>
</ol>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rhb</p>
  <div class="site-description" itemprop="description">纵浪大化中，不喜亦不惧</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">160</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RShawshank" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RShawshank" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rhb</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://lib.baomitu.com/canvas-nest.js/1.0.1/canvas-nest.js"></script>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
